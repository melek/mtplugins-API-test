{
  "Lib:EventMacros": {"47e":   {
    "mtversion": "1.8.4",
    "timestamp": "2021-04-04T20:32:40.0421746-07:00",
    "notes": "",
    "gmnotes": "",
    "properties":     {
      "-----------------": "",
      "------------------": "",
      "-------------------": "",
      "---------------|ALT INIT|-------------------": "",
      "---------------|ANIMATED VIEW AREA|-------------------": "",
      "---------------|AREAS |-------------------": "",
      "---------------|COPY PASTE DELETE MACROS|-------------------": "",
      "---------------|CROWD|-------------------": "",
      "---------------|DICE BOX|-------------------": "",
      "---------------|FEATURE GROUPS INSTALLED|-------------------": "",
      "---------------|HIDDEN SETTINGS|-------------------": "",
      "---------------|HOVER|-------------------": "",
      "---------------|MAP EDITOR|-------------------": "",
      "---------------|MASS VBL|-------------------": "",
      "---------------|SEEK TOKENS|-------------------": "",
      "---------------|SETTINGS|-------------------": "",
      "---------------|SYSTEM|-------------------": "",
      "---------------|TABLES|-------------------": "",
      "---------------|TEXT ANIMATION|-------------------": "",
      "---------------|THE PADS|-------------------": "",
      "---------------|TIMER FUNCTIONS|-------------------": "",
      "---------------|TREE TRUNKS|-------------------": "",
      "---------------|Whisperframe|-------------------": "",
      "---------------|languages|-------------------": "",
      "-------|drawing|---------": "",
      "abortProcess": 1,
      "allCoordsArray": "",
      "allMapsPads":       {
        "Forest new": "Canopy Canopy 1, Canopy Canopy 2, Canopy Canopy 3, Canopy Canopy 4, Canopy Canopy 5, Canopy Canopy 6, Canopy Canopy 7, Canopy Canopy 8, Canopy Canopy 14, Canopy Canopy 15, Canopy Canopy 46, Canopy Canopy 63, Canopy Canopy 68, Canopy Canopy 106, Canopy Canopy 126, Canopy Canopy 139, Canopy Canopy 147, Canopy Canopy 151, Canopy Canopy 156, Canopy Canopy 160, Canopy Canopy 165, Canopy Canopy 166, Canopy Canopy 172, Canopy Canopy 174, Canopy Canopy 176, Canopy Canopy 179, Canopy Canopy 183, Canopy Canopy 195, Canopy Canopy 204, Canopy Canopy 210, Canopy Canopy 213, Canopy Canopy 223, Canopy Canopy 245, Canopy Canopy 247, Canopy Canopy 260, Canopy Canopy 266, Canopy Canopy 268, Canopy Canopy 274, Canopy Canopy 295, Canopy Canopy 297, Canopy Canopy 298, Canopy Canopy 300, Canopy Canopy 308, Canopy Canopy 337, Canopy Canopy 345, Canopy Canopy 364, Canopy Canopy 365, Canopy Canopy 366, Canopy Canopy 372, Canopy Canopy 376, Canopy Canopy 378, Canopy Canopy 379, Canopy Canopy 390, Canopy Canopy 393, Canopy Canopy 397, Canopy Canopy 399, Canopy Canopy 403, Canopy Canopy 406, Canopy Canopy 429, Canopy Canopy 430, Canopy Canopy 442, Canopy Canopy 453, Canopy Canopy 467, Canopy Canopy 476, Canopy Canopy 479, Canopy Canopy 483, Canopy Canopy 484, Canopy Canopy 495, Canopy Canopy 505, Canopy Canopy 506, Canopy Canopy 507, Canopy Canopy 516, Canopy Canopy 521, Canopy Canopy 532, Canopy Canopy 536, Canopy Canopy 543, Canopy Canopy 558, Canopy Canopy 568, Canopy Canopy 577, Canopy Canopy 580, Canopy Canopy 594, Canopy Canopy 604, Canopy Canopy 613, Canopy Canopy 624, Canopy Canopy 627, Canopy Canopy 662, Canopy Canopy 663, Canopy Canopy 672, Canopy Canopy 674, Canopy Canopy 683, Canopy Canopy 684, Canopy Canopy 685, Canopy Canopy 692, Canopy Canopy 720, Canopy Canopy 724, Canopy Canopy 730, Canopy Canopy 735, Canopy Canopy 737, Canopy Canopy 741, Canopy Canopy 769, Canopy Canopy 776, Canopy Canopy 806, Canopy Canopy 807, Canopy Canopy 828, Canopy Canopy 845, Canopy Canopy 846, Canopy Canopy 850, Canopy Canopy 860, Canopy Canopy 861, Canopy Canopy 868, Canopy Canopy 872, Canopy Canopy 890, Canopy Canopy 901, Canopy Canopy 931, Canopy Canopy 938, Canopy Canopy 945, Canopy Canopy 947, Canopy Canopy 949, Canopy Canopy 958, Canopy Canopy 960, Canopy Canopy 981, Canopy Canopy 984, Canopy Canopy 990, Canopy Canopy 993, Canopy Canopy 995, Canopy Canopy 997, Canopy Canopy 1007, Canopy Canopy 1010, Canopy Canopy 1023, Canopy Canopy 1030, Canopy Canopy 1032, Canopy Canopy 1047, Canopy Canopy 1050, Canopy Canopy 1057, Canopy Canopy 1064, Canopy Canopy 1065, Canopy Canopy 1071, Canopy Canopy 1084, Canopy Canopy 1085, Canopy Canopy 1090, Canopy Canopy 1096, Canopy Canopy 1104, Canopy Canopy 1108, Canopy Canopy 1110, Canopy Canopy 1111, Canopy Canopy 1125, Canopy Canopy 1135, Canopy Canopy 1138, Canopy Canopy 1141, Canopy Canopy 1142, Canopy Canopy 1147, Canopy Canopy 1152, Canopy Canopy 1155, Canopy Canopy 1158, Canopy Canopy 1173, Canopy Canopy 1176, Canopy Canopy 1178, Canopy Canopy 1181, Canopy Canopy 1189, Canopy Canopy 1207, Canopy Canopy 1217, Canopy Canopy 1220, Canopy Canopy 1221, Canopy Canopy 1233, Canopy Canopy 1240, Canopy Canopy 1275, Canopy Canopy 1279, Canopy Canopy 1305, Canopy Canopy 1319, Canopy Canopy 1326, Canopy Canopy 1330, Canopy Canopy 1342, Canopy Canopy 1351, Canopy Canopy 1355, Canopy Canopy 1362, Canopy Canopy 1367, Canopy Canopy 1372, Canopy Canopy 1375, Canopy Canopy 1377, Canopy Canopy 1380, Canopy Canopy 1384, Canopy Canopy 1394, Canopy Canopy 1412, Canopy Canopy 1431, Canopy Canopy 1455, Canopy Canopy 1456, Canopy Canopy 1460, Canopy Canopy 1462, Canopy Canopy 1469, Canopy Canopy 1472, Canopy Canopy 1489, Canopy Canopy 1491, Canopy Canopy 1494, Canopy Canopy 1501, Canopy Canopy 1513, Canopy Canopy 1514, Canopy Canopy 1518, Canopy Canopy 1530, Canopy Canopy 1531, Canopy Canopy 1540, Canopy Canopy 1542, Canopy Canopy 1544, Canopy Canopy 1567, Canopy Canopy 1569, Canopy Canopy 1587, Canopy Canopy 1613, Canopy Canopy 1617, Canopy Canopy 1623, Canopy Canopy 1625, Canopy Canopy 1638, Canopy Canopy 1651, Canopy Canopy 1652, Canopy Canopy 1671, Canopy Canopy 1672, Canopy Canopy 1686, Canopy Canopy 1687, Canopy Canopy 1704, Canopy Canopy 1713, Canopy Canopy 1731, Canopy Canopy 1733, Canopy Canopy 1736, Canopy Canopy 1779, Canopy Canopy 1785, Canopy Canopy 1812, Canopy Canopy 1815, Canopy Canopy 1821, Canopy Canopy 1830, Canopy Canopy 1839, Canopy Canopy 1877",
        "Sound Test First Floor": "InterJump 32, SoundPad Ground floor noise, SoundPad Snoring 1, SoundPad Snoring 2",
        "BASE": "Ward 1, EventPad 1, EventPad 2, EventPad 3, PadStart 1, PadStart 2, PadEnd 1, PadEnd 2, InterPad 1, InterPad 2, PadStartBorder 1, PadStartBorder 2, PadStartBorder Horizontal, PadStartBorder Verticle, PadEndBorder 1, PadEndBorder 2, PadEndBorder Horizontal, PadEndBorder Verticle, InterPadBorder 1, InterPadBorder 2, InterPadBorder horizontal, InterPadBorder vertical, PadJump 1, InterJump 1, PadJumpBorder 1, PadJumpBorder 2, PadJumpBorder Horizontal, PadJumpBorder Vertical, InterJumpBorder 1, InterJumpBorder 3, InterJumpBorder Horizontal, InterJumpBorder Vertical, MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4, Roof 1, Foliage 1, Canopy 1, Canopy 2, Canopy 3, Canopy 4, Canopy 5, Canopy 6, Canopy 7, Canopy 8, Canopy 9",
        "Sound Test Ground Floor": "PadStart 1, PadEnd 1, InterJump 31, SoundPad Bard Music, SoundPad Fireplace Sounds, SoundPad Tavern sounds",
        "ShadowPad Example": "ShadowPad 1 Floor, ShadowPad 1 Ground",
        "Limited Sight": "EventPad 2, EventPad 3, EventPad 4, InterPad 3",
        "Life": "",
        "Teleports 2": "InterPad 2, InterPadBorder 1, InterPadBorder 2, InterPadBorder 10, InterPadBorder horizontal, InterPadBorder vertical, InterJump 2, InterJump 21, InterJumpBorder 2, InterJumpBorder 4, InterJumpBorder Horizontal, InterJumpBorder Vertical",
        "Shadow Pad Tutorial": "ShadowPad 1 Floor, ShadowPad 1 Ground, PadStart 1, PadEnd 1",
        "Example Map of Special pads": "Ward 1, Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2, Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4, Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3, Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2, EventPad 1, EventPad 2, EventPad 3, PadStart 2, PadStart 4, PadStart 10, PadStart You cant see me, PadEnd 2, PadEnd 4, PadEnd 10, PadEnd You cant see me, InterPad 1, InterPad 3, PadStartBorder 1, PadEndBorder 1, InterPadBorder 10, PadJump 1, InterJump 10, PadJumpBorder 1, PadJumpBorder 2, InterJumpBorder 10, MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4, Roof 1, Foliage 1, Foliage 2, Canopy 1",
        "Difficult Terrain": "",
        "Follow Me Tiles": ""
      },
      "allMapsPadsJson":       {
        "Forest new":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "Canopy Canopy 1, Canopy Canopy 2, Canopy Canopy 3, Canopy Canopy 4, Canopy Canopy 5, Canopy Canopy 6, Canopy Canopy 7, Canopy Canopy 8, Canopy Canopy 14, Canopy Canopy 15, Canopy Canopy 46, Canopy Canopy 63, Canopy Canopy 68, Canopy Canopy 106, Canopy Canopy 126, Canopy Canopy 139, Canopy Canopy 147, Canopy Canopy 151, Canopy Canopy 156, Canopy Canopy 160, Canopy Canopy 165, Canopy Canopy 166, Canopy Canopy 172, Canopy Canopy 174, Canopy Canopy 176, Canopy Canopy 179, Canopy Canopy 183, Canopy Canopy 195, Canopy Canopy 204, Canopy Canopy 210, Canopy Canopy 213, Canopy Canopy 223, Canopy Canopy 245, Canopy Canopy 247, Canopy Canopy 260, Canopy Canopy 266, Canopy Canopy 268, Canopy Canopy 274, Canopy Canopy 295, Canopy Canopy 297, Canopy Canopy 298, Canopy Canopy 300, Canopy Canopy 308, Canopy Canopy 337, Canopy Canopy 345, Canopy Canopy 364, Canopy Canopy 365, Canopy Canopy 366, Canopy Canopy 372, Canopy Canopy 376, Canopy Canopy 378, Canopy Canopy 379, Canopy Canopy 390, Canopy Canopy 393, Canopy Canopy 397, Canopy Canopy 399, Canopy Canopy 403, Canopy Canopy 406, Canopy Canopy 429, Canopy Canopy 430, Canopy Canopy 442, Canopy Canopy 453, Canopy Canopy 467, Canopy Canopy 476, Canopy Canopy 479, Canopy Canopy 483, Canopy Canopy 484, Canopy Canopy 495, Canopy Canopy 505, Canopy Canopy 506, Canopy Canopy 507, Canopy Canopy 516, Canopy Canopy 521, Canopy Canopy 532, Canopy Canopy 536, Canopy Canopy 543, Canopy Canopy 558, Canopy Canopy 568, Canopy Canopy 577, Canopy Canopy 580, Canopy Canopy 594, Canopy Canopy 604, Canopy Canopy 613, Canopy Canopy 624, Canopy Canopy 627, Canopy Canopy 662, Canopy Canopy 663, Canopy Canopy 672, Canopy Canopy 674, Canopy Canopy 683, Canopy Canopy 684, Canopy Canopy 685, Canopy Canopy 692, Canopy Canopy 720, Canopy Canopy 724, Canopy Canopy 730, Canopy Canopy 735, Canopy Canopy 737, Canopy Canopy 741, Canopy Canopy 769, Canopy Canopy 776, Canopy Canopy 806, Canopy Canopy 807, Canopy Canopy 828, Canopy Canopy 845, Canopy Canopy 846, Canopy Canopy 850, Canopy Canopy 860, Canopy Canopy 861, Canopy Canopy 868, Canopy Canopy 872, Canopy Canopy 890, Canopy Canopy 901, Canopy Canopy 931, Canopy Canopy 938, Canopy Canopy 945, Canopy Canopy 947, Canopy Canopy 949, Canopy Canopy 958, Canopy Canopy 960, Canopy Canopy 981, Canopy Canopy 984, Canopy Canopy 990, Canopy Canopy 993, Canopy Canopy 995, Canopy Canopy 997, Canopy Canopy 1007, Canopy Canopy 1010, Canopy Canopy 1023, Canopy Canopy 1030, Canopy Canopy 1032, Canopy Canopy 1047, Canopy Canopy 1050, Canopy Canopy 1057, Canopy Canopy 1064, Canopy Canopy 1065, Canopy Canopy 1071, Canopy Canopy 1084, Canopy Canopy 1085, Canopy Canopy 1090, Canopy Canopy 1096, Canopy Canopy 1104, Canopy Canopy 1108, Canopy Canopy 1110, Canopy Canopy 1111, Canopy Canopy 1125, Canopy Canopy 1135, Canopy Canopy 1138, Canopy Canopy 1141, Canopy Canopy 1142, Canopy Canopy 1147, Canopy Canopy 1152, Canopy Canopy 1155, Canopy Canopy 1158, Canopy Canopy 1173, Canopy Canopy 1176, Canopy Canopy 1178, Canopy Canopy 1181, Canopy Canopy 1189, Canopy Canopy 1207, Canopy Canopy 1217, Canopy Canopy 1220, Canopy Canopy 1221, Canopy Canopy 1233, Canopy Canopy 1240, Canopy Canopy 1275, Canopy Canopy 1279, Canopy Canopy 1305, Canopy Canopy 1319, Canopy Canopy 1326, Canopy Canopy 1330, Canopy Canopy 1342, Canopy Canopy 1351, Canopy Canopy 1355, Canopy Canopy 1362, Canopy Canopy 1367, Canopy Canopy 1372, Canopy Canopy 1375, Canopy Canopy 1377, Canopy Canopy 1380, Canopy Canopy 1384, Canopy Canopy 1394, Canopy Canopy 1412, Canopy Canopy 1431, Canopy Canopy 1455, Canopy Canopy 1456, Canopy Canopy 1460, Canopy Canopy 1462, Canopy Canopy 1469, Canopy Canopy 1472, Canopy Canopy 1489, Canopy Canopy 1491, Canopy Canopy 1494, Canopy Canopy 1501, Canopy Canopy 1513, Canopy Canopy 1514, Canopy Canopy 1518, Canopy Canopy 1530, Canopy Canopy 1531, Canopy Canopy 1540, Canopy Canopy 1542, Canopy Canopy 1544, Canopy Canopy 1567, Canopy Canopy 1569, Canopy Canopy 1587, Canopy Canopy 1613, Canopy Canopy 1617, Canopy Canopy 1623, Canopy Canopy 1625, Canopy Canopy 1638, Canopy Canopy 1651, Canopy Canopy 1652, Canopy Canopy 1671, Canopy Canopy 1672, Canopy Canopy 1686, Canopy Canopy 1687, Canopy Canopy 1704, Canopy Canopy 1713, Canopy Canopy 1731, Canopy Canopy 1733, Canopy Canopy 1736, Canopy Canopy 1779, Canopy Canopy 1785, Canopy Canopy 1812, Canopy Canopy 1815, Canopy Canopy 1821, Canopy Canopy 1830, Canopy Canopy 1839, Canopy Canopy 1877",
          "VPCU": "",
          "SoundPad": ""
        },
        "Sound Test First Floor":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "InterJump 32",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": "SoundPad Ground floor noise, SoundPad Snoring 1, SoundPad Snoring 2"
        },
        "BASE":         {
          "Ward": "Ward 1",
          "Linked": "",
          "EventPad": "EventPad 1, EventPad 2, EventPad 3",
          "ShadowPad": "",
          "PadStart": "PadStart 1, PadStart 2",
          "PadEnd": "PadEnd 1, PadEnd 2",
          "InterPad": "InterPad 1, InterPad 2",
          "PadStartBorder": "PadStartBorder 1, PadStartBorder 2, PadStartBorder Horizontal, PadStartBorder Verticle",
          "PadEndBorder": "PadEndBorder 1, PadEndBorder 2, PadEndBorder Horizontal, PadEndBorder Verticle",
          "InterPadBorder": "InterPadBorder 1, InterPadBorder 2, InterPadBorder horizontal, InterPadBorder vertical",
          "PadJump": "PadJump 1",
          "InterJump": "InterJump 1",
          "PadJumpBorder": "PadJumpBorder 1, PadJumpBorder 2, PadJumpBorder Horizontal, PadJumpBorder Vertical",
          "InterJumpBorder": "InterJumpBorder 1, InterJumpBorder 3, InterJumpBorder Horizontal, InterJumpBorder Vertical",
          "MappedPad": "MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4",
          "Roof": "Roof 1",
          "Foliage": "Foliage 1",
          "Canopy": "Canopy 1, Canopy 2, Canopy 3, Canopy 4, Canopy 5, Canopy 6, Canopy 7, Canopy 8, Canopy 9",
          "VPCU": "",
          "SoundPad": ""
        },
        "Sound Test Ground Floor":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "PadStart 1",
          "PadEnd": "PadEnd 1",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "InterJump 31",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": "SoundPad Bard Music, SoundPad Fireplace Sounds, SoundPad Tavern sounds"
        },
        "ShadowPad Example":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "ShadowPad 1 Floor, ShadowPad 1 Ground",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Limited Sight":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "EventPad 2, EventPad 3, EventPad 4",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "InterPad 3",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Life":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Teleports 2":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "InterPad 2",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "InterPadBorder 1, InterPadBorder 2, InterPadBorder 10, InterPadBorder horizontal, InterPadBorder vertical",
          "PadJump": "",
          "InterJump": "InterJump 2, InterJump 21",
          "PadJumpBorder": "",
          "InterJumpBorder": "InterJumpBorder 2, InterJumpBorder 4, InterJumpBorder Horizontal, InterJumpBorder Vertical",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Shadow Pad Tutorial":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "ShadowPad 1 Floor, ShadowPad 1 Ground",
          "PadStart": "PadStart 1",
          "PadEnd": "PadEnd 1",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Example Map of Special pads":         {
          "Ward": "Ward 1",
          "Linked": "Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2, Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4, Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3, Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2",
          "EventPad": "EventPad 1, EventPad 2, EventPad 3",
          "ShadowPad": "",
          "PadStart": "PadStart 2, PadStart 4, PadStart 10, PadStart You cant see me",
          "PadEnd": "PadEnd 2, PadEnd 4, PadEnd 10, PadEnd You cant see me",
          "InterPad": "InterPad 1, InterPad 3",
          "PadStartBorder": "PadStartBorder 1",
          "PadEndBorder": "PadEndBorder 1",
          "InterPadBorder": "InterPadBorder 10",
          "PadJump": "PadJump 1",
          "InterJump": "InterJump 10",
          "PadJumpBorder": "PadJumpBorder 1, PadJumpBorder 2",
          "InterJumpBorder": "InterJumpBorder 10",
          "MappedPad": "MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4",
          "Roof": "Roof 1",
          "Foliage": "Foliage 1, Foliage 2",
          "Canopy": "Canopy 1",
          "VPCU": "",
          "SoundPad": ""
        },
        "Difficult Terrain":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Follow Me Tiles":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        }
      },
      "animationPerClient": 0,
      "annulInvisState": "invisibility_annul",
      "baseMapName": "Grasslands",
      "centreOnMePads":       [
                {
          "map": "BASE",
          "spot": ""
        },
                {
          "map": "BASE",
          "spot": " another place another time"
        },
                {
          "map": "Difficult Terrain",
          "spot": ""
        },
                {
          "map": "Example Map of Special pads",
          "spot": ""
        },
                {
          "map": "Follow Me Tiles",
          "spot": ""
        },
                {
          "map": "Forest",
          "spot": ""
        },
                {
          "map": "Forest new",
          "spot": ""
        },
                {
          "map": "Life",
          "spot": ""
        },
                {
          "map": "Limited Sight",
          "spot": ""
        },
                {
          "map": "Shadow Pad Tutorial",
          "spot": ""
        },
                {
          "map": "ShadowPad Example",
          "spot": ""
        },
                {
          "map": "Sound Test First Floor",
          "spot": ""
        },
                {
          "map": "Sound Test Ground Floor",
          "spot": ""
        },
                {
          "map": "Sound Test Ground Floor",
          "spot": " Bar Entrance"
        },
                {
          "map": "Teleports 2",
          "spot": ""
        },
                {
          "map": "VBL",
          "spot": ""
        }
      ],
      "checkMapsOCL": 0,
      "checkSwitchInterMap": 1,
      "circleXrange5":       [
        -5,
        -5,
        -5,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5
      ],
      "circleXrange6":       [
        -6,
        -6,
        -6,
        -5,
        -5,
        -5,
        -5,
        -5,
        -5,
        -5,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        6,
        6
      ],
      "circleYrange5":       [
        -1,
        0,
        1,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -1,
        0,
        1
      ],
      "circleYrange6":       [
        -1,
        0,
        1,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -1,
        0,
        1
      ],
      "coneXrange_11_180_25":       [
        0,
        -1,
        -2,
        -2,
        -2,
        -3,
        -3,
        -3,
        -4,
        -4,
        -4,
        -4,
        -4,
        -5,
        -5,
        -5,
        -5,
        -5,
        -6,
        -6,
        -6,
        -6,
        -6,
        -6,
        -6,
        -7,
        -7,
        -7,
        -7,
        -7,
        -7,
        -7,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -11,
        -11,
        -11,
        -11,
        -11,
        -11,
        -11,
        -12,
        -12,
        -12
      ],
      "coneYrange_11_180_25":       [
        0,
        0,
        0,
        -1,
        1,
        -1,
        1,
        0,
        0,
        -1,
        2,
        1,
        -2,
        1,
        0,
        2,
        -2,
        -1,
        2,
        1,
        3,
        -1,
        0,
        -3,
        -2,
        2,
        3,
        -3,
        0,
        1,
        -2,
        -1,
        4,
        3,
        2,
        1,
        0,
        -1,
        -2,
        -3,
        -4,
        4,
        2,
        1,
        -4,
        0,
        -1,
        -2,
        -3,
        3,
        5,
        2,
        -3,
        -4,
        -5,
        1,
        0,
        -1,
        -2,
        3,
        4,
        -2,
        -3,
        2,
        1,
        0,
        -1,
        3,
        -1,
        1,
        0
      ],
      "cpDel.backUpMacros":       {
        "Green Team Teleport":         {
          "index": 12,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1, 'Green')]",
          "label": "Green Team Teleport",
          "applyToSelected": false,
          "fontSize": "0.90em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Trap":         {
          "index": 8,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!----------------------------- Standard Trap -------------------------------->']\n<!-- Here you enter the code to apply the effect of the TRAP Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n[h:me = arg(0)]\n[h:event = arg(1)]\n[h:triggerType = arg(5)]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:attackRoll = d20]\n[h:roll=1d6]\n[h,if(attackRoll > Dexterity):HP=HP-roll]\n[h,if(attackRoll > Dexterity):broadcast(\"You have triggered a trap and sustained \"+roll+\" hits.<br>\")]",
          "label": "Standard Trap",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "Red Team Teleport":         {
          "index": 11,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1, 'Red')]",
          "label": "Red Team Teleport",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Pit":         {
          "index": 19,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!-----------------------------Standard Pit (trapped)---------------------------------->']\n<!-- Here you enter the code to apply the effect of the pit Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n<!-- check which event this token triggers this can be \n- movedOn \n- movedOff \n- movedOver \n- movedReturn\twhen you move the token AND use way points AND leave the token but end the move onto the token\n-->\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'<!--Failed Ag Test-->']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(padName): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've fallen into a pit<br>\")]\n\t[h: AgTest = \"Failed\"]\n}; {\n\t[h:'<!--Succeeded Ag Test-->']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly fell into a pit, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\n\t[h:'<!-- if you move into (and not over) the pit and succeed your Ag check, you are pushed back to the edge of the pit. This means that a player cannot move into a pit voluntarily -->']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t=  json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t=  json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
          "label": "Standard Pit",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "Limit Movement":         {
          "index": 6,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!-- limitMovementMacro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- \n\tThis macro is run if the limitMovement variable is set <> 0 in the settings (toggles) and it handles the movement limitation and it \n\twill ONLY run if Limit Movement (in the settings-->toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement: is the max amount the token is allowed to move.\n\t- lastPath: an array of coordinates of the path over which the token has moved\n\t- startingLocation: the coordinates where the token started (in the form of an array)\n\t- currentLocation: the coordinates where the token ended (in the form of an array)\n\t- usedMove: the amount of cells moved (getMoveCount())\n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of cells a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move']\n\t}; {\t\n\t\t[limitMovement = 4*Dexterity]\n\t}]\n-->\"]\n\n[tok \t\t\t= getSelectedNames()]\n[if(listCount(tok) > 1), CODE:{\n\t<!-- multiple tokens are moved -->\n\t<!-- get first token from list of selected tokens and make that token current token -->\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t<!-- because of multiple selected tokens, just check if the initpanel is in use -->\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t<!-- variable to check if a single token is moved or multiple -->\n\t[singleMove = 0]\n}; {\n\t<!-- single token is moved -->\n\t<!-- if only one token is moved, check if its in the init panel -->\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n<!-- limit movement AREAS -->\n<!-- note that all these text outputs will be ignored. Im leaving them here for reference -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[h:output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[h:output = output + strformat(\"In total you moved: %{usedMove}\")]\n[broadcast(output)]\n}]\n\n[message\t\t= \"You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> cells. The maximum allowed movement is <b>%{limitMovement}<\/b> cells.\"]\n[if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t<!-- only limit movement if: mover is not the gm, token is in initiative panel, the token has actually moved AND it has moved more then the allowed amount-->\n\t[broadcast(strformat(message))]\n\t<!-- The following code you should not touch as its used for onTokenMove to process the rest. -->\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
          "label": "Limit Movement",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "CORE",
          "autoExecute": true,
          "tooltip": ""
        },
        "onCampaignLoad":         {
          "index": 5,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "1",
          "minWidth": "90",
          "color": "yellow",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[H:'\n<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->\n<!-- ----------------------------------------------------------------------------- ----ONCAMPAIGNLOAD LIB:EVENTMACROS ----------------- -->\n<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->']\n\n[H: '<!-- defineFunction(function, macro, ignoreOutput, newScope) -->']\n\n[h:prefix = \"bot_\"]\n\n[h:defineFunction(prefix+\"limitMovement\", \"Limit Movement@this\" ,1,0) ]",
          "label": "onCampaignLoad",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "CORE",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Net Trap":         {
          "index": 18,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!-----------------------------Standard Net Trap (tripwire)---------------------------------->']\n<!-- Here you enter the code to apply the effect of the pit Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n<!-- check which event this token triggers this can be \n- movedOn \n- movedOver \n-->\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n[h:netTrapPad\t\t\t= \"net trap 1\"]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'<!--Failed Ag Test-->']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(netTrapPad): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've triggered a net trap<br>\")]\n\t[h: AgTest = \"Failed\"]\n\t[h: setState('Trapped', 1, me)]\n}; {\n\t[h:'<!--Succeeded Ag Test-->']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly triggered a trip wire, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\t[h: setState('Trapped', 0, me)]\n\n\t[h:'<!-- if you move onto (and not over) the tripwire and succeed your Ag check, you are pushed back to the edge of the tripwire. This means that a player cannot move onto a tripwire  voluntarily -->']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
          "label": "Standard Net Trap",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "REMOVE THIS":         {
          "index": 20,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!-- limitMovementMacro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- \n\tThis macro is run if the limitMovement variable is set <> 0 in the settings (toggles) and it handles the movement limitation and it \n\twill ONLY run if Limit Movement (in the settings-->toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement: is the max amount the token is allowed to move.\n\t- lastPath: an array of coordinates of the path over which the token has moved\n\t- startingLocation: the coordinates where the token started (in the form of an array)\n\t- currentLocation: the coordinates where the token ended (in the form of an array)\n\t- usedMove: the amount of cells moved (getMoveCount())\n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of cells a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move']\n\t}; {\t\n\t\t[limitMovement = 4*Dexterity]\n\t}]\n-->\"]\n\n[tok \t\t\t= getSelectedNames()]\n[if(listCount(tok) > 1), CODE:{\n\t<!-- multiple tokens are moved -->\n\t<!-- get first token from list of selected tokens and make that token current token -->\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t<!-- because of multiple selected tokens, just check if the initpanel is in use -->\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t<!-- variable to check if a single token is moved or multiple -->\n\t[singleMove = 0]\n}; {\n\t<!-- single token is moved -->\n\t<!-- if only one token is moved, check if its in the init panel -->\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n<!-- limit movement AREAS -->\n<!-- note that all these text outputs will be ignored. Im leaving them here for reference -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[h:output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[h:output = output + strformat(\"In total you moved: %{usedMove}\")]\n[broadcast(output)]\n}]\n\n[message\t\t= \"You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> cells. The maximum allowed movement is <b>%{limitMovement}<\/b> cells.\"]\n[if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t<!-- only limit movement if: mover is not the gm, token is in initiative panel, the token has actually moved AND it has moved more then the allowed amount-->\n\t[broadcast(strformat(message))]\n\t<!-- The following code you should not touch as its used for onTokenMove to process the rest. -->\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
          "label": "REMOVE THIS",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "",
          "autoExecute": true,
          "tooltip": ""
        },
        "Limit Sight":         {
          "index": 3,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!----------------------------- Limit Sight -------------------------------->']\n[h:'<!-- check which event type this token triggers this can be \n- movedOn \n- movedOff \nLimited 1: circle distance=7,5 \nLimited 2: circle distance=3,5 \nLimited 3: circle distance=5,5 \nLimited 4: circle distance=1,5 \n-->']\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n\n[h:triggerType\t\t\t= arg(5)]\n\n<!-- assert that the trigger is a pad or area event -->\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n<!-- first retrieve the current sight level, is none is set, then set to 0 -->\n[h:\t\t\t\t\t\tsightLevel = getProperty(\"w42.bot.sightLevel\")]\n[h,if(sightLevel == \"\"):\tsightLevel = 0]\n\n<!-- get current sight type. If this is NOT a limited sight, then its the original sight so store this on the token so it can be retrieved later when the tokens steps off the EventPad(s) -->\n[h:sightType = getSightType()]\n[h,if(!startsWith(sightType, \"Limited \")):setProperty(\"w42.bot.oldSightType\", sightType)]\n\n<!-- For each extra EventToken (that contains this macro) the token is standing on increase the level. If the token moves off the eventPads, decrease the level. E.g. if a token moves onto 4 stacked event pads that run this macro, then this macro will run four times in a row, each time increasing the sight level with one step upto sight level 4. If the token then moves off one, but remains on three others, the sight level is decreased by 1-->\n<!-- also make sure that the value is always between 0 and 4 -->\n[h,if(event == \"movedOn\"):\tsightLevel = min(4,sightLevel + 1)]\n[h,if(event == \"movedOff\"):\tsightLevel = max(0,sightLevel - 1)]\n\n<!-- finally depending on the sight level (where 0==original sight type set the sight type of the token -->\n[h:setProperty(\"w42.bot.sightLevel\", sightLevel)]\n[h, if(sightLevel):setSightType(\"Limited \"+sightLevel); setSightType(getProperty(\"w42.bot.oldSightType\"))]",
          "label": "Limit Sight",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "InterTel Msg":         {
          "index": 15,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(tok+\" is being teleported from \"+oldMap+\" to \"+newMap,\"Inter map teleport\", 0,\"default\",\"300\",\"50\")]",
          "label": "InterTel Msg",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Typical Door":         {
          "index": 9,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'<!-----------------------------Standard Door Event---------------------------------->']\n[h:'<!--Here you enter the code to that effects the token that operates the door-->']\n\n[h:'<!-- \n- \"tokList\" is a list of tokens that are in the vicinity of the door when its operated. The first in the list are the tokens owned by the user that operated the door\n- \"users\" is a list of users where the first in the list is the user that operated the door, the rest of the list are users that own tokens that are in the vicinity\n- \"door\" is the name of the door that is operated\n- \"doorIsopened\" is true (1) when the player opens the door and false (0) when the player closed the door\n- \"isLocked\" is true (1) when the door has the \"Locked\" state and false (0) when it has not.\n- \"triggerType\" is always \"door\" this to prevent accidentily assigning the wrong eventtypes to a trigger\n-->']\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:thisPlayer\t\t\t= arg(1)]\n[h:tokList\t\t\t\t= arg(2)]\n[h:byStanders\t\t\t= arg(3)]\n[h:door\t\t\t\t\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n[h:doorIsOpened\t\t\t= arg(6)]\n[h:isLocked\t\t\t\t= arg(7)]\n\n<!-- assert that the trigger is a door event -->\n[h:assert(triggerType == \"door\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to door: \"+door, 0)]\n\n<!-- make operating token currentToken -->\n[h:switchToken(me)]\n\n<!-- THIS IS THE PART THAT YOU MOST LIKELY WANT TO EDIT -->\n<!-- BROADCAST IS THE ONLY WAY TO CONVEY A MESSAGE TO THE CHAT-->\n[h, if(isLocked), CODE:{\n\t<!-- this is executed when someone tries to open the door but its locked -->\n\n\t<!-- this is send to the operator -->\n\t[broadcast(\"You try to open the door but it won't budge, perhaps its locked?\",thisPlayer)]\n\n\t<!-- this is send to the bystanders -->\n\t[broadcast(me+\" tries to open the door but it appears to be locked\",byStanders)]\n\t\n\t<!-- if the door is locked AND you send something to the chat, than you need to abort here. Else its done in the core function and another message is send to the chat. -->\n\t[abort(0)]\n}; {\n\t<!-- this is executed when someone opens or closes the door-->\n\t<!-- to the operator -->\n\t[if(doorIsOpened): broadcast(\"The door makes a loud 'SQUEEEEEK' noise when you open the door\", thisPlayer); broadcast(\"You close the door with an audible 'CLICK' \", thisPlayer)]\n\t<!-- to the bystanders -->\n\t[if(doorIsOpened): broadcast(\"With a loud 'SQUEEEEEK' the door opens\", byStanders); broadcast(\"The door closes with an audible 'CLICK' \", byStanders)]\n}]",
          "label": "Typical Door",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "door events",
          "autoExecute": true,
          "tooltip": ""
        },
        "onTokenMoveTrigger":         {
          "index": 16,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:broadcast(arg(0)+\" moved!\"]",
          "label": "onTokenMoveTrigger",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Teleport All":         {
          "index": 10,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1)]",
          "label": "Teleport All",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Tel Pre Message":         {
          "index": 14,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_animateText(\"Teleporting in 5,     4,     3,     2,    1     \", \"Test message\",0,\"default\",\"300\",\"50\")]",
          "label": "Tel Pre Message",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Teleport Message":         {
          "index": 13,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"Message for you sir \"+tok, \"Test message\",0,\"default\",\"300\",\"50\")]",
          "label": "Teleport Message",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        }
      },
      "cpDel.groupList": "__no group name__, CORE, door events, Event list macros, pad events",
      "cpDel.macroList": "",
      "cpDel.macrosInGroup":       {
        "__no group name__": "REMOVE THIS",
        "CORE": "Limit Movement, onCampaignLoad",
        "door events": "Typical Door",
        "Event list macros": "Green Team Teleport, Red Team Teleport, InterTel Msg, onTokenMoveTrigger, Teleport All, Tel Pre Message, Teleport Message",
        "pad events": "Standard Trap, Standard Pit, Standard Net Trap, Limit Sight"
      },
      "crowd":       [
        "Canopy Canopy 14",
        "Canopy Canopy 15",
        "Canopy Canopy 46",
        "Canopy Canopy 63",
        "Canopy Canopy 68",
        "Canopy Canopy 106",
        "Canopy Canopy 126",
        "Canopy Canopy 139",
        "Canopy Canopy 147",
        "Canopy Canopy 151",
        "Canopy Canopy 156",
        "Canopy Canopy 160",
        "Canopy Canopy 165",
        "Canopy Canopy 166",
        "Canopy Canopy 172",
        "Canopy Canopy 174",
        "Canopy Canopy 176",
        "Canopy Canopy 179",
        "Canopy Canopy 183",
        "Canopy Canopy 195",
        "Canopy Canopy 204",
        "Canopy Canopy 210",
        "Canopy Canopy 213",
        "Canopy Canopy 223",
        "Canopy Canopy 245",
        "Canopy Canopy 247",
        "Canopy Canopy 260",
        "Canopy Canopy 266",
        "Canopy Canopy 268",
        "Canopy Canopy 274",
        "Canopy Canopy 295",
        "Canopy Canopy 297",
        "Canopy Canopy 298",
        "Canopy Canopy 300",
        "Canopy Canopy 308",
        "Canopy Canopy 337",
        "Canopy Canopy 345",
        "Canopy Canopy 364",
        "Canopy Canopy 365",
        "Canopy Canopy 366",
        "Canopy Canopy 372",
        "Canopy Canopy 376",
        "Canopy Canopy 378",
        "Canopy Canopy 379",
        "Canopy Canopy 390",
        "Canopy Canopy 393",
        "Canopy Canopy 397",
        "Canopy Canopy 399",
        "Canopy Canopy 403",
        "Canopy Canopy 406",
        "Canopy Canopy 429",
        "Canopy Canopy 430",
        "Canopy Canopy 442",
        "Canopy Canopy 453",
        "Canopy Canopy 467",
        "Canopy Canopy 476",
        "Canopy Canopy 479",
        "Canopy Canopy 483",
        "Canopy Canopy 484",
        "Canopy Canopy 495",
        "Canopy Canopy 505",
        "Canopy Canopy 506",
        "Canopy Canopy 507",
        "Canopy Canopy 516",
        "Canopy Canopy 521",
        "Canopy Canopy 532",
        "Canopy Canopy 536",
        "Canopy Canopy 543",
        "Canopy Canopy 558",
        "Canopy Canopy 568",
        "Canopy Canopy 577",
        "Canopy Canopy 580",
        "Canopy Canopy 594",
        "Canopy Canopy 604",
        "Canopy Canopy 613",
        "Canopy Canopy 624",
        "Canopy Canopy 627",
        "Canopy Canopy 662",
        "Canopy Canopy 663",
        "Canopy Canopy 672",
        "Canopy Canopy 674",
        "Canopy Canopy 683",
        "Canopy Canopy 684",
        "Canopy Canopy 685",
        "Canopy Canopy 692",
        "Canopy Canopy 720",
        "Canopy Canopy 724",
        "Canopy Canopy 730",
        "Canopy Canopy 735",
        "Canopy Canopy 737",
        "Canopy Canopy 741",
        "Canopy Canopy 769",
        "Canopy Canopy 776",
        "Canopy Canopy 806",
        "Canopy Canopy 807",
        "Canopy Canopy 828",
        "Canopy Canopy 845",
        "Canopy Canopy 846",
        "Canopy Canopy 850",
        "Canopy Canopy 860",
        "Canopy Canopy 861",
        "Canopy Canopy 868",
        "Canopy Canopy 872",
        "Canopy Canopy 890",
        "Canopy Canopy 901",
        "Canopy Canopy 931",
        "Canopy Canopy 938",
        "Canopy Canopy 945",
        "Canopy Canopy 947",
        "Canopy Canopy 949",
        "Canopy Canopy 958",
        "Canopy Canopy 960",
        "Canopy Canopy 981",
        "Canopy Canopy 984",
        "Canopy Canopy 990",
        "Canopy Canopy 993",
        "Canopy Canopy 995",
        "Canopy Canopy 997",
        "Canopy Canopy 1007",
        "Canopy Canopy 1010",
        "Canopy Canopy 1023",
        "Canopy Canopy 1030",
        "Canopy Canopy 1032",
        "Canopy Canopy 1047",
        "Canopy Canopy 1050",
        "Canopy Canopy 1057",
        "Canopy Canopy 1064",
        "Canopy Canopy 1065",
        "Canopy Canopy 1071",
        "Canopy Canopy 1084",
        "Canopy Canopy 1085",
        "Canopy Canopy 1090",
        "Canopy Canopy 1096",
        "Canopy Canopy 1104",
        "Canopy Canopy 1108",
        "Canopy Canopy 1110",
        "Canopy Canopy 1111",
        "Canopy Canopy 1125",
        "Canopy Canopy 1135",
        "Canopy Canopy 1138",
        "Canopy Canopy 1141",
        "Canopy Canopy 1142",
        "Canopy Canopy 1147",
        "Canopy Canopy 1152",
        "Canopy Canopy 1155",
        "Canopy Canopy 1158",
        "Canopy Canopy 1173",
        "Canopy Canopy 1176",
        "Canopy Canopy 1178",
        "Canopy Canopy 1181",
        "Canopy Canopy 1189",
        "Canopy Canopy 1207",
        "Canopy Canopy 1217",
        "Canopy Canopy 1220",
        "Canopy Canopy 1221",
        "Canopy Canopy 1233",
        "Canopy Canopy 1240",
        "Canopy Canopy 1275",
        "Canopy Canopy 1279",
        "Canopy Canopy 1305",
        "Canopy Canopy 1319",
        "Canopy Canopy 1326",
        "Canopy Canopy 1330",
        "Canopy Canopy 1342",
        "Canopy Canopy 1351",
        "Canopy Canopy 1355",
        "Canopy Canopy 1362",
        "Canopy Canopy 1367",
        "Canopy Canopy 1372",
        "Canopy Canopy 1375",
        "Canopy Canopy 1377",
        "Canopy Canopy 1380",
        "Canopy Canopy 1384",
        "Canopy Canopy 1394",
        "Canopy Canopy 1412",
        "Canopy Canopy 1431",
        "Canopy Canopy 1455",
        "Canopy Canopy 1456",
        "Canopy Canopy 1460",
        "Canopy Canopy 1462",
        "Canopy Canopy 1469",
        "Canopy Canopy 1472",
        "Canopy Canopy 1489",
        "Canopy Canopy 1491",
        "Canopy Canopy 1494",
        "Canopy Canopy 1501",
        "Canopy Canopy 1513",
        "Canopy Canopy 1514",
        "Canopy Canopy 1518",
        "Canopy Canopy 1530",
        "Canopy Canopy 1531",
        "Canopy Canopy 1540",
        "Canopy Canopy 1542",
        "Canopy Canopy 1544",
        "Canopy Canopy 1567",
        "Canopy Canopy 1569",
        "Canopy Canopy 1587",
        "Canopy Canopy 1613",
        "Canopy Canopy 1617",
        "Canopy Canopy 1623",
        "Canopy Canopy 1625",
        "Canopy Canopy 1638",
        "Canopy Canopy 1651",
        "Canopy Canopy 1652",
        "Canopy Canopy 1671",
        "Canopy Canopy 1672",
        "Canopy Canopy 1686",
        "Canopy Canopy 1687",
        "Canopy Canopy 1704",
        "Canopy Canopy 1713",
        "Canopy Canopy 1731",
        "Canopy Canopy 1733",
        "Canopy Canopy 1736",
        "Canopy Canopy 1779",
        "Canopy Canopy 1785",
        "Canopy Canopy 1812",
        "Canopy Canopy 1815",
        "Canopy Canopy 1821",
        "Canopy Canopy 1830",
        "Canopy Canopy 1839",
        "Canopy Canopy 1877"
      ],
      "crowd.antagonist": "",
      "crowd.images": [],
      "crowd.speed": "",
      "crowd.tokens":       [
        "Crowd_01",
        "Crowd_02",
        "Crowd_03",
        "Crowd_04",
        "Crowd_05",
        "Crowd_06",
        "Crowd_07",
        "Crowd_08",
        "Crowd_09",
        "Crowd_10"
      ],
      "crowd.xMax": 14,
      "crowd.xMin": 0,
      "crowd.yMax": 14,
      "crowd.yMin": 2,
      "delay": "",
      "dieList0": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList1": "4, 6, 8, 10",
      "dieList2": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList3": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList4": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList5": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList6": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList7": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList8": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList9": "4, 5, 6, 8, 10, 12, 20, 100",
      "disableOCLCheck": 0,
      "drawTokenMap": "",
      "drawTokenName": "Area Marker",
      "excludeLightTypes": "Deflector, Flame, Grenade, Horde Melee, Special, Ranges, Suppress, bla",
      "excludedMaps":       [
        "Forest",
        "VBL"
      ],
      "fieldToks":       [
        "0000000089DAD88B1C61000000000000",
        "000000008DDAD88B2361000000000000",
        "0000000091DAD88B2F61000000000000",
        "0000000095DAD88B3B61000000000000",
        "000000009ADAD88B4761000000000000",
        "000000009EDAD88B5361000000000000",
        "00000000A3DAD88B6461000000000000",
        "00000000A8DAD88B6C61000000000000",
        "00000000ACDAD88B7761000000000000",
        "00000000B0DAD88B8361000000000000",
        "00000000B4DAD88B9161000000000000",
        "00000000B9DAD88B9B61000000000000",
        "00000000BEDAD88BAC61000000000000",
        "00000000C2DAD88BB361000000000000",
        "00000000C6DAD88BC161000000000000",
        "00000000CBDAD88BCB61000000000000",
        "00000000CFDAD88BD761000000000000",
        "00000000D3DAD88BE461000000000000",
        "00000000D8DAD88BF461000000000000",
        "00000000DDDAD88BFB61000000000000",
        "00000000E1DAD88B0962000000000000",
        "00000000E6DAD88B1362000000000000",
        "00000000EADAD88B2162000000000000",
        "00000000EFDAD88B2B62000000000000",
        "00000000F4DAD88B3C62000000000000",
        "00000000F9DAD88B4562000000000000",
        "00000000FEDAD88B5162000000000000",
        "0000000003DBD88B5D62000000000000",
        "0000000007DBD88B6C62000000000000",
        "000000000CDBD88B7762000000000000",
        "0000000012DBD88B8462000000000000",
        "0000000016DBD88B8D62000000000000",
        "000000001BDBD88B9962000000000000",
        "000000001FDBD88BA562000000000000",
        "0000000023DBD88BB162000000000000",
        "0000000028DBD88BBD62000000000000",
        "000000002DDBD88BCC62000000000000",
        "0000000032DBD88BD562000000000000",
        "0000000036DBD88BE362000000000000",
        "000000003BDBD88BED62000000000000",
        "0000000040DBD88BFC62000000000000",
        "0000000045DBD88B0863000000000000"
      ],
      "forceRoomShare": 2,
      "fullScreenBroadcast": 0,
      "fullScreenMode": 0,
      "gmNames": ["melek"],
      "height": "",
      "height1": "",
      "invisState": "invisibility",
      "languages": "",
      "lastAnimatedTextSettings": "",
      "lastLinkId": "",
      "lastLinkSettings": "currentMap=;lastLinkId=",
      "lastMassVBLSettings": "option=0 ; searchStr=tree ; doTokenLayer=0 ; doObjectLayer=1 ; doHiddenLayer=0 ; doBackgroundLayer=1 ; scaleOption=0 ; scale=0.5 ; storeVBL=1 ; vblName=maptrees ; ",
      "lastSelection.GroupSelect": [],
      "libCoordSize": 30,
      "libversion": "47e",
      "linkedAreas":       {
        "Difficult Terrain Map": {},
        "Difficult Terrain Map.W42.Limit":         {
          "difficult area": "Limit Movement",
          "Very difficult terrain": "Limit Movement"
        },
        "BASE": {},
        "BASE.W42.Limit": {},
        "Limited Sight": {"Limit Vision Area": "eventMacro=Limit Sight ; eventTriggerList=movedOn, movedOff ; "},
        "Limited Sight.W42.Limit": {}
      },
      "linkedMappedPads":       {
        "Forest new": {},
        "Sound Test First Floor": {},
        "BASE": {},
        "Sound Test Ground Floor": {},
        "ShadowPad Example": {},
        "Limited Sight": {},
        "Life": {},
        "Teleports 2": {},
        "Shadow Pad Tutorial": {},
        "Example Map of Special pads":         {
          "1": "Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2",
          "2": "Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4",
          "3": "Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3",
          "4": "Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2"
        },
        "Difficult Terrain": {},
        "Follow Me Tiles": {}
      },
      "macroCopies": "",
      "mapField.xMax": -8,
      "mapField.xMin": -14,
      "mapField.yMax": 22,
      "mapField.yMin": 17,
      "mappedCoords": "",
      "maxGroupSelect": 500,
      "maxOrderSelect": 300,
      "maxPadsPerRun": 500,
      "numericIdOnly": 0,
      "onTokenMoveEvent": "",
      "optionsList0": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList1": "showMod=0 ; showTarget=0 ; showExplode=0 ; showResults=0 ; showTooltip=0 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList2": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList3": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList4": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList5": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList6": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList7": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList8": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList9": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "padNameList": "Ward, Linked, EventPad, ShadowPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJump, PadDrop, InterJump, InterDrop, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, MappedPad, Roof, Foliage, Canopy, VPCU, SoundPad",
      "pixelStep": "",
      "players": "",
      "plothos.bot.messages": {},
      "purgeInvisState": "invisibility_purge",
      "purgeState": "invisibility_purge",
      "rpe.allIndexes": "33, 29, 30, 34, 35, 28, 12, 15, 11, 14, 10, 13, 16, 6, 5, 3, 27, 23, 26, 24, 20, 22, 9",
      "rpe.macroGroups":       {
        " ": "",
        "Benchmark Macros": "33, 29, 30, 34, 35",
        "Event list macros": "28, 12, 15, 11, 14, 10, 13, 16",
        "CORE": "6, 5",
        "Event Pad Macros": "3, 27, 23, 26, 24",
        "Event Button macros": "20, 22",
        "Event Door Macros": 9
      },
      "rpe.options":       {
        "editMode": 0,
        "reSort": 0,
        "cleanComment": 0,
        "loadLastOnStart": 0,
        "formWidth": 92,
        "formHeight": 18,
        "openDialog": 0,
        "saveTA": 0,
        "notepadFormat": 0,
        "macroSelect": 0,
        "stdButtons": 0
      },
      "runSwitchForm": 0,
      "seeInvisState": "invisibility_see",
      "seekTokensLastSettings": "findTok=centreOnMePad ; showImage=0 ; showName=1 ; showLayer=0 ; copyTok=0 ; libTok=0 ; doTokenLayer=1 ; doObjectLayer=1 ; doHiddenLayer=1 ; doBackgroundLayer=1",
      "showAreaTokens":       {
        "BASE": {},
        "Difficult Terrain Map":         {
          "difficult area": "83B41DD7CCBE493D2C20000001001CC4, 83B41DD7CFBE493D3220000001001CC7, 83B41DD7D2BE493D3D20000001001CD2, 83B41DD7D5BE493D4820000001001CD5, 83B41DD7D8BE493D5320000001001CD0, 83B41DD7DCBE493D5E20000001001CD4, 83B41DD7E0BE493D6920000001001CC0, 83B41DD7E4BE493D7420000001001CC4, 83B41DD7EABE493D8420000001001CC2, 83B41DD7EDBE493D8A20000001001CC5, 83B41DD7FBBE493D9A20000001001CD3, 83B41DD7FEBE493DA020000001001CD6, 83B41DD703BF493DAF20000001001D03, 83B41DD706BF493DB620000001001D06, 83B41DD726BF493DC620000001001D06, 83B41DD729BF493DCC20000001001D01, 83B41DD72DBF493DD720000001001D05, 83B41DD730BF493DE220000001001D10, 83B41DD738BF493DF220000001001D10, 83B41DD750BF493DF820000001001D50, 83B41DD753BF493D0321000001001D53, 83B41DD757BF493D0E21000001001D57, 83B41DD75ABF493D1921000001001D52, 83B41DD75DBF493D2421000001001D55, 83B41DD760BF493D2F21000001001D40, 83B41DD765BF493D3F21000001001D45, 83B41DD768BF493D4521000001001D40, 83B41DD76BBF493D5021000001001D43, 83B41DD76EBF493D5B21000001001D46, 83B41DD772BF493D6621000001001D52, 83B41DD775BF493D7121000001001D55, 83B41DD778BF493D7C21000001001D50, 83B41DD78ABF493D8C21000001001D82, 83B41DD78DBF493D9221000001001D85, 83B41DD791BF493D9D21000001001D91, 83B41DD794BF493DA821000001001D94, 83B41DD798BF493DB321000001001D90, 83B41DD79BBF493DBE21000001001D93, 83B41DD7A8BF493DCE21000001001D80, 83B41DD7ABBF493DD421000001001D83, 83B41DD7AFBF493DDF21000001001D87, 83B41DD7B2BF493DEA21000001001D92, 83B41DD7C8BF493DFA21000001001DC0, 83B41DD7CBBF493D0022000001001DC3, 83B41DD7D8BF493D1022000001001DD0, 83B41DD7DBBF493D1622000001001DD3, 83B41DD7E6BF493D2622000001001DC6, 83B41DD7E9BF493D2C22000001001DC1, 83B41DD7F7BF493D3C22000001001DD7, 83B41DD7FABF493D4222000001001DD2, 83B41DD7FEBF493D4F22000001001DD6, 83B41DD701C0493D5822000001000001, 83B41DD704C0493D6322000001000004, 83B41DD708C0493D6E22000001000000, 83B41DD70BC0493D7922000001000003, 83B41DD70EC0493D8422000001000006, 83B41DD72AC0493D9422000001000002, 83B41DD72DC0493D9A22000001000005, 83B41DD73BC0493DAA22000001000013, 83B41DD73EC0493DB022000001000016, 83B41DD741C0493DBB22000001000041, 83B41DD745C0493DC622000001000045, 83B41DD74BC0493DD622000001000043, 83B41DD74EC0493DDC22000001000046, 83B41DD75FC0493DEC22000001000057, 83B41DD762C0493DF222000001000042, 83B41DD766C0493DFD22000001000046, 83B41DD769C0493D0823000001000041, 83B41DD76CC0493D1323000001000044, 83B41DD76FC0493D1E23000001000047, 83B41DD77DC0493D2E23000001000055, 83B41DD780C0493D3423000001000080, 83B41DD78EC0493D4423000001000086, 83B41DD791C0493D4A23000001000091, 83B41DD795C0493D5523000001000095, 83B41DD798C0493D6023000001000090, 83B41DD79CC0493D6B23000001000094, 83B41DD79FC0493D7623000001000097, 83B41DD7A3C0493D8123000001000083, 83B41DD7A6C0493D8C23000001000086, 83B41DD7B6C0493D9C23000001000096, 83B41DD7B9C0493DA223000001000091, 83B41DD7BCC0493DAD23000001000094, 83B41DD7BFC0493DB823000001000097, 83B41DD7C3C0493DC3230000010000C3, 83B41DD7C6C0493DCE230000010000C6, 83B41DD7D3C0493DDE230000010000D3, 83B41DD7D6C0493DE4230000010000D6, 83B41DD7E2C0493DF4230000010000C2, 83B41DD7E5C0493DFA230000010000C5, 83B41DD7F4C0493D0A240000010000D4, 83B41DD7F7C0493D10240000010000D7, 83B41DD708C1493D2024000001000100, 83B41DD70BC1493D2624000001000103, 83B41DD70EC1493D3124000001000106, 83B41DD713C1493D4024000001000113, 83B41DD716C1493D4724000001000116, 83B41DD719C1493D5224000001000111, 83B41DD724C1493D6224000001000104, 83B41DD727C1493D6824000001000107, 83B41DD731C1493D7824000001000111, 83B41DD735C1493D7E24000001000115, 83B41DD738C1493D8924000001000110, 83B41DD73CC1493D9424000001000114, 83B41DD748C1493DA424000001000140, 83B41DD74BC1493DAA24000001000143, 83B41DD759C1493DBA24000001000151, 83B41DD75DC1493DC024000001000155, 83B41DD76EC1493DD024000001000146, 83B41DD771C1493DD624000001000151, 83B41DD774C1493DE124000001000154, 83B41DD778C1493DEC24000001000150, 83B41DD77BC1493DF724000001000153, 83B41DD77FC1493D0225000001000157, 83B41DD783C1493D0D25000001000183, 83B41DD787C1493D1825000001000187, 83B41DD78BC1493D2325000001000183, 83B41DD78EC1493D2E25000001000186, 83B41DD798C1493D3E25000001000190, 83B41DD79CC1493D4425000001000194, 83B41DD7A7C1493D5425000001000187, 83B41DD7AAC1493D5A25000001000182, 83B41DD7B8C1493D6A25000001000190, 83B41DD7BBC1493D7025000001000193, 83B41DD7C5C1493D80250000010001C5, 83B41DD7C9C1493D86250000010001C1, 83B41DD7CCC1493D91250000010001C4, 83B41DD7D0C1493D9C250000010001D0, 83B41DD7D3C1493DA7250000010001D3, 83B41DD7D6C1493DB2250000010001D6, 83B41DD7E6C1493DC2250000010001C6, 83B41DD7E9C1493DC8250000010001C1, 83B41DD7EDC1493DD3250000010001C5, 83B41DD7F0C1493DDE250000010001D0, 83B41DD7F3C1493DE9250000010001D3, 83B41DD7F8C1493DF4250000010001D0, 83B41DD702C2493D0426000001000002, 83B41DD706C2493D0A26000001000006, 83B41DD70BC2493D1A26000001000003, 83B41DD70EC2493D2026000001000006, 83B41DD712C2493D2B26000001000012, 83B41DD72EC2493D3626000001000006, 83B41DD734C2493D4126000001000014, 83B41DD737C2493D4C26000001000017, 83B41DD73AC2493D5726000001000012, 83B41DD73EC2493D6226000001000016, 83B41DD742C2493D6D26000001000042, 83B41DD745C2493D7826000001000045, 83B41DD748C2493D8326000001000040, 83B41DD753C2493D9326000001000053, 83B41DD756C2493D9926000001000056, 83B41DD75AC2493DA426000001000052, 83B41DD75DC2493DAF26000001000055, 83B41DD761C2493DBA26000001000041",
          "Very difficult terrain": "83B41DD717074E3D5333000001040517, 83B41DD71A074E3D5933000001040512, 83B41DD71D074E3D6433000001040515, 83B41DD720074E3D6F33000001040500, 83B41DD723074E3D7A33000001040503, 83B41DD726074E3D8533000001040506, 83B41DD72C074E3D9533000001040504, 83B41DD72F074E3D9B33000001040507, 83B41DD73D074E3DAB33000001040515, 83B41DD740074E3DB133000001040540, 83B41DD746074E3DC133000001040546, 83B41DD749074E3DC733000001040541, 83B41DD75B074E3DD733000001040553, 83B41DD75D074E3DDD33000001040555, 83B41DD761074E3DE833000001040541, 83B41DD764074E3DF333000001040544, 83B41DD767074E3DFE33000001040547, 83B41DD76C074E3D0E34000001040544, 83B41DD76F074E3D1434000001040547, 83B41DD77C074E3D2434000001040554, 83B41DD77F074E3D2A34000001040557, 83B41DD784074E3D3A34000001040584, 83B41DD787074E3D4034000001040587, 83B41DD78B074E3D4B34000001040583, 83B41DD78E074E3D5634000001040586, 83B41DD7A2074E3D6634000001040582, 83B41DD7A5074E3D6C34000001040585, 83B41DD7A8074E3D7734000001040580, 83B41DD7AC074E3D8234000001040584, 83B41DD7AF074E3D8D34000001040587, 83B41DD7B2074E3D9834000001040592, 83B41DD7CC074E3DA8340000010405C4, 83B41DD7CF074E3DAE340000010405C7, 83B41DD7DC074E3DBE340000010405D4, 83B41DD7DF074E3DC4340000010405D7, 83B41DD7E3074E3DCF340000010405C3, 83B41DD7E6074E3DDA340000010405C6, 83B41DD7F2074E3DEA340000010405D2, 83B41DD7F5074E3DF0340000010405D5, 83B41DD7F9074E3DFB340000010405D1, 83B41DD7FC074E3D06350000010405D4, 83B41DD7FF074E3D11350000010405D7, 83B41DD702084E3D1C35000001040802, 83B41DD711084E3D2C35000001040811, 83B41DD714084E3D3235000001040814, 83B41DD721084E3D4235000001040801, 83B41DD724084E3D4835000001040804, 83B41DD727084E3D5335000001040807, 83B41DD72B084E3D5E35000001040803, 83B41DD72E084E3D6935000001040806, 83B41DD731084E3D7435000001040811, 83B41DD73E084E3D8435000001040816, 83B41DD741084E3D8A35000001040841, 83B41DD745084E3D9535000001040845, 83B41DD748084E3DA035000001040840, 83B41DD74C084E3DAB35000001040844, 83B41DD74F084E3DB635000001040847, 83B41DD752084E3DC135000001040852, 83B41DD755084E3DCC35000001040855, 83B41DD763084E3DDC35000001040843, 83B41DD766084E3DE235000001040846, 83B41DD77F084E3DF235000001040857, 83B41DD782084E3DF835000001040882, 83B41DD785084E3D0336000001040885, 83B41DD788084E3D0E36000001040880, 83B41DD795084E3D1E36000001040895, 83B41DD798084E3D2436000001040890, 83B41DD79B084E3D2F36000001040893, 83B41DD79E084E3D3A36000001040896, 83B41DD7AD084E3D4A36000001040885, 83B41DD7B0084E3D5036000001040890, 83B41DD7B4084E3D5B36000001040894, 83B41DD7B7084E3D6636000001040897, 83B41DD7BA084E3D7136000001040892, 83B41DD7BE084E3D7C36000001040896, 83B41DD7C9084E3D8C360000010408C1, 83B41DD7CD084E3D92360000010408C5, 83B41DD7D9084E3DA2360000010408D1, 83B41DD7DC084E3DA8360000010408D4, 83B41DD7E0084E3DB3360000010408C0, 83B41DD7E3084E3DBE360000010408C3, 83B41DD7EB084E3DCE360000010408C3, 83B41DD7EE084E3DD4360000010408C6, 83B41DD7FE084E3DE4360000010408D6, 83B41DD701094E3DEA36000001040901, 83B41DD705094E3DF536000001040905, 83B41DD708094E3D0037000001040900, 83B41DD70B094E3D0B37000001040903, 83B41DD70F094E3D1637000001040907, 83B41DD71A094E3D2637000001040912, 83B41DD71E094E3D2C37000001040916, 83B41DD721094E3D3737000001040901, 83B41DD724094E3D4237000001040904, 83B41DD728094E3D4D37000001040900, 83B41DD72B094E3D5837000001040903, 83B41DD72E094E3D6337000001040906, 83B41DD732094E3D6E37000001040912, 83B41DD73D094E3D7E37000001040915, 83B41DD741094E3D8437000001040941, 83B41DD74F094E3D9437000001040947, 83B41DD752094E3D9A37000001040952, 83B41DD763094E3DAA37000001040943, 83B41DD766094E3DB037000001040946, 83B41DD769094E3DBB37000001040941, 83B41DD76D094E3DC637000001040945, 83B41DD770094E3DD137000001040950, 83B41DD774094E3DDC37000001040954, 83B41DD78D094E3DEC37000001040985, 83B41DD790094E3DF237000001040990, 83B41DD793094E3DFD37000001040993, 83B41DD796094E3D0838000001040996, 83B41DD7A2094E3D1838000001040982, 83B41DD7A5094E3D1E38000001040985, 83B41DD7A8094E3D2938000001040980, 83B41DD7AB094E3D3438000001040983, 83B41DD7B3094E3D4438000001040993"
        }
      },
      "showGroupPanelOnSelect": 0,
      "speed": 50,
      "startUpCoords": "1,19",
      "startUpMap": "BASE",
      "stepSize": 26,
      "storedAreas":       {
        "Difficult Terrain Map":         {
          "difficult area":           [
                        {
              "x": 400,
              "y": 900
            },
                        {
              "x": 500,
              "y": 800
            },
                        {
              "x": 600,
              "y": 700
            },
                        {
              "x": 700,
              "y": 600
            },
                        {
              "x": 800,
              "y": 500
            },
                        {
              "x": 650,
              "y": 0
            },
                        {
              "x": 400,
              "y": 800
            },
                        {
              "x": 500,
              "y": 700
            },
                        {
              "x": 300,
              "y": 900
            },
                        {
              "x": 700,
              "y": 500
            },
                        {
              "x": 600,
              "y": 600
            },
                        {
              "x": 800,
              "y": 400
            },
                        {
              "x": 550,
              "y": -50
            },
                        {
              "x": 150,
              "y": 900
            },
                        {
              "x": 700,
              "y": 350
            },
                        {
              "x": 750,
              "y": 300
            },
                        {
              "x": 500,
              "y": 900
            },
                        {
              "x": 700,
              "y": 700
            },
                        {
              "x": 600,
              "y": 800
            },
                        {
              "x": 800,
              "y": 600
            },
                        {
              "x": 700,
              "y": 800
            },
                        {
              "x": 600,
              "y": 900
            },
                        {
              "x": 800,
              "y": 700
            },
                        {
              "x": 250,
              "y": 950
            },
                        {
              "x": 350,
              "y": 850
            },
                        {
              "x": 450,
              "y": 750
            },
                        {
              "x": 550,
              "y": 650
            },
                        {
              "x": 750,
              "y": 450
            },
                        {
              "x": 650,
              "y": 550
            },
                        {
              "x": 700,
              "y": -50
            },
                        {
              "x": 450,
              "y": 950
            },
                        {
              "x": 650,
              "y": 750
            },
                        {
              "x": 550,
              "y": 850
            },
                        {
              "x": 750,
              "y": 650
            },
                        {
              "x": 500,
              "y": 1000
            },
                        {
              "x": 450,
              "y": 200
            },
                        {
              "x": 500,
              "y": 150
            },
                        {
              "x": 600,
              "y": -50
            },
                        {
              "x": 550,
              "y": 100
            },
                        {
              "x": 500,
              "y": 200
            },
                        {
              "x": 700,
              "y": 0
            },
                        {
              "x": 600,
              "y": 100
            },
                        {
              "x": 500,
              "y": 100
            },
                        {
              "x": 600,
              "y": 0
            },
                        {
              "x": 500,
              "y": 0
            },
                        {
              "x": 500,
              "y": -150
            },
                        {
              "x": 550,
              "y": -100
            },
                        {
              "x": 300,
              "y": 1000
            },
                        {
              "x": 700,
              "y": 400
            },
                        {
              "x": 300,
              "y": 800
            },
                        {
              "x": 200,
              "y": 900
            },
                        {
              "x": 700,
              "y": 50
            },
                        {
              "x": 250,
              "y": 1000
            },
                        {
              "x": 600,
              "y": 200
            },
                        {
              "x": 700,
              "y": 100
            },
                        {
              "x": 500,
              "y": 750
            },
                        {
              "x": 350,
              "y": 900
            },
                        {
              "x": 300,
              "y": 950
            },
                        {
              "x": 400,
              "y": 850
            },
                        {
              "x": 450,
              "y": 800
            },
                        {
              "x": 600,
              "y": 650
            },
                        {
              "x": 650,
              "y": 600
            },
                        {
              "x": 700,
              "y": 550
            },
                        {
              "x": 550,
              "y": 700
            },
                        {
              "x": 500,
              "y": -200
            },
                        {
              "x": 800,
              "y": 450
            },
                        {
              "x": 600,
              "y": -100
            },
                        {
              "x": 750,
              "y": 500
            },
                        {
              "x": 700,
              "y": 200
            },
                        {
              "x": 500,
              "y": 950
            },
                        {
              "x": 550,
              "y": 900
            },
                        {
              "x": 600,
              "y": 850
            },
                        {
              "x": 700,
              "y": 750
            },
                        {
              "x": 650,
              "y": 800
            },
                        {
              "x": 750,
              "y": 700
            },
                        {
              "x": 800,
              "y": 650
            },
                        {
              "x": 700,
              "y": 300
            },
                        {
              "x": 600,
              "y": 50
            },
                        {
              "x": 350,
              "y": 1050
            },
                        {
              "x": 600,
              "y": 250
            },
                        {
              "x": 750,
              "y": 100
            },
                        {
              "x": 650,
              "y": 200
            },
                        {
              "x": 700,
              "y": 150
            },
                        {
              "x": 500,
              "y": 50
            },
                        {
              "x": 600,
              "y": 150
            },
                        {
              "x": 650,
              "y": 100
            },
                        {
              "x": 550,
              "y": 200
            },
                        {
              "x": 450,
              "y": 1000
            },
                        {
              "x": 400,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 1050
            },
                        {
              "x": 700,
              "y": 250
            },
                        {
              "x": 750,
              "y": 200
            },
                        {
              "x": 750,
              "y": 0
            },
                        {
              "x": 450,
              "y": 1050
            },
                        {
              "x": 200,
              "y": 950
            },
                        {
              "x": 750,
              "y": 400
            },
                        {
              "x": 300,
              "y": 850
            },
                        {
              "x": 250,
              "y": 900
            },
                        {
              "x": 350,
              "y": 800
            },
                        {
              "x": 700,
              "y": 450
            },
                        {
              "x": 550,
              "y": 600
            },
                        {
              "x": 500,
              "y": 650
            },
                        {
              "x": 800,
              "y": 350
            },
                        {
              "x": 400,
              "y": 750
            },
                        {
              "x": 450,
              "y": 700
            },
                        {
              "x": 500,
              "y": -50
            },
                        {
              "x": 550,
              "y": -150
            },
                        {
              "x": 550,
              "y": 0
            },
                        {
              "x": 450,
              "y": 850
            },
                        {
              "x": 350,
              "y": 950
            },
                        {
              "x": 650,
              "y": 650
            },
                        {
              "x": 550,
              "y": 750
            },
                        {
              "x": 750,
              "y": 550
            },
                        {
              "x": 450,
              "y": 150
            },
                        {
              "x": 400,
              "y": 1000
            },
                        {
              "x": 650,
              "y": 50
            },
                        {
              "x": 150,
              "y": 950
            },
                        {
              "x": 750,
              "y": 350
            },
                        {
              "x": 200,
              "y": 1000
            },
                        {
              "x": 650,
              "y": -100
            },
                        {
              "x": 600,
              "y": -150
            },
                        {
              "x": 750,
              "y": 250
            },
                        {
              "x": 750,
              "y": 50
            },
                        {
              "x": 750,
              "y": -50
            },
                        {
              "x": 650,
              "y": 150
            },
                        {
              "x": 550,
              "y": 250
            },
                        {
              "x": 550,
              "y": 950
            },
                        {
              "x": 750,
              "y": 750
            },
                        {
              "x": 650,
              "y": 850
            },
                        {
              "x": 650,
              "y": 250
            },
                        {
              "x": 750,
              "y": 150
            },
                        {
              "x": 650,
              "y": -50
            },
                        {
              "x": 550,
              "y": 50
            },
                        {
              "x": 350,
              "y": 1000
            },
                        {
              "x": 500,
              "y": -100
            },
                        {
              "x": 300,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 1000
            },
                        {
              "x": 500,
              "y": 1050
            },
                        {
              "x": 800,
              "y": 750
            },
                        {
              "x": 750,
              "y": 800
            },
                        {
              "x": 700,
              "y": 850
            },
                        {
              "x": 600,
              "y": 950
            },
                        {
              "x": 250,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 150
            },
                        {
              "x": 400,
              "y": 950
            },
                        {
              "x": 500,
              "y": 850
            },
                        {
              "x": 550,
              "y": 800
            },
                        {
              "x": 600,
              "y": 750
            },
                        {
              "x": 650,
              "y": 700
            },
                        {
              "x": 700,
              "y": 650
            },
                        {
              "x": 750,
              "y": 600
            },
                        {
              "x": 450,
              "y": 900
            },
                        {
              "x": 800,
              "y": 550
            },
                        {
              "x": 700,
              "y": -100
            }
          ],
          "Very difficult terrain":           [
                        {
              "x": 450,
              "y": -100
            },
                        {
              "x": 400,
              "y": -150
            },
                        {
              "x": 450,
              "y": -50
            },
                        {
              "x": 650,
              "y": 400
            },
                        {
              "x": 200,
              "y": 850
            },
                        {
              "x": 250,
              "y": 800
            },
                        {
              "x": 300,
              "y": 750
            },
                        {
              "x": 550,
              "y": 500
            },
                        {
              "x": 500,
              "y": 550
            },
                        {
              "x": 450,
              "y": 600
            },
                        {
              "x": 400,
              "y": 650
            },
                        {
              "x": 600,
              "y": 450
            },
                        {
              "x": 350,
              "y": 700
            },
                        {
              "x": 450,
              "y": 0
            },
                        {
              "x": 250,
              "y": 300
            },
                        {
              "x": 350,
              "y": 200
            },
                        {
              "x": 450,
              "y": 100
            },
                        {
              "x": 350,
              "y": 100
            },
                        {
              "x": 400,
              "y": 150
            },
                        {
              "x": 300,
              "y": 250
            },
                        {
              "x": 450,
              "y": -150
            },
                        {
              "x": 400,
              "y": 250
            },
                        {
              "x": 350,
              "y": 300
            },
                        {
              "x": 250,
              "y": 400
            },
                        {
              "x": 200,
              "y": 450
            },
                        {
              "x": 300,
              "y": 350
            },
                        {
              "x": 400,
              "y": 0
            },
                        {
              "x": 400,
              "y": 300
            },
                        {
              "x": 200,
              "y": 500
            },
                        {
              "x": 300,
              "y": 400
            },
                        {
              "x": 200,
              "y": 400
            },
                        {
              "x": 300,
              "y": 300
            },
                        {
              "x": 400,
              "y": 200
            },
                        {
              "x": 450,
              "y": -200
            },
                        {
              "x": 400,
              "y": -250
            },
                        {
              "x": 400,
              "y": 700
            },
                        {
              "x": 600,
              "y": 500
            },
                        {
              "x": 500,
              "y": 600
            },
                        {
              "x": 400,
              "y": 400
            },
                        {
              "x": 300,
              "y": 500
            },
                        {
              "x": 200,
              "y": 600
            },
                        {
              "x": 500,
              "y": 300
            },
                        {
              "x": 300,
              "y": 600
            },
                        {
              "x": 400,
              "y": 500
            },
                        {
              "x": 500,
              "y": 400
            },
                        {
              "x": 200,
              "y": 700
            },
                        {
              "x": 600,
              "y": 300
            },
                        {
              "x": 400,
              "y": 600
            },
                        {
              "x": 500,
              "y": 500
            },
                        {
              "x": 600,
              "y": 400
            },
                        {
              "x": 200,
              "y": 800
            },
                        {
              "x": 300,
              "y": 700
            },
                        {
              "x": 400,
              "y": 50
            },
                        {
              "x": 300,
              "y": 550
            },
                        {
              "x": 350,
              "y": 500
            },
                        {
              "x": 400,
              "y": 450
            },
                        {
              "x": 450,
              "y": 400
            },
                        {
              "x": 250,
              "y": 600
            },
                        {
              "x": 550,
              "y": 300
            },
                        {
              "x": 200,
              "y": 650
            },
                        {
              "x": 150,
              "y": 700
            },
                        {
              "x": 500,
              "y": 350
            },
                        {
              "x": 350,
              "y": 400
            },
                        {
              "x": 300,
              "y": 450
            },
                        {
              "x": 250,
              "y": 500
            },
                        {
              "x": 500,
              "y": 250
            },
                        {
              "x": 200,
              "y": 550
            },
                        {
              "x": 450,
              "y": 300
            },
                        {
              "x": 400,
              "y": 350
            },
                        {
              "x": 150,
              "y": 800
            },
                        {
              "x": 650,
              "y": 300
            },
                        {
              "x": 350,
              "y": 600
            },
                        {
              "x": 600,
              "y": 350
            },
                        {
              "x": 200,
              "y": 750
            },
                        {
              "x": 250,
              "y": 700
            },
                        {
              "x": 550,
              "y": 400
            },
                        {
              "x": 500,
              "y": 450
            },
                        {
              "x": 450,
              "y": 500
            },
                        {
              "x": 300,
              "y": 650
            },
                        {
              "x": 400,
              "y": 550
            },
                        {
              "x": 600,
              "y": 550
            },
                        {
              "x": 650,
              "y": 500
            },
                        {
              "x": 400,
              "y": -100
            },
                        {
              "x": 400,
              "y": 100
            },
                        {
              "x": 300,
              "y": 200
            },
                        {
              "x": 350,
              "y": 0
            },
                        {
              "x": 400,
              "y": -50
            },
                        {
              "x": 250,
              "y": 350
            },
                        {
              "x": 350,
              "y": 250
            },
                        {
              "x": 250,
              "y": 850
            },
                        {
              "x": 350,
              "y": 750
            },
                        {
              "x": 450,
              "y": 650
            },
                        {
              "x": 650,
              "y": 450
            },
                        {
              "x": 550,
              "y": 550
            },
                        {
              "x": 650,
              "y": 350
            },
                        {
              "x": 150,
              "y": 850
            },
                        {
              "x": 250,
              "y": 750
            },
                        {
              "x": 550,
              "y": 450
            },
                        {
              "x": 350,
              "y": 650
            },
                        {
              "x": 450,
              "y": 550
            },
                        {
              "x": 250,
              "y": 250
            },
                        {
              "x": 350,
              "y": 150
            },
                        {
              "x": 450,
              "y": 350
            },
                        {
              "x": 250,
              "y": 550
            },
                        {
              "x": 350,
              "y": 450
            },
                        {
              "x": 450,
              "y": 50
            },
                        {
              "x": 150,
              "y": 750
            },
                        {
              "x": 550,
              "y": 350
            },
                        {
              "x": 350,
              "y": 550
            },
                        {
              "x": 450,
              "y": 450
            },
                        {
              "x": 250,
              "y": 650
            },
                        {
              "x": 350,
              "y": 50
            },
                        {
              "x": 400,
              "y": -200
            },
                        {
              "x": 250,
              "y": 450
            },
                        {
              "x": 450,
              "y": 250
            },
                        {
              "x": 350,
              "y": 350
            }
          ]
        },
        "BASE": {},
        "Limited Sight": {"Limit Vision Area":         [
                    {
            "x": -1000,
            "y": -350
          },
                    {
            "x": 250,
            "y": -100
          },
                    {
            "x": 200,
            "y": -150
          },
                    {
            "x": -50,
            "y": -600
          },
                    {
            "x": 150,
            "y": -400
          },
                    {
            "x": 100,
            "y": -450
          },
                    {
            "x": 400,
            "y": -150
          },
                    {
            "x": 250,
            "y": -300
          },
                    {
            "x": 200,
            "y": -350
          },
                    {
            "x": 300,
            "y": -250
          },
                    {
            "x": 350,
            "y": -200
          },
                    {
            "x": -1600,
            "y": -650
          },
                    {
            "x": -1650,
            "y": -600
          },
                    {
            "x": -1700,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -700
          },
                    {
            "x": -1600,
            "y": -550
          },
                    {
            "x": -1650,
            "y": -500
          },
                    {
            "x": -1700,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -600
          },
                    {
            "x": -1500,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -700
          },
                    {
            "x": 200,
            "y": -200
          },
                    {
            "x": 300,
            "y": -100
          },
                    {
            "x": -1650,
            "y": 0
          },
                    {
            "x": -400,
            "y": -350
          },
                    {
            "x": -350,
            "y": -400
          },
                    {
            "x": -300,
            "y": -450
          },
                    {
            "x": -250,
            "y": -500
          },
                    {
            "x": -100,
            "y": -650
          },
                    {
            "x": -150,
            "y": -600
          },
                    {
            "x": -200,
            "y": -550
          },
                    {
            "x": 300,
            "y": 50
          },
                    {
            "x": -1600,
            "y": 350
          },
                    {
            "x": -1650,
            "y": 300
          },
                    {
            "x": -1700,
            "y": 250
          },
                    {
            "x": -1550,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 450
          },
                    {
            "x": 400,
            "y": 300
          },
                    {
            "x": 300,
            "y": 400
          },
                    {
            "x": -1600,
            "y": -400
          },
                    {
            "x": -1700,
            "y": -300
          },
                    {
            "x": -1500,
            "y": -500
          },
                    {
            "x": -1300,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -600
          },
                    {
            "x": 400,
            "y": 200
          },
                    {
            "x": 200,
            "y": 50
          },
                    {
            "x": 200,
            "y": 400
          },
                    {
            "x": 300,
            "y": 300
          },
                    {
            "x": 150,
            "y": -500
          },
                    {
            "x": 100,
            "y": -550
          },
                    {
            "x": 400,
            "y": -250
          },
                    {
            "x": 250,
            "y": -400
          },
                    {
            "x": 200,
            "y": -450
          },
                    {
            "x": 300,
            "y": -350
          },
                    {
            "x": 350,
            "y": -300
          },
                    {
            "x": -1550,
            "y": 0
          },
                    {
            "x": -1600,
            "y": 250
          },
                    {
            "x": -1650,
            "y": 200
          },
                    {
            "x": -1700,
            "y": 150
          },
                    {
            "x": 300,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 300
          },
                    {
            "x": -1500,
            "y": 350
          },
                    {
            "x": -200,
            "y": -400
          },
                    {
            "x": -100,
            "y": -500
          },
                    {
            "x": 400,
            "y": -650
          },
                    {
            "x": 350,
            "y": -700
          },
                    {
            "x": 400,
            "y": 50
          },
                    {
            "x": -1150,
            "y": -350
          },
                    {
            "x": -1050,
            "y": -450
          },
                    {
            "x": -1650,
            "y": 550
          },
                    {
            "x": -1550,
            "y": 650
          },
                    {
            "x": 0,
            "y": -550
          },
                    {
            "x": 0,
            "y": -650
          },
                    {
            "x": -1650,
            "y": 500
          },
                    {
            "x": -1700,
            "y": 450
          },
                    {
            "x": -1600,
            "y": 550
          },
                    {
            "x": -1550,
            "y": 600
          },
                    {
            "x": -1500,
            "y": 650
          },
                    {
            "x": 100,
            "y": -350
          },
                    {
            "x": 250,
            "y": -200
          },
                    {
            "x": 200,
            "y": -250
          },
                    {
            "x": 300,
            "y": -150
          },
                    {
            "x": 350,
            "y": -100
          },
                    {
            "x": -50,
            "y": -700
          },
                    {
            "x": -1650,
            "y": 400
          },
                    {
            "x": -1700,
            "y": 350
          },
                    {
            "x": -1600,
            "y": 450
          },
                    {
            "x": -1550,
            "y": 500
          },
                    {
            "x": -1500,
            "y": 550
          },
                    {
            "x": 250,
            "y": -650
          },
                    {
            "x": 350,
            "y": -550
          },
                    {
            "x": 350,
            "y": -650
          },
                    {
            "x": 200,
            "y": -100
          },
                    {
            "x": 250,
            "y": -550
          },
                    {
            "x": 350,
            "y": -450
          },
                    {
            "x": 150,
            "y": -650
          },
                    {
            "x": 250,
            "y": -450
          },
                    {
            "x": 350,
            "y": -350
          },
                    {
            "x": 150,
            "y": -550
          },
                    {
            "x": 400,
            "y": -50
          },
                    {
            "x": -1600,
            "y": -500
          },
                    {
            "x": -1700,
            "y": -400
          },
                    {
            "x": -1500,
            "y": -600
          },
                    {
            "x": -900,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -700
          },
                    {
            "x": -500,
            "y": -350
          },
                    {
            "x": -450,
            "y": -400
          },
                    {
            "x": -400,
            "y": -450
          },
                    {
            "x": -350,
            "y": -500
          },
                    {
            "x": -150,
            "y": -700
          },
                    {
            "x": -200,
            "y": -650
          },
                    {
            "x": -250,
            "y": -600
          },
                    {
            "x": -300,
            "y": -550
          },
                    {
            "x": -300,
            "y": -350
          },
                    {
            "x": -250,
            "y": -400
          },
                    {
            "x": -200,
            "y": -450
          },
                    {
            "x": -150,
            "y": -500
          },
                    {
            "x": -100,
            "y": -550
          },
                    {
            "x": -1400,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -300
          },
                    {
            "x": -1700,
            "y": -200
          },
                    {
            "x": -1500,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -700
          },
                    {
            "x": -1300,
            "y": -600
          },
                    {
            "x": 350,
            "y": 50
          },
                    {
            "x": -1650,
            "y": 650
          },
                    {
            "x": -1600,
            "y": 100
          },
                    {
            "x": -1500,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 100
          },
                    {
            "x": 250,
            "y": 50
          },
                    {
            "x": -1600,
            "y": 300
          },
                    {
            "x": -1700,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 0
          },
                    {
            "x": -900,
            "y": -400
          },
                    {
            "x": -800,
            "y": -500
          },
                    {
            "x": -600,
            "y": -700
          },
                    {
            "x": -700,
            "y": -600
          },
                    {
            "x": -300,
            "y": -400
          },
                    {
            "x": -200,
            "y": -500
          },
                    {
            "x": -100,
            "y": -600
          },
                    {
            "x": -800,
            "y": -400
          },
                    {
            "x": -700,
            "y": -500
          },
                    {
            "x": -500,
            "y": -700
          },
                    {
            "x": -600,
            "y": -600
          },
                    {
            "x": -1700,
            "y": 100
          },
                    {
            "x": -1600,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 300
          },
                    {
            "x": -100,
            "y": -400
          },
                    {
            "x": -1700,
            "y": 400
          },
                    {
            "x": -1600,
            "y": 500
          },
                    {
            "x": -1500,
            "y": 600
          },
                    {
            "x": -1700,
            "y": 300
          },
                    {
            "x": -1600,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 500
          },
                    {
            "x": 0,
            "y": -700
          },
                    {
            "x": 0,
            "y": -500
          },
                    {
            "x": -1700,
            "y": 500
          },
                    {
            "x": -1600,
            "y": 600
          },
                    {
            "x": -1500,
            "y": 700
          },
                    {
            "x": -1700,
            "y": 600
          },
                    {
            "x": -1600,
            "y": 700
          },
                    {
            "x": 0,
            "y": -600
          },
                    {
            "x": -1600,
            "y": 50
          },
                    {
            "x": -1700,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -600
          },
                    {
            "x": -1500,
            "y": -700
          },
                    {
            "x": 400,
            "y": -450
          },
                    {
            "x": 250,
            "y": -600
          },
                    {
            "x": 200,
            "y": -650
          },
                    {
            "x": 300,
            "y": -550
          },
                    {
            "x": 350,
            "y": -500
          },
                    {
            "x": 150,
            "y": -700
          },
                    {
            "x": 400,
            "y": 400
          },
                    {
            "x": -850,
            "y": -700
          },
                    {
            "x": -900,
            "y": -650
          },
                    {
            "x": -950,
            "y": -600
          },
                    {
            "x": 400,
            "y": -300
          },
                    {
            "x": 300,
            "y": -400
          },
                    {
            "x": 200,
            "y": -500
          },
                    {
            "x": 100,
            "y": -600
          },
                    {
            "x": -1400,
            "y": -400
          },
                    {
            "x": -1300,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -200
          },
                    {
            "x": -1700,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -300
          },
                    {
            "x": -1100,
            "y": -700
          },
                    {
            "x": -1200,
            "y": -600
          },
                    {
            "x": -400,
            "y": -400
          },
                    {
            "x": -300,
            "y": -500
          },
                    {
            "x": -100,
            "y": -700
          },
                    {
            "x": -200,
            "y": -600
          },
                    {
            "x": -950,
            "y": -500
          },
                    {
            "x": -750,
            "y": -700
          },
                    {
            "x": -800,
            "y": -650
          },
                    {
            "x": -850,
            "y": -600
          },
                    {
            "x": -900,
            "y": -550
          },
                    {
            "x": -950,
            "y": -700
          },
                    {
            "x": 50,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -650
          },
                    {
            "x": 50,
            "y": -450
          },
                    {
            "x": -1650,
            "y": 700
          },
                    {
            "x": -1700,
            "y": 650
          },
                    {
            "x": -1650,
            "y": 600
          },
                    {
            "x": -1700,
            "y": 550
          },
                    {
            "x": -1600,
            "y": 650
          },
                    {
            "x": -1550,
            "y": 700
          },
                    {
            "x": 100,
            "y": -400
          },
                    {
            "x": 400,
            "y": -100
          },
                    {
            "x": 200,
            "y": -300
          },
                    {
            "x": 300,
            "y": -200
          },
                    {
            "x": -1650,
            "y": 50
          },
                    {
            "x": -800,
            "y": -700
          },
                    {
            "x": -900,
            "y": -600
          },
                    {
            "x": 400,
            "y": -350
          },
                    {
            "x": 250,
            "y": -500
          },
                    {
            "x": 200,
            "y": -550
          },
                    {
            "x": 300,
            "y": -450
          },
                    {
            "x": 350,
            "y": -400
          },
                    {
            "x": 100,
            "y": -650
          },
                    {
            "x": 150,
            "y": -600
          },
                    {
            "x": -900,
            "y": -500
          },
                    {
            "x": -700,
            "y": -700
          },
                    {
            "x": -800,
            "y": -600
          },
                    {
            "x": 400,
            "y": -550
          },
                    {
            "x": 250,
            "y": -700
          },
                    {
            "x": 300,
            "y": -650
          },
                    {
            "x": 350,
            "y": -600
          },
                    {
            "x": 100,
            "y": -500
          },
                    {
            "x": 400,
            "y": -200
          },
                    {
            "x": 200,
            "y": -400
          },
                    {
            "x": 300,
            "y": -300
          },
                    {
            "x": 200,
            "y": -600
          },
                    {
            "x": 300,
            "y": -500
          },
                    {
            "x": 400,
            "y": -400
          },
                    {
            "x": 100,
            "y": -700
          },
                    {
            "x": -50,
            "y": -400
          },
                    {
            "x": 50,
            "y": -600
          },
                    {
            "x": 50,
            "y": -500
          },
                    {
            "x": 50,
            "y": -400
          },
                    {
            "x": 50,
            "y": -700
          },
                    {
            "x": 400,
            "y": -600
          },
                    {
            "x": 300,
            "y": -700
          },
                    {
            "x": 250,
            "y": 0
          },
                    {
            "x": -1500,
            "y": 50
          },
                    {
            "x": 400,
            "y": -500
          },
                    {
            "x": 200,
            "y": -700
          },
                    {
            "x": 300,
            "y": -600
          },
                    {
            "x": -1700,
            "y": -50
          },
                    {
            "x": 250,
            "y": 200
          },
                    {
            "x": 200,
            "y": 250
          },
                    {
            "x": 300,
            "y": 150
          },
                    {
            "x": 350,
            "y": 100
          },
                    {
            "x": -950,
            "y": -350
          },
                    {
            "x": -850,
            "y": -450
          },
                    {
            "x": -750,
            "y": -550
          },
                    {
            "x": -650,
            "y": -650
          },
                    {
            "x": -850,
            "y": -350
          },
                    {
            "x": -750,
            "y": -450
          },
                    {
            "x": -550,
            "y": -650
          },
                    {
            "x": -650,
            "y": -550
          },
                    {
            "x": 250,
            "y": 100
          },
                    {
            "x": 200,
            "y": 150
          },
                    {
            "x": -650,
            "y": -350
          },
                    {
            "x": -550,
            "y": -450
          },
                    {
            "x": -450,
            "y": -550
          },
                    {
            "x": -350,
            "y": -650
          },
                    {
            "x": -750,
            "y": -350
          },
                    {
            "x": -650,
            "y": -450
          },
                    {
            "x": -450,
            "y": -650
          },
                    {
            "x": -550,
            "y": -550
          },
                    {
            "x": -950,
            "y": -450
          },
                    {
            "x": -750,
            "y": -650
          },
                    {
            "x": -850,
            "y": -550
          },
                    {
            "x": -950,
            "y": -550
          },
                    {
            "x": -850,
            "y": -650
          },
                    {
            "x": 350,
            "y": 400
          },
                    {
            "x": 400,
            "y": 350
          },
                    {
            "x": -1400,
            "y": -350
          },
                    {
            "x": -1350,
            "y": -400
          },
                    {
            "x": -1450,
            "y": -450
          },
                    {
            "x": -1300,
            "y": -450
          },
                    {
            "x": -1250,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -150
          },
                    {
            "x": -1650,
            "y": -250
          },
                    {
            "x": -1650,
            "y": -100
          },
                    {
            "x": -1550,
            "y": -200
          },
                    {
            "x": -1550,
            "y": -350
          },
                    {
            "x": -1500,
            "y": -250
          },
                    {
            "x": -1050,
            "y": -700
          },
                    {
            "x": -1250,
            "y": -650
          },
                    {
            "x": -1100,
            "y": -650
          },
                    {
            "x": -1150,
            "y": -600
          },
                    {
            "x": -1350,
            "y": -550
          },
                    {
            "x": -1200,
            "y": -550
          },
                    {
            "x": -950,
            "y": -650
          },
                    {
            "x": -1000,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -400
          },
                    {
            "x": -1000,
            "y": -500
          },
                    {
            "x": -1200,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -500
          },
                    {
            "x": -1500,
            "y": -100
          },
                    {
            "x": -1000,
            "y": -600
          },
                    {
            "x": -950,
            "y": -400
          },
                    {
            "x": -900,
            "y": -450
          },
                    {
            "x": -850,
            "y": -500
          },
                    {
            "x": -650,
            "y": -700
          },
                    {
            "x": -700,
            "y": -650
          },
                    {
            "x": -750,
            "y": -600
          },
                    {
            "x": -800,
            "y": -550
          },
                    {
            "x": -1300,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -200
          },
                    {
            "x": -1000,
            "y": -700
          },
                    {
            "x": -1100,
            "y": -600
          },
                    {
            "x": 50,
            "y": -650
          },
                    {
            "x": 50,
            "y": -550
          },
                    {
            "x": 350,
            "y": 0
          },
                    {
            "x": -1700,
            "y": 50
          },
                    {
            "x": -600,
            "y": -350
          },
                    {
            "x": -550,
            "y": -400
          },
                    {
            "x": -500,
            "y": -450
          },
                    {
            "x": -450,
            "y": -500
          },
                    {
            "x": -250,
            "y": -700
          },
                    {
            "x": -300,
            "y": -650
          },
                    {
            "x": -350,
            "y": -600
          },
                    {
            "x": -400,
            "y": -550
          },
                    {
            "x": 250,
            "y": 350
          },
                    {
            "x": 350,
            "y": 250
          },
                    {
            "x": 250,
            "y": 250
          },
                    {
            "x": 350,
            "y": 150
          },
                    {
            "x": -100,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -700
          },
                    {
            "x": -1700,
            "y": -650
          },
                    {
            "x": 250,
            "y": 150
          },
                    {
            "x": 350,
            "y": 350
          },
                    {
            "x": -700,
            "y": -400
          },
                    {
            "x": -600,
            "y": -500
          },
                    {
            "x": -400,
            "y": -700
          },
                    {
            "x": -500,
            "y": -600
          },
                    {
            "x": 400,
            "y": -700
          },
                    {
            "x": -1650,
            "y": -50
          },
                    {
            "x": 250,
            "y": -50
          },
                    {
            "x": 350,
            "y": -50
          },
                    {
            "x": -500,
            "y": -400
          },
                    {
            "x": -400,
            "y": -500
          },
                    {
            "x": -200,
            "y": -700
          },
                    {
            "x": -300,
            "y": -600
          },
                    {
            "x": -900,
            "y": -350
          },
                    {
            "x": -850,
            "y": -400
          },
                    {
            "x": -800,
            "y": -450
          },
                    {
            "x": -750,
            "y": -500
          },
                    {
            "x": -550,
            "y": -700
          },
                    {
            "x": -600,
            "y": -650
          },
                    {
            "x": -650,
            "y": -600
          },
                    {
            "x": -700,
            "y": -550
          },
                    {
            "x": -700,
            "y": -350
          },
                    {
            "x": -650,
            "y": -400
          },
                    {
            "x": -600,
            "y": -450
          },
                    {
            "x": -550,
            "y": -500
          },
                    {
            "x": -500,
            "y": -550
          },
                    {
            "x": -350,
            "y": -700
          },
                    {
            "x": -400,
            "y": -650
          },
                    {
            "x": -450,
            "y": -600
          },
                    {
            "x": -1650,
            "y": 150
          },
                    {
            "x": -1550,
            "y": 250
          },
                    {
            "x": -1500,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 100
          },
                    {
            "x": -1500,
            "y": 150
          },
                    {
            "x": -1700,
            "y": 700
          },
                    {
            "x": 200,
            "y": 200
          },
                    {
            "x": 300,
            "y": 100
          },
                    {
            "x": 400,
            "y": 150
          },
                    {
            "x": 250,
            "y": 300
          },
                    {
            "x": 200,
            "y": 350
          },
                    {
            "x": 300,
            "y": 250
          },
                    {
            "x": 350,
            "y": 200
          },
                    {
            "x": 200,
            "y": 0
          },
                    {
            "x": 150,
            "y": -450
          },
                    {
            "x": 250,
            "y": -350
          },
                    {
            "x": 350,
            "y": -250
          },
                    {
            "x": -1450,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -300
          },
                    {
            "x": -1700,
            "y": -250
          },
                    {
            "x": -1550,
            "y": -400
          },
                    {
            "x": -1500,
            "y": -450
          },
                    {
            "x": -1250,
            "y": -700
          },
                    {
            "x": -1300,
            "y": -650
          },
                    {
            "x": -1350,
            "y": -600
          },
                    {
            "x": -1400,
            "y": -550
          },
                    {
            "x": 150,
            "y": -350
          },
                    {
            "x": 250,
            "y": -250
          },
                    {
            "x": 350,
            "y": -150
          },
                    {
            "x": 300,
            "y": 0
          },
                    {
            "x": 250,
            "y": 400
          },
                    {
            "x": 300,
            "y": 350
          },
                    {
            "x": 350,
            "y": 300
          },
                    {
            "x": 400,
            "y": 250
          },
                    {
            "x": -50,
            "y": -550
          },
                    {
            "x": -1700,
            "y": -700
          },
                    {
            "x": 400,
            "y": 0
          },
                    {
            "x": -1350,
            "y": -350
          },
                    {
            "x": -1250,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -150
          },
                    {
            "x": -1550,
            "y": 50
          },
                    {
            "x": -1050,
            "y": -650
          },
                    {
            "x": -1150,
            "y": -550
          },
                    {
            "x": -1600,
            "y": -700
          },
                    {
            "x": -1700,
            "y": -600
          },
                    {
            "x": 250,
            "y": -150
          },
                    {
            "x": -50,
            "y": -650
          },
                    {
            "x": -200,
            "y": -350
          },
                    {
            "x": -150,
            "y": -400
          },
                    {
            "x": -100,
            "y": -450
          },
                    {
            "x": -50,
            "y": -350
          },
                    {
            "x": -50,
            "y": -450
          },
                    {
            "x": -1200,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -500
          },
                    {
            "x": -1000,
            "y": -550
          },
                    {
            "x": -1650,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -550
          },
                    {
            "x": -1450,
            "y": -650
          },
                    {
            "x": 0,
            "y": -450
          },
                    {
            "x": 0,
            "y": -350
          },
                    {
            "x": -1650,
            "y": 450
          },
                    {
            "x": -1550,
            "y": 550
          },
                    {
            "x": -250,
            "y": -350
          },
                    {
            "x": -150,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -350
          },
                    {
            "x": -350,
            "y": -350
          },
                    {
            "x": -250,
            "y": -450
          },
                    {
            "x": -150,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -50
          },
                    {
            "x": -600,
            "y": -400
          },
                    {
            "x": -500,
            "y": -500
          },
                    {
            "x": -300,
            "y": -700
          },
                    {
            "x": -400,
            "y": -600
          },
                    {
            "x": -450,
            "y": -350
          },
                    {
            "x": -350,
            "y": -450
          },
                    {
            "x": -250,
            "y": -550
          },
                    {
            "x": -150,
            "y": -650
          },
                    {
            "x": -550,
            "y": -350
          },
                    {
            "x": -450,
            "y": -450
          },
                    {
            "x": -250,
            "y": -650
          },
                    {
            "x": -350,
            "y": -550
          },
                    {
            "x": -150,
            "y": -350
          },
                    {
            "x": 400,
            "y": 100
          },
                    {
            "x": 200,
            "y": 300
          },
                    {
            "x": 300,
            "y": 200
          },
                    {
            "x": -1600,
            "y": 150
          },
                    {
            "x": -1650,
            "y": 100
          },
                    {
            "x": -1550,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 250
          },
                    {
            "x": -1600,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 150
          },
                    {
            "x": -800,
            "y": -350
          },
                    {
            "x": -750,
            "y": -400
          },
                    {
            "x": -700,
            "y": -450
          },
                    {
            "x": -650,
            "y": -500
          },
                    {
            "x": -600,
            "y": -550
          },
                    {
            "x": -450,
            "y": -700
          },
                    {
            "x": -500,
            "y": -650
          },
                    {
            "x": -550,
            "y": -600
          },
                    {
            "x": 200,
            "y": 100
          },
                    {
            "x": -1650,
            "y": 250
          },
                    {
            "x": -1550,
            "y": 350
          },
                    {
            "x": -50,
            "y": -500
          },
                    {
            "x": -1450,
            "y": -350
          },
                    {
            "x": -1350,
            "y": -450
          },
                    {
            "x": -1650,
            "y": -150
          },
                    {
            "x": -1550,
            "y": -250
          },
                    {
            "x": -1150,
            "y": -650
          },
                    {
            "x": -1250,
            "y": -550
          },
                    {
            "x": -1450,
            "y": -400
          },
                    {
            "x": -1400,
            "y": -450
          },
                    {
            "x": -1350,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -250
          },
                    {
            "x": -1650,
            "y": -200
          },
                    {
            "x": -1700,
            "y": -150
          },
                    {
            "x": -1550,
            "y": -300
          },
                    {
            "x": -1500,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -700
          },
                    {
            "x": -1200,
            "y": -650
          },
                    {
            "x": -1250,
            "y": -600
          },
                    {
            "x": -1300,
            "y": -550
          },
                    {
            "x": -1250,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -550
          },
                    {
            "x": 0,
            "y": -400
          },
                    {
            "x": -1600,
            "y": 0
          },
                    {
            "x": -1650,
            "y": -400
          },
                    {
            "x": -1700,
            "y": -350
          },
                    {
            "x": -1600,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -500
          },
                    {
            "x": -1500,
            "y": -550
          },
                    {
            "x": -1350,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -600
          },
                    {
            "x": -1700,
            "y": 0
          },
                    {
            "x": -1650,
            "y": -350
          },
                    {
            "x": -1550,
            "y": -450
          },
                    {
            "x": -1350,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -550
          },
                    {
            "x": -1300,
            "y": -350
          },
                    {
            "x": -1250,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -450
          },
                    {
            "x": -1150,
            "y": -500
          },
                    {
            "x": -1550,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -150
          },
                    {
            "x": -1000,
            "y": -650
          },
                    {
            "x": -1050,
            "y": -600
          },
                    {
            "x": -1100,
            "y": -550
          },
                    {
            "x": 200,
            "y": -50
          },
                    {
            "x": -1100,
            "y": -350
          },
                    {
            "x": -1050,
            "y": -400
          },
                    {
            "x": -1000,
            "y": -450
          },
                    {
            "x": -1650,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -650
          },
                    {
            "x": -1650,
            "y": 350
          },
                    {
            "x": -1550,
            "y": 450
          }
        ]}
      },
      "storedVBL":       {
        "BASE": {"maptrees":         [
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6735,
            "y": 3160
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6045,
            "y": 3146
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5271,
            "y": 3239
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 7395,
            "y": 3197
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6692,
            "y": 2464
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5995,
            "y": 2467
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5306,
            "y": 2522
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 7394,
            "y": 2504
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6419,
            "y": 1729
          }
        ]},
        "BASE_ON": {"maptrees": 0}
      },
      "summonNpcPropType": "Character",
      "summonPcPropType": "Character",
      "summonPropTypesList": "Character",
      "summonSpecialList": "AssignedPad Green 1,  EventPad (Generic),  EventPad 1,  EventPad 2,  InterPad,  InterPad 1,  InterPad 2,  InterPadBorder 1,  InterPadBorder 2,  InterPadBorder horizontal,  InterPadBorder vertical,  MappedPad,  MappedPad 1,  MappedPad 2,  MappedPad 3,  MappedPad 4,  PadDrop,  PadDrop 1,  PadDropBorder 1,  PadDropBorder 2,  PadEnd 1,  PadEnd 2,  PadEndBorder 1,  PadEndBorder 2,  PadJump,  PadJump 1,  PadJumpBorder 1,  PadJumpBorder 2,  PadJumpBorder Horizontal,  PadJumpBorder Vertical,  PadStart,  PadStart 1,  PadStart 2,  PadStartBorder 1,  PadStartBorder 2,  PadStartBorder Horizontal,  PadStartBorder Verticle,AssignedPad Green 1,  EventPad (Generic),  EventPad 1,  EventPad 2,  InterPad,  InterPad 1,  InterPad 2,  InterPadBorder 1,  InterPadBorder 2,  InterPadBorder horizontal,  InterPadBorder vertical,  MappedPad,  MappedPad 1,  MappedPad 2,  MappedPad 3,  MappedPad 4,  PadDrop,  PadDrop 1,  PadDropBorder 1,  PadDropBorder 2,  PadEnd 1,  PadEnd 2,  PadEndBorder 1,  PadEndBorder 2,  PadJump,  PadJump 1,  PadJumpBorder 1,  PadJumpBorder 2,  PadJumpBorder Horizontal,  PadJumpBorder Vertical,  PadStart,  PadStart 1,  PadStart 2,  PadStartBorder 1,  PadStartBorder 2,  PadStartBorder Horizontal,  PadStartBorder Verticle, Canopy 1,  Canopy 2,  Canopy 3,  Canopy 4,  Canopy 5,  Canopy 6,  Canopy 7,  Canopy 8,  Canopy 9",
      "tbl.Dwarf":       {
        "1": {"Name": "Al"},
        "2": {"Name": "Ath"},
        "3": {"Name": "Athran"},
        "4": {"Name": "Bal"},
        "5": {"Name": "Bala"},
        "6": {"Name": "Bara"},
        "7": {"Name": "Bel"},
        "8": {"Name": "Bela"},
        "9": {"Name": "Ber"},
        "10": {"Name": "Bok"},
        "11": {"Name": "Bor"},
        "12": {"Name": "Bur"},
        "13": {"Name": "Da"},
        "14": {"Name": "Dam"},
        "15": {"Name": "Dora"},
        "16": {"Name": "Drok"},
        "17": {"Name": "Drong"},
        "18": {"Name": "Dur"},
        "19": {"Name": "Dwal"},
        "20": {"Name": "El"},
        "21": {"Name": "Ela"},
        "22": {"Name": "Elan"},
        "23": {"Name": "Elda"},
        "24": {"Name": "Fa"},
        "25": {"Name": "Far"},
        "26": {"Name": "Fara"},
        "27": {"Name": "Fim"},
        "28": {"Name": "Fima"},
        "29": {"Name": "Firen"},
        "30": {"Name": "Fur"},
        "31": {"Name": "Fura"},
        "32": {"Name": "Ga"},
        "33": {"Name": "Gim"},
        "34": {"Name": "Gol"},
        "35": {"Name": "Gollen"},
        "36": {"Name": "Got"},
        "37": {"Name": "Gota"},
        "38": {"Name": "Grim"},
        "39": {"Name": "Gro"},
        "40": {"Name": "Grun"},
        "41": {"Name": "Hak"},
        "42": {"Name": "Haka"},
        "43": {"Name": "Har"},
        "44": {"Name": "Hega"},
        "45": {"Name": "Hur"},
        "46": {"Name": "Kad"},
        "47": {"Name": "Kar"},
        "48": {"Name": "Kara"},
        "49": {"Name": "Kaz"},
        "50": {"Name": "Kaza"},
        "51": {"Name": "Krag"},
        "52": {"Name": "Logaz"},
        "53": {"Name": "Lok"},
        "54": {"Name": "Lun"},
        "55": {"Name": "Mo"},
        "56": {"Name": "Mola"},
        "57": {"Name": "Mor"},
        "58": {"Name": "Mora"},
        "59": {"Name": "No"},
        "60": {"Name": "Nola"},
        "61": {"Name": "Nor"},
        "62": {"Name": "Noran"},
        "63": {"Name": "Nun"},
        "64": {"Name": "Oda"},
        "65": {"Name": "Oka"},
        "66": {"Name": "Olla"},
        "67": {"Name": "Olf"},
        "68": {"Name": "Oth"},
        "69": {"Name": "Othra"},
        "70": {"Name": "Ro"},
        "71": {"Name": "Ror"},
        "72": {"Name": "Roran"},
        "73": {"Name": "Ska"},
        "74": {"Name": "Skalla"},
        "75": {"Name": "Skalf"},
        "76": {"Name": "Skar"},
        "77": {"Name": "Skor"},
        "78": {"Name": "Skora"},
        "79": {"Name": "Snor"},
        "80": {"Name": "Snora"},
        "81": {"Name": "Svcn"},
        "82": {"Name": "Thar"},
        "83": {"Name": "Trior"},
        "84": {"Name": "Thora"},
        "85": {"Name": "Thron"},
        "86": {"Name": "Thrun"},
        "87": {"Name": "Triura"},
        "88": {"Name": "Un"},
        "89": {"Name": "Utha"},
        "90": {"Name": "Ulla"},
        "91": {"Name": "Vala"},
        "92": {"Name": "Var"},
        "93": {"Name": "Vara"},
        "94": {"Name": "Zak"},
        "95": {"Name": "Zaka"},
        "96": {"Name": "Zakan"},
        "97": {"Name": "Zar"},
        "98": {"Name": "Zara"},
        "99": {"Name": "Zam"},
        "100": {"Name": "Zama"}
      },
      "tbl.Taverns":       {
        "1-2":         {
          "1_Usual": "Black",
          "1_Off": "Alabaster",
          "1_Disturbing": "Angry",
          "2_Usual": "Anchorage",
          "2_Off": "Barge",
          "2_Disturbing": "Baron"
        },
        "3-4":         {
          "1_Usual": "Blessed",
          "1_Off": "Bellowing",
          "1_Disturbing": "Banished",
          "2_Usual": "Arms",
          "2_Off": "Barrel",
          "2_Disturbing": "Bowels"
        },
        "5-6":         {
          "1_Usual": "Shining",
          "1_Off": "Brass",
          "1_Disturbing": "Barbarian%27s",
          "2_Usual": "Boat",
          "2_Off": "Beard",
          "2_Disturbing": "Brain"
        },
        "7-8":         {
          "1_Usual": "Blue",
          "1_Off": "Broken",
          "1_Disturbing": "Bloody",
          "2_Usual": "Bucket",
          "2_Off": "Candle",
          "2_Disturbing": "Cage"
        },
        "9-10":         {
          "1_Usual": "Broken",
          "1_Off": "Bucking",
          "1_Disturbing": "Bruised",
          "2_Usual": "Castle",
          "2_Off": "Captain",
          "2_Disturbing": "Cannon"
        },
        "11-12":         {
          "1_Usual": "Brown",
          "1_Off": "Charging",
          "1_Disturbing": "Caged",
          "2_Usual": "Chalice",
          "2_Off": "Carrot",
          "2_Disturbing": "Cave"
        },
        "13-14":         {
          "1_Usual": "Cheerful",
          "1_Off": "Charred",
          "1_Disturbing": "Chaotic",
          "2_Usual": "Club",
          "2_Off": "End",
          "2_Disturbing": "Coffin"
        },
        "15-16":         {
          "1_Usual": "Cheery",
          "1_Off": "Crooked",
          "1_Disturbing": "Constipated",
          "2_Usual": "Corner",
          "2_Off": "Chicken",
          "2_Disturbing": "Dung"
        },
        "17-18":         {
          "1_Usual": "Cosy",
          "1_Off": "Crying",
          "1_Disturbing": "Crazed",
          "2_Usual": "Cup",
          "2_Off": "Cow",
          "2_Disturbing": "Egg"
        },
        "19-20":         {
          "1_Usual": "Earnest",
          "1_Off": "Damp",
          "1_Disturbing": "Dense",
          "2_Usual": "Dog",
          "2_Off": "Coward",
          "2_Disturbing": "Eye"
        },
        "21-22":         {
          "1_Usual": "Eastern",
          "1_Off": "Deep",
          "1_Disturbing": "Disturbing",
          "2_Usual": "Door",
          "2_Off": "Dog",
          "2_Disturbing": "Eyeball"
        },
        "23-24":         {
          "1_Usual": "Elegant",
          "1_Off": "Dripping",
          "1_Disturbing": "Evil",
          "2_Usual": "Dragon",
          "2_Off": "Fire",
          "2_Disturbing": "Fang"
        },
        "25-26":         {
          "1_Usual": "Fair",
          "1_Off": "Drunken",
          "1_Disturbing": "Flatulent",
          "2_Usual": "Dwelling",
          "2_Off": "Fist",
          "2_Disturbing": "Feet"
        },
        "27-28":         {
          "1_Usual": "Fourth",
          "1_Off": "Ebon",
          "1_Disturbing": "Flayed",
          "2_Usual": "End",
          "2_Off": "Flail",
          "2_Disturbing": "Ghost"
        },
        "29-30":         {
          "1_Usual": "Friendly",
          "1_Off": "Eight",
          "1_Disturbing": "Fleshy",
          "2_Usual": "Feather",
          "2_Off": "Friar",
          "2_Disturbing": "Goblin"
        },
        "31-32":         {
          "1_Usual": "Gilded",
          "1_Off": "Empty",
          "1_Disturbing": "Forbidden",
          "2_Usual": "Garden",
          "2_Off": "Goat",
          "2_Disturbing": "Grave"
        },
        "33-34":         {
          "1_Usual": "Golden",
          "1_Off": "Fast",
          "1_Disturbing": "Fornicating",
          "2_Usual": "Gate",
          "2_Off": "Hand",
          "2_Disturbing": "Halberd"
        },
        "35-36":         {
          "1_Usual": "Good",
          "1_Off": "Flossy",
          "1_Disturbing": "Greedy",
          "2_Usual": "Goblet",
          "2_Off": "Hermit",
          "2_Disturbing": "John"
        },
        "37-38":         {
          "1_Usual": "Gray",
          "1_Off": "Garish",
          "1_Disturbing": "Gutted",
          "2_Usual": "Griffin",
          "2_Off": "Hoof",
          "2_Disturbing": "Leech"
        },
        "39-40":         {
          "1_Usual": "Green",
          "1_Off": "Giant",
          "1_Disturbing": "Hanged",
          "2_Usual": "Harbour",
          "2_Off": "Hook",
          "2_Disturbing": "Loo"
        },
        "41-42":         {
          "1_Usual": "Gray",
          "1_Off": "Glaring",
          "1_Disturbing": "Haunted",
          "2_Usual": "Haven",
          "2_Off": "Horse",
          "2_Disturbing": "Master"
        },
        "43-44":         {
          "1_Usual": "Half-way",
          "1_Off": "Hazy",
          "1_Disturbing": "Horny",
          "2_Usual": "Head",
          "2_Off": "Knight",
          "2_Disturbing": "Mistress"
        },
        "45-46":         {
          "1_Usual": "Happy",
          "1_Off": "Iron",
          "1_Disturbing": "Reapers",
          "2_Usual": "Hearth",
          "2_Off": "Lamb",
          "2_Disturbing": "Nail"
        },
        "47-48":         {
          "1_Usual": "Harvester%EF%BF%BDs",
          "1_Off": "Lonely",
          "1_Disturbing": "Ill",
          "2_Usual": "Return",
          "2_Off": "Lantern",
          "2_Disturbing": "Nickers"
        },
        "49-50":         {
          "1_Usual": "Hearty",
          "1_Off": "Nosey",
          "1_Disturbing": "Licking",
          "2_Usual": "Homestead",
          "2_Off": "Lemon",
          "2_Disturbing": "Ogre"
        },
        "51-52":         {
          "1_Usual": "Heavenly",
          "1_Off": "Plump",
          "1_Disturbing": "Mutated",
          "2_Usual": "Hoof",
          "2_Off": "Lover",
          "2_Disturbing": "Orc"
        },
        "53-54":         {
          "1_Usual": "Leaning",
          "1_Off": "Poncy",
          "1_Disturbing": "Nasty",
          "2_Usual": "Horse",
          "2_Off": "Maiden",
          "2_Disturbing": "Pee"
        },
        "55-56":         {
          "1_Usual": "Wanderer%EF%BF%BDs",
          "1_Off": "Purple",
          "1_Disturbing": "Nicked",
          "2_Usual": "House",
          "2_Off": "Man",
          "2_Disturbing": "Rat"
        },
        "57-58":         {
          "1_Usual": "Lost",
          "1_Off": "Raving",
          "1_Disturbing": "Offensive",
          "2_Usual": "Lodge",
          "2_Off": "Mask",
          "2_Disturbing": "RatCatcher"
        },
        "59-60":         {
          "1_Usual": "Lovely",
          "1_Off": "Rearing",
          "1_Disturbing": "Possessed",
          "2_Usual": "Maiden",
          "2_Off": "Mast",
          "2_Disturbing": "Shoe"
        },
        "61-62":         {
          "1_Usual": "Merry",
          "1_Off": "Restless",
          "1_Disturbing": "Rampaging",
          "2_Usual": "Mare",
          "2_Off": "Monk",
          "2_Disturbing": "Skull"
        },
        "63-64":         {
          "1_Usual": "Northern",
          "1_Off": "Running",
          "1_Disturbing": "Rampant",
          "2_Usual": "Mule",
          "2_Off": "Monkey",
          "2_Disturbing": "Snotling"
        },
        "65-66":         {
          "1_Usual": "Roamer%EF%BF%BDs",
          "1_Off": "Rusty",
          "1_Disturbing": "Randy",
          "2_Usual": "Pint",
          "2_Off": "Mule",
          "2_Disturbing": "Squib"
        },
        "67-68":         {
          "1_Usual": "Reaver%EF%BF%BDs",
          "1_Off": "Shady",
          "1_Disturbing": "Raunchy",
          "2_Usual": "Quarter",
          "2_Off": "Peasant",
          "2_Disturbing": "Squid"
        },
        "69-70":         {
          "1_Usual": "Southern",
          "1_Off": "Silken",
          "1_Disturbing": "Rotten",
          "2_Usual": "Pony",
          "2_Off": "Pig",
          "2_Disturbing": "Surgeon"
        },
        "71-72":         {
          "1_Usual": "Traveller%EF%BF%BDs",
          "1_Off": "Sleepy",
          "1_Disturbing": "Sceptic",
          "2_Usual": "Mansion",
          "2_Off": "Poney",
          "2_Disturbing": "Tart"
        },
        "73-74":         {
          "1_Usual": "Rover%EF%BF%BDs",
          "1_Off": "Slick",
          "1_Disturbing": "Screaming",
          "2_Usual": "Rat",
          "2_Off": "Prince",
          "2_Disturbing": "Testicle"
        },
        "75-76":         {
          "1_Usual": "Silver",
          "1_Off": "Smelly",
          "1_Disturbing": "Seductive",
          "2_Usual": "Retreat",
          "2_Off": "Purse",
          "2_Disturbing": "Throat"
        },
        "77-78":         {
          "1_Usual": "Sovereign",
          "1_Off": "Spending",
          "1_Disturbing": "Skinned",
          "2_Usual": "Rooms",
          "2_Off": "Ruin",
          "2_Disturbing": "Toe"
        },
        "79-80":         {
          "1_Usual": "Thirsty",
          "1_Off": "Steel",
          "1_Disturbing": "Slaughtered",
          "2_Usual": "Shelter",
          "2_Off": "Spirit",
          "2_Disturbing": "Toenail"
        },
        "81-82":         {
          "1_Usual": "Thriving",
          "1_Off": "Stony",
          "1_Disturbing": "Sleazy",
          "2_Usual": "Sign",
          "2_Off": "Stable",
          "2_Disturbing": "Tongue"
        },
        "83-84":         {
          "1_Usual": "Three",
          "1_Off": "Tangy",
          "1_Disturbing": "Slimy",
          "2_Usual": "Snug",
          "2_Off": "Stew",
          "2_Disturbing": "Tooth"
        },
        "85-86":         {
          "1_Usual": "Tilean",
          "1_Off": "Thirteenth",
          "1_Disturbing": "Snorting",
          "2_Usual": "Stallion",
          "2_Off": "Stove",
          "2_Disturbing": "Troll"
        },
        "87-88":         {
          "1_Usual": "Tilted",
          "1_Off": "Tilted",
          "1_Disturbing": "Snotty",
          "2_Usual": "Steed",
          "2_Off": "Toad",
          "2_Disturbing": "Turd"
        },
        "89-90":         {
          "1_Usual": "Two",
          "1_Off": "Tiny",
          "1_Disturbing": "Sour",
          "2_Usual": "Table",
          "2_Off": "Tomato",
          "2_Disturbing": "Warlock"
        },
        "91-92":         {
          "1_Usual": "Voyager%EF%BF%BDs",
          "1_Off": "Unhappy",
          "1_Disturbing": "Stinking",
          "2_Usual": "Tankard",
          "2_Off": "Wagon",
          "2_Disturbing": "Wart"
        },
        "93-94":         {
          "1_Usual": "Weary",
          "1_Off": "Velvet",
          "1_Disturbing": "Twisted",
          "2_Usual": "Unicorn",
          "2_Off": "Warrior",
          "2_Disturbing": "Wench"
        },
        "95-96":         {
          "1_Usual": "Western",
          "1_Off": "Watery",
          "1_Disturbing": "Ugly",
          "2_Usual": "Wagon",
          "2_Off": "Willow",
          "2_Disturbing": "Witch"
        },
        "97-98":         {
          "1_Usual": "White",
          "1_Off": "Weary",
          "1_Disturbing": "Unholy",
          "2_Usual": "Place",
          "2_Off": "Wings",
          "2_Disturbing": "Wrench"
        },
        "99-100":         {
          "1_Usual": "Yellow",
          "1_Off": "Weeping",
          "1_Disturbing": "Unsavoury",
          "2_Usual": "Resthouse",
          "2_Off": "Woman",
          "2_Disturbing": "Zombie"
        }
      },
      "tbl.Weapons":       {
        "tableColumnSize": 9,
        "Buckler":         {
          "Class+%28Thingie%29": "{Melee,+Parrying}",
          "Damage": "%5Br:SB-4%5D",
          "Type": "I",
          "Range": 3,
          "Reload": "",
          "Pen": "",
          "Special": "Balanced,++Defensive,",
          "tHander": "",
          "Enc": 10,
          "%3Cnew+column%3E": ""
        },
        "Dagger":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-3",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 10,
          "%3Cnew+column%3E": ""
        },
        "Demilance+%28Cavalry+Spear%29":         {
          "Class+%28Thingie%29": "Melee,+Cavalry",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Impact,+Tiring",
          "tHander": "",
          "Enc": 75,
          "%3Cnew+column%3E": ""
        },
        "Flail":         {
          "Class+%28Thingie%29": "Melee,+Flail",
          "Damage": "SB%2B1",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Tiring",
          "tHander": 1,
          "Enc": 95,
          "%3Cnew+column%3E": ""
        },
        "Foil":         {
          "Class+%28Thingie%29": "Melee,+Fencing",
          "Damage": "SB-2",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Precise",
          "tHander": "",
          "Enc": 40,
          "%3Cnew+column%3E": ""
        },
        "Gauntlet%2FKnuckle-duster":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-3",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Pummelling",
          "tHander": "",
          "Enc": 1,
          "%3Cnew+column%3E": ""
        },
        "Great+Sword":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Hammer":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Axe":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Mace":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Pick":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Club":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Halberd":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Special",
          "tHander": 1,
          "Enc": 175,
          "%3Cnew+column%3E": ""
        },
        "Sword":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Hammer":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Axe":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Mace":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Pick":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Club":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Improvised":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-4",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 35,
          "%3Cnew+column%3E": ""
        },
        "Lance":         {
          "Class+%28Thingie%29": "Melee,+Cavalry",
          "Damage": "SB%2B1",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Impact,++Tiring",
          "tHander": "",
          "Enc": 100,
          "%3Cnew+column%3E": ""
        },
        "Main+Gauche":         {
          "Class+%28Thingie%29": "Melee,+Parrying",
          "Damage": "SB-3",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Balanced,++Defensive",
          "tHander": "",
          "Enc": 15,
          "%3Cnew+column%3E": ""
        },
        "Morning+Star":         {
          "Class+%28Thingie%29": "Melee,+Flail",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Tiring",
          "tHander": "",
          "Enc": 60,
          "%3Cnew+column%3E": ""
        },
        "Quarter+Staff":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-2",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Defensive,+Pummelling",
          "tHander": 1,
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Rapier":         {
          "Class+%28Thingie%29": "Melee,+Fencing",
          "Damage": "SB-1",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast",
          "tHander": "",
          "Enc": 40,
          "%3Cnew+column%3E": ""
        },
        "Shield":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-2",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Defensive,+Special",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Spear":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        }
      },
      "tbl.tiny":       {
        "tableColumnSize": 4,
        "1":         {
          "greet": "hi",
          "name": "Jo"
        },
        "2-5":         {
          "greet": "ho",
          "name": "Sue"
        },
        "6":         {
          "greet": "he",
          "name": "tom"
        }
      },
      "timeLockDelay": 300,
      "tmpDraWArea": [],
      "toggles": "forceSelectClient=0 ; roofHaloColor=red ; doSwitchInterMap=0 ; doScaleTeleport=0 ; doGroups=1 ; doSnap2Grid=0 ; doVBLStamp=0 ; doResetFoW=0 ; doVBLCheck=0 ; doTriggerOnZeroMove=0 ; doCentreOnTok=0 ; doLockMovement=1 ; doFullScreenMode=0 ; doInvisibility=0 ; doShowPath=0 ; canSelectShadowTok=2 ; doSpecialPads=1 ; doFirstPointPath=1 ; doInnerPointsPath=1 ; limitMovement=0 ; eventMacroPreTokenMove=<none> ; eventMacroPreMultipleTokenMove=<none> ; eventMacroOnTokenMove=<none> ; eventMacroOnMultipleTokensMove=<none> ; eventPreMacroTeleport=<none> ; eventPostMacroTeleport=<none> ; eventMacroPreInterTeleport=<none> ; eventMacroPostInterTeleport=<none> ; eventMacroPostTokenMove=<none> ; eventMacroPostMultipleTokensMove=<none> ; movementLock=0 ; excludePropertyTypes=SpecialPad, libSystem, libSettings, none,brush ; drawArea=0",
      "treeTrunkImages": "asset://c9aab0b63e46d35910f9a921699299fb, asset://e8e2668d56b085bb3ad5b5441acbfd00, asset://0ca50b2dda25958fd74d167be8ff3248, asset://40755cd269a7ed04bf9c193d379822a6, asset://ca5ab391760ab396b8ff7bf8a30cf6b3, asset://f25f97f3a795fd2f10bd33b6a0e92381, asset://ac135e3b38d806e570aaa79ca7d63bf8, asset://b62d85d6b5b4cf883eb80c7f3104edf1, asset://8c51d7c434a64f6113713e75ce96888a, asset://bf9602ddb33418dac36d824f9582f6f2, asset://48e6e30912173007bd2baa12e03d0adb",
      "useAltImage": 1,
      "useCentreOnMePad": 0,
      "useStartUpMap": 1,
      "useStoredPath": 0,
      "vblExtendPx": 0,
      "vblSnap2Grid": 1,
      "vblSupport": 1,
      "w42.animatedViewSettings": "delay=0 ; stepSize=15 ; width=3000 ; height=1500 ; width1=3000 ; height1=1500 ; useStoredPath=0",
      "w42.bot.cleanSettings": "charComma=1 ; charSemicolon=1 ; charColon=1 ; charApostrophe=1 ; charGrave=0 ; charAcute=0 ; charAmpersand=1 ; charQuestion=1 ; charAt=1 ; charSpace=1 ; charPlus=0 ; charDash=1 ; charEqual=0 ; charHash=0 ; charBar=0 ; charLesser=0 ; charGreater=0 ; charPeriod=0 ; charDollar=1 ; lyrBackGround=1 ; lyrHidden=1 ; lyrObject=1 ; lyrToken=1 ; ",
      "w42.bot.dbdb":       {
        "t0":         {
          "Dungeon Tile 10": 270,
          "Dungeon Tile 24": 180
        },
        "t1":         {
          "Dungeon Tile 03": 0,
          "Dungeon Tile 06": 180,
          "Dungeon Tile 09": 90,
          "Dungeon Tile 27": 0,
          "Dungeon Tile 32": 180,
          "Dungeon Tile 45": 90,
          "Dungeon Tile 69": 270,
          "Dungeon Tile150 Mercutio": 0,
          "Dungeon Tile158 Bogie": 0,
          "Dungeon Tile161 Bogie": 0,
          "Dungeon Tile164 Bogie": 0,
          "Dungeon Tile165 Bogie": 0
        },
        "t12":         {
          "Dungeon Tile 02": 0,
          "Dungeon Tile 13": 0,
          "Dungeon Tile 16": 270,
          "Dungeon Tile 17": 0,
          "Dungeon Tile 26": 0,
          "Dungeon Tile 29": 90,
          "Dungeon Tile142 Maxxx": 90,
          "Dungeon Tile143 Maxxx": 90,
          "Dungeon Tile160 Bogie": 0,
          "Dungeon Tile163 Bogie": 0
        },
        "t13":         {
          "Dungeon Tile 01": 180,
          "Dungeon Tile 11": 180,
          "Dungeon Tile 25": 180,
          "Dungeon Tile 42": 180,
          "Dungeon Tile 57": 90,
          "Dungeon Tile 58": 90,
          "Dungeon Tile 60": 90,
          "Dungeon Tile151 Mercutio": 180,
          "Dungeon Tile157 Bogie": 180,
          "test1": 180
        },
        "t123":         {
          "Dungeon Tile 04": 90,
          "Dungeon Tile 07": 90,
          "Dungeon Tile 14": 270,
          "Dungeon Tile 30": 270,
          "Dungeon Tile 52": 270,
          "Dungeon Tile 70": 180,
          "Dungeon Tile 72": 0,
          "Dungeon Tile147 Mercutio": 180,
          "Dungeon Tile159 Bogie": 0,
          "Dungeon Tile162 Bogie": 90
        },
        "t1234":         {
          "Dungeon Tile 08": 270,
          "Dungeon Tile 12": 270,
          "Dungeon Tile 20": 270,
          "Dungeon Tile 55": 180,
          "Dungeon Tile144 Mercutio": 270,
          "Dungeon Tile145 Mercutio": 270,
          "Dungeon Tile146 Mercutio": 270,
          "Dungeon Tile148 Mercutio": 270,
          "Dungeon Tile149 Mercutio": 270,
          "Dungeon Tile152 Mercutio": 270,
          "Dungeon Tile153 Mercutio": 270,
          "Dungeon Tile154 Mercutio": 270,
          "Dungeon Tile155 Mercutio": 270,
          "Dungeon Tile156 Mercutio": 270
        }
      },
      "w42.bot.fg.GroupSettings": "bot.fg.Transportation=1;btnbot.fg.Transportation=Show Overview;bot.fg.EventTokenArea=1;bot.fg.UtilityMove=1;bot.fg.UtilityGeneral=1;bot.fg.Tables=1;bot.fg.Animations=1;bot.fg.MapCreation=1;bot.fg.VBL=1;bot.fg.Other=1;bot.fg.Functions=1",
      "w42.bot.lastTime": "",
      "w42.bot.lastTime1": 1589668038817,
      "w42.bot.lastTime2": 1398346576813,
      "w42.bot.lastTime3": 1460041044128,
      "w42.bot.lastTime4": 1406800597244,
      "w42.bot.pauseTime": 0,
      "w42.bot.pausedTime": 0,
      "w42.bot.processOrder.degrees": 90,
      "w42.bot.startTime": 1418380706138,
      "w42.bot.subTime": 1418380706138,
      "w42.bot.timeIsPaused": 0,
      "w42.bot.w42.bot.timeIsPaused": 0,
      "w42.bot.whisperPanel.languages": "Common, Dwarfish, Elfish",
      "w42.bot.whisperPanel.lastSettings":       {
        "italic": 0,
        "bold": 0,
        "underline": 0,
        "allPlayers": 0,
        "impersonate": 0,
        "currLanguage": "Dwarfish",
        "whisperText": "test",
        "color": "black",
        "Whisper": "Send Message"
      },
      "w42.bot.whisperPanel.playerChoices":       {
        "RolphLAN": "Common, Dwarfish, Elfish",
        "RolphTOK": "Eagle",
        "The Mighty JohnLAN": "",
        "The Mighty JohnTOK": "Tiny Dragon with Man on Top",
        "TomLAN": "",
        "TomTOK": "wEagle 9",
        "WolphLAN": "Common, Dwarfish, Elfish",
        "WolphTOK": "Eagle 1"
      },
      "w42.bot.whisperPanel.script":       {
        "Dwarfish": "script_dwarvish",
        "Elfish": "script_elvish"
      },
      "width": "",
      "width1": ""
    },
    "macros":     [
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 33,
        "label": "@skip this one",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "you never know for which its usefull, but macros whos name start with @ will be skipped in the benchmark.",
        "maxWidth": "",
        "tooltip": "an example benchmark macro. macro starting with @ are skipped in the benchmark",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "501654b8-3025-46ec-8f2e-6dbb5e3ec331",
          "commandChecksum": "7e8d415285f97162961c727a511fc6b6",
          "propsChecksum": "8881b2dc0c25354b7b14f4b512530f63"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 35,
        "label": "w42",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:var = '{\"Light\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Light\"},\"Mage Hand\":{\"level\":0,\"damage\":\"2d4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mage Hand\"},\"Expeditious Retreat\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Expeditious Retreat\"},\"Vanish\":{\"level\":\"1st\",\"damage\":\"2d5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Vanish\"},\"Read Magic\":{\"level\":0,\"damage\":\"2d10\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Read Magic\"},\"Resistance\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Resistance\"},\"Saving Finale\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Saving Finale\"},\"Feather Fall\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Feather Fall\"},\"Cure Light Wounds\":{\"level\":\"1st\",\"damage\":\"1d8+4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Light Wounds\"},\"Cacophonous Call\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cacophonous Call\",\"numMem\":2},\"Grease\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Reflex Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Grease\"},\"Timely Inspiration\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Timely Inspiration\"},\"Liberating Command\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Liberating Command\"},\"Charm Person\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Person\"},\"Invisibility\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Invisibility\"},\"Tongues\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Tongues\"},\"Charm Monster\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Monster\",\"numMem\":1},\"Hold Person\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Hold Person\"},\"Cure Serious Wounds\":{\"level\":\"3rd\",\"damage\":\"3d8+8\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Serious Wounds\"},\"Gallant Inspiration\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Gallant Inspiration\",\"numMem\":1},\"Cure Moderate Wounds\":{\"level\":\"2nd\",\"damage\":\"2d8+5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Moderate Wounds\"},\"Shatter\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Shatter\"},\"Dispel Magic\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dispel Magic\",\"numMem\":2},\"Silence\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Silence\"},\"See Invisibility\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"See Invisibility\"},\"Dimension Door\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dimension Door\"},\"Song of Kyonin\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Song of Kyonin\"},\"Mirror Image\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mirror Image\"},\"Terrible Remorse\":{\"level\":\"3rd\",\"damage\":\"3d6\",\"toHit\":\"No\",\"toHitBonus\":1,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":1,\"spell name\":\"Terrible Remorse\"},\"Virtuoso Performance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Virtuoso Performance\"},\"Primal Scream\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Primal Scream\"},\"Displacement\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Displacement\"},\"Cure Critical Wounds\":{\"level\":\"4th\",\"damage\":\"4d8+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Critical Wounds\"},\"Break Enchantment\":{\"level\":\"4th\",\"damage\":\"d20+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Break Enchantment\"},\"Freedom of Movement\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Freedom of Movement\",\"numMem\":1},\"Ki Shout\":{\"level\":\"5th\",\"damage\":\"13d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Fort Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ki Shout\"},\"Bards Escape\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bards Escape\",\"numMem\":1},\"Acid Fog\":{\"level\":\"5th\",\"damage\":\"2d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Acid Fog\",\"numMem\":0},\"Unadulterated Loathing\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Unadulterated Loathing\"},\"Wish\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Wish\"},\"Youthful Appearance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Youthful Appearance\"},\"Fire Breath\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fire Breath\"},\"Fireball\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fireball\"},\"Ablative Barrier\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ablative Barrier\"},\"Cackling Skull\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cackling Skull\"},\"Badgers Ferocity\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Badgers Ferocity\"},\"Daemon Ward\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Daemon Ward\"},\"Fabricate\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate\"},\"Fabricate Bullets\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate Bullets\"},\"Bears Endurance\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bears Endurance\"}}']\n[h:var = replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[^\"]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[^\"]+\"),', '\\$1:{')]\n[r:var = \"{\"+substring(var, 1, length(var)-1)+\"}\"]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "59ff058d-f944-46ef-8988-d15e1e04bb74",
          "commandChecksum": "9a45782f17df74d031a6d48353a3bfd3",
          "propsChecksum": "9ca23919831e2dbae966987619579ce7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 3,
        "label": "Limit Sight",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- Limit Sight -------------------------------->']\n[h:'<!-- check which event type this token triggers this can be \n- movedOn \n- movedOff \nLimited 1: circle distance=7,5 \nLimited 2: circle distance=3,5 \nLimited 3: circle distance=5,5 \nLimited 4: circle distance=1,5 \n-->']\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n\n[h:triggerType\t\t\t= arg(5)]\n\n<!-- assert that the trigger is a pad or area event -->\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n<!-- first retrieve the current sight level, is none is set, then set to 0 -->\n[h:\t\t\t\t\t\tsightLevel = getProperty(\"w42.bot.sightLevel\")]\n[h,if(sightLevel == \"\"):\tsightLevel = 0]\n\n<!-- get current sight type. If this is NOT a limited sight, then its the original sight so store this on the token so it can be retrieved later when the tokens steps off the EventPad(s) -->\n[h:sightType = getSightType()]\n[h,if(!startsWith(sightType, \"Limited \")):setProperty(\"w42.bot.oldSightType\", sightType)]\n\n<!-- For each extra EventToken (that contains this macro) the token is standing on increase the level. If the token moves off the eventPads, decrease the level. E.g. if a token moves onto 4 stacked event pads that run this macro, then this macro will run four times in a row, each time increasing the sight level with one step upto sight level 4. If the token then moves off one, but remains on three others, the sight level is decreased by 1-->\n<!-- also make sure that the value is always between 0 and 4 -->\n[h,if(event == \"movedOn\"):\tsightLevel = min(4,sightLevel + 1)]\n[h,if(event == \"movedOff\"):\tsightLevel = max(0,sightLevel - 1)]\n\n<!-- finally depending on the sight level (where 0==original sight type set the sight type of the token -->\n[h:setProperty(\"w42.bot.sightLevel\", sightLevel)]\n[h, if(sightLevel):setSightType(\"Limited \"+sightLevel); setSightType(getProperty(\"w42.bot.oldSightType\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bb3d49e9-6069-4586-a8c2-70513734d9f0",
          "commandChecksum": "ec2a5675309960643c4432dfea69598f",
          "propsChecksum": "35209277de07718b9107eb41604746f0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 36,
        "label": "am",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:var = '{\"Light\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Light\"},\"Mage Hand\":{\"level\":0,\"damage\":\"2d4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mage Hand\"},\"Expeditious Retreat\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Expeditious Retreat\"},\"Vanish\":{\"level\":\"1st\",\"damage\":\"2d5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Vanish\"},\"Read Magic\":{\"level\":0,\"damage\":\"2d10\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Read Magic\"},\"Resistance\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Resistance\"},\"Saving Finale\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Saving Finale\"},\"Feather Fall\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Feather Fall\"},\"Cure Light Wounds\":{\"level\":\"1st\",\"damage\":\"1d8+4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Light Wounds\"},\"Cacophonous Call\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cacophonous Call\",\"numMem\":2},\"Grease\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Reflex Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Grease\"},\"Timely Inspiration\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Timely Inspiration\"},\"Liberating Command\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Liberating Command\"},\"Charm Person\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Person\"},\"Invisibility\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Invisibility\"},\"Tongues\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Tongues\"},\"Charm Monster\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Monster\",\"numMem\":1},\"Hold Person\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Hold Person\"},\"Cure Serious Wounds\":{\"level\":\"3rd\",\"damage\":\"3d8+8\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Serious Wounds\"},\"Gallant Inspiration\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Gallant Inspiration\",\"numMem\":1},\"Cure Moderate Wounds\":{\"level\":\"2nd\",\"damage\":\"2d8+5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Moderate Wounds\"},\"Shatter\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Shatter\"},\"Dispel Magic\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dispel Magic\",\"numMem\":2},\"Silence\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Silence\"},\"See Invisibility\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"See Invisibility\"},\"Dimension Door\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dimension Door\"},\"Song of Kyonin\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Song of Kyonin\"},\"Mirror Image\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mirror Image\"},\"Terrible Remorse\":{\"level\":\"3rd\",\"damage\":\"3d6\",\"toHit\":\"No\",\"toHitBonus\":1,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":1,\"spell name\":\"Terrible Remorse\"},\"Virtuoso Performance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Virtuoso Performance\"},\"Primal Scream\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Primal Scream\"},\"Displacement\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Displacement\"},\"Cure Critical Wounds\":{\"level\":\"4th\",\"damage\":\"4d8+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Critical Wounds\"},\"Break Enchantment\":{\"level\":\"4th\",\"damage\":\"d20+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Break Enchantment\"},\"Freedom of Movement\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Freedom of Movement\",\"numMem\":1},\"Ki Shout\":{\"level\":\"5th\",\"damage\":\"13d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Fort Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ki Shout\"},\"Bards Escape\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bards Escape\",\"numMem\":1},\"Acid Fog\":{\"level\":\"5th\",\"damage\":\"2d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Acid Fog\",\"numMem\":0},\"Unadulterated Loathing\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Unadulterated Loathing\"},\"Wish\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Wish\"},\"Youthful Appearance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Youthful Appearance\"},\"Fire Breath\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fire Breath\"},\"Fireball\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fireball\"},\"Ablative Barrier\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ablative Barrier\"},\"Cackling Skull\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cackling Skull\"},\"Badgers Ferocity\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Badgers Ferocity\"},\"Daemon Ward\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Daemon Ward\"},\"Fabricate\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate\"},\"Fabricate Bullets\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate Bullets\"},\"Bears Endurance\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bears Endurance\"}}']\n[r:var = \"{\"+substring(replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[\\\\w\\\\s]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[\\\\w\\\\s]+\"),', '\\$1:{'), 1, length(replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[\\\\w\\\\s]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[\\\\w\\\\s]+\"),', '\\$1:{'))-1)+\"}\"]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6c2f5d35-f9b3-47aa-80f7-5466217b2f7a",
          "commandChecksum": "d62f8256ddc3f9a7d8c4c689dc2db610",
          "propsChecksum": "17650fa3ad09133c50221b326ceecd44"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "CORE",
        "includeLabel": false,
        "sortBy": "1",
        "index": 5,
        "label": "onCampaignLoad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H:'\n<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->\n<!-- ----------------------------------------------------------------------------- ----ONCAMPAIGNLOAD LIB:EVENTMACROS ----------------- -->\n<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->']\n\n[H: '<!-- defineFunction(function, macro, ignoreOutput, newScope) -->']\n\n[h:prefix = \"bot_\"]\n\n[h:defineFunction(prefix+\"limitMovement\", \"Limit Movement@this\" ,1,0) ]\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "43076151-fff6-4444-80f6-22907af00656",
          "commandChecksum": "e35b1a8514fe3d3a0f18113b3759229c",
          "propsChecksum": "b4e78d78b4e8752905ed9f4b700fcc94"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "CORE",
        "includeLabel": false,
        "sortBy": "",
        "index": 37,
        "label": "Limit Movement",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- limitMovementMacro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- \n\tThis macro is run if the limitMovement variable is set <> 0 in the settings (toggles) and it handles the movement limitation and it \n\twill ONLY run if Limit Movement (in the settings-->toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement:\tis the max amount the token is allowed to move.\n\t- lastPath:\t\t\tan array of coordinates of the path over which the token has moved\n\t- startingLocation:\tthe coordinates where the token started (in the form of an array)\n\t- currentLocation:\tthe coordinates where the token ended (in the form of an array)\n\t- usedMove:\t\t\tthe amount of units (distance per cell, e.g. feet or meters) moved (getMoveCount())\n\t\n\tNote that the actual movement limitation kicks in when:\n\t1. the initiative panel is active and the token is part of it\n\t2. a PLAYER moves the token\n\t3. the space the token is moved is more then its property 'movement' (edit token to change it)\n\t4. \n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of units a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move.<br>']\n\t}; {\t\n\t\t[limitMovement = getProperty('Speed')]\n\t}]\n-->\"]\n\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)] <!-- retrieve limitMovement setting -->\n\n\n[h:tok \t\t\t= getSelectedNames()]\n\n[h,if(getState('Dead')), CODE:{\t\n\t\t[limitMovement\t= 0]\t\n\t\t[message\t\t= strformat(\"%{tok} is incapacitated and cannot move.<br>\")]\n\t}; {\n\t\t[message\t\t= \"\"]\n\t\t<!-- if limitMovement is a property then get that property -->\n\t\t[if(!isNumber(limitMovement)): limitMovement\t= getProperty(limitMovement)]\n\t\t<!-- usually the max movement is set by a token property like 'movement' or 'speed'. This properties name can be set in the limit movement box in the settings and will be evaluated here. Alternatively you can simply enter a number like 5 -->\n\t\t[if(limitMovement == \"\"): limitMovement = 0]\n}]\n\n\n[if(listCount(tok) > 1), CODE:{\n\t<!-- multiple tokens are moved -->\n\t<!-- get first token from list of selected tokens and make that token current token -->\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t<!-- because of multiple selected tokens, just check if the initpanel is in use -->\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t<!-- variable to check if a single token is moved or multiple -->\n\t[singleMove = 0]\n}; {\n\t<!-- single token is moved -->\n\t<!-- if only one token is moved, check if its in the init panel -->\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n<!-- limit movement AREAS -->\n<!-- note that all these text outputs will be ignored. Im leaving them here for reference -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tMax allowed move is: \"+limitMovement+\"<br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[output = output + strformat(\"In total you moved: %{usedMove}\")]\n\t[broadcast(output)]\n}]\n\n[h:'pause(\"initInUse\", \"tmp\", \"usedMove\" , \"usedMove\" ,\"limitMovement\")']\n[h,if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t<!-- only limit movement if: mover is not the gm, token is in initiative panel, the token has actually moved AND it has moved more then the allowed amount-->\n\t[broadcast(strformat(\"%{message}You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> units. The maximum allowed movement is <b>%{limitMovement}<\/b> units.\"))]\n\t<!-- The following code you should not touch as its used for onTokenMove to process the rest. -->\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bf812134-01a9-4cc4-b6a7-f9477e2fbd3c",
          "commandChecksum": "ee376969b649c808f897a4a3a4e53f62",
          "propsChecksum": "2bb156e53c8be13585c7fd04c7b50560"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 38,
        "label": "test",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'<!--------------------------------------------------------------------------------------------->']\n[h:'<!-------------------------------------TEST----------------------------------------------------->']\n[h:'<!--------------------------------------------------------------------------------------------->']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "732357e9-4dfe-451d-b25a-560f21714a4b",
          "commandChecksum": "6d452ecf8151c26cf27012a6a3ee1bea",
          "propsChecksum": "7bb531172e9a4adb01f19f10cd4c2330"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 39,
        "label": "Standard Trap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- Standard Trap -------------------------------->']\n<!-- Here you enter the code to apply the effect of the TRAP Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n[h:me = arg(0)]\n[h:event = arg(1)]\n[h:triggerType = arg(5)]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:attackRoll = d20]\n[h:roll=1d6]\n[h,if(attackRoll > Dexterity):HP=HP-roll]\n[h,if(attackRoll > Dexterity):broadcast(\"You have triggered a trap and sustained \"+roll+\" hits.<br>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "e041c8ee-2619-4878-9969-1e251b4b70a6",
          "commandChecksum": "7cd474a588e38765825e3720b3f32078",
          "propsChecksum": "e2a46f61e6f31716aeed0d9da5be2ae2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 40,
        "label": "Standard Net Trap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-----------------------------Standard Net Trap (tripwire)---------------------------------->']\n<!-- Here you enter the code to apply the effect of the pit Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n<!-- check which event this token triggers this can be \n- movedOn \n- movedOver \n-->\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n[h:netTrapPad\t\t\t= \"net trap 1\"]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'<!--Failed Ag Test-->']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(netTrapPad): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've triggered a net trap<br>\")]\n\t[h: AgTest = \"Failed\"]\n\t[h: setState('Trapped', 1, me)]\n}; {\n\t[h:'<!--Succeeded Ag Test-->']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly triggered a trip wire, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\t[h: setState('Trapped', 0, me)]\n\n\t[h:'<!-- if you move onto (and not over) the tripwire and succeed your Ag check, you are pushed back to the edge of the tripwire. This means that a player cannot move onto a tripwire  voluntarily -->']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "500d0e4d-09f7-44bd-a19b-200a88f8c54b",
          "commandChecksum": "f5c6b11d3915b7305aeb3baab187ea62",
          "propsChecksum": "acca3b877f8d1e737dc60dfa0cf4921f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Door Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 9,
        "label": "Typical Door",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-----------------------------Standard Door Event---------------------------------->']\n[h:'<!--Here you enter the code to that effects the token that operates the door-->']\n\n[h:'<!-- \n- \"tokList\" is a list of tokens that are in the vicinity of the door when its operated. The first in the list are the tokens owned by the user that operated the door\n- \"users\" is a list of users where the first in the list is the user that operated the door, the rest of the list are users that own tokens that are in the vicinity\n- \"door\" is the name of the door that is operated\n- \"doorIsopened\" is true (1) when the player opens the door and false (0) when the player closed the door\n- \"isLocked\" is true (1) when the door has the \"Locked\" state and false (0) when it has not.\n- \"triggerType\" is always \"door\" this to prevent accidentily assigning the wrong eventtypes to a trigger\n-->']\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:thisPlayer\t\t\t= arg(1)]\n[h:tokList\t\t\t\t= arg(2)]\n[h:byStanders\t\t\t= arg(3)]\n[h:door\t\t\t\t\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n[h:doorIsOpened\t\t\t= arg(6)]\n[h:isLocked\t\t\t\t= arg(7)]\n\n<!-- assert that the trigger is a door event -->\n[h:assert(triggerType == \"door\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to door: \"+door, 0)]\n\n<!-- make operating token currentToken -->\n[h:switchToken(me)]\n\n<!-- THIS IS THE PART THAT YOU MOST LIKELY WANT TO EDIT -->\n<!-- BROADCAST IS THE ONLY WAY TO CONVEY A MESSAGE TO THE CHAT-->\n[h, if(isLocked), CODE:{\n\t<!-- this is executed when someone tries to open the door but its locked -->\n\n\t<!-- this is send to the operator -->\n\t[broadcast(\"You try to open the door but it won't budge, perhaps its locked?\",thisPlayer)]\n\n\t<!-- this is send to the bystanders -->\n\t[broadcast(me+\" tries to open the door but it appears to be locked\",byStanders)]\n\t\n\t<!-- if the door is locked AND you send something to the chat, than you need to abort here. Else its done in the core function and another message is send to the chat. -->\n\t[abort(0)]\n}; {\n\t<!-- this is executed when someone opens or closes the door-->\n\t<!-- to the operator -->\n\t[if(doorIsOpened): broadcast(\"The door makes a loud 'SQUEEEEEK' noise when you open the door\", thisPlayer); broadcast(\"You close the door with an audible 'CLICK' \", thisPlayer)]\n\t<!-- to the bystanders -->\n\t[if(doorIsOpened): broadcast(\"With a loud 'SQUEEEEEK' the door opens\", byStanders); broadcast(\"The door closes with an audible 'CLICK' \", byStanders)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "75dce0da-792e-47a6-9669-642b37cf0d59",
          "commandChecksum": "566b3253c9a29f627f17a8d5fc2948b2",
          "propsChecksum": "9616bed12e61a8616d65af61560b512e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 10,
        "label": "Teleport All",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "b4d61d22-13e8-449c-9b37-eb59022b977e",
          "commandChecksum": "0ce027f6e2e7211a2d44b5e2727d2b52",
          "propsChecksum": "65273f789758e107503646002efdbbf2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 11,
        "label": "Red Team Teleport",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1, 'Red')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "84e5b6e0-016a-4f37-a256-8ec3d1431ed0",
          "commandChecksum": "fea45a2bd165cedd8929fccbbc0c688a",
          "propsChecksum": "7db33fe8edfb830652e1e6fe7cc8874f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 12,
        "label": "Green Team Teleport",
        "fontSize": "0.90em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1, 'Green')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "20d80cf4-e4e2-42e7-addb-f6eab3e0e3bf",
          "commandChecksum": "05930631de42a9183f36c8417e915665",
          "propsChecksum": "ca6e06317d09a9e07a9ac0e83029cf3d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 13,
        "label": "Teleport Message",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"Message for you sir \"+tok, \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "96725bae-f2e6-4358-b602-cfe3c17791b7",
          "commandChecksum": "ccc46eb2321136f0f4e161663914ef8a",
          "propsChecksum": "afef034ce32ce633426e955873c30dbd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 14,
        "label": "Tel Pre Message",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[broadcast(macro.args)]\n[h:bot_animateText(\"Teleporting in 5,     4,     3,     2,    1     \", \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "c1dbc73e-e43d-4c8d-8301-3c3506e473f0",
          "commandChecksum": "5eabfb146f952fea016972685c3bf35b",
          "propsChecksum": "1999d1fdf8ffba22f9660f800c1716f7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 15,
        "label": "InterTel Msg",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(tok+\" is being teleported from \"+oldMap+\" to \"+newMap,\"Inter map teleport\", 0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "d8bfc7be-0fb6-4981-992b-a2da7938be24",
          "commandChecksum": "81e2fbdc7b2a7ab444c70a4213bae822",
          "propsChecksum": "2dfe97858d7241bea264d5ea9ca625a5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 16,
        "label": "onTokenMoveTrigger",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:broadcast(arg(0)+\" moved!\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "ece05af6-a91d-48af-b182-93690f2380c9",
          "commandChecksum": "4accc44e4f2065b6f0d389483e9949f3",
          "propsChecksum": "1578dc9c2aed4aed6bf869010aff29e9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Button macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 20,
        "label": "Switch To Map",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n<!-- switch all players to mapName. Argument to give for the Event Button is e.g. mapName=Difficult Terrain Map-->\n\n[message = \"Click Ok to switch to map: \"+getStrProp(arg(0),\"mapName\")]\n[pause(\"message\")]\n\n[h:bot_switchMap(mapName, 1)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "56d3eea0-720c-4c27-b015-c5f358dfc672",
          "commandChecksum": "5900bb53f8df31e8717f123f7d79177b",
          "propsChecksum": "5de845fa5e7d62aec73fb3635408f53d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Button macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 22,
        "label": "Test Event Button",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"The following button was selected: \"+getSelectedNames()+\"<br>The following arguments were passed: \"+arg(0), \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "3b514010-4620-4cd3-8550-a692f176c3b8",
          "commandChecksum": "794c90157c1a26080fc384c082faf925",
          "propsChecksum": "43d8f983eaf4e0087bb87a0c30efdbdc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 23,
        "label": "HillTopVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-----------------------------HillTopVBL---------------------------------->']\n<!-- Here you enter the code to apply the effect of the pit Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n<!-- check which event this token triggers this can be \n- movedOn \n- movedOff \n-->\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(padName)]\n[h:onHill\t\t\t\t= if(event==\"movedON\",1,0)]\n[h:offHill\t\t\t\t= if(event==\"movedOFF\",1,0)]\n\n[h:preHillCount\t\t\t= 0+getProperty(\"w42.bot.hillCount\")]\n[h:postHillCount\t\t= max(0,preHillCount+onHill-offHill)]\n[h:setProperty(\"w42.bot.hillCount\", postHillCount)]\n\n[h,if(!preHillCount && postHillCount), CODE:{ <!-- first token moves onto the hill -->\n\t[vbl\t= getTokenVBL()]\n\t[setProperty(\"w42.bot.hillVBL\", vbl)]\n\t[setTokenVBL(\"{'shape':'none'}\")]\n}]\n[h,if(preHillCount && !postHillCount), CODE:{ <!-- last token moves OFF the hill -->\n\t[vbl\t= getProperty(\"w42.bot.hillVBL\")]\n\t[setTokenVBL(vbl)]\n}]\n\n\n[h:broadcast(\"there are \"+postHillCount+\" token on the hill\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "9b9f7d4e-ec25-4e68-8469-a66e4bd3967e",
          "commandChecksum": "893eb1a1ed7fdd93e838a96d3aa0b5b2",
          "propsChecksum": "e80504afb0302f8e438c28a230c5ee85"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 26,
        "label": "Standard Pit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-----------------------------Standard Pit (trapped)---------------------------------->']\n<!-- Here you enter the code to apply the effect of the pit Example is given -->\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n\n<!-- check which event this token triggers this can be \n- movedOn \n- movedOff \n- movedOver \n- movedReturn\twhen you move the token AND use way points AND leave the token but end the move onto the token\n-->\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n<!-- assert that the trigger is a pad event -->\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'<!--Failed Ag Test-->']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(padName): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've fallen into a pit<br>\")]\n\t[h: AgTest = \"Failed\"]\n}; {\n\t[h:'<!--Succeeded Ag Test-->']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly fell into a pit, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\n\t[h:'<!-- if you move into (and not over) the pit and succeed your Ag check, you are pushed back to the edge of the pit. This means that a player cannot move into a pit voluntarily -->']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t=  json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t=  json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "84f16830-d0a6-43c2-b851-90e589c5cebc",
          "commandChecksum": "e38bd298dba75a16127625a72a5a3653",
          "propsChecksum": "005c01dd25cbd2a7d0dc69e23ef610f0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 27,
        "label": "Night Vision",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- Night Vision -------------------------------->']\n<!-- \n\tLink this macro to an eventPad. The eventPad in question will then act as sight type changer. \n\tIf you are ON the pad you have night vision, if your OFF the pad you have normal vision.\n\tThe following events should be set to trigger this event:\n\t- movedOn \n\t- movedOff \n-->\n\n[h:me\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n[h:triggerType\t= arg(5)]\n\n<!-- assert that the trigger is a pad or area event -->\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n[h,if(event == \"movedOn\"):\tsetSightType(\"Lowlight\")]\n[h,if(event == \"movedOff\"):\tsetSightType(\"Normal\")]\n\n<!--\nShould you have players with different sight types you will need to add an extra check. E.g. lets assume a player token has the token property \"nightVision\" which is either 0 (not) or 1 (has it). \nThen the first line becomes:\nif(event == \"movedOn\" && getProperty(\"nightVision\")==1):\tsetSightType(\"Lowlight\")\n-->\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4ed893b6-ac5a-4434-aefd-528f8b152dee",
          "commandChecksum": "4739ea4d98d46b873f2f5100ccd4bc7c",
          "propsChecksum": "7042ab207bf1611608a32f8cb1a011af"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 28,
        "label": "Excl FoW Maps",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- \n\tthis macro will turn off reset FoW for the maps that are listed here \n\tSo IF restore FoW is turned ON in the settings then it will NOT restore\n\tthe FoW on the map BASE in this example. Thus you can change or add \n\t\"BASE\" to e.g. \"Dungeon level 1, Forest of Dreadfull things, etc.\".\n\tThe listed maps will be excluded.\n\t\n\tAlternatively (if you like) you can also turn it around and set \n\tdoResetFoW = 1 and turn it OFF in the settings. In that case this macro\n\twill work in reverse\n-->']\n\n[h, if(listContains(\"BASE\", getCurrentMapName())): doResetFoW = 0]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "b972bf91-6d5a-49de-b182-adeade438792",
          "commandChecksum": "98d15388ea40b6a0ae9bd10cf56f42e2",
          "propsChecksum": "68dc7460d24b9ca5cf43a28108178a59"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 29,
        "label": "Default",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "",
        "maxWidth": "",
        "tooltip": "<html><b>DO NOT DELETE<\/b><br>This macro is used as reference to check how much time it takes<br>(during the benchmark) to run an empty macro.<br>The resulted value is deducted from the time of the benchmark macros",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c5b6cd2e-3539-44e8-a4d2-61a04be8d2a5",
          "commandChecksum": "d41d8cd98f00b204e9800998ecf8427e",
          "propsChecksum": "f2585b27c5a0d81a5b40c180a41ccd7a"
        }
      }
    ]
  }},
  "lib:OnTokenMove": {"48":   {
    "mtversion": "1.8.4",
    "timestamp": "2021-04-04T20:32:48.783185-07:00",
    "notes": "\n\n",
    "gmnotes": "Click \"onCampaignLoad\" to activate automatic stair and doors transitions! \n(Teleports, InterTeleports and the one way teleports)\nThe onCampaignLoad button can be found on the 'selection panel'\n\nWhen the animation of the doors stop working and start to create all kinds of duplicates, then the autoexec on the other clients doesn't work anymore. This usually happens when the ownership of this tokens has been assigned to someone not online. Make sure NO OWNERS ARE SET FOR THIS LIB:TOKEN",
    "properties":     {
      "---------INSTALLED FEATURES-----": "",
      "--------FEATURES-------": "",
      "--diagnose--": "",
      "--menu--": "",
      "am.bot.disguiseMacro":       {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "includeLabel": false,
        "sortBy": "81",
        "label": "Use Disguise",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_useDisguise()]",
        "maxWith": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "toolapplyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1e79f6ba-9681-499d-b231-c97cdcbf358a",
          "commandChecksum": "0ce1dac741989645cee926b9ff11ef4e",
          "propsChecksum": "b6fd6357814530597380f5d611697495"
        }
      },
      "bot.fg.Animations":       [
                {
          "Group_Name": "Animations",
          "Function": "Animated Doors",
          "Type": "Menu Macro",
          "Dependencies": "State: Locked; Token: DoorLeverToken",
          "Macro_Group": "Door Animation",
          "Description": "Full functionality to setup animated doors, both single and double, both rotating and sliding. Including support to activate them in at least 5 different ways. "
        },
                {
          "Group_Name": "Animations",
          "Function": "VBL on Doors",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Door Animation",
          "Description": "Toggling (open or close) an animated door will give the following options: look through key-hole, look through window, crack door open, open door half way, open door fully. The VBL will be adjusted accordingly"
        },
                {
          "Group_Name": "Animations",
          "Function": "Token door switches (with proximity check)",
          "Type": "Menu Macro",
          "Dependencies": "State: isButton",
          "Macro_Group": "Door Button",
          "Description": "Set up a door with a switch token that corresponds with that door when you click on the switch. Option for the gm to 'Lock' the door, so players can't open it. You can also set a proximity check, that checks whether a token of the player is close enough to open the door."
        },
                {
          "Group_Name": "Animations",
          "Function": "Animate Token Movement Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "A macro and macro button with which you can animate the movement of one or more tokens. See video"
        },
                {
          "Group_Name": "Animations",
          "Function": "Animate Token Movement Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "Same as the macro only in the form of a macro function that you can call inside your own macros."
        },
                {
          "Group_Name": "Animations",
          "Function": "Animated text Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "A macro that generates an input screen where you can setup the animated text. This will pop up a frame on every client pc showing a frame where a delayed text is printed in"
        },
                {
          "Group_Name": "Animations",
          "Function": "Animated text Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "Same as the macro only in the form of a macro function that you can call inside your own macros."
        },
                {
          "Group_Name": "Animations",
          "Function": "Set View Animation",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Use lastpath of selected token to run a screen animation"
        },
                {
          "Group_Name": "Animations",
          "Function": "Link View Animations",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Link the view animation of selected tokens and store it on one token"
        },
                {
          "Group_Name": "Animations",
          "Function": "Run View Animation",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Run view animation created for selected token"
        }
      ],
      "bot.fg.EventTokenArea":       [
                {
          "Group_Name": "Event token and area support",
          "Function": "Transparent Roofs",
          "Type": "Token",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Roof) When a token moves onto a building (with a roof) the roof automatically turns transparent (with a red halo) and return opague again when the token moves away from it. For this to work you will need to install the tabel into your framework inside the attached zip file."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Roof VBL Swap",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "in addition to existing Roof swap function, an option is added where you can store the VBL currently on a building and swap it with a VBL cross shape. Hence from the outside players can see the partially and as soon as they enter the building the VBL of the roof is swapped with the VBL of the building."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Warded Roofs",
          "Type": "Token/Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Roof) Roofs have now a corresponding 'set roof' macro with which you can assign doors to the roof. If doors are assigned, the Roof automatically becomes a 'warded' area, which you can ONLY enter through the OPEN door. Thus if the door is closed, there is no way a player can move her token onto the roof. If the door is open, a player can ONLY move in the building when it moves her token OVER the door token first."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Foliage",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Foliage) Tokens with these names work exactly as roofs, except there will be NO red halo outline for the transparent version AND you can choose to use a different picture to swap with when you move over it. (on default when you move over them their image is swapped with an transparent image from the tables)."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Canopy",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Canopy) Tokens with these names are automatically given an treetrunk as alternative image when a token moves over them."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Warded Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros",
          "Description": "(Ward) Tokens that move onto this area are moved back to their original position. They cannot enter the area."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Event Pads",
          "Type": "Token/Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Event Macros",
          "Description": "(EventPad) These tokens are triggered on certain event e.g. when a token move onto the pad. These events can be set through a 'set event pad' macro. These pads replace the former Pit and Trap pads and allow for a much more versatile use. When the pad is triggered then a macro that you linked to it will run. Extra example is added: trip wire in combination with a net trap (thnx Pinkrose)"
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Canopy, Foliage, Roof) Linked tokens are special pads that are activated simultaneously. If you have two or more tokens that are linked by the same link identifier, e.g. 'Linked 1 Roof 5' and 'Linked 1 Canopy 3' (here the link identifier is '1'), then when one of the tokens is activated (by moving a token on top of it) the other is activated as well."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Bridge Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(i.c.w. Canopy, Foliage, Roof) Bridges are pads that you link with Canopy, Foliage or Roof pads. When you move over a Bridge and then onto a Roof (in one move) then the roof does NOT dissapear (See vid. tutorial for more info)."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Tunnel Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(i.c.w. Canopy, Foliage, Roof) Tunnels work exactly the same as Bridges albeith the opposite effect. So when moving over a tunnel token the roofs disappear, while moving directly onto a roof they won't."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Shadow Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; ShadowPads",
          "Description": "(ShadowPads ) This allows to watch token movement on map A from map B. Typical use is a 2 story building where you can watch the ground floor from the first floor through a gap in the floor (and vice versa). See vid tutorial for more details."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Event Areas",
          "Type": "Area",
          "Dependencies": "State: Special Area; Token: Area Marker",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof; Event Area Macros",
          "Description": "These are Areas you can define (and these can take ANY form, with a resolution of the grid) and depending whether a token moves onto, over, off, etc. it will trigger an event (macro). The best use for these are to define difficult terrain areas which impede the movement of a token. For which the 'Limit Movement' macro in the lib:EventMacros lib is now adapted.<br>Finally one other good thing of these areas: they're FAST! A lot faster then the token method currently in use."
        }
      ],
      "bot.fg.Functions": [      {
        "Group_Name": "Function Macros",
        "Function": "Function Macros",
        "Type": "Function Macro",
        "Dependencies": "None",
        "Macro_Group": "Geofunctions Support; Geofunctions; Util - Math; Message; Util - General; Util - Documented",
        "Description": "<a href='macro://manFunctionsTxt@Lib:OnTokenMove/none/Impersonated?'>Bot Function Manual (for overview)<\/a>"
      }],
      "bot.fg.GroupList": "bot.fg.Transportation,bot.fg.EventTokenArea,bot.fg.UtilityMove,bot.fg.UtilityGeneral,bot.fg.Tables,bot.fg.Animations,bot.fg.MapCreation,bot.fg.VBL,bot.fg.Other,bot.fg.Functions",
      "bot.fg.MapCreation":       [
                {
          "Group_Name": "Map Creation macros",
          "Function": "Scatter",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "Select one or more tokens, set an area and a number and copies of the tokens will be randomly scattered accross the preset area. Ideal for e.g. rocks, trees, or a chaos warband."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Building A Forest",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "A macro to build a big forest FAST and have it ready for the Canopy 'Trick'. This is a specialized macro based on the 'Scatter' macro"
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Summon tokens",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Summon",
          "Description": "A macro with which you can summon tokens from the 'BASE' map onto the current.map . The location you can set by hand or you can summon it onto a selected token."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Fill Area",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "A macro that with which you can quickly fill an area with tokens (also useful for creating special areas)."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Draw Order Edit Panel",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Order",
          "Description": "With this panel you can edit the draw order of the selected tokens, rotate them individually, random or as a group. It also contains layer and shape dropdown list."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Crowd Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "An new set of macros that allows you to fill a e.g. Town square with tokens (forming a crowd), which can then 'flee in panic' when the fight goes down."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Map Editor",
          "Type": "Menu Macro/Area",
          "Dependencies": "State: editFieldMarker; Token: GridCoordMarker",
          "Macro_Group": "Scatter",
          "Description": "Two new macro to create a field on the map where its VERY easy to place token, used for map creation. Try it out for more info."
        }
      ],
      "bot.fg.MenuButtons": "Manual=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+pops+up+a+user+manual+of+this+tool%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmanualText%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EManual%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Settings=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EHere+you+can+set+stuff+as+a+different+name+for+BASE+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fsettings%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3ESettings%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; BoTFeatures=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Chtml%3EChange+the+installed+BoT+features.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfeatureTable%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EBoT+Features%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; InitializePads=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+cycles+through+all+maps+in+the+campaign+file%3Cbr%3Elooking+for+special+pads.+It+will+initialize+any+special+pad+it%3Cbr%3Eencounters+and+report+any+errors++on+the+way%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FinitializePads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EInitialize+Pads%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AltInitPads=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Apurple%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EIn+contrast+to+initialize+Pads%2C+this+macro+does+ONLY+initialize+the+CURRENT+map.%3Cbr%3E+It+uses+a+completely+different+and+more+time+consuming+method+for+this.%3Cbr%3EResulting+in+a+map+where+the+movement+of+tokens+is+less+snappy+in+general%3Cbr%3E+But+will+be+%28a+lot%29+faster+when+there+are+a+lot+%28%3E100%29+special+tokens+on+a+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FaltInitMap%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EAlt.+Init.+Pads%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ActivateSwitches=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23FFA500%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+activates+a+frame.+As+long+as+that+frame+is+open+the+following+functions+are+active%3A%3Cbr%3E-+Door+Switches+%28user+can+click+them+to+open+doors%29+%3Cbr%3E-+Event+Buttons+%28user+can+click+them+to+activate+linked+macro%29+%3Cbr%3E-+Full+screen+mode+%28if+turned+on+in+the+settings%2C+frames+are+automatically+turned+into+Dialogs%29+%3Cbr%3E-+Group+select+tokens+%28user+can+select+one+token+and+the+rest+is+auto-selected%29%3Cbr%3E-+Force+token+selection+%28token+that+gm+selects+on+his+client+is+also+selected+on+a+player+client%29%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FopenFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EActivate+Switches%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetSound=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ETo+setup+sound+pads%3C%2Fi%3E+macro%2C+select+one+SoundPad+token+and+click+this+button+to+set+it+up%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetupSound%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESetup+Sound+Pad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ClearSound=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+stop+ALL+sounds+currently+streaming%2Fplaying+AND+removes+them+from+memory%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearSound%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EClear+all+sounds%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ReplaceSoundURL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+search+and+replaces+all+URLs+for+ALL+soundpads+in+the+campaign+file%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchangeAdress%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ES%26R+all+sound+URL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetDoor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ETo+use+the+%3Ci%3EToggle+Door%28s%29%3C%2Fi%3E+macro%2C+select+one+or+more+doors+and+click+this+button+to+set+it+up%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetDoor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Door%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetRoof=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EHere+you+can+give+a+list+of+%3Ci%3Eentry+doors%3C%2Fi%3E+through+which+a+token+can%3Cbr%3Eenter+the+building.+Note+that+these+doors+MUST+be+on+the+edge+of+the%3Cbr%3Eroof+%28like+real+doors%29.+If+you+leave+this+list+empty%2C+a+token+can+move%3Cbr%3Eanywhere+on+or+over+the+%3Ci%3Eroof%3C%2Fi%3E+token%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetRoof%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Roof%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; BuildForest=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+one+ore+more+images+of+a+Tree+top+%28Canopy%29+and+click+this+button+to+randomly+spread+them+over+an+area%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FbuildForest%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EBuild+Forest%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ChooseTrunks=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+form+where+you+can+select+or+deselect+tree+trunk+images%3Cbr%3Ewhich+are+on+the+BASE+map.+The+checked+images+will+be+%28randomly%29+used+for+the+%3Ci%3ECanopy%3C%2Fi%3E+pads%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchooseTrunks%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChoose+Trunks%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EUse+this+macro+to+create+a+square+filled+with+tokens+%28a+crowd%29%2C%3Cbr%3Ethat+can+later+be+dispersed+by+using+the+%3Ci%3Emove+crowd%3C%2Fi%3E+macro%3C%2Fhtml%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcreateCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ChooseCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+form+where+you+can+select+or+deselect+crowd+tokens+images%3Cbr%3Ewhich+are+on+the+BASE+map.+The+checked+images+will+be+%28randomly%29+used+for%3Cbr%3Ethe+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchooseCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChoose+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ScatterTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+will+%3Ci%3Escatter%3C%2Fi%3E+selected+tokens+over+the+map%2C+according+to+the+set+parameters%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fscatter%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EScatter+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MassVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+draws+VBL+crosses+on+all+tokens+that+match+a+search+string%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMass+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DrawArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+fills+up+an+area+with+tokens.+You+can+either+select+ONE+token+and+run+it%2C+or+run+it+without+selection.%3Cbr%3EIf+you+select+one+token+before+you+run+this+then+that+token+will+be+added+to+the+dropdown.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleAreaDraw%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E0.+Draw+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetEventPad=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+can+be+used+to+link+an+Event+Macro+to+an+EventPad%3Cbr%3E%3Cbr%3E1.+Create+a+macro+on+the+lib%3AEventMacros+token+in+the+group%3A%3Cbr%3E%26%2339%26semi%3BEvent+Pad+Macros%26%2339%26semi%3B%2C+containing+the+code+that+is+activated+when+the%3Cbr%3EEvent+is+triggered.+For+example+%26%2339%26semi%3BSpear+Trap%3Cbr%3E2.+Select+an+%26%2339%26semi%3BEvent+token%26%2339%26semi%3B.+This+is+a+token+which+name+starts+with%3Cbr%3E%26%2339%26semi%3BEventPad+%26%2339%26semi%3B+e.g.+%26%2339%26semi%3BEventPad+1%26%2339%26semi%3B+or+%26%2339%26semi%3BEventPad+Pit+Trap%26%2339%26semi%3B.%3Cbr%3EThis+token+can+be+placed+on+any+layer%3Cbr%3E3.+Run+the+macro+%26%2339%26semi%3BSet+Event+Pad%26%2339%26semi%3B%3Cbr%3E4.+Pick+an+Event+macro+from+the+list%2C+e.g.+%26%2339%26semi%3BStandard+Pit%26%2339%26semi%3B%3Cbr%3E5.+Then+select+the+events+on+which+this+macro+is+triggered%3Cbr%3E7.+Click+OK+%3Cbr%3E8.+Run+%26%2339%26semi%3BInitialize+Maps%26%2339%26semi%3B%3Cbr%3E%3Cbr%3EThe+Event+Pad+is+now+set%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetEventPad%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Event+Pad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FillArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+fills+a+predefined+area+with+tokens%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfillArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E1.+Fill+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ResetPit=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+pop-up+with+all+the+initialized+doors.+Here+you+can+select+which+to+open%2Fclose%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FresetPit%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EReset+Pit%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DefineArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+define+an+Event+Area+which+you+then+can+link+to+an+event+macro%2C+to+be+triggered+when+a+token+moves+over+this+area.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdefineArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E2.+Define+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetEventButton=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+can+be+used+to+link+an+Event+Macro+to+a+Event+Button.%3Cbr%3E%3Cbr%3E1.+Create+a+macro+on+the+lib%3AEventMacros+token+in+the+group%3A+%26%2339%26semi%3BEvent+Button+Macros%26%2339%26semi%3B%2C+containing+the%3Cbr%3Ecode+that+is+activated+when+the+button%2C+e.g.+%26%2339%26semi%3BSwitch+To+Map%26%2339%26semi%3B%3Cbr%3E2.+Select+the+button+%28any+token+will+do%29+to+which+that+macro+should+apply+e.g.+%26%2339%26semi%3BSwitch+to+Fair+Haven%26%2339%26semi%3B%3Cbr%3E3.+Run+this+macro%3Cbr%3E4.+Select+%26%2339%26semi%3BSwitch+Map%26%2339%26semi%3B+from+the+list%3Cbr%3E5.+In+the+%26%2339%26semi%3BGive+Arguments%26%2339%26semi%3B+box+enter+the+arguments+as+a+stringproperty%2C+e.g.%26%2339%26semi%3BtoMap%09%09%09%3D+Fair+Haven%26%2339%26semi%3B%3Cbr%3E%3Cbr%3EHere+it+is+important+that+both+the+the+arguments+name+%28toMap%29+and+the+arguments+%28Fair+Haven%29%3Cbr%3Econtains+ONLY+alphanumeric++characters%21%3Cbr%3ENote+that+you+can+give+multiple+arguments%21+Just+seperate+them+with+a+%26semi%3B.%3Cbr%3EE.g.+toMap%09%09%09%3D+Fair+Haven%26semi%3Bmessage%09%09%09%3D+Going+to+Fair+Haven.%3Cbr%3E%3Cbr%3E6.+Click+OK.+Now+everything+is+set+up%3Cbr%3E%3Cbr%3ETo+use+the+buttons+you+need+to+run+the+macro+%26%2339%26semi%3BActivate+Switches%26%2339%26semi%3B.+This+is+used+for+door+switches%3Cbr%3Ebut+it+will+also+work+for+the+Event+Buttons.+Now+when+thats+done+you+will+notice+a+pop-up.+You+can%3Cbr%3Emake+this+pop-up+small%2C+but+you+cannot+close+it+%28else+the+buttons+will+not+work%29.%3Cbr%3E%3Cbr%3EIf+you+now+click+on+the+button+%26%2339%26semi%3BSwitch+to+Fair+Haven%26%2339%26semi%3B+the+macro+%26%2339%26semi%3BSwitch+Map%26%2339%26semi%3B+is+activated.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetEventButton%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Event+Button%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AssignArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+link+predefined+Areas+to+Event+Macros+and+to+the+Limit+Movement+macro%3Cbr%3EThe+Event+Macro+will+be+triggered+when+a+token+moves+over+the+Area.+The+handling+of+this+is+left%3Cbr%3Eto+the+macro+itself%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FassignArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E3.+Assign+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UnShowArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+predefined+areas+by+putting+token+in+the+cells+that+are+part+of+the+Area.%3Cbr%3EWhen+you+run+this+macro+again+the+tokens+are+removed+again.%3Cbr%3E%3Cbr%3EHence+this+macro+can+be+used+to+change+pre+defined+area.+To+do+this+first+run+this+macro%3Cbr%3Efor+the+area+you+wish+to+change.+The+map+will+then+be+filled+with+tokens.+Then+move+these%3Cbr%3Etokens+around%2C+delete+them%2C+copy+them+until+youre+happy.+Then+run+%3Ci%3EDefine+Area%3C%2Fi%3E+and%3Cbr%3Eenter+a+name+for+the+new+Area+%28can+be+the+same+as+the+original+in+which+case+it+will+be%3Cbr%3Eoverwritten%29+and+click+ok.+A+new+Area+is+now+defined.+Finally+you+can+run+Show+Area+again%3Cbr%3Eto+remove+the+tokens.+Note+that+is+you+created+new+tokens+that+these+will+NOT+be+removed+by%3Cbr%3Ethis+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E4.+%28Un%29Show+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UnShowAreaUtil=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+predefined+areas+by+putting+token+in+the+cells+that+are+part+of+the+Area.%3Cbr%3EWhen+you+run+this+macro+again+the+tokens+are+removed+again.%3Cbr%3E%3Cbr%3EHence+this+macro+can+be+used+to+change+pre+defined+area.+To+do+this+first+run+this+macro%3Cbr%3Efor+the+area+you+wish+to+change.+The+map+will+then+be+filled+with+tokens.+Then+move+these%3Cbr%3Etokens+around%2C+delete+them%2C+copy+them+until+youre+happy.+Then+run+%3Ci%3EDefine+Area%3C%2Fi%3E+and%3Cbr%3Eenter+a+name+for+the+new+Area+%28can+be+the+same+as+the+original+in+which+case+it+will+be%3Cbr%3Eoverwritten%29+and+click+ok.+A+new+Area+is+now+defined.+Finally+you+can+run+Show+Area+again%3Cbr%3Eto+remove+the+tokens.+Note+that+is+you+created+new+tokens+that+these+will+NOT+be+removed+by%3Cbr%3Ethis+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%28Un%29Show+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AssignTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+assign+token+that+are+on+the+TOKEN+or+HIDDEN+layer+to+Assignpads.%3Cbr%3ETokens+assigned+to+Assignpads+will+be+moved+onto+their+assigned+pad+when+you+run+Execute%3Cbr%3EAssignpads%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FassignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAssign+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Execute=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBefore+you+can+use+this+macro+you+first+need+to+assign+token+to+the+special+Assignpads.%3Cbr%3EOnce+that+is+done%2C+you+can+run+this+macro+and+pick+the+Assignpads+to+be+executed.%3Cbr%3EOn+execution+the+linked+token+will+be+moved+to+its+assigned+pad.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecAssignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExecute%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+create+a+new+BoT+table+by+copy+pasting+a+table+from+e.g.+excel%3Cbr%3Einto+the+text+box.+You+can+use+bot_table%28tableName%2C+optional%3A+column%2C+row%29+to+retrieve%3Cbr%3Ean+entry+from+that+table.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcreateTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+a+list+of+all+available+BoT+tables.+The+one+you+pick+can+be+edited.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EShow+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DeleteTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+a+list+of+all+available+BoT+tables.+The+one+you+pick+will+be+deleted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdeleteTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDelete+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateMTTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+create+a+new+MAPTOOL+table+by+copy+pasting+a+table+from+e.g.+excel%3Cbr%3Einto+the+text+box.+Pasted+entries+should+be+seperated+by+tabs+and+newlines+%28which+happens%29%3Cbr%3Eautomatically+if+you+paste+it+from+excel.+Next+to+that+you+can+use+either+1%2C+2+or+3+entries%3Cbr%3EWhere+the+first+entry+is+the+start+of+the+roll%2C+the+2nd+is+the+end+of+the+roll+range%3Cbr%3Ethe+third+is+the+value+so+either%3A%3Cbr%3E%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E2%26nbsp%26semi%3B%26nbsp%26semi%3B%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E2%26nbsp%26semi%3B%26nbsp%26semi%3B5%26nbsp%26semi%3B%26nbsp%26semi%3B%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fxls2Table%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+MT+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MapEditor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ECreates+a+filed+where+creating+a+token+map+becomes+really+easy.+Hit+this+button+for+more+info.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmapEditor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMap+Editor%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; QuitMapEditor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStops+the+Map+editor+%28and+removes+the+editor+field%29%3Chtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FquitEditor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EQuit+Map+Editor%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MovetoHidden=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBelongs+to+the+map+editor.+Moves+all+pasted+tokens+to+the+HIDDEN+layer+so+theyre+no+longer+visible.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveToHidden%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+to+Hidden%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MovetoToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBelongs+to+the+map+editor.+Moves+all+hidden+tokens+back+to+the+TOKEN+layer.%3Chtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveToToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+to+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SeekToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+searches+ALL+maps+and+ALL+tokens+and%3Cbr%3Ereturn+those+tokens+of+which+the+first+part+of+%3Cbr%3Etheir+name+matches+with+the+entered+search+string%3Cbr%3E%3Cb%3EPop-ups+on+first+use.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FseekToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESeek+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetLightSource=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThe+power+of+this+button+is+that+you+can+apply+it+to+multiple+tokens+at+once.%3Cbr%3ESelect+all+tokens+you+want+to+set+the+light+for+before+you+hit+this+button.%3Cbr%3EYou+can+set+light+sources+to+exclude+in+the+settings.%3Cbr%3E%3Cb%3EMake+sure+that+no+lightsource+in+the+campaign+setting+contains+a+comma%3A+%2C+%3C%2Fb%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetLightSource%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Light+Source%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetReference=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+is+used+to+setup+the+%3Cb%3EShadow+pads.%3C%2Fb%3E%3Cbr%3E+To+sync+the+movement+of+the+shadow+token+to+the+real+token+two+reference+tokens+are+required.%3Cbr%3E+%3Cbr%3E+To+set+this+up+do+the+following%3A%3Cbr%3E+1.+create+two+tokens+with+the+same+name+where+one+has+the+suffix+%26%2339%26semi%3B+Ground%26%2339%26semi%3B+and+the+other+%26%2339%26semi%3B+Floor%26%2339%26semi%3B%3Cbr%3E+2.+Make+sure+that+the+reference+tokens+are+snapped+to+grid+and+medium+sized.%3Cbr%3E+3.+Place+one+of+the+tokens+on+the+ground+floor+map+and+one+on+the+first+floor+map.%3Cbr%3E+4.+Then+select+one+of+the+reference+tokens+and+hit+this+macro.+Select+the+shadow+pads+to+which+it%3Cbr%3E+should+be+linked+and+hit+ok.%3Cbr%3E+%3Cbr%3E+Read+the+manual+for+more+detailed+instructions.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetReference%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Reference%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Remove20=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+replaces+%2520+with+spaces+%3E+%3C+in+the+selected+token+names%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FremoveP20%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERemove+%2520%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetDrawOrder=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+is+just+a+handy+macro+where+you+can+manually+set+the+draw+order+of+the+token.+%3Cbr%3EA+high+number+means+on+top+of+all+a+low+number+means+below+all.%3Cbr%3EThen+current+number+%28draw+order%29+is+shown+when+you+run+this+macro+on+a+token%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetDrawOrder%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Draw+Order%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; RenumberTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+you+have+used+the+scatter+function%3Cbr%3E+%28especially+icw+Spread%29+then+can%3Cbr%3Erenumber+the+scattered+tokens+before+you+%3Cbr%3Ehit+the+initialize+pads.+Assuming+that+you+%3Cbr%3Ehave+scattered+special+tokens+onto+the+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FrenumberToks%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERenumber+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ToggleSpecial=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+toggles+Canopy%2C+%3Cbr%3EFoliage+or+Roofs+on+or+off.+%3Cbr%3EThis+also+resets+the+tokens.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleSpecial%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Special%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetTokenSize=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+is+usefull+if+you+want+to+use+Alt+Init+Pads+macro+to+initialize+a+map.%3Cbr%3EWith+this+macro+you+can+pre-set+the+size+of+a+token.+So+you+wont+be+asked+%3Cbr%3Efor+it+when+you+run+alt.+init.+maps.%3Cbr%3ENote+that+you+only+need+to+do+this+for+free+size+tokens%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetTokSize%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Token+Size%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CopyDelMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+This+macro+allows+you+to+select+macros+on+the+selected+token.+The+selected+macros+you+can+copy+or+delete.%3Cbr%3E+%3Cbr%3E+In+case+of+%3Cb%3Ecopy%3C%2Fb%3E%2C+they+will+be+stored+in+a+property+on+lib%3AEventMacros.+When+you+select+another+token+you+can+%3Cbr%3E+click+%3Ci%3EPaste+Macros%3C%2Fi%3E.+This+will+open+a+similar+frame+where+you+can+select+the+macros+to+paste+on+the+selected%3Cbr%3E+token.%3Cbr%3E+In+case+of+%3Cb%3Edelete%3C%2Fb%3E+you+have+the+option+to+%3Ci%3Eallow+undo%3C%2Fi%3E.+The+selected+macros+will+be+deleted+from+the+token%3Cbr%3E+and+if+allow+undo+is+turned+on%2C+they+will+be+stored+in+a+property+on+that+token.+So+you+can+later+choose+to+undo+the%3Cbr%3E+process.+%3C%2Fhtml%3E++%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcpyDelMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECopy%2FDel+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PasteMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+This+button+you+can+use+to+paste+macro+on+the+selected+token.+Before+you+do+this%2C+you+first+need+to+run+the+%3Cbr%3E+Copy%2FDel+Macros+button+on+another+token.+%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpasteMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPaste+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UndoDelMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+If+you+deleted+macros+on+the+selected+token+using+the+Copy%2FDel+Macros+function%3Cbr%3E+AND+you+had+%3Ci%3Eallow+undo%3C%2Fi%3E+turned+on%2C+then+you+can+use+this+function+to+undo%3Cbr%3E+that+process+%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FundoDelMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUndo+Del.+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FindDuplicates=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EGive+a+list+of+all+tokens+of+all+layers+on+current+map+that+have+the+same+name%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfindDuplicates%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFind+Duplicates%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PadExplorer=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+all+special+pads+on+the+current+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FinitializeMap%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPad+Explorer%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AutoDisguiseBttn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+you+click+this%2C+a+text+box+will+appear+with%3Cbr%3Ea+token+property+you+can+add+to+your+Campaign%3Cbr%3EProperty+token+properties+to+automatically%3Cbr%3Eadd+the+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+to+tokens.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FautoDisguiseButton%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAuto+Disguise+Bttn%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetVBLStamp=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+applies+a+VBL+%28Vision+Blocking+Layer%29+upon+a+token.%3Cbr%3EThe+VBL+will+move+with+the+token+as+you+move+it.%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetVBLStamp%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+VBL+Stamp%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MassVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+draws+VBL+crosses+on+all+tokens+that+match+a+search+string%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMass+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ToggleVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+function+you+can+toggle+saved+mass+VBL+structures+%28set+with+Mass+VBL+macro%29+on+and+off%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Deleteprops=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+resets+ALL+properties+currently+on+the+token.+Effectively+deleting+all+properties.+Use+carefully%21%21%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdeleteProps%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDELETE+props%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Benchmark=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Apurple%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+runs+each+macro+that+is+in+the+%26%2339%26semi%3BBenchmark+Macros%26%2339%26semi%3B+group+on+lib%3AOntokenmove%3Cbr%3Eand+compares+their+individual+times.+It+uses+an+empty+loop+%28Default+in+that+group%29+as%3Cbr%3E+reference+as+deducts+that+resulting+time+from+the+added+macros.+%3Cbr%3E%3Cbr%3ETo+make+use+of+this%2C+create+one+or+more+macros+in+that+group+with+ONLY+the+code+that+you%3Cbr%3Ewish+to+test.+Then+run+this+macro+and+give+the+number+of+times+%281%2C10%2C100+or+1000%29+you+wish%3Cbr%3Eto+test.+The+higer+the+number+the+more+accurate+the+result%2C+but+obviously+it+will+take+more%3Cbr%3Etime+to+run%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fbenchmark%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EBenchmark%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DiagnoseMaps=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMap+Error+Checks.+This+function+checks+ALL+maps+and+ALL+%28lib%29tokens+for+potential+issues.%3Cbr%3EIt+checks+whether+token+names+contain+non-alphanumerical+characters+and+checks+the+libs+for+the%3Cbr%3Esame+and+owner+ship+and+visibility.+Any+errors+are+rendered+in+a+frame+with+hyperlinks+that+lead%3Cbr%3Eyou+to+the+token.+%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fdiagnose%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EDiagnose+Maps%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CleanTokNames=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThere+are+certain+characters+e.g.+%40+%23+%26+that%2C+when+used+in+a+token+name%2C%3Cbr%3Ecan+potentially+break+a+macro+IF+that+macro+uses+that+token+name.+An+obvious%3Cbr%3Eexample+is+getTokenNames%28%2C%29+which+returns+a+%2C+seperated+list.+Should+one+of%3Cbr%3Ethe+tokens+in+that+list+be+called+e.g.+%3Ci%3EFire+Elemental%2C+Giant%3C%2Fi%3E+than+the+list%3Cbr%3Ewould+thus+consist+out+of+%3Ci%3EFire+Elemental%3C%2Fi%3E+and+%3Ci%3EGiant%3C%2Fi%3E.+%3Cbr%3E%3Cbr%3EThis+macro+tracks+these+tokens+down+and+reports+them+in+the+chat.+You+then+have%3Cbr%3Ethe+choice+to+either+fix+them+automatically+or+not.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcleanTokNames%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EClean+Tok+Names%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Door=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+door+%28that+has+been+initialized%29+and+click+this+button+to+open+or+close+it%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleDoor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%27%3EToggle+Door%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Doors=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+pop-up+with+all+the+initialized+doors%3Cbr%3Eon+the+OBJECT+LAYER.+Here+you+can+select+which+to+open%2Fclose%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleDoors%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Door%3Cb%3Es%3C%2Fb%3E%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Lock=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3ABlue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+toggle+the+Lock+State+of+a+door.+Select+the+door+first.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Lock%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EDisperses+a+crowd+created+by+the+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3Cbr%3EMake+sure+the+antagonist+is+on+the+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveCrowdP=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Chtml%3EDisperses+a+crowd+created+by+the+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3Cbr%3E+Make+sure+the+antagonist+is+on+the+map.%3Cbr%3E+%3Cbr%3E+This+macro+uses+more+intelligence+however+and+is+more+realistic%3Cbr%3E+but+MUCH+slower+%28roughly+1+second+per+10+tokens%29%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveCrowdPlus%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Crowd%2B%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3ABlue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+will+animate+the+movement+of+the+selected+token.+An+options+panel+will+be+shown+first.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanimateMove%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnimateText=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+open+an+input+screen+where+you+can+set-up+animated+text.%3Cbr%3EThis+text+will+be+send+and+animated+within+a+frame+to+every+attached%3Cbr%3Eclient+pc.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanimateTextInput%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnimate+Text%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ExecuteEvent=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+generates+a+list+of+macros+per+group+from+the+lib%3AEvent+token.%3Cbr%3EYou+can+select+one+or+more+macros+which+then+will+be+executed%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecuteEvent%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExecute+Event%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ExecAssignpad=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBefore+you+can+use+this+macro+you+first+need+to+assign+token+to+the+special+Assignpads.%3Cbr%3EOnce+that+is+done%2C+you+can+run+this+macro+and+pick+the+Assignpads+to+be+executed.%3Cbr%3EOn+execution+the+linked+token+will+be+moved+to+its+assigned+pad.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecAssignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExec+Assignpad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DiceBox=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EOpens+a+form+with+dices+where+you+can+set+a+group+of+dice+to+roll%3Cbr%3EThe+workings+of+the+Dice+box+are+pretty+obvious.+What+might+not+be%3Cbr%3Eobvious+is+that+it+supports+10+different+dice+boxes.+You+can+click+the%3Cbr%3Emacro+10+times+and+set+each+frame+individually.%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FLaunch+Dice+Box%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDice+Box%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SwitchMap=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aorange%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+Forces+ALL+clients+to+chosen+map+AND+centres+view+on+the+token+%3Ci%3EcentreOnMePad%3C%2Fi%3E+%3Cbr%3E%3Cbr%3EIf+you+select+tokens+before+you+use+this+macro%2C+then+the+option+will+be+added+to+move%3Cbr%3Ethe+selected+tokens+to+the+new+map+as+well.+These+tokens+will+be+placed+near+the+%3Ci%3EcentreOnMePad%3C%2Fi%3E%3Cbr%3E%3Cbr%3EIf+there+is+no+%3Ci%3EcentreOnMePad%3C%2Fi%3E+then+the+coords+%28X%2CY%29+0%2C0+will+be+used+instead.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FswitchMap%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%27%3ESwitch+Map%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UseDisguise=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+-+Clicking+the+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+will+add+the+current+token+image+to+your+disguise+list.%3Cbr%3E+-+Changing+your+image+and+clicking+the+button+again+will+add+a+new+image+to+list.%3Cbr%3E+OR%3Cbr%3E+-+Selecting+%3Ci%3Eimage%3Atokens%3C%2Fi%3E+together+with+the+token+will+add+those+images+to+the+disguise%3Cbr%3Elist+of+the+token%3Cbr%3E%3Cbr%3E-+A+list+will+be+shown+for+all+the+possible+images+you+have+loaded.%3Cbr%3E+-+You+have+the+option+to+Change+or+Delete+an+image+from+your+list.%3Cbr%3E+-+On+the+lib+file%2C+if+you+click+%3Ci%3EautoDisguiseButton%3C%2Fi%3E+a+text+box+will+appear+with+a+token%3Cbr%3Eproperty+you+can+add+to+your+Campaign+Property+token+properties+to+automatically+add+the%3Cbr%3E+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+to+tokens.%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FuseDisguise%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUse+Disguise%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowHandout=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+Pops+up+a+dialog+showing+the+handout+of+the+selected+token+on+all+selected+clients.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowHandout%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EShow+Handout%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; WhisperFrame=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+opens+a+frame+where+you+can+send+formatted+text+to+specific+players.%3Cbr%3E+%3Cu%3EAlternatively%3C%2Fu%3E+you+can+send+a+message+to+%3Cu%3Eall%3C%2Fu%3E+players+as+if+you%3Cbr%3E+impersonate+the+selected+token%2C+without+actually+needing+to+impersonate+it.%3Cbr%3E+%3Cbr%3E+%3Cb%3ENotes%3C%2Fb%3E+%3Cbr%3E+-+you+must+either+be+the+gm+or+own+the+selected+token+to+do+this.%3Cbr%3E+-+the+impersonation+ONLY+works+with+%3Ci%3Eall+players%3C%2Fi%3E+check+box+%3Cbr%3E+++selected.+%28So+not+when+some+or+all+the+individual+player+checkboxes+are%3Cbr%3E+++selected%21%21%29.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FwhisperFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EWhisper+Frame%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MessageMngr=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+allows+you+to+store+prepared+messages+and+manage+these.%3Cbr%3EFor+GMs+these+will+be+store+on+lib%3AEventMacros%2C+for+players+these+will+%3Cbr%3Ebe+stored+on+the+token+that+they+own+%28and+is+selected%29.+%3Cbr%3ETo+add+a+picture+to+a+message%3A+%3Cbr%3E-+create+the+message+%28and+save+it%29.+%3Cbr%3E-+select+the+token+that+contains+the+image+%28can+be+token%2Cportrait+or+handout%29.%3Cbr%3E-+click+add+selected+image+for+that+message.+The+rest+should+be+simple.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fnotes%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMessage+Mngr%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; GroupMove=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+group+of+tokens+to+group+them+for+group+move.%3Cbr%3ENote+that+any+previous+set+groups+for+any+of+the+tokens+will+be%3Cbr%3Ecleared+if+you+run+this+macro.%3Cbr%3EAlso+note+that+this+macro+makes+use+of+the+label+field+of+the%3Cbr%3Etoken+and+any+current+value+will+get+overwritten%21%21.+Changing%3Cbr%3Ethis+value+after+a+group+has+been+set+will+de-activate+group-%3Cbr%3Emovement+when+you+move+THAT+token.+The+token+will+still+be%3Cbr%3Epart+of+the+group+and+will+be+moved+if+another+token+of+the%3Cbr%3Egroup+is+moved%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EGroup+%28Move%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UngroupMove=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+one+token+from+a+%3Ci%3Emove%3C%2Fi%3E+group+and+use+this+macro+to+clear+the+ENTIRE+group%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUngroup+%28Move%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Formations=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EOpen+the+group+move+macro+frame.%3Cbr%3ENote+that+it+can+appear+behind+this+panel.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMacroButtonsGroupMove%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFormations%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SummonTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+summon+any+token+from+the+BASE+map+that+is+on+the+TOKEN+layer.%3Cbr%3EIf+you+select+a+token+first+before+you+click+this+button+then+the+to-summon-token%28s%29+will+be%3Cbr%3Eplaced+on+the+selected+token.+Else+you+can+enter+x+and+y+coordinates+of+where+you+want+to+summon%3Cbr%3Ethe+token.+The+types+of+tokens+listed+in+the+Dialog+can+be+specified+through+the+settings.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsummonToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESummon+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ActivateGroup=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+opens+a+%3Ci%3Egroup+select%3C%2Fi%3E+frame+which+is+required+for+the+%3Ci%3ESelect+Group%3C%2Fi%3E+to+function.%3Cbr%3EWhen+this+panel+is+closed+you+can+still+group+and+ungroup%2C+but+the+%3Ci%3Eauto+select%3C%2Fi%3E+will+only%3Cbr%3Ework+when+this+frame+is+active.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FopenGroupFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EActivate+Group%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; GroupSelect=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+creates+a+%3Ci%3Eselect+group%3C%2Fi%3E+of+all+currently+selected+tokens.%3Cbr%3EAfter+a+group+is+set+%28and+the+group+select+frame+is+active%29+when+you%3Cbr%3Eselect+one+token+of+the+group%2C+all+the+other+tokens+of+the+group+will+be%3Cbr%3Eautomatically+selected+as+well.+This+is+particularly+usefull+when+drawing%3Cbr%3Emaps+and+you+want+to+group+a+set+of+tokens+into+one+object.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetSelectGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EGroup+%28Select%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UngroupSelect=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+ungroups+a+%3Ci%3ESelect+Group%3C%2Fi%3E.+You+only+need+to+select+one+token+of+the+group+to+ungroup+the+entire+group+%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearSelectGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUngroup+%28Select%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; VBLGrenade=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+one+or+more+tokens%2C+run+macro%2C+set+radius+%28in+grid+cells%29+and+ALL+VBL+in+that+radius+around+the+selected+tokens+will+be+cleared.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FVBLGrenade%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EVBL+Grenade%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; LockMovement=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+this+is+turned+ON%2C+no+PLAYER+can+move+a+token%2C+only+the+GM+can.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ared%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmovementLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELock+Movement%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; LockToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+this+is+turned+ON%2C+no+one+%28gm+included%29+can+move+the+selected+token%28s%29.%3Cbr%3EFor+this+to+work+the+toggle+in+the+settings%3A+%3Ci%3ELock+Movement+for+Locked+Tokens%3C%2Fi%3E+needs+to+be+turned+on%21%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ared%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtokenLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELock+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveEventOn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+disable%2Fenable+the+onTokenMoveEvent+macros.%3Cbr%3EThe+onTokenMoveEvent+can+be+demanding+for+every+move%3Cbr%3Ea+token+makes%2C+especially+when+creating+a+map+this+can+be%3Cbr%3Eannoying.+By+clicking+on+this+button+you+can+temporarily%3Cbr%3Edisable+the+event.+Clicking+it+again+will+turn+it+on+again.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleOnTokenMove%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EMove+Event+is%3Cbr%3ETurned+ON%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveEventOff=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+disable%2Fenable+the+onTokenMoveEvent+macros.%3Cbr%3EThe+onTokenMoveEvent+can+be+demanding+for+every+move%3Cbr%3Ea+token+makes%2C+especially+when+creating+a+map+this+can+be%3Cbr%3Eannoying.+By+clicking+on+this+button+you+can+temporarily%3Cbr%3Edisable+the+event.+Clicking+it+again+will+turn+it+on+again.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Adark+gray%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleOnTokenMove%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EMove+Event+is%3Cbr%3Eturned+OFF+%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FullScreenModeOn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+toggled%2C+the+frames+will+be+changed+into+dialogs%2C%3Cbr%3E+which+ARE+allowed+in+full+screen.+This+way+when+you%3Cbr%3E+toggle+this+button+you+can+have+acces+to+chat+and+macros%3Cbr%3E+in+the+form+of+dialogs.%3Cbr%3E+In+addition%2C+when+you+have+turned+on+the+%3Ci%3Eredefine+broadcast%3C%2Fi%3E%3Cbr%3E+setting+in+the+settings%2C+then+when+using+the+broadcast%28%29+function%3Cbr%3E+a+dialog+will+pop+up+showing+the+last+message+broadcasted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleFullScreen%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFull+Screen%3Cbr%3EMode+is+ON%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FullScreenModeOff=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+toggled%2C+the+frames+will+be+changed+into+dialogs%2C%3Cbr%3E+which+ARE+allowed+in+full+screen.+This+way+when+you%3Cbr%3E+toggle+this+button+you+can+have+acces+to+chat+and+macros%3Cbr%3E+in+the+form+of+dialogs.%3Cbr%3E+In+addition%2C+when+you+have+turned+on+the+%3Ci%3Eredefine+broadcast%3C%2Fi%3E%3Cbr%3E+setting+in+the+settings%2C+then+when+using+the+broadcast%28%29+function%3Cbr%3E+a+dialog+will+pop+up+showing+the+last+message+broadcasted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Adark+gray%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleFullScreen%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFull+Screen%3Cgr%3EMode+is+OFF%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowDescription=%3Ctd+width%3D%2750%25%27%3E%0A%09%09%3Ctable+bgcolor%3D%27gray%27%3E%0A%09%09%09%3Ctd+align%3D%27center%27+style%3D%22background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+%22+%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+Button%3C%2Fb%3E%3Cbr%3ESelect+a+%3Ci%3ERoom+Description%3C%2Fi%3E+token+and+hit+this+button+%3Cbr%3E%28See+Manual+for+more+info%29%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%3Ca+href%3D%27macro%3A%2F%2FshowDescription%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%3Cimg+src%3D%27asset%3A%2F%2F3fcd87c798fedd3ade1bd9ed272550e0%27+border%3D%270%27+height%3D%2730%27+width%3D%2730%27+alt%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+Button%3C%2Fb%3E%3Cbr%3ESelect+a+%3Ci%3ERoom+Description%3C%2Fi%3E+token+and+hit+this+button+%3Cbr%3E%28See+Manual+for+more+info%29%3C%2Fhtml%3E%27%2F%3E%3C%2Fa%3E%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; roomDescrHelp=%3Ctd+width%3D%2750%25%27%3E%0A%09%09%3Ctable+bgcolor%3D%27gray%27%3E%0A%09%09%09%3Ctd+align%3D%27center%27+style%3D%22background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+%22+%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+HELP%3C%2Fb%3E%3Cbr%3EA+reference+overview+of+the+tags+for+Nildiks+Room+Descriptor%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%3Ca+href%3D%27macro%3A%2F%2FroomDescrHelp%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%3Cimg+src%3D%27asset%3A%2F%2F1badb8f7d4e390d6c9c058f49c90c744%27+border%3D%270%27+height%3D%2730%27+width%3D%2730%27+alt%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+HELP%3C%2Fb%3E%3Cbr%3EA+reference+overview+of+the+tags+for+Nildiks+Room+Descriptor%3Cbr%3E%3C%2Fhtml%3E%27%2F%3E%3C%2Fa%3E%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; StartInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMakes+a+token+invisible%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FStart+Invisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EStart+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; EndInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMakes+a+token+visible%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FendInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EEnd+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SeeInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EToken+can+see+invisible+tokens+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FseeInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESee+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SawInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+seeing+invisible+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsawInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESaw+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PurgeInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ENegates+invisibility+for+tokens+as+longs+as+they+are+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpurgeInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPurge+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PurgedInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+negating+invisibility%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpurgedInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPurged+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnulInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EPermanently+destroys+invisibility+on+tokens+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanulInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnul+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnulledInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+destroying+invisibility%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanulledInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnulled+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; resetRanges=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23006000%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EResets+invisibility+related+ranges+on+selected+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FresetRanges%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EReset+Ranges%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; changeElevation=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23006000%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESet+the+elevation+for+the+selected+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchangeElevation%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChange+Elevation%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; setAnimateView=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EUse+lastpath+of+selected+token+to+run+a+screen+animation%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetAnimateView%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Animate+View%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; runAnimateView=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ELink+the+view+animation+of+selected+tokens+and+store+it+on+one+token%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FrunAnimateView%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERun+Animate+View%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; linkViewAnim=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ERun+view+animation+created+for+selected+token%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FlinkViewAnimations%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELink+View+Animations%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; embarkation=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+move+%28N%29PC+tokens+inside+a+vehicle.%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fembarkation%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EEmbarkation%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; toggleEmbark=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EIF+PCs+are+embarked+on+a+vehicle+you+can+quickly+%28dis%29embark+them%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleEmbark%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Embark%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E",
      "bot.fg.Other":       [
                {
          "Group_Name": "Other",
          "Function": "Force Selection",
          "Type": "Other",
          "Dependencies": "None",
          "Macro_Group": "Door Button",
          "Description": "To use with 'Always on Top' application. With this feature you can force a client slave to have the same button selected as you have on the master. Read the manual for more info. Usefull for those that like to use Full Screen Mode but still have a chat window and macros available. (and working)"
        },
                {
          "Group_Name": "Other",
          "Function": "Load Map and Coordinates on Start Up",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "This feature can be found in the settings, where you can set the map to load on start-up and the coordinates (or token name) on that map to go to."
        },
                {
          "Group_Name": "Other",
          "Function": "AssignedPads Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Assigned Pads",
          "Description": "Teleport pads that are linked to a specific token, can be used for a mass invasion!"
        },
                {
          "Group_Name": "Other",
          "Function": "AssignedPads Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Assigned Pads",
          "Description": "Same as the macro menu but now on the fly."
        }
      ],
      "bot.fg.Tables":       [
                {
          "Group_Name": "BoT Tables",
          "Function": "Create Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "Show Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "Delete Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros"
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_table()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "With this function you can retrieve a value from the stored BoT Tables. Usage: bot_table('name of table', optional: 'column', 'row', ). Both 'column' and 'row' can either be an index number or the name of the row/column. Leaving them empty will result in a random choice."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_listBoTtables()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns a list with the stored BoT Tables."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_listMTtables()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns a list with the stored Maptool Tables."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_getRows('table name')",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns the row names of the given BoT table"
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_getColumns('table name')",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns the column names of the given BoT table"
        }
      ],
      "bot.fg.Transportation":       [
                {
          "Group_Name": "Transportation",
          "Function": "On Map Teleport pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadStart, PadEnd) every teleport consists out of a starting pad and ending pad (paired pads), if you drop a token on one it will end on the other. You can resize or place them anyway you want, as long as its on the same map."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Between Map Teleport pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Interpad) Any Interpad is automatically paired with the Interpad with the SAME identifier (e.g. '1') on a DIFFERENT map. Again, size and place are completely free, as long as its on two different maps."
        },
                {
          "Group_Name": "Transportation",
          "Function": "One way teleports",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadJump, PadDrop, InterJump and InterDrop) Moving onto a 'Jump' token will transport you its paired 'drop' token. And NOT the other way round. The 'Inter' version can be used for transport between maps."
        },
                {
          "Group_Name": "Transportation",
          "Function": "One Way Teleport Border pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder) As with the one way teleports The big difference with the 'normal one way teleports' is that the 'border teleport' tokens will teleport a token that moves onto OR OVER the special pad. I've added 8 new tokens to the zip file (4 horizontal and 4 vertical as you must NOT rotate the tokens, because the footprint of the token does NOT rotate). <br>The inter versions can ideally be used for e.g. large maps where you can build seperate sections on seperate MT maps. This will keep the memory use per map low and will give an easy transfer between to sections. <br>The map versions can be used for creating e.g. a closed loop map where the edges of the map are connected. Moving over the edge will automatically transport you to the opposite edge."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Two Way Teleport Border pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(InterPadBorder, PadStartBorder, PadEndBorder) Same as the above one way, but now also two ways teleports."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Mapped Teleports",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(MappedPad) These pads work similar to the teleport pads, although of these there is only one type of pad and not two like the start and end pad with the 'normal' teleports. When initializing them you'll get a pop-up per map where they exist and here you can set the destination pad. The 'destination' must be a number, so you can if you like also put in forumulas or dice rolls, as long as the result is a number (and as long as a destination pad with that number actually exist)."
        }
      ],
      "bot.fg.UtilityGeneral":       [
                {
          "Group_Name": "Utility macros",
          "Function": "Set Light",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro whith which you can easily set lights sources on tokens"
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Rumbles Dice Box",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Rumbles Dice Box",
          "Description": "A frame where you can set a pool of dice that you can roll in one click. I have used Rumbles code and layout as a basis and rewrote most of it. Noteably I've added 'options' so you can fully customize the frame."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Show Token Handout",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that forces a pop-up on ALL clients showing a token handout (gm only)."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Switch Map",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A macro that forces ALL clients and selected tokens to the chosen map AND forces all views to the centreOnMePad (if its on the map)(gm only)."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Seek token",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A utility that scans ALL maps and ALL tokens returning a list of all tokens that match the search string. Updated with a wide variety of options, biggest change is showing the results as macro links which allows you to either Copy, Move or Select the token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "bot_debugInfo()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A macro that shows all kinds of debug info (primarily for tracking variable values), with several optional settings."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Aliasmasks Disguise macro",
          "Type": "Menu Macro",
          "Dependencies": "Table: Polymorph",
          "Macro_Group": "Aliasmak Usedisguise",
          "Description": "A macro that allows you to add extra token images to a token, so you can e.g. 'polymorph' during gameplay into something else."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "LMarkus Whisper Frame",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "LMarkus Whispers",
          "Description": "A frame where you can whisper (with some text formats) to one or more players without needing to use the /w option. It also includes an impersonation feature so you can speak as another token, without needing to actually impersonate it."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Rumbles Delete Macros utility",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Rumbles Delete Macros utility",
          "Description": "A macro that allows you to copy/paste/delete macros from/on a selected token onto another token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Plothos Message Manager uttility",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Plothos Message Manager",
          "Description": "A macro that allows you to create and store messages for players."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Event Buttons",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Event Macros",
          "Description": "A macro that links an lib:EventMacro macro to a token. When the token is selected, the macro is activated. Usefull for e.g. switching maps."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Benchmark",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro specially developed for macro developers. It can be used to discern the execution time for a certain macro."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Map Diagnosis",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that checks ALL maps and ALL (lib)tokens for potential issues. It checks whether token names contain non-alphanumerical characters and checks the libs for the same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead you to the token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Token Name Cleaner",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that detects and cleans up characters in token names that are incompatible with the macro system in maptool."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Bubblobills Input String Builder",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Bubblobills Input String Builder",
          "Description": "A macro with which you can easily create the code for a complex input string."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Nildiks Fancy Frames",
          "Type": "Menu Macro",
          "Dependencies": "Table: frames",
          "Macro_Group": "Nildiks Frames",
          "Description": "Two macro functions that allow you to show fancy frames around the 'frames' you usually show to the players."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Nildiks Room Description Token",
          "Type": "Menu Macro",
          "Dependencies": "Table: encounters, tbl_Image",
          "Macro_Group": "Nildiks Room Description",
          "Description": "The Room Description token allows you to easily access a description of the area where the players are AND to easily share texts (e.g. pieces or parchments, treasure etc) and images (of e.g. encounters) with them in one overview"
        }
      ],
      "bot.fg.UtilityMove":       [
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group (Select)",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Group Move; Group Select",
          "Description": "Create groups of tokens. When you select one token of the group, all the tokens are automatically selected."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Group Move; Group Select",
          "Description": "You can combine tokens into one group. When you move ONE token of that group then the whole group moves accordingly."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Rotation",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Group Move; Group Select",
          "Description": "When the group is defined you can use the CW or CCW rotation buttons to rotate the group. For snapped tokens the increment is 90, for unsnapped its 45 and its also possible to select a token from the group and set its facing and then click either CW or CCW, after which the group will be rotated to that direction (unsnapped only)."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Formations",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Group Move; Group Select",
          "Description": "For defined groups (or a group of selected tokens) you can set different formation like, square, wedge, line, echelon, spread and compact."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Centre on token",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "A toggle in the settings where you can turn on continuous centre on token. This will force a centre on map for every token moved. (only works for single token move)."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Restore FoW (Fog of War)",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "When a player moves a token all the FoW will be restored and only the PC visible areas will be cleared. This function has the extra advantage that the VBL lag bug (game gets very laggy after a while when there is a lot of VBL on the map) is ommitted."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "VBL (Vision Blocking Layer) move check",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This function is created by Aliasmask. It can also be found on his lib:Players. However to make both libs compatible I've added it to the BoT so it can be turned off on lib:Players. This function checks EVERY step of the just-moved-token and checks whether it can see into gridcell its moving into. If not then the movement is halted. This function too has the extra advantage that the VBL lag bug is ommitted."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Path Tracking",
          "Type": "Setting",
          "Dependencies": "State: pathFeet; Token: red feet, blue feet",
          "Macro_Group": "OnTokenMove",
          "Description": "Added toggle to the settings where you can turn on path tracking. This will show small feet in the grid cells where the last token moved. Red for NPCs and blue for PCs."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Lock Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This is a toggle on the macro panel that will lock down the movement of ALL tokens. Only the gm can move the tokens now. To use simply hit the macro button and hit it again to allow movement again."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Lock Token",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "Similar to lock movement, only this works on the individual token. It prevents the token from being moved. Both by player and gm! To use: select one or more token. Click the 'lock token' macro. There is a general toggle in the settings to turn this feature on and off."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Invisibility Purge",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This functions can be turned of or on the in the settings-->toggle tab. It uses <i>visible to owner only function<\/i>. When a token is invisible this setting is (automatically) turned on. Any token that has <i>Purge invisibility<\/i> turned on will be added as owner to the invisible when the invisible token is in range. See manual for full instructions.<\/i>"
        }
      ],
      "bot.fg.VBL":       [
                {
          "Group_Name": "VBL macros",
          "Function": "VBL Stamps on tokens",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "With this macro you can add a VBL layer upon a token that 'moves' with the token. (Its not really ON the token, but erased and redrawn as you move the token). Possible VBL are Square, Rectangle, Line, Regular Polygon. With a bunch of extra options (like offset, scale, fill, etc.)."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Drawable Polygon Stamps",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "In addition to the 'normal' stamps, you can now also save ANY VBL currently over the token as a stamp. So you can draw VBL over a token as you normally draw VBL and the store that VBL as a stamp onto the token. This is particularly usefull for dungeon tiles where you can store the VBL data onto the tile and then copy paste the tile over the map."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Mass VBL",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function will draw VBL on ALL tokens that match a (partial) search string. Its mainly intended for roofs and canopy but options (selection, all, layers) have been added to use it for other purposes. This macro also contains 2 different scaling techniques to apply the VBL onto the token. Finally you can also store the ENTIRE VBL structure and you can use Toggle VBL to turn that on or off"
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Toggle VBL",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function corresponds with Mass VBL. In Mass VBL you can store all the added VBL and with this function you can turn it on or off instantly."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "VBL Grenade",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function will erase ALL VBL in a given radius (in grid cells) around one or more selected tokens."
        }
      ],
      "bot.fg.diagArrays": "diagStateArray=[\"isButton\",\"Locked\",\"pathFeet\",\"Special Area\",\"Prone\",\"editFieldMarker\"] ; diagTokenArray=[\"DoorLeverToken\",\"blue feet\",\"red feet\",\"Area Marker\",\"GridCoordMarker\",\"VPCU\"] ; diagTableArray=[\"tbl_Image\",\"Polymorph\",\"encounters\",\"frames\"]",
      "bot.fg.diagLists": "diagStateList=the switch buttons to operate doors, doors so the gm can lock them (doors will NOT work without this state), path tracking (blue and red feet), creating special areas (like movement limitation), used for the Crowd utility, used for Map Editor Utility ; diagTokenList=the switch buttons to operate doors, path tracking (the PC track), path tracking (the NPC track), creating special areas (like movement limitation), the transparent field tokens required for the Map Editor, a token required as placeholder when using the Embarkation macros (vehicles) ; diagTableList=Roofs - Formations - Dicebox - Room Descriptions, Aliasmask Polymorph (table is only necessary if you want to access images from that table), Nildiks Room Description  (table is only necessary if you want to access images from that table), Nildiks Fancy Frames and Room Description",
      "bot.fg.menuMacroList": "utilAnimationList=Door, Doors, Lock, ClearSound, MoveCrowd, MoveCrowdP, MoveToken, AnimateText, runAnimateView, ResetPit, UnShowAreaUtil, ExecuteEvent, ExecAssignpad ; utilUtilList=DiceBox, SwitchMap, SeekToken, SetLightSource, UseDisguise, ToggleSpecial, ShowHandout, WhisperFrame, MessageMngr, SetDrawOrder, GroupMove, UngroupMove, Formations, ActivateGroup, GroupSelect, UngroupSelect, toggleEmbark, SummonTokens, ToggleVBL, VBLGrenade, LockMovement, LockToken, moveEventToggle, ShowDescription ; utilInvisList=StartInvis, EndInvis, SeeInvis, SawInvis, PurgeInvis, PurgedInvis, AnulInvis, AnulledInvis, resetRanges, changeElevation ; basicsList=Settings, BoTFeatures, InitializePads, AltInitPads, Manual ; animationList=SetDoor, SetRoof, setAnimateView, linkViewAnim, ActivateSwitches ; soundList=ClearSound, ReplaceSoundURL, SetSound ; scatterList=BuildForest, ChooseTrunks, CreateCrowd, ChooseCrowd, ScatterTokens, MassVBL ; eventList=DrawArea, SetEventPad, FillArea, ResetPit, DefineArea, SetEventButton, AssignArea, UnShowArea ; assignList=AssignTokens, Execute ; tablesList=CreateTable, ShowTable, DeleteTable, CreateMTTable ; mapList=MapEditor, QuitMapEditor, MovetoHidden, MovetoToken ; utilsList=SeekToken, SetLightSource, SetReference, Remove20, SetDrawOrder, RenumberTokens, ToggleSpecial, SetTokenSize, CopyDelMacros, PasteMacros, UndoDelMacros, FindDuplicates, embarkation, PadExplorer, AutoDisguiseBttn, SetVBLStamp, MassVBL, ToggleVBL, Deleteprops, Benchmark, DiagnoseMaps, CleanTokNames, roomDescrHelp",
      "gmNames": "",
      "libversion": 48,
      "onTokenMoveEvent": 1,
      "w42.bot.soundSettings": "uri=http://wolph42.ddns.net:4242/sounds/Bot_Inn/musician.mp3 ; startVolume=0.1 ; distStart=60 ; maxVolume=1 ; distMaxVolume=15"
    },
    "macros":     [
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "1",
        "index": 1,
        "label": "onCampaignLoad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H:'\n<!-- ---------------------------------------------------------------------------------------------------------------------------------- -->\n<!-- ----------------------------------------------------------------------------- ----ONCAMPAIGNLOAD LIB:ONTOKENMOVE ----------------- -->\n<!-- -------------------------------------------------a--------------------------------------------------------------------------------- -->']\n\n[h: thisLib\t\t= getMacroLocation()]\n\n[h:'<!-- initialize new settings -->']\n[h,if(getLibProperty('maxGroupSelect','lib:EventMacros') == \"\"):\tsetLibProperty(\"maxGroupSelect\", 500,\"lib:EventMacros\")]\n[h,if(getLibProperty('maxOrderSelect','lib:EventMacros') == \"\"):\tsetLibProperty(\"maxOrderSelect\", 300,\"lib:EventMacros\")]\n[h,if(getLibProperty('linkedMappedPads','lib:EventMacros') == \"\"):\tsetLibProperty(\"linkedMappedPads\", '{}',\"lib:EventMacros\")]\n[h,if(getLibProperty('libCoordSize','lib:EventMacros') == \"\"):\t\tsetLibProperty(\"libCoordSize\", 30,\"lib:EventMacros\")]\n[h,if(getLibProperty('padNameList','lib:EventMacros') == \"\"):\t\tsetLibProperty(\"padNameList\", \"Ward, Linked, EventPad , ShadowPad, PadStart , PadEnd , InterPad , PadStartBorder , PadEndBorder , InterPadBorder , PadJump , PadDrop , InterJump , InterDrop , PadJumpBorder , PadDropBorder , InterJumpBorder , InterDropBorder , MappedPad , Roof, Foliage , Canopy\",\"lib:EventMacros\")]\n\n[h:'<!-- defineFunction(function, macro, ignoreOutput, newScope) -->']\n[h:prefix = \"bot_\"]\n\n[h:'<!-- 1. macro frame  macros -->']\n\n[h:defineFunction(prefix+\"followMe\", \"followMe@\"+thisLib) ]\n\n[h:defineFunction(prefix+\"MacroButtonsOTMSetup\", \"MacroButtonsOTMSetup@\"+thisLib) ]\n[h:defineFunction(prefix+\"MacroButtonsOTMUtils\", \"MacroButtonsOTMUtils@\"+thisLib) ]\n[h:defineFunction(prefix+\"createMacroButtonsOTMSetup\", \"createMacroButtonsOTMSetup@\"+thisLib ) ]\n[h:defineFunction(prefix+\"createMacroButtonsOTMUtils\", \"createMacroButtonsOTMUtils@\"+thisLib ) ]\n[h:defineFunction(prefix+\"MacroButtonsGroupMove\", \"MacroButtonsGroupMove@\"+thisLib) ]\n[h:defineFunction(prefix+\"createMacroButtonsGroupMove\", \"createMacroButtonsGroupMove@\"+thisLib) ]\n[h:defineFunction(prefix+\"HTMLMacroButton\", \"HTMLMacroButton@\"+thisLib) ]\n[h:defineFunction(prefix+\"HTMLMacroImageButton\", \"HTMLMacroImageButton@\"+thisLib) ]\n[h:defineFunction(prefix+\"updateVirtualMenu\", \"updateVirtualMenu@\"+thisLib) ]\n\n[h:'<!-- 2. onTokenMove macros-->']\n[h:defineFunction(prefix+\"initializePads\", \"initializePads@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"initializeMap\", \"initializeMap@\"+thisLib, 0, 0) ]\n[h:defineFunction(prefix+\"checkInterPads\", \"checkInterPads@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"altInitMap\", \"altInitMap@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"path2pads\", \"path2pads@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"chkMoveStop\", \"chkMoveStop@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"determineTokSize\", \"determineTokSize@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"moveVBLToken\", \"moveVBLToken@\"+thisLib, 1, 0 ) ]\n\n[h:'<!--3. Pad Macros-->']\n[h:defineFunction(prefix+\"Canopy\", \"Canopy@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadStart\", \"PadStart@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadEnd\", \"PadEnd@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadStartBorder\", \"PadStartBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadEndBorder\", \"PadEndBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadJump\", \"PadJump@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadJumpBorder\", \"PadJumpBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterPad\", \"InterPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterPadBorder\", \"InterPadBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterJump\", \"InterJump@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterJumpBorder\", \"InterJumpBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"MappedPad\", \"MappedPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Ward\", \"Ward@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Roof\", \"Roof@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Foliage\", \"Foliage@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"EventPad\", \"EventPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"EventArea\", \"EventArea@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"ShadowPad\", \"ShadowPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"SoundPad\", \"SoundPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"Linked\", \"Linked@\"+thisLib, 1, 0 ) ]\n\n[h:'<!-- 4. shadowPads-->']\n[h:defineFunction(prefix+\"doShadowPad\", \"doShadowPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"setReference\", \"setReference@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"shadowCoords\", \"shadowCoords@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"removeShadow\", \"removeShadow@\"+thisLib, 1, 0 ) ]\n\n[h:'<!-- 4a. soundPads-->']\n[h:defineFunction(prefix+\"chkSounds\", \"chkSounds@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"setupSound\", \"setupSound@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"playPadSound\", \"playPadSound@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"isOnDrawing\", \"isOnDrawing@\"+thisLib, 1, 1 ) ]\n\n[h:'<!-- 5. Teleport and Roof-->']\n[h:defineFunction(prefix+\"roofSwap\", \"roofSwap@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"teleport\", \"teleport@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"mapTeleport\", \"mapTeleport@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"setRoof\", \"setRoof@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"setVBLRoof\", \"setVBLRoof@\"+thisLib, 1, 1 ) ]\n\n[h:'<!--  6a. Door Button macros -->']\n[h:defineFunction(prefix+\"operateLever\", \"operateLever@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"toggleLock\", \"toggleLock@\"+thisLib, 1, 1 ) ]\n\n[h:'<!-- 6b. Door Animation -->']\n[h:defineFunction(prefix+\"setDoor\", \"setDoor@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"toggleDoor\", \"toggleDoor@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toggleDoors\", \"toggleDoors@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"isDoorClosed\", \"isDoorClosed@\"+thisLib)] \n[h:'defineFunction(prefix+\"setVBLDoor\", \"setVBLDoor@\"+thisLib,1,0)'] \n\n[h:'<!-- 7a. EVENT AREA  macros-->']\n[h:'<!-- 7b. EVENT macros-->']\n[h:defineFunction(prefix+\"getEventType\", \"getEventType@\"+thisLib, 1,0) ]\n[h:defineFunction(prefix+\"convertTrapPit\", \"convertTrapPit@\"+thisLib, 0,1) ]\n[h:defineFunction(prefix+\"setEventPad\", \"setEventPad@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"setEventButton\", \"setEventButton@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"resetPit\", \"resetPit@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"executeEvent\", \"executeEvent@\"+thisLib, 0, 1 ) ]\n\n[h:'<!-- Group Move macros -->']\n[h:defineFunction(prefix+\"rotateGroup\", \"rotateGroup@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"setGroup\", \"setGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"clearGroup\", \"clearGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"rotateCW\", \"rotateCW@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"rotateCCW\", \"rotateCCW@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"spreadGroup\", \"spreadGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"contractGroup\", \"contractGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationSquare\", \"formationSquare@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationWedge\", \"formationWedge@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationPWedge\", \"formationPWedge@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationLine\", \"formationLine@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationEchelon\", \"formationEchelon@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationStagger\", \"formationStagger@\"+thisLib, 1, 0) ]\n\n[h:'<!-- 9. Assigned Pads -->']\n[h:defineFunction(prefix+\"assignPads\", \"assignPads@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"execAssignPads\", \"execAssignPads@\"+thisLib, 1, 1 ) ]\n\n[h:'<!-- 10. Group Select -->']\n[h:defineFunction(prefix+\"groupFrame\", \"groupFrame@\"+thisLib, 1, 1 ) ]\n\n[h:'<!-- 11. order -->']\n[h:defineFunction(prefix+\"orderFrame\", \"orderFrame@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"reOrderTokens\", \"reOrderTokens@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"orderWarning\", \"orderWarning@\"+thisLib, 1, 1 ) ]\n\n[h:'<!-- 12. geometric functions -->']\n[defineFunction(prefix+\"pointInTriangle\", \"pointInTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointInCone\", \"pointInCone@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"showTriangle\", \"showTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showCone\", \"showCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showLine\", \"showLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showSquare\", \"showSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showCircle\", \"showCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"getTriangleCoords\", \"getTriangleCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getConeCoords\", \"getConeCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getLineCoords\", \"getLineCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getSquareCoords\", \"getSquareCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getCircleCoords\", \"getCircleCoords@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"pointOnTriangle\", \"pointOnTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnCone\", \"pointOnCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnLine\", \"pointOnLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnSquare\", \"pointOnSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnCircle\", \"pointOnCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"selectOnTriangle\", \"selectOnTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnCone\", \"selectOnCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnLine\", \"selectOnLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnSquare\", \"selectOnSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnCircle\", \"selectOnCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"getNeighbourXY\", \"getNeighbourXY@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"isClockWise\", \"isClockWise@\"+thisLib, 1, 1)]\n\n[h:'<!-- 13. Tables  -->']\n[defineFunction(prefix+\"createTable\", \"createTable@\"+thisLib,1,1)]\n\n[defineFunction(prefix+\"getRows\", \"getRows@\"+thisLib,1,1)]\n[defineFunction(prefix+\"getColumns\", \"getColumns@\"+thisLib,1,1)]\n[defineFunction(prefix+\"table\", \"table@\"+thisLib,1,1)]\n[defineFunction(prefix+\"deleteTable\", \"deleteTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"showTable\", \"showTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"setTable\", \"setTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"searchRow\", \"searchRow@\"+thisLib,0,0)]\n\n[defineFunction(prefix+\"listMTTables\", \"listMTTables@\"+thisLib,1,1)]\n[defineFunction(prefix+\"listBoTTables\", \"listBoTTables@\"+thisLib,1,1)]\n\n[defineFunction(\"json.paths\", \"json.paths@\"+thisLib,1,1)]\n[defineFunction(\"json.pget\", \"json.pget@\"+thisLib,1,1)]\n[defineFunction(\"json.pset\", \"json.pset@\"+thisLib,1,1)]\n[defineFunction(\"json.pappend\", \"json.pappend@\"+thisLib,1,1)]\n\n[h:'<!-- 14. scatter -->']\n[h:defineFunction(prefix+\"scatter\", \"scatter@\"+thisLib)]\n[h:defineFunction(prefix+\"buildForest\", \"buildForest@\"+thisLib)]\n[h:defineFunction(prefix+\"chooseTrunks\", \"chooseTrunks@\"+thisLib)]\n[h:defineFunction(prefix+\"getValidTrunks\", \"getValidTrunks@\"+thisLib, 0, 0)]\n[h:defineFunction(prefix+\"createCrowd\", \"createCrowd@\"+thisLib)]\n[h:defineFunction(prefix+\"moveCrowd\", \"moveCrowd@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"moveCrowdPlus\", \"moveCrowdPlus@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"chooseCrowd\", \"chooseCrowd@\"+thisLib)]\n[h:defineFunction(prefix+\"getValidCrowd\", \"getValidCrowd@\"+thisLib, 0, 0)]\n[h:defineFunction(prefix+\"mapEditor\", \"mapEditor@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"fieldEditDialog\", \"fieldEditDialog@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"quitEditor\", \"quitEditor@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"moveToHidden\", \"moveToHidden@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"moveToToken\", \"moveToToken@\"+thisLib, 1, 1)]\n\n[h:'<!-- 15. Summon macros-->']\n[h:defineFunction(prefix+\"embarkation\", \"embarkation@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"toggleEmbark\", \"toggleEmbark@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"summonToken\", \"summonToken@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"getValidTokens\", \"getValidTokens@\"+thisLib, 0, 0) ]\n\n[h:'<!-- 16. animateMove macros-->']\n[h:defineFunction(prefix+\"animateMove\", \"animateMove@\"+thisLib, 1,0 ) ]\n[h:defineFunction(prefix+\"animateText\", \"animateText@\"+thisLib, 1,1 ) ]\n[h:defineFunction(prefix+\"delay\", \"delay@\"+thisLib, 1,1 ) ]\n\n[h:'<!-- 17. MESSAGE macros-->']\n[h:defineFunction(prefix+\"message\", \"message@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"self\", \"self@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nself\", \"nself@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"all\", \"all@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"gm\", \"gm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ngm\", \"ngm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"selfgm\", \"selfgm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nselfgm\", \"nselfgm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ownergm\", \"ownergm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nownergm\", \"nownergm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"owner\", \"owner@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nowner\", \"nowner@\"+thisLib,1,1)]\n\n\n[h:'<!-- 18. Invisibility -->']\n[h:defineFunction(prefix+\"startInvisibility\", \"startInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"endInvisibility\", \"endInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"seeInvisibility\", \"seeInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"sawInvisibility\", \"sawInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"purgeInvisibility\", \"purgeInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"purgedInvisibility\", \"purgedInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"anulInvisibility\", \"anulInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"anulledInvisibility\", \"anulledInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"checkInvisibility\", \"checkInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"resetRanges\", \"resetRanges@\"+thisLib ,1,1) ]\n\n[h:'<!-- 19. Animate View Area -->']\n[h:defineFunction(prefix+\"setAnimateView\", \"setAnimateView@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"runAnimateView\", \"runAnimateView@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"linkViewAnimations\", \"linkViewAnimations@\"+thisLib ,1,1) ]\n\n[h:'<!-- a. Aliasmasks Disguise Macros -->']\n[H: defineFunction(\"bot_useDisguise\",\"useDisguise@\"+thisLib,1,1)]\n\n[h:'<!-- b. bubblobills Delete Utility-->']\n[h:defineFunction(prefix+\"buildInputString\",\"buildInputString@\"+thisLib)]\n\n[h:'<!-- c. W42 & LMarkus Whisper Frame -->']\n[H:defineFunction(prefix+\"outputTo\", \"outputTo@this\" )]\n[H:defineFunction(prefix+\"whisperFrame\", \"whisperFrame@this\" )]\n[H:defineFunction(prefix+\"textToScript\", \"textToScript@this\", 1,1)]\n[h:defineFunction(prefix+\"scrambleText\", \"scrambleText@\"+thisLib,1,1)]\n\n\n[h:'<!-- d. Nildiks Frames -->']\n[h:defineFunction(prefix+\"frameOpen\", \"frameOpen@\"+thisLib,1,1) ]\n[h:defineFunction(prefix+\"frameClose\", \"frameClose@\"+thisLib,1,1) ]\n[h:defineFunction(prefix+\"frameOverview\", \"frameOverview@\"+thisLib,1,1) ]\n\n[h:'<!-- e. Nildiks Room Descriptions -->']\n\n[h:'<!-- f. Plothos Message Manager-->']\n\n[h:'<!-- g. Rumbles Delete Macro Utility-->']\n[h:defineFunction(prefix+\"cpyDelMacros\",\"cpyDelMacros@\"+thisLib)]\n[h:defineFunction(prefix+\"undoDelMacros\",\"undoDelMacros@\"+thisLib)]\n[h:defineFunction(prefix+\"pasteMacros\",\"pasteMacros@\"+thisLib)]\n\n[h:'<!-- h. Rumbles Dice box -->']\n[h:defineFunction(\"dbxOutputTo\",\"dbxOutputTo@\"+thisLib)]\n[h:defineFunction(\"dbxLaunch\", \"Launch Dice Box@\"+thisLib)]\n\n[h:'<!-- Util Documented -->']\n[h:defineFunction(prefix+\"createSplices\", \"createSplices@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getPath\", \"getPath@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getTokensPath\", \"getTokensPath@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"ids2Names\", \"ids2Names@\"+thisLib)]\n[h:defineFunction(prefix+\"ids2NamesArray\", \"ids2NamesArray@\"+thisLib)]\n[h:defineFunction(prefix+\"showHTML\", \"showHTML@\"+thisLib)]\n[h:defineFunction(\"pause\", \"pause@\"+thisLib, 1,0 ) ]\n[h:defineFunction(prefix+\"inStr\", \"inStr@\"+thisLib)] \n[h:defineFunction(prefix+\"getGridSize\", \"getGridSize@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"round2Grid\", \"round2Grid@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ppc2GridCoord\", \"ppc2GridCoord@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"snapAngle\", \"snapAngle@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"snapToGrid\", \"snapToGrid@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"travelAngle\", \"travelAngle@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"seekToken\", \"seekToken@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"getNewImage\", \"getNewImage@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"execAllPlayers\", \"execAllPlayers@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"sortTokByProp\", \"sortTokByProp@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"debugInfo\", \"debugInfo@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"CoMScan\", \"CoMScan@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"switchMap\", \"switchMap@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"findDuplicates\", \"findDuplicates@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"getTokCDistance\", \"getTokCDistance@\"+thisLib,1,1)]\n\n[h:'<!-- Util General-->']\n[h:defineFunction(prefix+\"cleanTokNames\", \"cleanTokNames@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"abortProcess\", \"abortProcess@\"+thisLib)]\n[h:defineFunction(prefix+\"setDrawOrder\", \"setDrawOrder@\"+thisLib)]\n[h:defineFunction(prefix+\"removeP20\", \"removeP20@\"+thisLib)]\n\n[h:defineFunction(prefix+\"setLightSource\", \"setLightSource@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"applyLightSource\", \"applyLightSource@\"+thisLib,1,0)]\n\n[h:defineFunction(prefix+\"movementLock\", \"movementLock@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"tokenLock\", \"tokenLock@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"showHandout\", \"showHandout@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"benchmark\", \"benchmark@\"+thisLib, 0, 1 ) ]\n\n[h:defineFunction(prefix+\"isFullScreen\", \"isFullScreen@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toggleFullScreen\", \"toggleFullScreen@\"+thisLib, 1, 1 ) ]\n\n[h:defineFunction(prefix+\"renumberToks\", \"renumberToks@\"+thisLib)]\n[h:defineFunction(prefix+\"toggleSpecial\", \"toggleSpecial@\"+thisLib)]\n[h:defineFunction(prefix+\"removeTokens\", \"removeTokens@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"getRangedDistance\", \"getRangedDistance@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"changeElevation\", \"changeElevation@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"changeElevation\", \"changeElevation@\"+thisLib,1,1)]\n\n[h:'<!-- Util - math -->']\n[h:defineFunction(prefix+\"pi\", \"pi@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"cos\", \"cos@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"sin\", \"sin@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"tan\", \"tan@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toRadians\", \"toRadians@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(\"odd\", \"odd@\"+thisLib)]\n[h:defineFunction(\"mod\", \"mod@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"facingToCoord\", \"facingToCoord@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"facingToCoordX\", \"facingToCoordX@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"facingToCoordY\", \"facingToCoordY@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getTokenFacing\", \"getTokenFacing@\"+thisLib,1,1)] \n[h:defineFunction(prefix+\"setTokenFacing\", \"setTokenFacing@\"+thisLib,1,1)] \n\n[h:'<!--util - OnCampaignLoad-->']\n[h:defineFunction(prefix+\"diagnose\", \"diagnose@\"+thisLib, 1, 0 ) ]\n\n[h:'<!-- Util - Timer -->']\n[h:defineFunction(prefix+\"resetTimer\", \"resetTimer@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"timeOut\", \"timeOut@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"startTime\", \"startTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"pauseTime\", \"pauseTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"resumeTime\", \"resumeTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"subTime\", \"subTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"totalTime\", \"totalTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"formatTime\", \"formatTime@\"+thisLib, 1, 1)]\n\n[h:'<!-- Util - VBL -->']\n[h:defineFunction(prefix+\"createVBL\", \"createVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"removeVBL\", \"removeVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"VBLGrenade\", \"VBLGrenade@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"moveStamp\", \"moveStamp@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"setVBL\", \"setVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"extendPoint\", \"extendPoint@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"drawFgVBL\", \"drawFgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"saveFgVBL\", \"saveFgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"drawBgVBL\", \"drawBgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"saveBgVBL\", \"saveBgVBL@\"+thisLib, 1, 1 ) ]\n\n[h:'<!--x. Documentation -->']\n[h:defineFunction(prefix+\"manualText\", \"manualText@\"+thisLib)]\n[h:defineFunction(prefix+\"optionTable\", \"optionTable@\"+thisLib)]\n[h:defineFunction(prefix+\"manFunctionsTxt\", \"manFunctionsTxt@\"+thisLib)]\n[h:defineFunction(prefix+\"videoTutorials\", \"videoTutorials@\"+thisLib)]\n[h:defineFunction(prefix+\"settings\", \"settings@\"+thisLib)]\n\n[h:'<!-- defineFunction(function, macro, ignoreOutput, newScope) -->']\n\n[h:'<!-- REDEFINED FUNCTIONS -->']\n<!-- isdefined: 0 no, 1 yes, 2 mt core function -->\n[h,if(getLibProperty('fullScreenBroadcast','lib:EventMacros') == 1 && isFunctionDefined(\"broadcast\") == 2):defineFunction(\"broadcast\", \"bot_broadcast@\"+thisLib, 1, 1 ) ]\n\n[H: '<!------------------------------------------------------- ASSERTIONS, check if settings are set up correctly -->']\n[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:mapList\t\t= getAllMapNames(\"json\")]\n[h,if(!json.contains(mapList, baseMap)), CODE:{\n\t<!-- if this is the first time someone sets up then run the feature installation window. Check if your on the right map, lib eventmacros is there, settings is run once -->\n\t[firstTimeUse\t= 1]\n\t[macro(\"welcomeInit@lib:OnTokenMove\"):\"\"]\n\t[botTok\t= findToken(\"lib:OnTokenMove\")]\n\t[emTok\t= findToken(\"lib:EventMacros\")]\n\t[assert(botTok != \"\", \"BASE map name is not set up correctly. Please run Settings and set up the correct BASE map, when done run onCampaignLoad macro on the lib:OnTokenMove token\",0)]\n\t[assert(emTok != \"\", \"Make sure that there is a lib:EventMacros on the same map as lib:OnTokenMove and that you have run the settings (and set up the BASE map correctly in the settings)\",0)]\n\t[setLibProperty(\"baseMapName\", getCurrentMapName(), \"lib:EventMacros\")]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n};{\n\t[firstTimeUse\t= 0]\n}]\n\n[H: '<!------------------------------------------------------- Check if list of logged on GMs has changed -->']\n[h:newGmNames = getLibProperty(\"gmNames\", \"lib:EventMacros\")]\n[h,if(json.type(newGmNames)!=\"ARRAY\"):newGmNames\t= \"[]\"]\n[h:oldgmNames = newGmNames]\n[H:playerName = json.fromList(getPlayerName())]\n[h:tmpAllPlayers = getAllPlayerNames(\"json\")]\n[H,if(isGM()), CODE:{\n\t[newGmNames\t= json.union(newGmNames,playerName)]\n\t[intersect\t= '[]']\n}; { \n\t[intersect\t= json.intersection(newGmNames,playerName)]\n\t[if(!json.isEmpty(intersect)): newGmNames = json.difference(newGmNames,playerName)]\n}]\n[H: newGmNames = json.intersection(tmpAllPlayers,newGmNames)]\n\n[H: '<!------------------------------------------------------- if the list has changed, make sure you do the update on the BASE map!! -->']\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h,if(!json.equals(oldgmNames,newGmNames)), CODE:{\n\t[if(!firstTimeUse):setCurrentMap(baseMap)]\n \t[setLibProperty(\"gmNames\",newGmNames, \"lib:EventMacros\")]\n}; {}]\n\n[h:noGM = json.isEmpty(getLibProperty(\"gmNames\", \"lib:EventMacros\"))]\n[h,if(noGM), CODE:{\n\t[abort(input(\n\t\t\"junk|<html><b>The system has no GMs registered.<br>If you started the game without a gm restart it and correct it.<br>Else pick the gm from the list below<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"gmNames|\"+getAllPlayerNames()+\"|Select the gm|LIST|SELECT=0 VALUE=STRING\"\n\t))]\n\t[setLibProperty(\"gmNames\", json.fromList(gmNames), \"lib:EventMacros\")]\n}]\n\n[H: '<!-- ----------------------------------------------------- /Check if list of logged on GMs has changed -->']\n\n[h:'<!-- ------------------- check for areas, if theyre not initialized do so now ------------------------>']\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"Lib:EventMacros\") ]\n[h, if(json.type(linkedAreas)==\"UNKNOWN\"): setLibProperty(\"linkedAreas\", \"{}\", \"Lib:EventMacros\")]\n\n[h:'<!-- ------------------ if the maps are not initialized, do so now ----------------------------------->']\n[h:oldMapsPads\t\t= getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n[h:initialized\t\t= 1]\n[h:chckMapsOCL\t\t= getLibProperty(\"checkMapsOCL\", \"lib:EventMacros\")]\n[h:macroLocation\t= getMacroLocation()]\n\n[h, if(json.type(oldMapsPads)=='OBJECT' && chckMapsOCL), CODE:{\n\t[excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n\t[toCheckMaps\t= json.difference(mapList, excludedMaps)]\n\t[foreach(currentMap, mapList,\"\"), CODE:{\n\t\t[setCurrentMap(currentMap)]\n\t\t<!-- find the map on which the lib token is located -->\n\t\t[if(findToken(macroLocation) != \"\"): macroMap = currentMap]\n\t\t<!-- check if map is initialized -->\n\t\t[if(!json.contains(oldMapsPads, currentMap) && json.contains(toCheckMaps, currentMap)):initialized = 0]<br>\n\t}]\n}; {}]\n\n[h, if(json.type(oldMapsPads)!='OBJECT' && chckMapsOCL), CODE:{\n\t[initialized\t= 0]\n\t[foreach(currentMap, mapList,\"\"), CODE:{\n\t\t[setCurrentMap(currentMap)]\n\t\t[if(findToken(macroLocation) != \"\"): macroMap = currentMap]\n\t}]\n}; {}]\n\n[r,if(!initialized && chckMapsOCL), CODE:{\n\t[r:bot_initializePads(1)]\n\t[h:newMapsPads = macro.return]\n\t[h:setCurrentMap(macroMap)]\n\t[h:setLibProperty(\"allMapsPads\",newMapsPads,\"lib:EventMacros\")]\n}; {}]\n\n[h,if(getLibProperty('runSwitchForm','lib:EventMacros')==1), CODE:{\n\t[macro(\"SwitchFrame@Lib:OnTokenMove\"):\"\"]\n}; {}]\n\n<!-- AMs disguise macro initialization -->\n[H: disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\")]\n[H, if(json.isEmpty(disguiseMacro)), CODE: {\n\t[macroName\t= \"Use Disguise\"]\n\t[index\t\t= getMacroIndexes(macroName)]\n\t[command\t= getMacroCommand(index)]\n\t[props\t\t= json.set(getMacroProps(index,\"json\"),\"command\",command)]\n\t[props\t\t= json.removeAll(props,json.set(\"{}\",\"index\",\"\",\"group\",\"\"))]\n\t[setLibProperty(\"am.bot.disguiseMacro\",props)]\n};{}]\n\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n[h,if(disableOCLCheck != 1), CODE:{\n\t[h:'<!-- -------------------------------- OUTPUT TO CHAT THROUGH BROADCAST -------------------------------- -->']\n\t\n\t[h: info\t\t= getInfo(\"client\")]\n\t[h: assert(json.type(info)== \"OBJECT\", \"MAKE SURE THAT THE LIB TOKENS ARE ON THE TOKEN LAYER. After that, save and reload the campaign file.\",0)]\n\t[h: libs\t\t= json.get(info, \"library tokens\")]\n\t[h: botVersion\t= json.get(libs, \"lib:OnTokenMove\")]\n\t[h: assert(listContains(json.fields(libs), \"Lib:EventMacros\"), \"Lib:EventMacros not found! Make sure that its in the campaign file, and then save and reload the campaign file\",0)]\n\t[h: mtVersion\t= json.get(info, \"version\")]\n\t[h,if(indexOf(mtVersion, \"b\") != -1): \n\t\tmtVersionNr\t= substring(mtVersion, indexOf(mtVersion,\"b\")+1,indexOf(mtVersion,\"b\")+3)\n\t;\n\t\tmtVersionNr\t= substring(mtVersion, 2,3)\n\t]\n\n<!-- too often this renders an error so removing it for now -->\n[mtVersionNr = 4]\n\n\t<!-- check for installation errors and sets the messages error messages - NO NEW SCOPE\n\tstateOutput, tokOutput, tableOutput, libOwnerOutput\t-->\n\t[h, if(!firstTimeUse):bot_diagnose(1)]\n\t[vblSupport\t\t= if(bot_inStr(lower(mtVersion), \"nerps\") || mtVersionNr > 89 || mtVersionNr == 4, 1, 0)]\n\t[vblSupport = if(bot_inStr(lower(mtVersion), \"nerps\") || mtVersionNr > 89 || mtVersionNr >= 4, 1, 0)]\n\t[vblOutput\t\t= if(vblSupport, \" v This Maptool version <b>supports<\/b> automatic vision blocking manipulation, this functionality will be <b>enabled<\/b>\", \" x This Maptool version <b>does <u><font color='red'>not<\/font><\/u> support<\/b> automatic vision blocking manipulation, this functionality will be <b>disabled<\/b>\"))]\n\t[setLibProperty('vblSupport',vblSupport,'lib:EventMacros')]\n\t[message\t\t= \" v Current online GM's are: <b>\"+json.toList(newGmNames) + \"<\/b>\"]\n\t[message\t\t= listAppend(message, \" v This campaign runs in Maptool version <b>\"+mtVersion+\"<\/b>\",\"<br>\")]\n\t[message\t\t= listAppend(message, \" v This campaign is powered by version <b>\"+botVersion+\"<\/b> of the <b>Bag of Tricks<\/b> (<font color='blue'><a href='https://forums.rptools.net/viewtopic.php?f=46&t=28409&p=274496#p274496'>check for updates<\/a><\/font>)\",\"<br>\")]\n\t[message\t\t= listAppend(message, vblOutput,\"<br>\")]\n\t[h, if(!firstTimeUse), CODE:{\n\t\t[message\t\t= listAppend(message, stateOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, invisOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, tokOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, tableOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, libOwnerOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, togglesOutput,\"<br>\")]\n\t};{\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t}]\n\t\n\t[if(right != \"\"): message = replace(message, \" v \", right+\" \")]\n\t[if(wrong != \"\"): message = replace(message, \" x \", wrong+\" \")]\n\n\t<!-- 0:message, OPTIONAL1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:target6:broadcast-->\n\t[bot_message(message, \"<b>Bag of Tricks - OnCampaignLoad checks<\/b>\", \"maroon-yellow\", bot_self())]\n\n\t[broadcast(\"\n\t\t<table  cellpadding='5' cellspacing='0'  bgcolor='blue'>\n\t\t\t<tr>\n\t\t\t\t<td cellpadding='10' >\n\t\t\t\t\t<span title='This open TWO manuals of the BoT' style='text-decoration:none; color:yellow;'>\n\t\t\t\t\t\t\" + \n\t\t\t\t\t\tmacroLink('Open BoT Manual', 'manualText@lib:OnTokenMove','self')\n\t\t\t\t\t\t+ \"\n\t\t\t\t\t<\/span>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\",\"self\")] \n};{}]\n\n<!-- ---------------------- on campaign load goto map and coords settings, must come AFTER diagnose due to the map switching -------------------------------------------------------- -->\n[h,if(getLibProperty('useStartUpMap','lib:EventMacros')==1), CODE:{\n\t[if(!firstTimeUse):setCurrentMap(getLibProperty('startUpMap','lib:EventMacros'))]\n\t[gotoCoord\t= getLibProperty('startUpCoords','lib:EventMacros')]\n\t[h,if(findToken(\"centreOnMePad\") != \"\" && getLibProperty('useCentreOnMePad','lib:EventMacros')==1), CODE:{\n\t\t<!-- if centreOnMePad checkbox is checked AND the token is on the map, centre the map on there -->\n\t\t[goto(getTokenX(0,\"centreOnMePad\"),getTokenY(0,\"centreOnMePad\"))]\n\t}; {\n\t\t<!-- else centre the map on the given coords -->\n\t\t<!-- you can set either a coordinate e.g. 4,5 or a token name e.g. \"Nihilus Faine\" -->\n\t\t[if(listCount(gotoCoord)==2): goto(listGet(gotoCoord, 0),listGet(gotoCoord, 1)) ; goto(gotoCoord)]\n\t}]\n}; {\n\t[setCurrentMap(oldMap)]\n}]\n\n<!-- make sure there is no output to chat -->\n[abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8e6469a0-f9d5-4f6b-bba0-ef42186c282a",
          "commandChecksum": "48873f8cbcddbe9949dc5b86d8b35144",
          "propsChecksum": "e15844a3ded28bad9ef7d9a304411677"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "43",
        "index": 2,
        "label": "(Un)Show Area",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"showArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "667b150d-125d-4696-82e1-34f0496153fd",
          "commandChecksum": "87637f02f5c62d991a7cdd709aacc471",
          "propsChecksum": "5fdf4763213fda88643e3bbd07cf6551"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "10",
        "index": 3,
        "label": "<i>Animate Text",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"animateTextInput@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ffa78912-efb0-4f2e-8675-a258bb868316",
          "commandChecksum": "9210aaa35848d75e6f6885bcd21c3e36",
          "propsChecksum": "c538a025e13cc2901615af5fc839e318"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "998",
        "index": 4,
        "label": "<image src=\" asset://3fcd87c798fedd3ade1bd9ed272550e0\"><\/image> ",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"showDescription@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b462b1bd-02d6-40fa-a20d-0e5e5477bec9",
          "commandChecksum": "fa12341d480b8edf8298f549383a1ff6",
          "propsChecksum": "7dd74d26de9759738bc1c439c5f991dd"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "112",
        "index": 5,
        "label": "Activate Group",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, macro(\"openGroupFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e34c7479-60a2-4afe-9ff8-a1d116eaa99f",
          "commandChecksum": "698d0f7773ef7c22c2aff7c3badcf82a",
          "propsChecksum": "4f852921563e41833890ca35d4c400b6"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "13",
        "index": 6,
        "label": "Activate Switches",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, macro(\"openFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e9a0c119-a3a7-4367-9ad3-dd3a3d7c7aeb",
          "commandChecksum": "550ba1684efb6ee5d43a1fafb7db562d",
          "propsChecksum": "36e5c4334b6f76c793f6dfab0b97245a"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "4",
        "index": 7,
        "label": "Alt. Init. Pads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_altInitMap()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4fb5fc53-38c6-4d0f-92e7-d93e7c03c8fb",
          "commandChecksum": "4c22110367b59eb069b9995a14b1f5e9",
          "propsChecksum": "ec01e6b61ff63aeb036ed7ca35b82fe6"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "11",
        "index": 8,
        "label": "Animate Move",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_animateMove()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a1a1e4dc-ebd4-4cb1-a3cd-2750fb557c0a",
          "commandChecksum": "c679df278e1c0d7bf44583d62147276a",
          "propsChecksum": "36413f765c108b4117bb2efa1377134d"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "42",
        "index": 9,
        "label": "Assign Areas",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"assignArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2fab65ef-e63f-42e6-91b4-3cb5af3767a7",
          "commandChecksum": "75d4c8c7c6ef11b5fa592d81d7cad025",
          "propsChecksum": "cd528e22aadd54aabb4f2e8e4383dead"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "51",
        "index": 10,
        "label": "Assign Tokens to Pads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_assignPads()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "49d07c5e-e3a7-4055-98f5-77da433c417f",
          "commandChecksum": "3fdb98347dd75bba4770b0a8f078cbd4",
          "propsChecksum": "0d448cfb9b33e91ada979935a23c4fb3"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "81a",
        "index": 11,
        "label": "Auto Disguise Btn",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- autoDisguiseButton -------------------------------------------------------- -->']\n\n[H, if(json.isEmpty(macro.args)), CODE: {\n\t[propText\t\t= '*autoDisguiseButton:[macro(\"autoDisguiseButton@lib:disguise\"): currentToken()]']\n\t[input(\n\t\t\"label|<html><b>Copy text in to Token Property to auto load Disguise Button:<\/b><br><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50\")\n\t)]\n};{\n\t[id\t\t\t\t= json.get(macro.args,0)]\n\t[switchToken(id)]\n\t[disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\",getMacroLocation())]\n\t[setProperty(\"autoDisguiseButton\",\"\")]\n\t[if(!hasMacro(\"Use Disguise\")): createMacro(disguiseMacro)]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f548be85-28f7-4520-bf2c-8e53eb7596b8",
          "commandChecksum": "284855b405a69e88505ee3e647124f6c",
          "propsChecksum": "6106069b0353041d4264428618059e0e"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "1",
        "index": 12,
        "label": "Bag of Tricks Macros",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[r:bot_MacroButtonsOTMSetup()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa4a1af0-a2b6-4926-a725-441fd14814b0",
          "commandChecksum": "d61d7e64b79d870a4c67e4b51088af33",
          "propsChecksum": "9ec2ec9556084903eda93c1ea681f6f3"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "21",
        "index": 13,
        "label": "Build Forest",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_buildForest()]",
        "maxWidth": "",
        "tooltip": "<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8ddcb394-9871-4145-9c8c-5a2bfa5a4401",
          "commandChecksum": "3ef3403868168bea93a7e593c6a4e1c3",
          "propsChecksum": "28dcd720426c3ad6b18c383520e0468c"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "24",
        "index": 14,
        "label": "Choose Crowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_chooseCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "97d149cf-a604-4fca-b689-b19f4b8e2e91",
          "commandChecksum": "79c389e75f13defc9d44851f652b962e",
          "propsChecksum": "46142b3a07bfc72bb287158547a31c69"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "20",
        "index": 15,
        "label": "Choose Trunks",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_chooseTrunks()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "af436691-b44d-45d2-9e8a-65b24606be70",
          "commandChecksum": "b8d1a87eb8525fe1afdd9dd8a1e57813",
          "propsChecksum": "38b4c6605ec25cf16aa9b7d0f3f9a51c"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "82a",
        "index": 16,
        "label": "Clean Tok Names",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_cleanTokNames()]",
        "maxWidth": "",
        "tooltip": "<html>There are certain characters e.g. @ # & that, when used in a token name,<br> can potentially break a macro IF that macro uses that token name. An obvious<br> example is getTokenNames(\",\") which returns a , seperated list. Should one of<br> the tokens in that list be called e.g. \"Fire Elemental, Giant\" than the list<br> would thus consist out of \"Fire Elemental\" and \"Giant\". <br><br> This macro tracks these tokens down and reports them in the chat. You then have<br> the choice to either fix them automatically or not.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a0d13a5b-48cf-4638-b4e4-ce5dfce04716",
          "commandChecksum": "86f7083fee699963b43bcd744dc73510",
          "propsChecksum": "bc9b70c4a39f103cecca39692b4bb694"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "94",
        "index": 17,
        "label": "Contract Group",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_contractGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52d7331d-3571-4d25-a5d6-d5891120ce81",
          "commandChecksum": "e11e3aa9e04b7db1aab15be4b9505cb2",
          "propsChecksum": "3c9df8faf8342f9cee0ab2f595f34074"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "11a",
        "index": 18,
        "label": "Convert Trap/Pits",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_convertTrapPit()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cae9586e-0271-4240-8157-52f31bab8cd6",
          "commandChecksum": "b4a3c354a9a7ee9449ca9bb1b2473598",
          "propsChecksum": "1a2c07668024e2fa45b3809da58b6ad8"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "87",
        "index": 19,
        "label": "Copy / Del. Macro",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_cpyDelMacros()]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b6bdbbc4-4482-477d-9c18-e3554207973e",
          "commandChecksum": "0b99299b932ae8bc90701a5f38d65a22",
          "propsChecksum": "8cd2acda9e98f5d554914785dbe1b2de"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "25",
        "index": 20,
        "label": "Create Crowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_createCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>Same as choose trunks. Creates a list of tokens which 'Create Crowd' uses.<br> Based on tokens on BASE map starting name with 'Crowd '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "38bcef92-aa9e-4b24-86ad-a2a37e5c1145",
          "commandChecksum": "5ab40c6fd2414a4cd276f942fe808860",
          "propsChecksum": "4a309d02428c8222e194a25a3ae8596f"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "41",
        "index": 21,
        "label": "Define Area",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"defineArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "96a27a88-3c17-44f9-ad4e-2727915959f0",
          "commandChecksum": "6196ea54d7d931c6dac2373a62120f45",
          "propsChecksum": "35b2918e51fada706223bbe493c30500"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "82",
        "index": 22,
        "label": "Diagnose Maps",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_diagnose()]",
        "maxWidth": "",
        "tooltip": "<html>Map diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8522b490-350b-4327-9f04-18b71d5e19b4",
          "commandChecksum": "e6fd1665aa70ce92d77b1ab660cee406",
          "propsChecksum": "961b85cb45f42f04669f33e611b871c1"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "43",
        "index": 23,
        "label": "Draw Area",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"toggleAreaDraw@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "006b67d1-fa16-4ea9-9fbb-3632a333cc54",
          "commandChecksum": "32dc95e55faba469d392cca0a8a9c590",
          "propsChecksum": "992d7e54728639c1e2d1a9eafa1736ca"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "red",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "111",
        "index": 24,
        "label": "Draw Order",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, macro(\"openOrderFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "853db290-4f12-4d47-b65b-c10ee3be8b61",
          "commandChecksum": "6ece77298c7dbb4c7772f5e493c92291",
          "propsChecksum": "b4103fcf7de4a19785a31e98928bd527"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "98",
        "index": 25,
        "label": "Echelon Formation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationEchelon()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c6002b59-75fd-4913-8ee2-4baef6931a42",
          "commandChecksum": "26bf3841c04019223ae1e6cd6d2a656c",
          "propsChecksum": "0e1df36fc782162b99b581a830ef1a48"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "52",
        "index": 26,
        "label": "Execute AssignPads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads()]",
        "maxWidth": "",
        "tooltip": "<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f5983928-19b7-47d9-946f-b8be57c10cdf",
          "commandChecksum": "e2799c4cab011449075570f5ecd119da",
          "propsChecksum": "48dc38f79c34ea6ad14b7ad945aaeb20"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "11",
        "index": 27,
        "label": "Execute Event",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_executeEvent()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fec39215-bfee-4b3d-a728-c4546d3ea740",
          "commandChecksum": "d77e1b8aa2c48447bde9177b5eec4f8d",
          "propsChecksum": "728e1ba507b36bd6c5311c20ed6de75c"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "33",
        "index": 28,
        "label": "Execute event",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_executeEvent()]",
        "maxWidth": "",
        "tooltip": "<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8f055d6a-65a6-4bd6-b9e1-c2b019db50fa",
          "commandChecksum": "d77e1b8aa2c48447bde9177b5eec4f8d",
          "propsChecksum": "01957e6475feedf49559a480cc6575aa"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "43",
        "index": 29,
        "label": "Fill Area",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"fillArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills a predefined area with tokens<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a32112f0-dd24-4088-a7be-b3489e112c69",
          "commandChecksum": "d48898d75c5eebb035d6ce456c2d816d",
          "propsChecksum": "7b91648a62f73008200bb8acf1ccd66b"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "77",
        "index": 30,
        "label": "Find Duplicates",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_findDuplicates()]",
        "maxWidth": "",
        "tooltip": "Give a list of all tokens of all layers on current map that have the same name",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "195922c8-b675-4800-bfe1-982ae6df6dad",
          "commandChecksum": "b307f44d4f2a580d533f8d4de1a833d3",
          "propsChecksum": "46ebc46ba1db882d94138eda03ab10e5"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "91",
        "index": 31,
        "label": "Formation Buttons",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_MacroButtonsGroupMove()]",
        "maxWidth": "",
        "tooltip": "<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "91c82a6a-e9ea-49c7-ba65-c5b176402c73",
          "commandChecksum": "9170337ffe76a9de6f3a696b9b309936",
          "propsChecksum": "ff616da6d3663fe3f96343a6b77c3154"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "81b",
        "index": 32,
        "label": "Frame Overview",
        "fontSize": "1.00em",
        "minWidth": "192",
        "playerEditable": false,
        "command": "[h:bot_frameOverview()]",
        "maxWidth": "",
        "tooltip": "<html>This macro toggles shows an <br>overview of all Nildiks frames.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2b7b179a-e04f-4882-97bb-4e69cbb01a01",
          "commandChecksum": "befa94d1d806f0d740f61945e73cd328",
          "propsChecksum": "d75491fa4b436f3bdb32465d31a4d629"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "101",
        "index": 33,
        "label": "Group (Move)",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_setGroup()]",
        "maxWidth": "",
        "tooltip": "<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ef498a23-8abf-448a-9471-1f970980ebc5",
          "commandChecksum": "70e4630276c69afb862e09d5f566daf2",
          "propsChecksum": "b78619ec9e6b8c8eb62160dda3319d20"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "113",
        "index": 34,
        "label": "Group (Select)",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, macro(\"setSelectGroup@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0cfaa9b3-229c-43d1-bab5-0b713957bde4",
          "commandChecksum": "960d83e50284677ed9e2f6dd768c720e",
          "propsChecksum": "ff77832be62acd18c4fa0d96e7ccd7ad"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "3",
        "index": 35,
        "label": "Initialize Pads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_initializePads()]",
        "maxWidth": "",
        "tooltip": "<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3004fee2-5f59-4b26-9b20-e3de1a7ac1d8",
          "commandChecksum": "a57b6e5605628f6f7937c29a22a60157",
          "propsChecksum": "f74e096b17b58d2964ea6bb11848cb28"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "97",
        "index": 36,
        "label": "Line Formation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationLine()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5e04c721-ba78-4ac4-8896-4b844848339a",
          "commandChecksum": "64a5d4d524a28211787c32587df0d87a",
          "propsChecksum": "e55c22ae6af7a376138482411d728cb4"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "121",
        "index": 37,
        "label": "Lock Movement",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_movementLock()]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no PLAYER can move a token, only the GM can.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "19d87d4b-376f-4fe8-8e29-7cd8e57a08d8",
          "commandChecksum": "2caa8cae1f33e38e3de1cb105fa83e2e",
          "propsChecksum": "f830d6b0fafe50915fa92e312defc947"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "121",
        "index": 38,
        "label": "Lock Token",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_tokenLock()]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b1bfcdfc-a6d9-4203-974a-0fc189e3a272",
          "commandChecksum": "9a27f2f23492faef260c042f2f89cd81",
          "propsChecksum": "c17ccd697a22a9964bf59d8426bf7b18"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "4",
        "index": 39,
        "label": "Manual",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_manualText()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9360540f-ef53-4465-abeb-93a7d4324252",
          "commandChecksum": "47c186c062ecc9f674c3b539fce662a2",
          "propsChecksum": "2a223a13c360800b7c5262aea9110f73"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "28",
        "index": 40,
        "label": "Map Editor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_mapEditor()]",
        "maxWidth": "",
        "tooltip": "Creates an overlay on the token layer where you can quickly create a new map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "666c8866-0520-49f9-ae6f-b6f14f5c9760",
          "commandChecksum": "fd927fa63aaee6deb57c3d744a8fe218",
          "propsChecksum": "a0f4587a8840c8a76c5dce1faa07872d"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "122",
        "index": 41,
        "label": "Mass VBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"MassVBL@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This function draws VBL crosses on all tokens that match a search string",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "33426f9f-e167-444d-b18b-09f45920f5b3",
          "commandChecksum": "480d9c67818e81d1a545995daa5c2a91",
          "propsChecksum": "478af4b4faf5c8093719b7e548131d70"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "85",
        "index": 42,
        "label": "Setup Sound Pad",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[macro(\"setupSound@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5d7a2d27-5bfa-4273-8aca-0d37119625b5",
          "commandChecksum": "be08577caaa75f040551223898d6fb5a",
          "propsChecksum": "ccfd29598f942867e3c771268ff38bcf"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "26",
        "index": 43,
        "label": "Move Crowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_moveCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cb28f912-33fb-4a5d-b369-a1f3659a184a",
          "commandChecksum": "7bbdd88c1943c5493946b6bbdd719c7f",
          "propsChecksum": "838d993c867acaf43113301325f78e30"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "27",
        "index": 44,
        "label": "Move Crowd +",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_moveCrowdPlus()]",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "33fef0f8-9bf4-41b8-ab6b-58222dfb413f",
          "commandChecksum": "fe1dd0880bc5963dcac01ca0279a6356",
          "propsChecksum": "6aeddc511a79a8a0caad8f85d1af4cad"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "8",
        "index": 45,
        "label": "Move Token",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_animateMove()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will animate the movement of the selected token. An options panel will be shown first.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa5dc37a-0fd4-4138-ad4a-e1bf4c239e8d",
          "commandChecksum": "c679df278e1c0d7bf44583d62147276a",
          "propsChecksum": "2761d438587119f44171633e22f76ecb"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "30",
        "index": 46,
        "label": "Move to hidden",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_moveToHidden()]",
        "maxWidth": "",
        "tooltip": "Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so they're no longer visible",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85700593-e32f-4d53-9a1a-96e0ba8ae288",
          "commandChecksum": "173d07393304d1858e996a4a1f60bde2",
          "propsChecksum": "01d493197eac57e5a86e8aa6dc32ec42"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "30a",
        "index": 47,
        "label": "Move to token",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_moveToToken()]",
        "maxWidth": "",
        "tooltip": "Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e920053e-7d0d-4d33-b6ce-97f181e6800a",
          "commandChecksum": "6953081459002d0de80335ac1cb69386",
          "propsChecksum": "d5a34e28522766a9e898aff08f8d6582"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "96",
        "index": 48,
        "label": "Packed-Wedge",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationPWedge()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4e3fd8f-f8c6-419e-9def-27cd6c3e0f43",
          "commandChecksum": "085e6fbb098820999d088318f1c145f8",
          "propsChecksum": "c743411fcc092de0e681f933b388b118"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "81",
        "index": 49,
        "label": "Pads Explorer",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_initializeMap()]",
        "maxWidth": "",
        "tooltip": "Show overview of special pads on map",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8aa58db1-8ba9-4c0b-b684-f2c28412bb49",
          "commandChecksum": "b504782766fb4c8641f7a1d641be0175",
          "propsChecksum": "9310e0caa81f295da35e30441f0a4777"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "88",
        "index": 50,
        "label": "Paste Macros",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_pasteMacros()]",
        "maxWidth": "",
        "tooltip": "<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "51fdd7a2-eb17-427f-9e27-f7845db67852",
          "commandChecksum": "4c44e43dbdb9a59736d03c779bc761fc",
          "propsChecksum": "eff2314833adb037f59d752a009ad73d"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "29",
        "index": 51,
        "label": "Quit Editor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_quitEditor()]",
        "maxWidth": "",
        "tooltip": "removes the overlay and the states of the pasted tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cd800d25-6574-444e-b214-a8e97c620d90",
          "commandChecksum": "bafb9b993041933ef9339fa89719b1df",
          "propsChecksum": "db9c0104ed1fefb04701100d6decf465"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "74",
        "index": 52,
        "label": "Remove %20",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_removeP20()]",
        "maxWidth": "",
        "tooltip": "This macro replaces %20 with spaces \" \" in the selected token names",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bcd28e56-65aa-46fa-af5f-b49c6b8ef346",
          "commandChecksum": "b0e5812a822ff2d1f45d8eb0370aa5fb",
          "propsChecksum": "e56852f311a27f1ad585d09dd047b047"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "72",
        "index": 53,
        "label": "Renumber Tokens",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_renumberToks()]",
        "maxWidth": "",
        "tooltip": "<html>When you have used the scatter function<br> (especially icw Spread) then you need to <br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fc306ffa-bb61-4adb-b718-1fe54ead53ec",
          "commandChecksum": "df271719bd8f0ad8e52277365a2e455b",
          "propsChecksum": "d30e3a0a7916ed67e2774fab60c20c2a"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "31",
        "index": 54,
        "label": "Reset Pit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:setTokenImage(getTokenPortrait())]",
        "maxWidth": "",
        "tooltip": "<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7fc59a3a-9d25-40a4-8a1b-d6364ac4289c",
          "commandChecksum": "2af7e2d3fa1a35fd6b2ee6dff372acc1",
          "propsChecksum": "f0ca059de6462f44b0cb60733e4726df"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "92",
        "index": 55,
        "label": "Rotate CCW",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_rotateCCW()]",
        "maxWidth": "",
        "tooltip": "Select a 'group' token and rotate the other corresponding group tokens around it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "42d5c68b-af09-4e89-b50f-d70c9d553e44",
          "commandChecksum": "2e7654c26f1d5e33b7804c7aa7048404",
          "propsChecksum": "b3eeffc8044c3a52c2fb2cde14fb156b"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "91",
        "index": 56,
        "label": "Rotate CW",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_rotateCW()]",
        "maxWidth": "",
        "tooltip": "Select a 'group' token and rotate the other corresponding group tokens around it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4cb348be-9eba-4fc7-b307-73c9f57e9db7",
          "commandChecksum": "edc5b4323bac218a914584e67505e9cd",
          "propsChecksum": "113909d3a04400fdf9d9321503f5ec05"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "79",
        "index": 57,
        "label": "DiceBox",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:dbxLaunch()]",
        "maxWidth": "",
        "tooltip": "<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7250b088-a623-4097-a550-1568f88244c6",
          "commandChecksum": "98658570b3e0cc0d011110d7fd677e59",
          "propsChecksum": "f9628c8e3f3854b5de31a2cd28231caa"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "22",
        "index": 58,
        "label": "Scatter Tokens",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_scatter()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "addda563-ece6-4a42-a959-79698fe713e3",
          "commandChecksum": "ebe58c929e2a71d578013c23c785dd41",
          "propsChecksum": "ea769b5544aff1f028ba0972d1d63404"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "77",
        "index": 59,
        "label": "Seek Token",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"seekToken@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6bdaa5ec-bf4c-4e0f-b19b-25400acf8d08",
          "commandChecksum": "24e7210d58a6dd40342186b96a788881",
          "propsChecksum": "03e2721b8266470496fb5b5f76e27609"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "6",
        "index": 60,
        "label": "Set Door",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_setDoor()]",
        "maxWidth": "",
        "tooltip": "<html>To use the <i>Toggle Door(s)<\/i> macro, select one or more doors and click this button to set it up<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "64dbb4f3-9c02-4835-8b41-f75ecdb234cc",
          "commandChecksum": "3bdb9c147f31ce3156425981ef4987ba",
          "propsChecksum": "78f1dc45cb4844f9a59499c641b209fd"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "71",
        "index": 61,
        "label": "Set Draw Order",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_setDrawOrder()]",
        "maxWidth": "",
        "tooltip": "<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "02380a35-825f-4653-9910-72eb80e725fd",
          "commandChecksum": "a315463a2ac633698ce1cca4f34c8f05",
          "propsChecksum": "9dacd72c3332d4953f07fe3f7e6ef482"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "32",
        "index": 62,
        "label": "Set Event Button",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_setEventButton()]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. \"Switch to Fair Haven\"<br>3. Run this macro<br>4. Select \"Switch Map\" from the list<br>5. In the \"Give Arguments\" box enter the arguments as a stringproperty, e.g.\"toMap=Fair Haven\"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2127d5e1-aed1-42c3-be74-00fe8f4fa248",
          "commandChecksum": "e210641deddb97cf68d75404e6f08013",
          "propsChecksum": "ef47568d47304e5de4219f8953706771"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "32",
        "index": 63,
        "label": "Set Event Pad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_setEventPad()]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6d1baf2d-8fc2-46fc-b16a-474701d8ca38",
          "commandChecksum": "0a90ca893a35b04199cdb2da390a19dd",
          "propsChecksum": "80fa122fbaf145350d219d9a3f90a5f0"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "75",
        "index": 64,
        "label": "Set Light Source",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_setLightSource()]",
        "maxWidth": "",
        "tooltip": "<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , <\/b><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "86092041-8d15-4819-886d-8d8c856faef0",
          "commandChecksum": "e3d74fe4743c91be13b1f5e32565a23d",
          "propsChecksum": "c7b1afc7e8dbba4cffef9a6f69679ba4"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "75",
        "index": 65,
        "label": "Set Reference",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_setReference()]",
        "maxWidth": "",
        "tooltip": "<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "92feefb4-cc40-49b8-aa00-ba497f366bb5",
          "commandChecksum": "c0e2d29509cd6818216d39b5e29750e0",
          "propsChecksum": "49475fd324dd3aa8c771da09344b94a9"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "80",
        "index": 66,
        "label": "Set Roof",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_setRoof()]",
        "maxWidth": "",
        "tooltip": "<html>Here you can give a list of 'entry doors' through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the 'roof' token<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4f78ae7d-ff38-412c-b813-bc8ef2cb86ae",
          "commandChecksum": "a7c55c27518cfb86b67ceb512ddc4d83",
          "propsChecksum": "b700a952d1876312c72684c12afd7670"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "76",
        "index": 67,
        "label": "Set Token Size",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"setTokSize@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro is usufull is you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "13fb1ead-2211-4756-845e-c96643875de7",
          "commandChecksum": "727a43a8750be4cc56db4fcb0950986f",
          "propsChecksum": "dc1eeefc8e6f4c4dcdccf1d20940e4ec"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "122",
        "index": 68,
        "label": "Set VBL Stamp",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"setVBLStamp@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8c31d683-28ac-4cf1-a4b7-6b1472d53e28",
          "commandChecksum": "194b429ed7ca6aa72c497d386e923704",
          "propsChecksum": "1a85960c1aae52d85ed9af63e5527d2f"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "2",
        "index": 69,
        "label": "Settings",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_settings()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "40c73abc-770f-4ccc-b714-4bd0669bcc0e",
          "commandChecksum": "a7f60807d315bffb2902ca216b1d6f70",
          "propsChecksum": "89b67f077d98ace8fcc355f53d9d6035"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "79",
        "index": 70,
        "label": "Show Handout",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"showHandout@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> Pops up a dialog showing the handout of the selected token on all selected clients",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2c257e67-f2fa-447f-b728-d11de7f02d83",
          "commandChecksum": "f81cb6d9c06206cade8492f93675f5c9",
          "propsChecksum": "c290531aeb1498c0d6fb9d580aad9a1b"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "93",
        "index": 71,
        "label": "Spread Group",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_spreadGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and spread the other tokens with an offset of X=1 and Y=1",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "559c7991-db40-4ef2-82ce-1ad67c5afaf5",
          "commandChecksum": "26b0472b5fba3f1bb98eb5c17933c284",
          "propsChecksum": "77c8a71bf28524a76d69711b736bd15a"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "100",
        "index": 72,
        "label": "Square Formation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationSquare()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "35ec1fb1-0a2a-4247-8a38-fe096a594181",
          "commandChecksum": "df9fdb4d3b7bd275572e48e895c1aaf3",
          "propsChecksum": "76bfc2bb9c985173a2a4061f9080f307"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "99",
        "index": 73,
        "label": "StaggerFormation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationStagger()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "569a15bf-60bc-4da8-b6be-44d436a42711",
          "commandChecksum": "88ca77e4565e342ba7da88f8fe75992a",
          "propsChecksum": "8998e342ba2e24a85616431b0f4ad108"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "23a",
        "index": 74,
        "label": "Summon Token",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_summonToken()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5394f166-5654-47e7-baa0-2a58a945bd16",
          "commandChecksum": "16de006f2845af74a302952fa3e4c514",
          "propsChecksum": "10f1fc57523087bb0a93b97828534630"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "78",
        "index": 75,
        "label": "Switch Map",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"switchMap@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4a3341ae-d719-4b39-8c4e-e7079900acfa",
          "commandChecksum": "2ac22dcecfb5dc6141d924445f9122b5",
          "propsChecksum": "4e2d4b710b2a16f62d27d38850f4e182"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "7",
        "index": 76,
        "label": "Toggle Door",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_toggleDoor()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa1146ae-ce17-4827-873b-43cd867382ce",
          "commandChecksum": "553ea12602db01fdffcdd1de8e86364d",
          "propsChecksum": "a2ce9e67ffcef2c9c3ab40e738dbd69b"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 77,
        "label": "Toggle Door<b>s<\/b>",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_toggleDoors()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cb488bf1-445a-4555-a915-cca7ea7e503b",
          "commandChecksum": "87d28c4f13b7d99c44239e9cbacd1fa2",
          "propsChecksum": "30143ea078bb8313d4ef64f603a4baef"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "900",
        "index": 78,
        "label": "Toggle EventMove",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r,macro(\"toggleOnTokenMove@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7a8d6bf1-54eb-4ab9-b9e2-bdcd4ce108ab",
          "commandChecksum": "d7080583572deafb30d89f25be6cbe2e",
          "propsChecksum": "6e9a7c83db6ca5a78cbdb7284cea2638"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "901",
        "index": 79,
        "label": "Toggle Full Screen",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"toggleFullScreen@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0dadcc4e-d039-42e5-9923-8677af6cb1a9",
          "commandChecksum": "81a3d7023f4b0bc580e0054900c9320e",
          "propsChecksum": "3990cb648388c1ea69f0f29321600200"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "11",
        "index": 80,
        "label": "Toggle Lock",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_toggleLock()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1203a6e3-7074-4a36-b558-f6fc8f48538a",
          "commandChecksum": "a11beea7b7489d13014f236be59522c8",
          "propsChecksum": "c1c1d38f723bf879a6f55e48838f415a"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "122",
        "index": 81,
        "label": "Toggle Mass VBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"toggleMassVBL@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f909cf24-5e77-4637-adfd-fab9c29622f8",
          "commandChecksum": "c8d416441dfe192bd6f9800829a3f0b8",
          "propsChecksum": "1f28b0fce2cd952e251cb62a8cefbf30"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "73",
        "index": 82,
        "label": "Toggle Special",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_toggleSpecial()]",
        "maxWidth": "",
        "tooltip": "<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f43cb894-6e16-4790-957a-9976cb553fe3",
          "commandChecksum": "18218b015026daefceae150ab36b12ea",
          "propsChecksum": "7d55722ce0372f8ffb246d11a2c0e494"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "89",
        "index": 83,
        "label": "Undo Del. Macros",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_undoDelMacros()]",
        "maxWidth": "",
        "tooltip": "<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3e892d63-c2f4-4c8f-a5f5-3ef0248b2525",
          "commandChecksum": "b43e8910224907e2b908af0042b57dee",
          "propsChecksum": "1d6ce9724205b4c15969799da3a4cd2d"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "102",
        "index": 84,
        "label": "Ungroup (Move)",
        "fontSize": "1.00em",
        "minWidth": "192",
        "playerEditable": false,
        "command": "[h:bot_clearGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token from a group and use this macro to clear the ENTIRE group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "19ae95e9-51ea-4208-86a6-931f2fd99629",
          "commandChecksum": "1bb17d2afe33e84292d78c4ce3dbd479",
          "propsChecksum": "f3527c83db4676f707e1b32d5af20483"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "114",
        "index": 85,
        "label": "Ungroup (Select)",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, macro(\"clearSelectGroup@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f4e837ff-da11-4208-a56a-73af7c0cbf97",
          "commandChecksum": "7eb16e507a1d1003865f81691cf30025",
          "propsChecksum": "279f86a4d7f4ae9ab18c590ee0108d7f"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "81",
        "index": 86,
        "label": "Use Disguise",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_useDisguise()]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fef499bd-cc23-45fe-ab21-6643bbe971d3",
          "commandChecksum": "0ce1dac741989645cee926b9ff11ef4e",
          "propsChecksum": "7da58f70ebf88b22175ece7d1c29bbba"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "122",
        "index": 87,
        "label": "VBL Grenade",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"VBLGrenade@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8af4abcf-32bc-4bdd-8dea-7aaae90f279d",
          "commandChecksum": "5380fe2b4ab15642f3b7311c6c466a2a",
          "propsChecksum": "276085974e6c5b03167ad82b4e3a61e0"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "95",
        "index": 88,
        "label": "Wedge Formation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_formationWedge()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "802b28c7-838b-47aa-aa40-4868141a3545",
          "commandChecksum": "ebbe25fe137a2163d4530c0454722117",
          "propsChecksum": "24ee5aef87395290ffb58c0e0d54283b"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "80a",
        "index": 89,
        "label": "Whisper Frame",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_whisperFrame()]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a3f272e3-f3de-4718-b946-0ca7a459355e",
          "commandChecksum": "9f0cc18eb4cc5d22341926831e4f0080",
          "propsChecksum": "5ad331dd21de0b64cd00e0e4924fac2a"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "901",
        "index": 91,
        "label": "reset ALL props",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r,macro(\"deleteProps@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "(copy to Campaign panel)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d44921bc-434b-4c97-bdc5-c4ccd7dd8a0f",
          "commandChecksum": "474d2d430fad812ab096a7e848a01751",
          "propsChecksum": "88321b67e2c6ff580a29df74fe87415e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 92,
        "label": "Canopy",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------CANOPY------------------------------------------------->']\n[h:canopyTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(canopyTriggered,startingLocation) || json.contains(canopyTriggered,currentLocation)), CODE:{\n\t[switchToken(padName)]\n\t[inHouse = if(json.contains(canopyTriggered,currentLocation), 1, 0)]\n['pause(\"inHouse\",\"canopyTriggered\",\"currentLocation\",\"padName\", \"lastPath\")']\n\t[r,macro(\"roofSwap@this\"): json.append(\"\", inHouse, tok, padName, 0)]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8cf3c310-fc53-48c6-81ec-34a634490d10",
          "commandChecksum": "b44dd1c32c075049347386b384e9b4b6",
          "propsChecksum": "b2596922ce8dfd742ac1a4af48db7023"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 93,
        "label": "EventArea",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------------- EventArea --------------------------------------------------->']\n<!-- ignore output, no new scope -->\n\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n<!-- Routine for an EventArea, EventArea is only triggered when the test subject is moved on or over the area-->\n\n[areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n[intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n[eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n[diffCount\t\t\t= json.length(intersectPath)*DpC]\n[if(!json.isEmpty(eventPadTriggered)), CODE:{ \n\n\t[if(json.contains(thisMapLinks, areaName)):\t\tstrPropVars = json.get(thisMapLinks, areaName); strPropVars = \"\"]\n\t<!-- define:  \"eventMacro, eventTriggerList\" -->\n\t[if(strPropVars != \"\"), CODE: {\n\t\t[varsFromStrProp(strPropVars)]\n\t}; {\n\t\t[eventMacro = \"\"]\n\t\t[eventTriggerList = \"\"]\n\t}]\n\n\t[eventType\t\t= bot_getEventType()]\n\t[triggered\t\t= listContains(eventTriggerList, eventType)]\n\t[if(triggered),CODE:{\n\t\t[args\t\t\t= json.append(\"\", tok, eventType, areaName, lastPath, eventPadTriggered, 'area' , diffCount)]\n\t\t[macro(eventMacro+\"@Lib:EventMacros\"): args]\n\t}; {\n\t\t[macro.return = \"\"]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fed4c052-d6e2-4c8a-8634-eaff39dd1c80",
          "commandChecksum": "023d19e4505dd85e7b51c47826fbbfde",
          "propsChecksum": "02b5ce0f0355fc97e3c69d99ecebe18a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 94,
        "label": "EventPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------------- EventPad --------------------------------------------------->']\n<!-- NOTE THAT ALL OUTPUT IS IGNORED, SO THE ONLY WAY TO GET SOMETHING TO THE CHAT IS BY USING BROADCAST! -->\n<!-- Routine for an EventPad, EventPad is only triggered when the test subject is moved on or over the Eventtoken-->\n[h: eventPadTriggered = movedOverToken(padName,lastPath)]\n[h, if(!json.isEmpty(eventPadTriggered)), CODE:{\n\t<!-- check which event type this token triggers this can be \n\t- movedOn \n\t- movedOff \n\t- movedOver \n\t- movedNot\t\twhen you move the token but place it back on its original spot\n\t- movedReturn\twhen you move the token AND use way points AND leave the token but end the move onto the token\n\t- movedRemain\twhen you move but remain on the token during the entire move \n\t- movedWard\t\t(1001)\twhen you move the token over or onto a Ward -->\n\t[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", padName)]\n\t[h:eventType\t\t= bot_getEventType()]\n\t[h:triggered\t\t= listContains(eventTypeList, eventType)]\n\t<!-- With the use of the campaign macro you can set the name of the macro that should be called when the event is triggered-->\n\t[h,if(triggered),CODE:{\n\t\t[h:macroName = getProperty(\"w42.bot.macroName\", padName)]\n\t\t[h:args = json.append(\"\", tok, eventType, padName, lastPath, eventPadTriggered, 'pad')]\n\t\t[h,macro(macroName+\"@Lib:EventMacros\"): args]\n\t\t[bot_playPadSound(padName, tok)]\t\n\t}; {\n\t\t[h:macro.return=\"\"]\n\t}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "da82a723-c3c2-4a71-93ec-25d3555f99f5",
          "commandChecksum": "0c2db2f4a6f96b5d82ec55954325aff0",
          "propsChecksum": "6c63bdd62faa39504cc4e422e7dbbfcd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9b",
        "index": 95,
        "label": "Foliage",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------ FOLIAGE ------------------------------------------------->']\n[h:foliageTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(foliageTriggered)), CODE:{\n\t[switchToken(padName)]\n\t[inHouse = if(json.contains(foliageTriggered,currentLocation), 1, 0)]\n\t['foliageSwap(inHouse, tok, padName)']\n\n\t[args = json.append(\"\", inHouse, tok, padName, 0)]\n\t[macro(\"roofSwap@this\"): args]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7e9201a4-7b36-45ca-8e3f-9f261417386e",
          "commandChecksum": "1a87605ad375ad74665e1d874023fb7d",
          "propsChecksum": "ecfcfb685e69a11f44d2b252160709e1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 96,
        "label": "InterJump",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------ InterJump ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\n\t\t\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"\n\t))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9a2c0d54-38e4-4396-9262-8487c26e709e",
          "commandChecksum": "2a22c973262533392da12c3520136e6f",
          "propsChecksum": "653f84c1522c5b7eeea05d2ded976bcb"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 97,
        "label": "InterJumpBorder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------- InterJumpBorder ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c69f4bb9-b44c-4acf-875b-21ebfda64229",
          "commandChecksum": "9cbb860dbdd2cff9713aeaeb9d4aa3c1",
          "propsChecksum": "a023d849b1e1e18189e6fdd127490da2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 98,
        "label": "InterPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------INTERPAD------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "61c61792-6170-4236-b59e-291b99d10a01",
          "commandChecksum": "305b5c2925af1c060d4cf764e677e430",
          "propsChecksum": "600fc913bed8396866f34e4ffafc1515"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 99,
        "label": "InterPadBorder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------- InterPadBorder ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOn\t= json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOn): bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "391ca4e2-ccef-492a-ab05-ecda81976a33",
          "commandChecksum": "b145990cf1d2d05ec82032e13d61a361",
          "propsChecksum": "7c98fa433675be18ce47e0f38de95226"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "10",
        "index": 100,
        "label": "Linked",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------- LINKED ----------------------------------------------- -->']\n<!-- @@ 3 CODE LEVELS -->\n\n<!-- abort if moving on or over the pad -->\n[linkedTriggered\t= movedOverToken(padName,lastPath)]\n[h:startOnPad\t\t= if(json.contains(linkedTriggered,startingLocation), 1, 0)]\n[h:endOnPad\t\t\t= if(json.contains(linkedTriggered,currentLocation),  1, 0)]\n<!-- \"Linked 1 Roof 2\" == \"Match1 Match2 Match3 Match4\" -->\n[h:linkId\t\t\t= getGroup(strfind(padName, \"[^\\\\s]+\"), 2, 0)]\n[h:startLinkId\t\t= if(startOnPad, linkId, startLinkId)]\n[h:endLinkId\t\t= if(endOnPad, linkId, endLinkId)]\n\n['pause(\"linkedTriggered\",\"startOnPad\",\"endOnPad\",\"linkId\",\"lastLinkId\",\"startLinkId\",\"endLinkId\")']\n\n[h,if(!json.isEmpty(linkedTriggered) && startOnPad != endOnPad), CODE:{\n\t<!-- first check if you know what the end pad is and if not, figure it out. This is needed to make the right decision -->\n\t<!-- do NOT switchToken before movedOverToken as it then does NOT work. -->\n\t[if(startOnPad && endLinkId == \"\"), CODE:{\n\t\t[linkedAll\t\t= getProperty(\"w42.bot.linked\", padName)]\n\t\t[foreach(pad, linkedAll), CODE:{\n\t\t\t[tlinkedTriggered\t= movedOverToken(pad,lastPath)]\n\t\t\t[endLinkId\t\t\t= if(json.contains(tlinkedTriggered,currentLocation),  linkId, endLinkId)]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t<!-- if endLinkId remains empty then you moved OF the linked pads. If endlinkId == lastLinkId (it *can* have a different id) then you remained and nothing should be done. -->\n\t[if(endLinkID != lastLinkId), CODE:{\n\t\t[switchToken(padName)]\n\t\t[linkedBridge\t= getProperty(\"w42.bot.linkedBridge\")]\n\t\t[linkedTunnel\t= getProperty(\"w42.bot.linkedTunnel\")]\n\t\t[linkedSpecial\t= lower(getProperty(\"w42.bot.linkedSpecial\"))]\n\t\t<!-- If you ALSO moved over a \"Bridge\" token then do NOT activate -->\n\t\t[overBridge\t= 0]\n\t\t[foreach(pad, linkedBridge):overBridge\t= max(overBridge, !json.isEmpty(movedOverToken(pad,lastPath)))]\n\n\t\t<!-- If tunnels are linked ONLY activate the roof if moved over a tunnel -->\n\t\t[overTunnel\t= if(listCount(linkedTunnel), 0, 1)]\n\t\t[foreach(pad, linkedTunnel):overTunnel\t= max(overTunnel, !json.isEmpty(movedOverToken(pad,lastPath)))]\n\t\t\n\t\t<!-- if you move OFF a roof that is linked to a e.g. Canopy where you move ON to then the roof is handled last and all tokens are deactivated. To prevent this keep track of activation -->\n\t\t['activated\t= max(   eval(\"activated\"+linkId),min(!overBridge, overTunnel, endOnPad )   )']\n\t\t['set(\"activated\"+linkId, activated)']\n\n\t\t[activate\t= min(!overBridge, overTunnel, endOnPad)]\n\n\t\t<!-- execute all linked special pads -->\n\t\t[foreach(pad, linkedSpecial):bot_roofSwap(activate, tok, pad, if(bot_inStr(pad, \"roof\"),1,0), roofHaloColor)]\n\t\t\n\t\t['pause(\"linkedTriggered\",\"startOnPad\",\"endOnPad\",\"linkId\",\"lastLinkId\",\"startLinkId\",\"endLinkId\",\"lastPath\",\"padName\",\"tok\",\"pathPadList\",\"linkedAll\",\"linkedPads\", \"overBridge\",\"overTunnel\")']\n\t\t[switchToken(tok)]\n\t}]\n\t\n''\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ee1e57cc-151d-44a6-bf27-02f3caf9fcf0",
          "commandChecksum": "e5a131ba71a40e35c8c399c6414f525d",
          "propsChecksum": "0d8203204652a6e0546e001f323edce6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 101,
        "label": "MappedPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------ MappedPad ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[iMapped = eval(string(getProperty(\"w42.bot.MappedPad\", padName)))]\n\t[teleportEndName = \"MappedPad \" + iMapped)]\n\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "35eea412-ba42-4b97-aea7-f0dfabeca279",
          "commandChecksum": "c23f2ec307c977297277ca9bfbde5684",
          "propsChecksum": "803ea9afb8818cee06785a5f9121464f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 102,
        "label": "PadEnd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- TELEPORTS END ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"End\", \"Start\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b24cb0d0-f4fe-45e1-800c-86a030d3a825",
          "commandChecksum": "308a0c11d85b7d0094fdbbeb3003601b",
          "propsChecksum": "c0ede1031cf30235af548da2c083d41e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 103,
        "label": "PadEndBorder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- PadEndBorder ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOff\t= !json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOff): return(0,\"\")] <!-- or movedRemain -->\n\t[teleportEndName = replace(padName, \"End\", \"Start\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e483553a-5eb1-4de3-ae26-42ffb3a9a054",
          "commandChecksum": "40df9774c2aac51063c0f2c2a0936c88",
          "propsChecksum": "74d36a796586243c12b92de58b0c7e0f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 104,
        "label": "PadJump",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- PadJump ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"Jump\", \"Drop\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "206fb16b-ec48-4bc5-9d35-dca207cddbf5",
          "commandChecksum": "9154a7254cf26b9a756b94aba19ae6ca",
          "propsChecksum": "42bcdb67f24cf1b05d3f64dcbaaa57b1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 105,
        "label": "PadJumpBorder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- PadJumpBorder ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[teleportEndName = replace(padName, \"Jump\", \"Drop\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "04388f46-cd72-48ff-97d1-1775492f19d2",
          "commandChecksum": "ce8d1127995fe91f9f7ac9abac8206ab",
          "propsChecksum": "e8bc450e849c8a21b4469db2bdb3a080"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 106,
        "label": "PadStart",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- TELEPORTS START ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"Start\", \"End\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "af3ca7cf-b2c2-445a-85ad-7a102c37a697",
          "commandChecksum": "02247af6bc8d24204cb305b1082f674a",
          "propsChecksum": "96ae20e946332bddf0382056a39f2803"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 107,
        "label": "PadStartBorder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------- PadStartBorder ------------------------------------------------->']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOff\t= !json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOff): return(0,\"\")] <!-- or movedRemain -->\n\n\t\n\t[teleportEndName = replace(padName, \"Start\", \"End\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dc80bd9b-32f4-4f0f-bdf7-70e808295b92",
          "commandChecksum": "c9ab4d07d7b12855e3b8d0809c265c01",
          "propsChecksum": "e7664d8ad5c075c3ce7024ab0be2b997"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 108,
        "label": "Roof",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------ROOF------------------------------------------------->']\n[h:roofTriggered = movedOverToken(padName,lastPath)]\n<!-- abort if moving inside the building OR moved over the building -->\n[h: startInHouse\t= if(json.contains(roofTriggered,startingLocation), 1, 0)]\n[h: endInHouse\t\t= if(json.contains(roofTriggered,currentLocation),  1, 0)]\n[h: continue\t\t= if(startInHouse == endInHouse, 0, 1)]\n\n[h,if(!json.isEmpty(roofTriggered) && continue), CODE:{\n\t<!-- if doors are linked to the roof you can only enter the building through the door (if its open) -->\n\t[Doors = getProperty(\"w42.bot.Doors\", padName)]\n\t[wentThroughDoor = if(listCount(Doors), 0,1)]\n\t[doorClosed = 0]\n\t[foreach(door, Doors), CODE:{\n\t\t\t[doorTriggered\t= movedOverToken(door,lastPath)]\n\t\t\t[if(!json.isEmpty(doorTriggered)): wentThroughDoor = 1]\n\t\t\t[isClosed = if(getProperty(\"closedAngle\", door) == bot_getTokenFacing(door), 1, 0)]\n\t\t\t[if(isClosed && wentThroughDoor): doorClosed = 1]\n\t}]\n\t[switchToken(padName)]\n\t['pause(\"Doors\",\"wentThroughDoor\",\"doorTriggered\",\"lastPath\",\"roofTriggered\", \"startInHouse\", \"continue\")']\n\t[if(!isGM() && (!wentThroughDoor || doorClosed)),CODE:{\n\t\t[if(startInHouse)\t: iEntryPoint = json.length(roofTriggered)-1; iEntryPoint = json.indexOf (lastPath, json.get(roofTriggered, 0))-1]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint)]\n\t\t[x \t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t['pause(\"roofTriggered\", \"doorTriggered\", \"lastPath\", \"entryMod\", \"iEntryPoint\",\"edgePoint\",\"x\",\"y\", \"startInHouse\")']\n\t\t[moveToken(x, y, 1, tok)]\n\t\t[if(doorClosed):\n\t\t\tbroadcast(\"You need to open the door first, before you can \"+if(startInHouse,\"exit\",\"enter\")+\" the building\")\n\t\t; \n\t\t\tbroadcast(\"You can only \"+if(startInHouse,\"exit\",\"enter\")+\" this building through (one of) the door(s)\")\n\t\t]\n\t\t[continue = 0]\n\t}; {}]\t\t\n\t\n\t<!-- ROOFSWAP (inHouse, me, roofName, showHale) -->\n\t[if(continue): bot_roofSwap(endInHouse, tok, padName, 1, roofHaloColor)]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "78d498c9-98fe-486b-b033-cc384ab5204e",
          "commandChecksum": "e7b7d690943a2afea3ae9a26191e42d2",
          "propsChecksum": "f581ae18ed980e7c3031568bc1057fc8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "11",
        "index": 109,
        "label": "ShadowPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- ShadowPad -------------------------------->']\n[h:eventPadTriggered = movedOverToken(padName,lastPath)]\n[h:tok = getName(currentToken())]\n[h,if(!json.isEmpty(eventPadTriggered)), CODE:{\n\t[event\t= \tbot_getEventType()]\n\t[bot_doShadowPad(tok, event, padName)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4162967-2a71-47af-8936-f4227d308b8f",
          "commandChecksum": "c66208739420e06cd19b9992a7ab3334",
          "propsChecksum": "2975012d4402d03c2df535a1a1992b0b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "9",
        "index": 110,
        "label": "Ward",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------WARDED AREAS E.G. BARBED WIRE ON THE BASE MAP------------------------------->']\n[h:wardedPadTriggered = movedOverToken(padName,lastPath)]\n[h, if(!json.isEmpty(wardedPadTriggered)), CODE:{\n\t[entryPoint = json.get(wardedPadTriggered, 0)]\n\t[iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[edgePoint =  json.get(lastPath, iEntryPoint-1)]\n\t[lastPath =  json.get(lastPath, 0, iEntryPoint-1)]\n\t\n\t[x = json.get(edgePoint, \"x\")]\n\t[y = json.get(edgePoint, \"y\")]\n\t[moveToken(x, y)]\n\n\t[broadcast(\"This area is warded, you are not allowed to move there\")]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a26e540d-70b5-4504-9d5c-316e0d1d2488",
          "commandChecksum": "8965ee31229882ce8c0a993760563ddc",
          "propsChecksum": "4bb29195b39c4d15129554f7642b439d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 111,
        "label": "Clear Messages",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:abort(input(\n\t\"junkvar|Make sure you want to do this.|This action will erase ALL messages you have readied|label\",\n\t\"checkvar|No, Yes|Proceed?|radio|\"\n))]\n[h:abort(checkvar)]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",\"{}\",target); setProperty(\"Messages\",\"{}\",target)]\n\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68ee9176-db61-43c6-9cfd-2d3273dd3428",
          "commandChecksum": "4eefdf3580fa555d0de893903dfe460b",
          "propsChecksum": "bdc9cb520ba80da7ae4cafbe379ced4a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 112,
        "label": "Create New Message",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:abort(input(\n\t\"label|Msg1|Enter a label (no spaces) for this message data|text|width=20\",\n\t\"title|Important Info|Enter the title of the message (for the player to see)|text|width=20\",\n\t\"text|You are not illiterate|Enter the message text here|text|width=50\",\n\t\"italic|0|<html><i>Italic|CHECK\",\n\t\"bold|0|<html><b>Bold|CHECK\",\n\t\"underline|0|<html><u>Underline|CHECK\",\n\t\"color|black, gray, maroon, red, yellow, green, blue, navy, purple|Color|LIST\"\n))]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t\t= \"Lib:EventMacros\"\t\t\t\t; target\t\t= currentToken()]\n[h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target)\t; messages\t= getProperty(\"Messages\",target)]\n\n[h,if(json.type(messages)==\"UNKNOWN\"): messages\t= \"{}\"]\n[h:usedlabels\t\t= json.fields(messages)]\n[h:overwritecheck\t= 0]\n[h:done\t\t\t\t= 0]\n[h,while(!done),CODE:{\n\t[if(listFind(usedlabels,label) == -1),CODE:{\n\t\t[done\t\t= 1]\n\t}; {\n\t\t[abort(input(\n\t\t\t\"junkvar|Proceed How?|The label \"+label+\" already exists|label\",\n\t\t\t\"msglabel2|\"+label+\"(2)|Enter another name|text|width=20\",\n\t\t\t\"overwritecheck|0|Or check here to overwrite the previous message|check\"\n\t\t))]\n\t\t[if(overwritecheck==1): done = 1; label = msglabel2]\n\t}]\n}]\n\n<!-- initialize unused vars -->\n[h:picID\t\t= \"\"]\n[h:picSize\t\t= 0]\n[h:picPos\t\t= -1]\n\n[h:messageinfo\t= json.fromStrProp(strPropFromVars(\"title, text, italic, bold, underline, color, picID, picSize, picPos\",\"UNSUFFIXED\"))]\n[h:messages\t\t= json.set(messages,label,messageinfo)]\n\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "38ef7448-c29d-4ed4-8729-65a9f0dd545d",
          "commandChecksum": "da50b7bd85ef62d27d3f4e9ab72af36f",
          "propsChecksum": "66cae677a71744805888123b2529243c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 113,
        "label": "Delete Message",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:msglabel\t= macro.args]\n\n[h:abort(input(\t\"confpick|No, Yes|Confirm that you wish to delete \"+msglabel+\"|radio|\" ))]\n\n[h,if(confpick == 1), CODE:{\n\t [h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n\t [h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n\t [h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n\t [h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target); messages\t= getProperty(\"Messages\",target)]\n\t [h:messages\t= json.remove(messages,msglabel)]\n\t [h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n}; {}]\n\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad2ff61f-de55-48e6-b117-16280b8b115e",
          "commandChecksum": "344510013c8883ed2b57d977f3bc0025",
          "propsChecksum": "9a4d07e329419f7b85e4c7b5fab0d42b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 114,
        "label": "Edit Message",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:debug=0]\n[h:varsFromStrProp(macro.args)]\n[h:msglabelbefore\t= msglabel]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target); messages\t= getProperty(\"Messages\",target)]\n[h:colors\t\t\t= \"black, gray, maroon, red, yellow, green, blue, navy, purple\"]\n\n[h:messageinfo\t\t= json.get(messages,msglabel)]\n[h:varsFromStrProp(json.toStrProp(messageinfo))]\n[h,if(addPic):\tpicID\t= bot_showHandout(1)]\n\n[h,if(picID != \"\"), CODE:{\n\t[toFind\t\t= strfind(picID, \"(.*)-(.*)\")]\n\t[tmp\t= getFindCount(toFind)]\n\t[if(getFindCount(toFind)), CODE:{\n\t\t[picID\t\t= getGroup(toFind,1,1)]\n\t\t[picSize\t= getGroup(toFind,1,2)]\n\t}]\n\n\t[imageStr\t= \"<html><table><tr><td>Yes<\/td><td height='100'><img width=90 height=90 src='\"+picID+\"'><\/img>\t<\/td><\/tr><\/table><\/html>\"]\n\t[showPic\t= \"picHide|\"+imageStr+\", No, Remove|Show picture|RADIO|ORIENT=H SELECT=0\"]\n\t[showSize\t= \"picSize|\"+picSize+\"|Size of picture (px)\"]\n\t[showPos\t= \"picPos|below text, above text|Where to show the picture|RADIO|ORIENT=H SELECT=0\"]\n};{\n\t[picID\t\t= \"\"]\n\t[picSize\t= 0]\n\t[picPos\t\t= -1]\n\t[picHide\t= 0]\n\t[showPic\t= \"\"]\n\t[showSize\t= \"\"]\n\t[showPos\t= \"\"]\n}]\n\n[h:abort(input(\n\t\"msglabel|\"+msglabel+\"|Label used to find this in the manager|text|width\t= 20\",\n\t\"title|\"+title+\"|Title shown in the text frame the player will see|text|width\t= 20\",\n\t\"text|\"+text+\"|Text of the message|text|width\t= 100\",\n\t\"italic|\"+italic+\"|<html><i>Italic|CHECK|\",\n\t\"bold|\"+bold+\"|<html><b>Bold|CHECK\",\n\t\"underline|\"+underline+\"|<html><u>Underline|CHECK\",\n\t\"color|black, gray, maroon, red, yellow, green, blue, navy, purple|<html><font color='\"+listGet(colors,color)+\"'><b>Color<\/b><\/font><\/html>|LIST|SELECT=\"+color,\n\tshowPic,\n\tshowSize,\n\tshowPos\n))]\n[h,if(debug): bot_debugInfo(\"addPic, picID, msglabel, picHide\")]\n\n[h,if(picHide), CODE:{\n\t[picPos\t= -1]\n\t[if(picHide\t== 2): picID = \"\"]\n};{}]\n\n[h:messageinfo\t= json.fromStrProp(strPropFromVars(\"title, text, italic, bold, underline, color, picID, picSize, picPos\",\"UNSUFFIXED\"))]\n\n[h,if(msglabel != msglabelbefore), CODE:{\n\t[abort(input(\n\t\t\"junkvar|You may copy or delete the original one|You have changed the label and will create a new msg|label\",\n\t\t\"copypick|Delete Original, Keep Original|Do which?|radio|\"\n\t))]\n\t[if(copypick == 0): messageinfo\t= json.remove(messageinfo,msglabelbefore)]\n}; {}]\n\n[h:usedlabels\t= json.fields(messageinfo)]\n[h:done\t\t\t= 0]\n\n[h,while(!done), CODE:{\n\t[if(listFind(usedlabels,msglabel)==-1),CODE:{\n\t\t[done\t= 1]\n\t}; {\n\t\t[abort(input(\n\t\t\t\"junkvar|Proceed How?|The label \"+msglabel+\" already exists|label\",\n\t\t\t\"msglabel2|\"+msglabel+\"(2)|Enter another name|text|width=20\",\n\t\t\t\"overwritecheck|0|Or check here to overwrite the previous message|check\"\n\t\t))]\n\t\t[if(overwritecheck==1): done = 1; msglabel = msglabel2]\n\t}]\n}]\n\n[h:messages\t= json.set(messages,msglabel,messageinfo)]\n\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dd5d68ba-051b-4d4a-9c7c-d3d88ebfcc56",
          "commandChecksum": "043b12c248121f45ce0cad26dd56805d",
          "propsChecksum": "81a9fded498e59e3024f41b335e1a5f2"
        }
      },
            {
        "autoExecute": false,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 115,
        "label": "Open Text Frame",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:msgpass\t= macro.args]\n[h:varsFromStrProp(json.toStrProp(msgpass))]\n[h:colors\t= \"black, gray, maroon, red, yellow, green, blue, navy, purple\"]\n\n[frame(title):{\n\t<font size='+2'><b>[r:title]<\/b><\/font><br><br>\n\t[r,if(picPos == 1)\t: strformat(\"<img width=%{picSize} height=%{picSize} src='%{picID}'><\/img><br>\")]\n\t[r,if(italic)\t: \"<i>\"]\n\t[r,if(bold)\t\t: \"<b>\"]\n\t[r,if(underline): \"<u>\"]\n\t[r,if(color)\t: \"<font color=\"+listGet(colors, color)+\">\"]\n\t[r:text]\n\t[r,if(italic)\t: \"<\/i>\"]\n\t[r,if(bold)\t\t: \"<\/b>\"]\n\t[r,if(underline): \"<\/u>\"]\n\t[r,if(color)\t: \"<\/font>\"]\n\t[r,if(picPos == 0)\t: strformat(\"<br><img width=%{picSize} height=%{picSize} src='%{picID}'><\/img>\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "769b630b-6c37-4b62-8021-a7ba775f1ddf",
          "commandChecksum": "a034e9293de77b685fa05ce3c78526a0",
          "propsChecksum": "7e56d32e94227fd01c07662d2c260e40"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 116,
        "label": "Reset Messages",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",\"{}\",target); setProperty(\"Messages\",\"{}\",target)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "938c6edc-1587-421f-af8c-339dee360704",
          "commandChecksum": "3d839e98ac50459d2aa9828cbf7f11d4",
          "propsChecksum": "baa4904b1be91565d5c3416c311eaff8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 117,
        "label": "Send Prepped Text Starter",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:playernames=listSort(getAllPlayerNames(),\"A\")]\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h,if(string(messageinfo)==\"\"): messageinfo\t= \"{}\"]\n[h:usedlabels\t= json.fields(messageinfo)]\n\n[h:inptext=\"junkvar|Send text frame to whom?|Text can be sent to any player|label\"]\n[h,foreach(playername,playernames),CODE:{\n\t[inptext\t= listAppend(inptext, \"Player\"+roll.count+\"|0|\"+playername+\"|check\", \"##\")]\n\t[num\t\t= roll.count]\n}]\n\n[h:abort(input(\n\tinptext,\n\t\"msgpick|\"+usedlabels+\"|Which message do you want to send?|list|select=0 value=string\"\n))]\n\n[h:varvar=0]\n[c(num+1,\"\"), CODE: {\n\t[if(eval(\"Player\"+varvar) == 1),CODE:{\n\t\t[h:playername\t= listGet(playernames,varvar)]\n\t\t[macro(\"Send Prepped Text Wrap@this\"):playername+\",\"+msgpick]\n\t}; {}]\n\t[h:varvar\t= varvar + 1]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6326998e-7d40-430f-9799-dde8147f1c67",
          "commandChecksum": "f50c73c22fd9b8dda59ff01e31d54b03",
          "propsChecksum": "59a7f2582e8e251d152078e9aad7498e"
        }
      },
            {
        "autoExecute": false,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 118,
        "label": "Send Prepped Text Wrap",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:passed\t\t= macro.args]\n[h:playername\t= listGet(passed,0)]\n[h:msgpick\t\t= listGet(passed,1)]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h:indivmsginfo\t= json.get(messageinfo,msgpick)]\n\n[r,w(playername): \"The GM has info for you. Click \"+macroLink(\"here\",\"Open Text Frame@this\",\"none\",indivmsginfo,target)+\" to review it.\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c7d26c0b-7e3f-447c-8887-6e7345003d9c",
          "commandChecksum": "35e0904fac1013dc1d9fe8f4107c944b",
          "propsChecksum": "d3d6681b8e0f6925bc209668a53a1cb0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "20",
        "index": 119,
        "label": "View Messages Text",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:fullview\t= macro.args]\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h,if(target == currentToken()): tokenImg\t= getTokenImage(); tokenImg\t= getImage(target)]\n[h:output\t= strformat(\n\t\"<table><tr valign=top><td><img src='%{tokenImg}-50' /><\/td><td><font size='+2'><b>Message Manager<\/b><\/font><br>%s -- %s<\/td><\/tr><\/table><br>\",\n\t macroLink(\"Add Message\",\"Create New Message@this\",\"none\",\"\",target),\n\t macroLink(\"Delete All\",\"Clear Messages@this\",\"none\",\"\",target)\n)]\n\n[h,if(string(messageinfo) == \"\"): messageinfo\t= \"{}\"]\n[h:messagelabels\t= json.fields(messageinfo)]\n[h,if(messagelabels == \"\"): output\t= output + \"(No messages saved)\"]\n[h:messagelabels\t= listSort(messagelabels, \"A\")]\n\n[h:messages\t= \"\"]\n[h,foreach(label,messagelabels),CODE:{\n\t [indivmsginfo\t= json.get(messageinfo,label)]\n\t [msgtext\t\t= json.get(indivmsginfo, \"text\")]\n\t [messages\t\t= listAppend(messages,\n\t\t\t\"<b>(\"+label+\"):<\/b><font size='-2'> -- \"\n\t\t\t+macrolink(\"Send This\",\"Send Prepped Text From Menu@this\",\"all\",label,target)\t\t\t\t\t\t+\" -- \"\n\t\t\t+macroLink(\"Edit This\", \"Edit Message@this\",\"none\",strformat(\"msglabel=%{label};addPic=0\"),target)\t+\" -- \"\n\t\t\t+macroLink(\"Delete This\",\"Delete Message@this\",\"none\",label,target)\t\t\t\t\t\t\t\t\t+\" -- \"\n\t\t\t+macroLink(\"Add Selected Picture\",\"Edit Message@this\",\"none\",strformat(\"msglabel=%{label};addPic=1\"),target)\t+\"<\/font><br>\"\n\t\t\t+\"<b>\"+json.get(indivmsginfo, \"title\")+\":<\/b> \",\"<br><br>\")\n\t]\n\t[if(label != fullview), CODE: { \n\t\t\t[h,if(length(msgtext) >150): \n\t\t\t\tmessages\t= messages + substring(msgtext,0,100)+\"... <font size='-2'>\"+macroLink(\"View Full\",\"notes@this\",\"none\",label,target)+\"<\/font>\"\n\t\t\t; \n\t\t\t\tmessages\t= messages + msgtext\n\t\t\t]\n\t }; {\n\t\t\t[h:messages\t\t= messages + msgtext + \"<font size='-2'>\" + macroLink(\"Shorten\",\"notes@this\",\"none\",\"\",target) + \"<\/font>\"]\n\t }]\n}]\n[R: output + messages]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c138eb3d-043e-4fae-bdf1-604986ce28e0",
          "commandChecksum": "0240edb066d74efde73961a6d6e74b6f",
          "propsChecksum": "1f8ffb8acc50628a474a415c076ac2b7"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "f. Plothos Message Manager",
        "includeLabel": false,
        "sortBy": "0",
        "index": 120,
        "label": "notes",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- NOTES ------------------------------------------- -->']\n<!-- \n<html>\nThis macro allows you to store prepared messages and manage these.<br>\nFor GM's these will be store on lib:EventMacros, for players these will <br>\nbe stored on the token that they own (and is selected). <br>\nTo add a picture to a message: <br>\n- create the message (and save it). <br>\n- select the token that contains the image (can be token,portrait or handout).<br>\n- click 'add selected image' for that message. The rest should be simple.<br>\n<\/html>\n-->\n[h:fullview\t= macro.args]\n\n[frame(\"Messages\"):{\n\t[macro(\"View Messages Text@this\"):fullview]\n}]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3bfd8f26-f18f-4c36-87a8-3eb79f4734dd",
          "commandChecksum": "7b9c7c434db0506b3fbacfd621c379fe",
          "propsChecksum": "0267c196c1c74199eed08cfe4b4e8b20"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "4",
        "index": 121,
        "label": "HTMLMacroButton",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:bgColor\t= arg(1)]\n[h,if(argCount() > 5): shadow = arg(5); shadow = \"\")]\n[h,if(argCount() > 6): toolTip = arg(6); toolTip = \"\")]\n[h,if(argCount() > 7): args = arg(7); args = \"[]\")]\n[h,if(argCount() > 8): libType = arg(8); libType = \"@this\")]\n[h,if(argCount() > 9): output = arg(9); output = \"none\")]\n\n[h:btnformat\t= strformat(\"padding:0px; border-width:1pt; border-style:solid; border-color:black; text-align:center; white-space:nowrap; background-image:url(%{shadow}); background-color:%{bgColor};\")]\n \n<td width='[r:arg(0)]%'>\n\t<table width='100%' cellpadding='0' cellspacing='0'>\n\t\t<tr>\n\t\t\t<td style='[r:btnformat]'>\n\t\t\t\t<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>\n\t\t\t\t\t[r:macroLink(arg(3),arg(4)+libType,output,args)]\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/table>\n<\/td>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "32514b8d-1521-487c-b29f-da721b14e252",
          "commandChecksum": "37eadc2016ed58aadd18f2155ce97b5d",
          "propsChecksum": "a05cfdaf45cc8ebe9c7375fb2db51917"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "4",
        "index": 123,
        "label": "HTMLMacroImageButton",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h,if(argCount() > 5): shadow = arg(5); shadow = \"\")]\n[h,if(argCount() > 6): toolTip = arg(6); toolTip = \"\")]\n[h,if(argCount() > 7): args = arg(7); args = \"[]\")]\n[h,if(argCount() > 8): libType = arg(8); libType = \"@this\")]\n[h,if(argCount() > 9): output = arg(9); output = \"none\")]\n[h:shownImage = strformat(\"<img src='%s' border='0' height='30' width='30' alt='%{toolTip}'/>\",arg(3))]\n\n<td width='[r:arg(0)]%'>\n\t\t<table bgcolor='[r:arg(1)]'>\n\t\t\t<td align='center' style=\"background-image:url([r:shadow]); \" >\n\t\t\t\t<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>[r:macroLink(shownImage,arg(4)+libType,output,args)]<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n<\/td>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2213007a-a7c2-46d8-8ac1-8df054f708c0",
          "commandChecksum": "ade3df5634b5084782b1729ad0b192c6",
          "propsChecksum": "1c10f3b449e02ff2f32ddeadbefbc719"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "yellow",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "3",
        "index": 124,
        "label": "MacroButtonsGroupMove",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- MacroButtonsGroupMove  -->']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Group Move Macros\", \"width=100; height=310; temporary=1; input=1\"): {\n\t\t[r:bot_createMacroButtonsGroupMove()]\n\t}]\n};{\n\t[frame(\"Group Move Macros\", \"width=100; height=310; temporary=1\"): {\n\t\t[r:bot_createMacroButtonsGroupMove()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "37d73ddc-45bb-47b7-9bab-53964129d78e",
          "commandChecksum": "fb0941f4992e4e09d6cf119f3d403ed6",
          "propsChecksum": "9a5bc4a70e4d31fb4ba7a5373d126636"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "0",
        "index": 125,
        "label": "MacroButtonsOTMSetup",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- MacroButtonsOTMSetup  -->']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9ebe420a-4d67-49ae-b222-72f8eb2c209a",
          "commandChecksum": "efe1abe859049b22c53835c3542856ee",
          "propsChecksum": "98e0418c8b39b9927d3276ff9b0f6b79"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "0",
        "index": 126,
        "label": "MacroButtonsOTMUtils",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- MacroButtonsOTMUtils  -->']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMUtils()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMUtils()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3b5ff767-4b41-4925-896b-7f68a319a330",
          "commandChecksum": "a6b8560e63824829855527e4045e3596",
          "propsChecksum": "367baf9e31b0e62c2a4b047514a639a7"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "3",
        "index": 127,
        "label": "createMacroButtonsGroupMove",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- createMacroButtonsGroupMove -->']\n\n[h:'<!-- bot_HTMLMacroImageButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']\n\n[h:bColor\t\t='#e5e5cc']\n\n[h: out \t\t= '#BDBDFF']\n[h: in \t\t\t= '#9595FF']\n[h: inner \t\t= '#0000FF']\n[h: innerOFF\t= '#8888FF']\n[h: font \t\t= 'Yellow']\n\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n[h: shadow = tblImage(\"tbl_Image\",2)]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='0' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=1 cellspacing='0' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadding=2 cellspacing='0' bgcolor='%{bColor}'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine  = \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd = \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor='[r:bColor]' style='font-size:8.5px; text-align:center'>\n<table width='100%' cellpadding='1' cellspacing='0'><tr><td>\n\n[h:groupTitle = \"Group Move\"]\n[r:strformat(macroGroup)]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",3), \"rotateCW\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Rotate Group Clockwise<\/b>Select a <i>group<\/i> token and rotate the other corresponding group tokens around it<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",4), \"rotateCCW\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Rotate Group Counter Clockwise<\/b>Select a <i>group<\/i> token and rotate the other corresponding group tokens around it<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",5), \"spreadGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Spread Group<\/b>Select one token of a group and spread the other tokens with an offset of X=1 and Y=1<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",6), \"contractGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Contract Group<\/b>Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",7), \"formationWedge\", \tshadow, \"<html><bgcolor=red color=yellow><b>Wedge formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",8), \"formationPWedge\",\tshadow, \"<html><bgcolor=red color=yellow><b>Packed Wedge formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",9), \"formationLine\",\tshadow, \"<html><bgcolor=red color=yellow><b>Line formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",10), \"formationEchelon\",shadow, \"<html><bgcolor=red color=yellow><b>Echelon formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",11), \"formationStagger\",shadow, \"<html><bgcolor=red color=yellow><b>Stagger formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",12), \"formationSquare\",shadow, \"<html><bgcolor=red color=yellow><b>Square formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",13), \"setGroup\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Set Group<\/b> Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",14), \"clearGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Clear Group<\/b> Select one token from a group and use this macro to clear the ENTIRE group<\/html>\")]\n[r:macroGroupEnd]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "872c456d-c50c-444e-b455-75754e28439c",
          "commandChecksum": "cdb1ded09c23ec7b6445200a6c57ec1b",
          "propsChecksum": "ec90038f623d58cc873a25fb2c909d33"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "orange",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "2",
        "index": 128,
        "label": "createbuttonDB",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName\t\t\t, shadow, toolTip, arguments, macro location, output to) -->']\n[h:Manual\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Manual\"\t\t\t\t, \"manualText\"\t\t\t, shadow, \"<html>This pops up a user manual of this tool<\/html>\"))]\n[h:Settings\t\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Settings\"\t\t\t\t, \"settings\"\t\t\t, shadow, \"<html>Here you can set stuff as a different name for BASE map.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:BoTFeatures\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"BoT Features\"\t\t\t, \"featureTable\"\t\t, shadow, \"<html><html>Change the installed BoT features.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:InitializePads\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Initialize Pads\"\t\t, \"initializePads\"\t\t, shadow, \"<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way<\/html>\"))]\n[h:AltInitPads\t\t= encode(bot_HTMLMacroButton(50,\"purple\",\"yellow\",\"Alt. Init. Pads\"\t\t, \"altInitMap\"\t\t\t, shadow, \"<html>In contrast to initialize Pads, this macro does ONLY initialize the CURRENT map.<br> It uses a completely different and more time consuming method for this.<br>Resulting in a map where the movement of tokens is less snappy in general<br> But will be (a lot) faster when there are a lot (>100) special tokens on a map.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:ActivateSwitches\t= encode(bot_HTMLMacroButton(50,\"#FFA500\",\"black\",\"Activate Switches\"\t\t, \"openFrame\"\t\t\t, shadow, \"<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br><\/html>\"))]\n[h:ClearSound\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Clear all sounds\"\t\t, \"clearSound\"\t\t\t, shadow, \"<html>This stop ALL sounds currently streaming/playing AND removes them from memory<\/html>\"))]\n[h:SetSound\t\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Setup Sound Pad\"\t\t, \"setupSound\"\t\t\t, shadow, \"<html>To setup sound pads<\/i> macro, select one SoundPad token and click this button to set it up<\/html>\"))]\n[h:ReplaceSoundURL\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"S&R all sound URL\"\t\t, \"changeAdress\"\t\t, shadow, \"<html>This search and replaces all URLs for ALL soundpads in the campaign file<\/html>\"))]\n[h:SetDoor\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Door\"\t\t\t\t, \"setDoor\"\t\t\t\t, shadow, \"<html>To use the <i>Toggle Door(s)<\/i> macro, select one or more doors and click this button to set it up<\/html>\"))]\n[h:SetRoof\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Roof\"\t\t\t\t, \"setRoof\"\t\t\t\t, shadow, \"<html>Here you can give a list of <i>entry doors<\/i> through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the <i>roof<\/i> token<\/html>\"))]\n[h:BuildForest\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Build Forest\"\t\t\t, \"buildForest\"\t\t\t, shadow, \"<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area<\/html>\"))]\n[h:ChooseTrunks\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Choose Trunks\"\t\t\t, \"chooseTrunks\"\t\t, shadow, \"<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>\"))]\n[h:CreateCrowd\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Create Crowd\"\t\t\t, \"createCrowd\"\t\t\t, shadow, \"<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the <i>move crowd<\/i> macro<\/html><\/html>\"))]\n[h:ChooseCrowd\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Choose Crowd\"\t\t\t, \"chooseCrowd\"\t\t\t, shadow, \"<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>\"))]\n[h:ScatterTokens\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Scatter Tokens\"\t\t, \"scatter\"\t\t\t\t, shadow, \"<html>This macro will <i>scatter<\/i> selected tokens over the map, according to the set parameters<\/html>\"))]\n[h:MassVBL\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Mass VBL\"\t\t\t\t, \"MassVBL\"\t\t\t\t, shadow, \"<html>This function draws VBL crosses on all tokens that match a search string\"))]\n[h:DrawArea\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"0. Draw Area\"\t\t\t, \"toggleAreaDraw\"\t\t, shadow, \"<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown.<\/html>\"))]\n[h:SetEventPad\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Event Pad\"\t\t\t, \"setEventPad\"\t\t\t, shadow, \"<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set\"))]\n[h:FillArea\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"1. Fill Area\"\t\t\t, \"fillArea\"\t\t\t, shadow, \"<html>This macro fills a predefined area with tokens<\/html>\"))]\n[h:ResetPit\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Reset Pit\"\t\t\t\t, \"resetPit\"\t\t\t, shadow, \"<html>This will show a pop-up with all the initialized doors. Here you can select which to open/close<\/html>\"))]\n[h:DefineArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"2. Define Area\"\t\t, \"defineArea\"\t\t\t, shadow, \"<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.<\/html>\"))]\n[h:SetEventButton\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Event Button\"\t\t, \"setEventButton\"\t\t, shadow, \"<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. 'Switch to Fair Haven'<br>3. Run this macro<br>4. Select 'Switch Map' from the list<br>5. In the 'Give Arguments' box enter the arguments as a stringproperty, e.g.'toMap\t\t\t= Fair Haven'<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap\t\t\t= Fair Haven;message\t\t\t= Going to Fair Haven.<br><br>6. Click OK. Now everything is set up<br><br>To use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>make this pop-up small, but you cannot close it (else the buttons will not work).<br><br>If you now click on the button 'Switch to Fair Haven' the macro 'Switch Map' is activated.<\/html>\"))]\n[h:AssignArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"3. Assign Area\"\t\t, \"assignArea\"\t\t\t, shadow, \"<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself<\/html>\"))]\n[h:UnShowArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"4. (Un)Show Area\"\t\t, \"showArea\"\t\t\t, shadow, \"<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.<\/html>\"))]\n[h:UnShowAreaUtil\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"(Un)Show Area\"\t\t, \"showArea\"\t\t\t, shadow, \"<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.<\/html>\"))]\n[h:AssignTokens\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Assign Tokens\"\t\t\t, \"assignPads\"\t\t\t, shadow, \"<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br><\/html>\"))]\n[h:Execute\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Execute\"\t\t\t\t, \"execAssignPads\"\t\t, shadow, \"<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br><\/html>\"))]\n[h:CreateTable\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Create Table\"\t\t\t, \"createTable\"\t\t\t, shadow, \"<html>With this macro you can create a new BoT table by copy pasting a table from e.g. excel<br>into the text box. You can use bot_table(tableName, optional: column, row) to retrieve<br>an entry from that table.<\/html>\"))]\n[h:ShowTable\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Show Table\"\t\t\t, \"showTable\"\t\t\t, shadow, \"<html>This macro shows a list of all available BoT tables. The one you pick can be edited.<\/html>\"))]\n[h:DeleteTable\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Delete Table\"\t\t\t, \"deleteTable\"\t\t\t, shadow, \"<html>This macro shows a list of all available BoT tables. The one you pick will be deleted.<\/html>\"))]\n[h:CreateMTTable\t= encode(bot_HTMLMacroButton(50,\"blue\",\"white\",\"Create MT Table\"\t\t, \"xls2Table\"\t\t\t, shadow, \"<html>With this macro you can create a new MAPTOOL table by copy pasting a table from e.g. excel<br>into the text box. Pasted entries should be seperated by tabs and newlines (which happens)<br>automatically if you paste it from excel. Next to that you can use either 1, 2 or 3 entries<br>Where the first entry is the start of the roll, the 2nd is the end of the roll range<br>the third is the value so either:<br><i>You summon a dragon<\/i><br>2  <i>You summon a dragon<\/i><br>2  5  <i>You summon a dragon<\/i><br><\/html>\"))]\n[h:MapEditor\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Map Editor\"\t\t\t, \"mapEditor\"\t\t\t, shadow, \"<html>Creates a filed where creating a token map becomes really easy. Hit this button for more info.<\/html>\"))]\n[h:QuitMapEditor\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Quit Map Editor\"\t\t, \"quitEditor\"\t\t\t, shadow, \"<html>Stops the Map editor (and removes the editor field)<html>\"))]\n[h:MovetoHidden\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Move to Hidden\"\t\t, \"moveToHidden\"\t\t, shadow, \"<html>Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so theyre no longer visible.<\/html>\"))]\n[h:MovetoToken\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Move to Token\"\t\t, \"moveToToken\"\t\t\t, shadow, \"<html>Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer.<html>\"))]\n[h:SeekToken\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Seek Token\"\t\t\t, \"seekToken\"\t\t\t, shadow, \"<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use.<\/html>\"))]\n[h:SetLightSource\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Light Source\"\t\t, \"setLightSource\"\t\t, shadow, \"<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , <\/b><\/html>\"))]\n[h:SetReference\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Reference\"\t\t\t, \"setReference\"\t\t, shadow, \"<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions.<\/html>\"))]\n[h:Remove20\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Remove %20\"\t\t\t, \"removeP20\"\t\t\t, shadow, \"<html>This macro replaces %20 with spaces > < in the selected token names<\/html>\"))]\n[h:SetDrawOrder\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Draw Order\"\t\t, \"setDrawOrder\"\t\t, shadow, \"<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token<\/html>\"))]\n[h:RenumberTokens\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Renumber Tokens\"\t\t, \"renumberToks\"\t\t, shadow, \"<html>When you have used the scatter function<br> (especially icw Spread) then can<br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map.<\/html>\"))]\n[h:ToggleSpecial\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Toggle Special\"\t\t, \"toggleSpecial\"\t\t, shadow, \"<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.<\/html>\"))]\n[h:SetTokenSize\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Token Size\"\t\t, \"setTokSize\"\t\t\t, shadow, \"<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you wont be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens\"))]\n[h:CopyDelMacros\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Copy/Del Macros\"\t\t, \"cpyDelMacros\"\t\t, shadow, \"<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>  \"))]\n[h:PasteMacros\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Paste Macros\"\t\t\t, \"pasteMacros\"\t\t\t, shadow, \"<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>\"))]\n[h:UndoDelMacros\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Undo Del. Macros\"\t\t, \"undoDelMacros\"\t\t, shadow, \"<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html> \"))]\n[h:FindDuplicates\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Find Duplicates\"\t\t, \"findDuplicates\"\t\t, shadow, \"<html>Give a list of all tokens of all layers on current map that have the same name<\/html>\"))]\n[h:PadExplorer\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Pad Explorer\"\t\t\t, \"initializeMap\"\t\t, shadow, \"<html>This macro shows all special pads on the current map.<\/html>\"))]\n[h:AutoDisguiseBttn\t= encode(bot_HTMLMacroButton(50,\"gray\",\"white\",\"Auto Disguise Bttn\"\t\t, \"autoDisguiseButton\"\t, shadow, \"<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>\"))]\n[h:SetVBLStamp\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Set VBL Stamp\"\t\t\t, \"setVBLStamp\"\t\t\t, shadow, \"<html>This function applies a VBL (Vision Blocking Layer) upon a token.<br>The VBL will move with the token as you move it.\"))]\n[h:MassVBL\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Mass VBL\"\t\t\t\t, \"MassVBL\"\t\t\t\t, shadow, \"<html>This function draws VBL crosses on all tokens that match a search string\"))]\n[h:ToggleVBL\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Toggle VBL\"\t\t\t, \"toggleMassVBL\"\t\t, shadow, \"<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off\"))]\n[h:Deleteprops\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"DELETE props\"\t\t\t, \"deleteProps\"\t\t\t, shadow, \"<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!!\"))]\n[h:Benchmark\t\t= encode(bot_HTMLMacroButton(50,\"purple\",\"white\",\"Benchmark\"\t\t\t, \"benchmark\"\t\t\t, shadow, \"<html>This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br>and compares their individual times. It uses an empty loop (Default in that group) as<br> reference as deducts that resulting time from the added macros. <br><br>To make use of this, create one or more macros in that group with ONLY the code that you<br>wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br>to test. The higer the number the more accurate the result, but obviously it will take more<br>time to run\", \"\", \"@this\", \"all\"))]\n[h:DiagnoseMaps\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Diagnose Maps\"\t\t\t, \"diagnose\"\t\t\t, shadow, \"<html>Map Error Checks. This function checks ALL maps and ALL (lib)tokens for potential issues.<br>It checks whether token names contain non-alphanumerical characters and checks the libs for the<br>same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br>you to the token. <\/html> \", \"\", \"@this\", \"all\"))]\n[h:CleanTokNames\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Clean Tok Names\"\t\t\t, \"cleanTokNames\"\t\t, shadow, \"<html>There are certain characters e.g. @ # & that, when used in a token name,<br>can potentially break a macro IF that macro uses that token name. An obvious<br>example is getTokenNames(,) which returns a , seperated list. Should one of<br>the tokens in that list be called e.g. <i>Fire Elemental, Giant<\/i> than the list<br>would thus consist out of <i>Fire Elemental<\/i> and <i>Giant<\/i>. <br><br>This macro tracks these tokens down and reports them in the chat. You then have<br>the choice to either fix them automatically or not.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:Door\t\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Toggle Door\"\t\t\t, \"toggleDoor\"\t\t\t, shadow, \"<html>Select a door (that has been initialized) and click this button to open or close it<\/html>\",\"\"))]\n[h:Doors\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"yellow\",\"Toggle Door<b>s<\/b>\"\t, \"toggleDoors\"\t\t\t, shadow, \"<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close<\/html>\"))]\n[h:Lock\t\t\t\t= encode(bot_HTMLMacroButton(50,\"Blue\",\"yellow\",\"Toggle Lock\"\t\t\t, \"toggleLock\"\t\t\t, shadow, \"<html>This will toggle the Lock State of a door. Select the door first.<\/html>\"))]\n[h:MoveCrowd\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Move Crowd\"\t\t\t, \"moveCrowd\"\t\t\t, shadow, \"<html>Disperses a crowd created by the <i>Create Crowd<\/i> macro.<br>Make sure the antagonist is on the map.<\/html>\"))]\n[h:MoveCrowdP\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Move Crowd+\"\t\t\t, \"moveCrowdPlus\"\t\t, shadow, \"<html><html>Disperses a crowd created by the <i>Create Crowd<\/i> macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)<\/html>\"))]\n[h:MoveToken\t\t= encode(bot_HTMLMacroButton(50,\"Blue\",\"yellow\",\"Move Token\"\t\t\t, \"animateMove\"\t\t\t, shadow, \"<html>This macro will animate the movement of the selected token. An options panel will be shown first.<\/html>\"))]\n[h:AnimateText\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Animate Text\"\t\t\t, \"animateTextInput\"\t, shadow, \"<html>This will open an input screen where you can set-up animated text.<br>This text will be send and animated within a frame to every attached<br>client pc.<\/html>\"))]\n[h:ExecuteEvent\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Execute Event\"\t\t\t, \"executeEvent\"\t\t, shadow, \"<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed<\/html>\"))]\n[h:ExecAssignpad\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Exec Assignpad\"\t\t, \"execAssignPads\"\t\t, shadow, \"<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br><\/html>\"))]\n[h:DiceBox\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Dice Box\"\t\t\t\t, \"Launch Dice Box\"\t\t, shadow, \"<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually.\"))]\n[h:SwitchMap\t\t= encode(bot_HTMLMacroButton(50,\"orange\",\"black\",\"Switch Map\"\t\t\t, \"switchMap\"\t\t\t, shadow, \"<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.<\/html>\",\"\"))]\n[h:UseDisguise\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Use Disguise\"\t\t\t, \"useDisguise\"\t\t\t, shadow, \"<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html> \"))]\n[h:ShowHandout\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Show Handout\"\t\t\t, \"showHandout\"\t\t\t, shadow, \"<html> Pops up a dialog showing the handout of the selected token on all selected clients.<\/html>\"))]\n[h:WhisperFrame\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Whisper Frame\"\t\t\t, \"whisperFrame\"\t\t, shadow, \"<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!).<\/html>\"))]\n[h:MessageMngr\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Message Mngr\"\t\t\t, \"notes\"\t\t\t\t, shadow, \"<html>This macro allows you to store prepared messages and manage these.<br>For GMs these will be store on lib:EventMacros, for players these will <br>be stored on the token that they own (and is selected). <br>To add a picture to a message: <br>- create the message (and save it). <br>- select the token that contains the image (can be token,portrait or handout).<br>- click add selected image for that message. The rest should be simple.<br><\/html>\"))]\n[h:GroupMove\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Group (Move)\"\t\t\t, \"setGroup\"\t\t\t, shadow, \"<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved<\/html>\"))]\n[h:UngroupMove\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Ungroup (Move)\"\t\t, \"clearGroup\"\t\t\t, shadow, \"<html>Select one token from a <i>move<\/i> group and use this macro to clear the ENTIRE group<\/html>\"))]\n[h:Formations\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Formations\"\t\t\t, \"MacroButtonsGroupMove\",shadow, \"<html>Open the group move macro frame.<br>Note that it can appear behind this panel.<\/html>\"))]\n[h:SummonTokens\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Summon Tokens\"\t\t\t, \"summonToken\"\t\t\t, shadow, \"<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.<\/html>\"))]\n[h:ActivateGroup\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Activate Group\"\t\t\t, \"openGroupFrame\"\t\t, shadow, \"<html>This opens a <i>group select<\/i> frame which is required for the <i>Select Group<\/i> to function.<br>When this panel is closed you can still group and ungroup, but the <i>auto select<\/i> will only<br>work when this frame is active.<\/html>\"))]\n[h:GroupSelect\t\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Group (Select)\"\t\t\t, \"setSelectGroup\"\t\t, shadow, \"<html>This macro creates a <i>select group<\/i> of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.<\/html>\"))]\n[h:UngroupSelect\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Ungroup (Select)\"\t\t, \"clearSelectGroup\"\t, shadow, \"<html>This ungroups a <i>Select Group<\/i>. You only need to select one token of the group to ungroup the entire group <\/html>\"))]\n[h:VBLGrenade\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"VBL Grenade\"\t\t\t, \"VBLGrenade\"\t\t\t, shadow, \"<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.<\/html>\"))]\n[h:LockMovement\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"red\",\"Lock Movement\"\t\t\t, \"movementLock\"\t\t, shadow, \"<html>When this is turned ON, no PLAYER can move a token, only the GM can.<\/html>\"))]\n[h:LockToken\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"red\",\"Lock Token\"\t\t\t\t, \"tokenLock\"\t\t\t, shadow, \"<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: <i>Lock Movement for Locked Tokens<\/i> needs to be turned on!<\/html>\"))]\n[h:MoveEventOn\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Move Event is<br>Turned ON\"\t\t\t, \"toggleOnTokenMove\"\t, shadow, \"<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:MoveEventOff\t\t= encode(bot_HTMLMacroButton(50,\"gray\",\"dark gray\",\"Move Event is<br>turned OFF \"\t, \"toggleOnTokenMove\"\t, shadow, \"<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:FullScreenModeOn\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Full Screen<br>Mode is ON\"\t\t\t, \"toggleFullScreen\"\t, shadow, \"<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.<\/html>\"))]\n[h:FullScreenModeOff= encode(bot_HTMLMacroButton(50,\"gray\",\"dark gray\",\"Full Screen<gr>Mode is OFF\"\t\t, \"toggleFullScreen\"\t, shadow, \"<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.<\/html>\"))]\n[h:ShowDescription\t= encode(bot_HTMLMacroImageButton(50,\"gray\",\"white\",tblImage(\"tbl_Image\",26)\t\t, \"showDescription\"\t\t, shadow, \"<html><bgcolor=red color=yellow><b>Nildiks Room Description Button<\/b><br>Select a <i>Room Description<\/i> token and hit this button <br>(See Manual for more info)<\/html>\"))]\n[h:roomDescrHelp\t= encode(bot_HTMLMacroImageButton(50,\"gray\",\"white\",tblImage(\"tbl_Image\",31)\t\t, \"roomDescrHelp\"\t\t, shadow, \"<html><bgcolor=red color=yellow><b>Nildiks Room Description HELP<\/b><br>A reference overview of the tags for Nildiks Room Descriptor<br><\/html>\"))]\n[h:StartInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Start Invisibility\"\t, \"Start Invisibility\"\t, shadow, \"<html>Makes a token invisible<br>\"))]\n[h:EndInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"End Invisibility\"\t\t, \"endInvisibility\"\t\t, shadow, \"<html>Makes a token visible<br>\"))]\n[h:SeeInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"See Invisibility\"\t\t, \"seeInvisibility\"\t\t, shadow, \"<html>Token can see invisible tokens in range<br>\"))]\n[h:SawInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Saw Invisibility\"\t\t, \"sawInvisibility\"\t\t, shadow, \"<html>Stop seeing invisible tokens<br>\"))]\n[h:PurgeInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Purge Invisibility\"\t, \"purgeInvisibility\"\t, shadow, \"<html>Negates invisibility for tokens as longs as they are in range<br>\"))]\n[h:PurgedInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Purged Invisibility\"\t, \"purgedInvisibility\"\t, shadow, \"<html>Stop negating invisibility<br>\"))]\n[h:AnulInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Anul Invisibility\"\t\t, \"anulInvisibility\"\t, shadow, \"<html>Permanently destroys invisibility on tokens in range<br>\"))]\n[h:AnulledInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Anulled Invisibility\"\t, \"anulledInvisibility\"\t, shadow, \"<html>Stop destroying invisibility<br>\"))]\n[h:resetRanges\t\t= encode(bot_HTMLMacroButton(50,\"#006000\",\"white\",\"Reset Ranges\"\t\t, \"resetRanges\"\t\t\t, shadow, \"<html>Resets invisibility related ranges on selected tokens<br>\"))]\n[h:changeElevation\t= encode(bot_HTMLMacroButton(50,\"#006000\",\"white\",\"Change Elevation\"\t, \"changeElevation\"\t\t, shadow, \"<html>Set the elevation for the selected tokens<br>\"))]\n[h:setAnimateView\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Animate View\"\t\t, \"setAnimateView\"\t\t, shadow, \"<html>Use lastpath of selected token to run a screen animation<br>\"))]\n[h:linkViewAnim\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Link View Animations\"\t, \"linkViewAnimations\"\t, shadow, \"<html>Run view animation created for selected token<br>\"))]\n[h:runAnimateView\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Run Animate View\"\t\t, \"runAnimateView\"\t\t, shadow, \"<html>Link the view animation of selected tokens and store it on one token<br>\"))]\n[h:embarkation\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Embarkation\"\t\t\t, \"embarkation\"\t\t\t, shadow, \"<html>With this macro you can move (N)PC tokens inside a vehicle.<br>\"))]\n[h:toggleEmbark\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Toggle Embark\"\t\t\t, \"toggleEmbark\"\t\t, shadow, \"<html>IF PCs are embarked on a vehicle you can quickly (dis)embark them<br>\"))]\n\n[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']\n\n[h:menuButtons\t\t= strPropFromvars(\"Manual,Settings,BoTFeatures,InitializePads,AltInitPads,ActivateSwitches,SetSound,ClearSound,ReplaceSoundURL,SetDoor,SetRoof,BuildForest,ChooseTrunks,CreateCrowd,ChooseCrowd,ScatterTokens,MassVBL,DrawArea,SetEventPad,FillArea,ResetPit,DefineArea,SetEventButton,AssignArea,UnShowArea,UnShowAreaUtil,AssignTokens,Execute,CreateTable,ShowTable,DeleteTable,CreateMTTable,MapEditor,QuitMapEditor,MovetoHidden,MovetoToken,SeekToken,SetLightSource,SetReference,Remove20,SetDrawOrder,RenumberTokens,ToggleSpecial,SetTokenSize,CopyDelMacros,PasteMacros,UndoDelMacros,FindDuplicates,PadExplorer,AutoDisguiseBttn,SetVBLStamp,MassVBL,ToggleVBL,Deleteprops,Benchmark,DiagnoseMaps,CleanTokNames,Door,Doors,Lock,MoveCrowd,MoveCrowdP,MoveToken,AnimateText,ExecuteEvent,ExecAssignpad,DiceBox,SwitchMap,UseDisguise,ShowHandout,WhisperFrame,MessageMngr,GroupMove,UngroupMove,Formations,SummonTokens,ActivateGroup,GroupSelect,UngroupSelect,VBLGrenade,LockMovement,LockToken,MoveEventOn,MoveEventOff,FullScreenModeOn,FullScreenModeOff,ShowDescription,roomDescrHelp,StartInvis,EndInvis,SeeInvis,SawInvis,PurgeInvis,PurgedInvis,AnulInvis,AnulledInvis,resetRanges, changeElevation, setAnimateView,runAnimateView,linkViewAnim,embarkation,toggleEmbark\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"bot.fg.MenuButtons\", menuButtons, \"lib:OnTokenMove\")]\n\nMenu button database updated",
        "maxWidth": "",
        "tooltip": "creates a DB of all html necessary to create the macro buttons",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "191811d3-bc8f-4abd-99f8-705f035bb035",
          "commandChecksum": "9881681c0541165fef12fa7dc960315b",
          "propsChecksum": "506d79682d58f7ea1fbc71736e687bac"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "1",
        "index": 129,
        "label": "createMacroButtonsOTMUtils",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- createMacroButtonsOTMUtils (optional: lastMessage) -->']\n[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']\n\n[h, if(argCount() > 0): txtOutput\t= arg(0) ; txtOutput\t= \"\"]\n\n[h:'<!-- get the menu buttons html -->']\n[h:menuButtons\t= getLibProperty(\"bot.fg.MenuButtons\", \"lib:OnTokenMove\")]\n[h:varsFromStrProp(menuButtons)]\n\n[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadinvisding=0 cellspacing='1' bgcolor='#e5e5cc'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine\t= \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd\t= \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor=\"#e5e5cc\" style=\"font-size:8.5px; text-align:center\">\n<table width=\"100%\" cellpadding=\"0\" cellspacing=\"1\"><tr><td>\n\t<table width=\"100%\"><tr><td bgColor = \"#c5c5ac\" align=\"center\">\n\t\t<span color=\"gray\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Setup<\/b>\" ,\"MacroButtonsOTMSetup@this\",\"none\")]<\/span>\n\t\t<\/td><td bgColor = \"#e5e5cc\" align=\"center\">\n\t\t<span color=\"black\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Utils<\/b>\" ,\"MacroButtonsOTMUtils@this\",\"none\")]<\/span>\n\t<\/td><\/tr><\/table>\n\t<\/td><\/tr><tr><td>\n\n<!-- depending on the toggles being on or off, show the correct html button -->\n[h: moveEventToggle\t\t\t= if(getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')==1,  MoveEventOn, MoveEventOff)]\n\n<!-- The menu buttons html is created by the createButtonsDB macro. Then the result is stored (encoded) in a libEventTokens property\nas a strprop. Above the button names e.g. 'door' are created as variables. The below lists are macro per menu item e.g. 'utilList'\ncontains a set of macros that is shown under the 'utils' grouptitle. Hence the entire menu structure is build up dynamically. Every\ntwo buttons a newLine html is added so the buttons are paired by two. You could change the odd() part to check for every three so you\nwould have three buttons next to eachother. Since the list items are strings they need to be eval() and also decode() as theyre stored\nencoded in the strProp. -->\n\n<!-- create the lists corresponding with the macro menu groups based on the installation settings -->\n[h:varsFromStrProp(getLibProperty('bot.fg.menuMacroList',  'lib:OnTokenMove'))]\n\n[r, if(listCount(utilAnimationList)), CODE:{\n\t[h:groupTitle\t= \"Animation & Events\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilAnimationList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilAnimationList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilUtilList)), CODE:{\n\t[h:groupTitle\t= \"Utils\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilUtilList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilUtilList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilInvisList)), CODE:{\n\t[h:groupTitle\t= \"Invisibility\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilInvisList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilInvisList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']\n\n[r,if(txtOutput != \"\"), CODE:{\n\t[h:'<!-- show last message output when in FS mode -->']\n\t[r:txtOutput]\n};{}]\n\n<\/td><\/tr><\/table><\/body><\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ba2cefa5-afcc-413c-8d9a-bfb518ecd1ee",
          "commandChecksum": "48812e7ef91cc2ba3a79547d903f6078",
          "propsChecksum": "4666a8c3b8ba13118259ba0aff381b3a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "5",
        "index": 130,
        "label": "toggleOnTokenMove",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:assert(isGM(),\"GM Only!!,0\")]\n\n<!-- make sure your on the basemap when changing the ontokenmove lib -->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:baseMapName\t\t= getLibProperty('baseMapName', 'lib:EventMacros')]\n[h:onTokenMoveEvent\t= getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')]\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n\n[h:macroList = getMacros(\",\",\"lib:OnTokenMove\")]\n\n[r,g,if(listContains(macroList, \"onTokenMove\")), CODE:{\n\t[h:setMacroProps(\"onTokenMove\", \"label=#onTokenMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setMacroProps(\"onMultipleTokensMove\", \"label=#onMultipleTokensMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setLibProperty('onTokenMoveEvent', 0, 'lib:onTokenMove')]\n\tThe on token move event is turned <font color=\"red\"><b>off\n}; {\n\t[h:setMacroProps(\"#onTokenMove\", \"label=onTokenMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setMacroProps(\"#onMultipleTokensMove\", \"label=onMultipleTokensMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setLibProperty('onTokenMoveEvent', 1, 'lib:onTokenMove')]\n\tThe on token move event is turned <font color=\"red\"><b>on\n}]\n\n[h, if(oldMap != baseMapName):setCurrentMap(oldMap)]\n[h, if(isFrameVisible(\"Bag Of Tricks Macros\")): bot_MacroButtonsOTMUtils()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f0cf3f8a-9577-45b4-a287-1f4e78e75aa3",
          "commandChecksum": "cc7c9a23c4de0fdead14c398e2359e8f",
          "propsChecksum": "336d3b987addc775b219bd4177250c34"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "19: Animated View Area",
        "includeLabel": false,
        "sortBy": "10",
        "index": 131,
        "label": "setAnimateView",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- setAnimateView() ------------------------------------------------------- -->']\n<!-- set of functions to create animation of the map. Players view 'hovers' over the map along a pre set path by the gm. This preset path is created by using the lastpath of a token. UNDER CONSTRUCTION -->\n\n[h:me\t\t\t= getSelectedNames()]\n[h:assert(listCount(me)==1,\"Make sure (only) one token is selected before you run this macro\",0)]\n[h:switchToken(me)]\n\n<!-- grab settings from token where animation is stored -->\n[h:\t\t\t\t\t\tsettings\t\t= getProperty(\"w42.animatedViewSettings\")]\n<!-- if that did not exist grab the last settings used -->\n[h,if(settings == \"\"):\tsettings\t\t= getLibProperty(\"w42.animatedViewSettings\", \"lib:EventMacros\")]\n<!-- if those do not exist use the below settings -->\n[h,if(settings == \"\"):\tsettings\t\t= \"delay=0;stepSize=50;width=100;height=50;width1=100;height1=50;useStoredPath=0\"]\n<!-- create settings -->\n[h:varsFromStrProp(settings)]\n\n[h:coords\t\t= getLastPath(0)]\n[h:previousPath\t= getProperty(\"w42.storedPathCoords\")] <!-- previous path store on token (if any) -->\n[h,if(json.type(previousPath)!=\"UNKNOWN\"):pCoords = previousPath ; pCoords = \"[]\"]\n\n[h:numCoords\t= json.length(coords)]\n[h:numPCoords\t= json.length(pCoords)]\n[h:assert(numCoords > 1 || numPCoords > 1, \"The 'lastpath' of this token does not exist or is too short (at least 2 coordinates), drag it on the map first and then try again\",0)]\n\n[h:gs\t\t\t= bot_getGridSize()]\n<!-- on first use -->\n[h,if(!isNumber(stepSize)): stepSize = gs]\n\n<!-- in case of pixelstep width and height are stored as pixels, so correct that before the input -->\n[h:pixelStep\t=\tif(mod(stepSize,gs)==0, 0,1)]\n[h,if(pixelStep), CODE:{\n\t[if(isNumber(width)):\twidth\t= round(width/gs,0)\t\t; width\t\t= 80]\n\t[if(isNumber(height)):\theight\t= round(height/gs,0)\t; height\t= 50]\n\t[if(isNumber(width1)):\twidth1\t= round(width1/gs,0)\t; width1\t= 80]\n\t[if(isNumber(height1)):\theight1\t= round(height1/gs,0)\t; height1\t= 50]\n}]\n\n[h, if(!numCoords): useStoredPath = numPCoords]<!-- if there is no lastpath then use the previously stored coords instead...if any! -->\n[h, if(!numPCoords): useStoredPath = 0]\n[h:abort(input(\n\tif(!numCoords, \"junk|<html>There is no lastpath for this token, only a stored path <\/html>|-|LABEL|SPAN=TRUE\",\"\"),\n\t\"junk|<html>\nThis function will animate the viewing area for all clients.  The path you see is the lastpath\t\t\t\t\t\t\t\t<br>\nof the currently selected token or the path that is store on the selected token (see below).                        \t\t<br>\nThe <b>width<\/b> and <b>height<\/b> are the number of cells that the view area shows each frame (a <b>frame<\/b> is the       <br>\nmoment the current view area is actually shown on all screens). The <b>delay<\/b> is the delay between                   \t<br>\neach frame shown The <b>pixel shift or step size<\/b> is the amount of pixels the view area moves each                    \t<br>\nframe. To have it move in number of cells use a multiple of the <b>gridsize (<font color='red'>\"+gs+\"<\/font color>)<\/b>.\t<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<br>\n<b>Example<\/b> (horizontal move, so we ignore the y coordinate and height):                                           \t\t<br>\nDragging a token from the origin (x=0) 3 cells to the right creates the path (0)(1)(2)(3).                          \t\t<br>\nLets assume a gridsize of 100. Then that same path in pixel coordinates is (0)(100)(200)(300).                      \t\t<br>\nIf you set the pixel shift to 50 that means that the view area shifts 50 pixels every                               \t\t<br>\nframe. The animated path in pixels will thus be (0)(50)(100)(150)(200)(250)(300). Every coordinate                  \t\t<br>\nis one frame shown as fast as your PC can handle it OR using the delay if its not 0. Here                           \t\t<br>\ndelay=1000 is 1 second between every frame. Lets assume a (view) width of 10 cells, That means                      \t\t<br>\nthat the most left cell you can see on your screen is -5 and the most right one you can see is                      \t\t<br>\n+5 or in pixels: -500 and 500. The view area per frame (xLeft, xRight)thus becomes:                                 \t\t<br>\n(-500,500)(-450,550)(-400,600)(-350,650)(-300,700)(-250,750)(-200,800).                                             \t\t<br>\n\t\n\t<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"stepSize|\"+stepSize+\"|pixel shift per frame (in # pixels)\",\n\t\"delay|\"+delay+\"|Delay per frame (ms)\",\n\t\"width|\"+width+\"|starting width of the viewarea (in # cells)\",\n\t\"height|\"+height+\"|starting height of the viewarea (in # cells)\",\n\t\"width1|\"+width1+\"|final width of the viewarea (in # cells)\",\n\t\"height1|\"+height1+\"|final height of the viewarea (in # cells)\",\n\tif(numCoords && numPCoords, \"useStoredPath|\"+useStoredPath+\"|Use stored path on the token instead of the lastpath?|CHECK\", \"\"),\n\tif(numCoords, \"storePath|0|store 'lastpath' on the token?|CHECK\", \"\"),\n\t\"\"\n))]\n\n[h:stepCount\t= ceil(gs/stepSize*(json.length(coords)-1))]\n[h:minStepSize\t= ceil(gs*json.length(coords)/999)]\n\n<!-- if stepSize is larger than gs than round to the nearest multiple gs -->\n[h,if(mod(stepSize,gs)!=0 && stepSize > gs):stepSize = round(stepSize/gs,0)*gs]\n\n[h:pixelStep\t= if(mod(stepSize,gs)==0, 0,1)]\n[h,if(pixelStep), CODE:{\n\t[width\t\t= round(width*gs,0)]\n\t[height\t\t= round(height*gs,0)]\n\t[width1\t\t= round(width1*gs,0)]\n\t[height1\t= round(height1*gs,0)]\n}]\n\n[h:settings\t= strPropFromVars(\"delay,stepSize,width,height,width1,height1,useStoredPath\",\"UNSUFFIXED\")]\n[h:setProperty(\"w42.animatedViewSettings\", settings)]\n[h:setLibProperty(\"w42.animatedViewSettings\", settings, \"lib:EventMacros\")]\n[h,if(storePath):setProperty(\"w42.storedPathCoords\", coords)]\n[h,if(useStoredPath): coords\t= pCoords]\n\n[h:assert(stepCount < 999, \"Your path counts a total of :\"+stepCount+\" steps. It cannot be longer than 1000, pls increase the stepsize to at least: \" + minStepSize,0)]\n<!-- e.g.\nstepSize = 10 means 10 px per step\ngridsize = 50 means 50px per cell\nEvery coord represents one cell. Hence new coords need to be inserted between the existing coords AND the new coords need to be recalculated to pixel format.\n -->\n\n[h:newCoords\t= \"[]\"]\n[h:pS\t\t\t= pixelStep]\n[h:d\t\t\t= delay]\n\n<!-- zoom step size for width and height. Which is the difference between the end zoom - start zoom divided by number of steps \nthe zoom step size is most likely a float, however make sure to only round it when its actually used -->\n[h,if(pixelStep), CODE:{\n\t[stepDiv\t= round(gs/stepSize,0)]\n\t[lessCoords\t= json.get(coords, 0,-2)] <!-- remove last coord as there wont be any nextCoord -->\n\t[totalSteps\t= json.length(lessCoords)*stepDiv] <!-- calculate the actual amount of step -->\n\t[currentStep= 0]\n['pause(\"stepDiv\", \"gs\", \"stepSize\")']\n\t<!-- this happens when the stepsize is smaller or a non-multiple of the gridsize. In this case you need to adapt and insert coords -->\n\t[dW\t\t\t= width1 - width]\n\t[dH\t\t\t= height1 - height]\n\t[foreach(coord, lessCoords), CODE:{\n\t\t[nextCoord\t= json.get(coords,roll.count+1)]\n\t\t[x\t\t\t= json.get(coord, \"x\")\t\t*gs]\n\t\t[nx\t\t\t= json.get(nextCoord, \"x\")\t*gs]\n\t\t[y\t\t\t= json.get(coord, \"y\")\t\t*gs]\n\t\t[ny\t\t\t= json.get(nextCoord, \"y\")\t*gs]\n\t\t[dX\t\t\t= nx - x]\n\t\t[dY\t\t\t= ny - y]\n\t\t[divX\t\t= floor(dX/stepDiv)]\n\t\t[divY\t\t= floor(dY/stepDiv)]\n\t\t[count(stepDiv), CODE:{\n\t\t\t\t<!-- set new zoom -->\n\t\t\t\t[nwidth\t\t= width + round(dW*currentStep/totalSteps, 0)]\n\t\t\t\t[nheight\t= height + round(dH*currentStep/totalSteps, 0)]\n\t\t\t\t<!-- set viewarea -->\n\t\t\t\t[x1\t\t\t= x - round(nwidth/2,0)]\n\t\t\t\t[y1\t\t\t= y - round(nheight/2,0)]\n\t\t\t\t[x2\t\t\t= x + round(nwidth/2,0)]\n\t\t\t\t[y2\t\t\t= y + round(nheight/2,0)]\n\n\t\t\t\t[newCoords\t= json.append(newCoords, strPropFromVars(\"x1, y1, x2, y2, pS, d\",\"UNSUFFIXED\"))]\n\t\t\t\t[currentStep= currentStep + 1]\n\t\t\t\t<!-- set new point of origin -->\n\t\t\t\t[x\t\t\t= x + divX]\n\t\t\t\t[y\t\t\t= y + divY]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t[stepDiv=0]\n''\n};{\n\t[coordsDiv\t\t= stepSize/gs] <!-- the divider for the amount of coordinates -->\n\t[stepCount\t\t= ceil(json.length(coords)/coordsDiv) - 1] <!-- -1 because the last width adjustment is not applied (exit foreach) -->\n\t[dW\t\t\t\t= (width1 - width) / stepCount]\n\t[dH\t\t\t\t= (height1 - height) / stepCount]\n\n\t[newCoords\t\t= \"[]\"]\n\t[foreach(coord, Coords), CODE:{\n\t\t[if(!mod(roll.count,coordsDiv)), CODE:{\n\t\t\t[x\t\t\t= json.get(coord, \"x\")]\n\t\t\t[y\t\t\t= json.get(coord, \"y\")]\n\t\t\t[x1\t\t\t= x - round(width/2,0)]\n\t\t\t[y1\t\t\t= y - round(height/2,0)]\n\t\t\t[x2\t\t\t= x + round(width/2,0)]\n\t\t\t[y2\t\t\t= y + round(height/2,0)]\n\n\t\t\t[newCoords\t= json.append(newCoords, strPropFromVars(\"x1, y1, x2, y2, pS, d\",\"UNSUFFIXED\"))]\n\t\t\t\n\t\t\t[width\t\t= width + dW]\n\t\t\t[height\t\t= height + dH]\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n}]\n\n[h:setProperty(\"w42.viewAnimationCoords\", newCoords)] <!-- store the animation on the token -->\n\n[h:'broadcast(replace(newCoords, \",\", \"<br>\"))']\n[h:ncoords=json.length(newCoords)]\n[h:'pause(\"width\",\"height\",\"dW\",\"dH\",\"stepDiv\",\"stepSize\",\"coords\",\"newCoords\",\"stepCount\",\"ncoords\",\"height\",\"y1\",\"y2\")']\n\n[h:'<!-- ------------------- execAllPlayers (macro name, arguments, players, output to) ----------------------------------------------------- -->']\n[h:bot_execAllPlayers(\"deferHover@Lib:OnTokenMove\", newCoords)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "816e1534-508e-44b0-bacd-b5e0c138ad5f",
          "commandChecksum": "6c0191258b9c243e14ef098acf01c4e2",
          "propsChecksum": "66a4c8c74c9432d4598d4d4225f27d64"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "3",
        "index": 133,
        "label": "abortProcess",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[setLibProperty(\"abortProcess\", arg(0), \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c15323ee-53ce-432a-bc76-65e80a5fafe0",
          "commandChecksum": "dfc853ce9dcb37a6ba1696d5defa3fca",
          "propsChecksum": "af643abdcbe7e04f9674b3a128551950"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "17",
        "index": 134,
        "label": "applyLightSource",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- ----------------------------------- applyLIGHTSOURCE ------------------------------------------------>\n[h: switchToken(tok)]\n[h: setLight(lightSet,light,eval(\"Lamp\"+i+\"S\"+j))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cc880471-12e0-457c-8f64-68f5d1861437",
          "commandChecksum": "10c9b3243a2da41ea3f5d9ecf26f1883",
          "propsChecksum": "ecb4b4ae1d0e21ff7137b3b33c601715"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "35",
        "index": 135,
        "label": "benchmark",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------------------- BENCHMARK ------------------------------------------------------------------------------------ -->']\n<!--\n<html>\nThis macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br>\nand compares their individual times. It uses an empty loop (Default in that group) as<br> \nreference as deducts that resulting time from the added macros. <br>\n<br>\nTo make use of this, create one or more macros in that group with ONLY the code that you<br>\nwish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br>\nto test. The higer the number the more accurate the result, but obviously it will take more<br>\ntime to run\n-->\n\n<!-- create list of all macros present in the benchmark group on lib:ontokenmove \n\texclusde the macro Default and any macro which name starts with @ -->\n[h:macroIDList\t\t= getMacroGroup(\"Benchmark Macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"\"]\n[h,foreach(id, macroIDList), CODE:{\n\t[macroName\t\t= getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\")]\n\t[if(macroName != \"Default\" && !startsWith(macroName, \"@\")):macroNameList\t= listAppend(macroNameList, macroName)]\n}]\n\n<!-- create an indication of time it takes to run the loops -->\n[h:timeResults\t= \"\"]\n[h:bot_startTime()]\n[h,foreach(mac, macroNameList,\"\"), CODE:{ [macro(mac+\"@lib:EventMacros\"):\"\"] }]\n[h:time\t= bot_totalTime()]\n\n[h:timeChoices\t= \"1,10,100,1000\"]\n[h:abort(input(\n\t\"junk|<html><b>The following macros will be tested: <\/b><i><br>\"+macroNameList+\"<\/i><br>Choose the number of times you wish to run each macro.<br>The higer the number, the more accurate the result, but<br>that will take more time<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"choice|1 (~\"+bot_formatTime(time,0)+\"),10 (~\"+bot_formatTime(time*10,0)+\"),100 (~\"+bot_formatTime(time*100,0)+\"),1000 (~\"+bot_formatTime(time*1000,0)+\")|Run how many times?|RADIO|SELECT=2\"\n))]\n[h:numTimes\t\t= listGet(timeChoices,choice)]\n\n<!-- first run the empty reference macro  -->\n[h:bot_startTime()]\n[h,count(numTimes), CODE:{\n\t[macro(\"Default@lib:EventMacros\"):\"\"]\n}]\n[h:defaultTime\t= bot_totalTime()]\n\n[h:timeResults\t= \"\"]\n<b>BENCHMARK RESULTS:<\/b><br><br>\n<table>\n\t<tr><td><b><u>Macro Name<\/u><\/b><\/td><td><b><u>Execution Time<\/u><\/b><\/td><\/tr><tr><td>\n\t\t[r,foreach(mac, macroNameList,\"<\/td><\/tr><tr><td>\"), CODE:{\n\t\t\t[h:bot_startTime()]\n\t\t\t[h,count(numTimes), CODE:{\n\t\t\t\t[macro(mac+\"@lib:EventMacros\"):\"\"]\n\t\t\t}]\n\t\t\t[h:resultTime\t= max(0,(bot_totalTime() - defaultTime))/numTimes]\n\t\t\t<i>{mac}<\/i><\/td><td>{resultTime}ms (= {bot_formatTime(resultTime)})\n\t\t\t[h:timeResults\t= listAppend(timeResults, resultTime)]\n\t\t}]\n\t<\/td><\/tr>\n<\/table>\n\n[r,if(listCount(macroNameList) > 1), CODE:{\n\t[h:sortedResults\t= listSort(timeResults,\"N-\")]\n\t[h:slowestTime\t\t= listGet(sortedResults, 0)]\n\t[h:fastestTime\t\t= listGet(sortedResults, listCount(timeResults)-1)]\n\t[h:slowestName\t\t= listGet(macroNameList, listFind(timeResults, slowestTime))]\n\t[h:fastestName\t\t= listGet(macroNameList, listFind(timeResults, fastestTime))]\n\t<br>\n\t<b><u>Conclusions:<\/u><\/b><br>\n\t<table>\n\t\t<tr><td>The <b>slowest<\/b> macro is:<\/td><td><b>{slowestName}<\/b> ({slowestTime} ms)<\/td><\/tr>\n\t\t<tr><td>The <b>fastest<\/b> macro is:<\/td><td><b>{fastestName}<\/b> ({fastestTime} ms)<\/td><\/tr>\n\t<\/table>\n\t<br>\n\t<b>Normalized<\/b> results using the fastest ({fastestName}) as base:<br>\n\n\t<table>\n\t\t<tr><td><b><u>Macro Name<\/u><\/b><\/td><td colspan='2'><b><u>Execution Time<\/u><\/b><\/td><\/tr><tr><td>\n\t\t\t[r,foreach(time,sortedResults,\"<\/td><\/tr><tr><td>\"), CODE:{\n\t\t\t\t[h:macroName\t= listGet(macroNameList, listFind(timeResults, time))]\n\t\t\t\t[h,if(fastestTime != 0):normTime\t\t= round(time/fastestTime,1)+\"x\" ; normTime = \"infinate\"]\n\t\t\t\t<i>[r:macroName]<\/i><\/td><td><b>[r:normTime]<\/b><\/td><td>slower then <i>[r:fastestName]<\/i>\n\t\t\t}]\n\t\t<\/td><\/tr>\n\t<\/table>\n};{}]\n<br>\n<b>Remarks:<\/b><br>\nThe resulting execution times are the ACTUAL times it takes to execute the given macro once. Some time is lost by running the macro in a loop and the macro is also looped {numTimes}x.<br>\nSo the resulting times of these tests are processed as follows:<br>\n- first the time it takes to run 'Default' (which is empty) is deducted from the total time. This takes care of the loop time.<br>\n- that result is divided by {numTimes} (number of iterations).<br>\nThe result is thus a close approximation of the actual execution time.<br>\n<br>\nHowever its usually still usefull to run this test 2 or 3 times. There is usually quite some difference between the 1st and 2nd benchmark (probly a caching thing) which can be eliminated by running the benchmark  2 or three times.<br>",
        "maxWidth": "",
        "tooltip": "<html> This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br> and compares their individual times. It uses an empty loop (Default in that group) as<br>  reference as deducts that resulting time from the added macros. <br> <br> To make use of this, create one or more macros in that group with ONLY the code that you<br> wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br> to test. The higer the number the more accurate the result, but obviously it will take more<br> time to run",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a1a10973-8d81-487d-9cfb-e6d87fbc4da3",
          "commandChecksum": "67e2ae426f246257c0f645d273507194",
          "propsChecksum": "84e3eaf92db4a4b1daa0aef9cb4ad415"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "42",
        "index": 136,
        "label": "bot_broadcast",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- bot_broadcast (message, userlist, use oldfunction) ---------------------------------------- -->']\n\n[h,if(argCount()>1): arg1\t\t= arg(1); arg1\t= bot_all()]\n[h,if(argCount()>2): oldFunc\t= arg(2); oldFunc\t= 0]\n\n<!-- PARTIAL WORKAROUND: passing an empty array as argument results in bc to all, which should not happen -->\n[h,if(json.isEmpty(arg1)):arg1 = \"['']\"]\n\n[h,if(getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\") && !oldFunc), CODE:{\n\t[oldFunction(arg(0),arg1)]\n\t[bot_execAllPlayers (\"deferBroadcast@this\", arg(0), arg1)]\n};{\n\t[oldFunction(arg(0),arg1)]\n}]\n\n[macro.return = arg(0)]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b3c18035-4611-48bc-ae96-f4c4026b5f1c",
          "commandChecksum": "af7443fa2880579eed8b856c2904e045",
          "propsChecksum": "41dfd0368790f7c745f211c2b89d40ef"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "1a",
        "index": 137,
        "label": "cleanTokNames",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- add input where user can choose what to check (including parenthesis, brackets, etc. if possible. -->\n<!-- \n<html>There are certain characters e.g. @ # & that, when used in a token name,<br>\ncan potentially break a macro IF that macro uses that token name. An obvious<br>\nexample is getTokenNames(',') which returns a , seperated list. Should one of<br>\nthe tokens in that list be called e.g. 'Fire Elemental, Giant' than the list<br>\nwould thus consist out of 'Fire Elemental' and 'Giant'. <br><br>\nThis macro tracks these tokens down and reports them in the chat. You then have<br>\nthe choice to either fix them automatically or not.<\/html> \n-->\n\n<!-- prevent error on first use by initializing values -->\n[h:varsFromStrProp(\"charComma=1 ; charColon=1 ; charApostrophe=1 ; charGrave=0 ; charAcute=0 ; charAmpersand=1 ; charQuestion=1 ; charAt=1 ; charSpace=1 ; charPlus=0 ; charDash=0 ; charEqual=0 ; charHash=0 ; charBar=0 ; charLesser=0 ; charGreater=0 ; charPeriod=0 ; charDollar=1 ; lyrBackGround=1 ; lyrHidden=1 ; lyrObject=1 ; lyrToken=1 ; \"))]\n[h:varsFromStrProp(getLibProperty(\"w42.bot.cleanSettings\", \"Lib:EventMacros\"))]\n\n<!-- \n\t\"charGrave|\"+charGrave+\"|<html>' (grave)<\/html>|CHECK\",\n\t\"charAcute|\"+charAcute+\"|<html>' (acute)<\/html>|CHECK\",\n -->\n[H: abort(input(\n\t\"tab0 | Choose Character to check for || TAB\", \n\t\"junk|<html>Select which characters to check in tokens<\/html>|<html>\tThe below characters *might* cause an issue<br>\tin token names. This all depends on how you<br>\twill use them. This check allows you to find<br>\tand fix them.<\/html>|LABEL|SPAN=TRUE\",\n\n\t\"junk|<html><br><b>Really bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charComma|\"+charComma+\"|<html>, (comma)<\/html>|CHECK\",\n\t\"charSemicolon|\"+charSemicolon+\"|<html>; (Semicolon)<\/html>|CHECK\",\n\t\"charColon|\"+charColon+\"|<html>: (colon)<\/html>|CHECK\",\n\t\"charApostrophe|\"+charApostrophe+\"|<html>' (apostrophe)<\/html>|CHECK\",\n\t  \n\t\"junk|<html><br><b>Potentially bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charAmpersand|\"+charAmpersand+\"|<html>& (ampersand)<\/html>|CHECK\",\n\t\"charDollar|\"+charDollar+\"|<html>\\$(dollar sign)<\/html>|CHECK\",\n\t\"charQuestion|\"+charQuestion+\"|<html>? (question mark)<\/html>|CHECK\",\n\t\"charAt|\"+charAt+\"|<html>@ (at)<\/html>|CHECK\",\n\t\"charSpace|\"+charSpace+\"|<html><i>Trailing & Leading Spaces<\/i><\/html>|CHECK\",\n\t\n\t\"junk|<html><br><b>Might be bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charPlus|\"+charPlus+\"|<html>+ (plus)<\/html>|CHECK\",\n\t\"charDash|\"+charDash+\"|<html>- (dash)<\/html>|CHECK\",\n\t\"charEqual|\"+charEqual+\"|<html>= (equals)<\/html>|CHECK\",\n\t\"charHash|\"+charHash+\"|<html># (hash)<\/html>|CHECK\",\n\t\"charBar|\"+charBar+\"|<html><i>Bar character (=shift backslash)|CHECK\",\n\t\"charLesser|\"+charLesser+\"|<html>< (lesser than)<\/html>|CHECK\",\n\t\"charGreater|\"+charGreater+\"|<html>> (greater then)<\/html>|CHECK\",\n\t\"charPeriod|\"+charPeriod+\"|<html><b>.<\/b> (period)<\/html>|CHECK\",\n\t\"junk|<html><br><b>Pick your own<\/b><br>\tAt your own risk. This uses rather complicated<br>\tregex method and as its unkown to me what you<br>\tenter here, things might blow up.<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charChosen||<html>Leave 0 to ignore this field<\/html>\",\n\t\n\t\"tab0 | Choose Replacement || TAB\", \n\t\"junk|<html><br><b>\n\tWhen an illegal character is found,<br>\tit will be replaced with another character.<br>\tPls enter this here<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"replacementChar|_|Enter Character\",\n\t\"junk|<html><br><b>\tSuggestions:<\/b><br>\tNothing ('')<br>\tUnderscore ('_')<br>\tSpace (' ')<br><br>Note that when you use Space, you might need<br>\tto run diagnose\tagain as this might result in<br>\ttrailing or leading spaces.\t<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\n\t\"tab0 | Choose Layers || TAB\", \n\t\"junk|<html><br><b>\tOn wich layers should the token<br>names be checked??<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"lyrToken|\"+lyrToken+\"|<html>Token<\/html>|CHECK\",\n\t\"lyrObject|\"+lyrObject+\"|<html>Object<\/html>|CHECK\",\n\t\"lyrHidden|\"+lyrHidden+\"|<html>Hidden<\/html>|CHECK\",\n\t\"lyrBackGround|\"+lyrBackGround+\"|<html>Background<\/html>|CHECK\"\n))]\n[h:varList = \"\ncharComma,charSemicolon,charColon,charApostrophe,charGrave,charAcute,charAmpersand,charQuestion,\ncharAt,charSpace,charPlus,charDash,charEqual,charHash,charBar,charLesser,charGreater,\ncharPeriod,charDollar,lyrBackGround,lyrHidden,lyrObject,lyrToken\n\"]\n\n[h:setLibProperty(\"w42.bot.cleanSettings\", strPropFromVars(varList,\"UNSUFFIXED\"),\"Lib:EventMacros\"))]\n\n<!--\n\t\t\t\tif(charGrave,\"?\",\"\")+\n\t\t\t\tif(charAcute,\"?\",\"\")+\n-->\n<!-- dash must go last or else error!! -->\n[h:regStr\t\t=\tif(charDollar,\"\\\\\\$\",\"\")]\n\n[h:replaceStr\t= \tif(charColon,\":\",\"\")+\n\t\t\t\t\tif(charSemicolon,\";\",\"\")+\n\t\t\t\t\tif(charApostrophe,\"'\",\"\")+\n\n\t\t\t\t\tif(charAmpersand,\"&\",\"\")+\n\t\t\t\t\tif(charQuestion,\"?\",\"\")+\n\t\t\t\t\tif(charAt,\"@\",\"\")+\n\t\t\t\t\t\n\t\t\t\t\tif(charPlus,\"+\",\"\")+\n\t\t\t\t\tif(charEqual,\"=\",\"\")+\n\t\t\t\t\tif(charHash,\"#\",\"\")+\n\t\t\t\t\tif(charBar,\"|\",\"\")+\n\t\t\t\t\tif(charLesser,\"<\",\"\")+\n\t\t\t\t\tif(charGreater,\">\",\"\")+\n\t\t\t\t\tif(charPeriod,\".\",\"\")+\n\t\t\t\t\tif(charChosen!=0,charChosen,\"\")+\n\t\t\t\t\tif(charDash,\"-\",\"\")\n]\n[h:regStr\t\t= regStr + replaceStr]\n\n[h:layerJson\t\t= \"[]\"]\n[h, if(lyrToken):\t\tlayerJson\t= json.append(layerJson, \"TOKEN\")]\n[h, if(lyrObject):\t\tlayerJson\t= json.append(layerJson, \"OBJECT\")]\n[h, if(lyrHidden):\t\tlayerJson\t= json.append(layerJson, \"HIDDEN\")]\n[h, if(lyrBackGround):\tlayerJson\t= json.append(layerJson, \"BACKGROUND\")]\n\n<!-- gather all token names use % to filter out any with a , -->\n[H:commaTokList\t= getTokenNames(\"%\", json.set(\"{}\", \"layer\", layerJson))]\n[h:tokJson\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", layerJson))]\n\n<!-- check if any token contains a , in its name and remove these from the list-->\n[h:regResult\t\t= strfind(commaTokList,\"[^%]*(,+)[^%]*\")]\n[h:numWrong\t\t\t= min(1000,getFindCount(regResult))]\n[h:commaTokJson\t= \"[]\"]\n[h,if(numWrong), CODE:{\n\t[count(numWrong): commaTokJson = json.append(commaTokJson, getGroup(regResult, roll.count+1,0))]\n}]\n\t\t\n[h,if(charComma):\n\tbroadcast(strformat(\"<b><font color='red'>The following tokens have a comma (,) in their name:<\/b><\/font><br>%{commaTokJson}\"))\n;\n\tcommaTokJson\t= \"[]\"\n]\n\n<!-- remove the token entries that contained a , in their name and convert to list else the regex wont work -->\n[h:cleanTokList\t= json.toList(json.difference(tokJson, commaTokJson))]\n\n[h:jsonTokIllCharList\t= \"[]\"]\n[h,if(regStr != \"\"), CODE:{\n\t<!-- check the tokens for any illegal character -->\n\t<!-- full and working regex string for testing purposes -->\n\t[regResult\t= strfind(cleanTokList,\"[^,]*([&+:;=?@#|'<>.-]+)[^,]*\")]\n\t[regResult\t= strfind(cleanTokList,\"[^,]*([\"+regStr+\"]+)[^,]*\")]\n\t[numWrong\t= min(1000,getFindCount(regResult))]\n\t[if(numWrong), CODE:{\n\t\t[count(numWrong): jsonTokIllCharList = json.append(jsonTokIllCharList, getGroup(regResult, roll.count+1,0))]\n\t}]\n\t<!-- remove found entries to prevent doubles -->\n\t[cleanTokList\t= json.difference(cleanTokList, jsonTokIllCharList)]\n\t[broadcast(\"<b><font color='red'>The following tokens have erronous characters in their name:<\/b><\/font>\")]\n\t[broadcast(jsonTokIllCharList)]\n};{}]\n\n[h:jsonTokSpaceList\t= \"[]\"]\n[h, if(charSpace), CODE:{\n\t<!-- check the remaining tokens for trailing or leading spaces -->\n\t[regResult\t= strfind(cleanTokList,\"(?<=,)\\\\s[^,]*|[^,]*\\\\s(?=,)\")]\n\t[numWrong\t= min(1000,getFindCount(regResult))]\n\n\t[if(numWrong), CODE:{\n\t\t[count(numWrong): jsonTokSpaceList = json.append(jsonTokSpaceList, getGroup(regResult, roll.count+1,0))]\n\t}]\n\t[broadcast(strformat(\"<b><font color='red'>The following tokens have trailing and/or leading spaces in their name:<\/b><\/font><br>%{jsonTokSpaceList}\"))]\n};{}]\n\n<!-- check whether the ID of the tokens are NOT numerical -->\n<!-- code (for the most part) by lmarkus -->\n[h:hasWrongIdName\t= \"[]\"]\n[h:idList\t= getTokens(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n[h:splices\t= bot_createSplices(idList)]\n[h,foreach(splice, splices), CODE:{\n\t[foreach(id, splice), if(length(id) != 32): hasWrongIdName = json.append(hasWrongIdName, id)]\n\t\n}]\n<!-- and fix these -->\n[h:txtOutputL\t= \"\"]\n[h,foreach(id, hasWrongIdName), CODE:{\n\t[txtOutputL\t= listAppend(txtOutputL, getName(strformat(\"%032d\",id)))]\n\t[copyToken(strformat(\"%032d\",id),1,\"\",json.set(\"{}\",\"name\",getName(strformat(\"%032d\",id)),\"delta\",1,\"x\",0,\"y\",0)) ]\n\t[removeToken(strformat(\"%032d\",id)) ]\n}]\n[h:broadcast(strformat(\"<b><font color='red'>The following tokens had an erronous ID tag. This is now fixed:<\/b><\/font><br>%{hasWrongIdName}\"))]\n\n<!-- ask whether the user wishes to continue with the fix -->\n[h:message\t= \"In the chat you can see the lists of tokens that will be fixed if you continue.<br>Click <b>OK<\/b> to continue<br>Click <b>CANCEL<\/b> to discontinue\"]\n[h:pause(\"message\")]\n\n<!-- fix it -->\n<!-- fix commas -->\n[h,foreach(tok, commaTokJson), CODE:{\n\t[token(tok):token.name = replace(token.name, \",\", replacementChar)]\n}]\n\n<!-- fix spaces -->\n[h,foreach(tok, jsonTokSpaceList), CODE:{\n\t[token(tok):token.name = trim(token.name)]\n}]\n\n<!-- fix ill chars -->\n[h,foreach(tok, jsonTokIllCharList), CODE:{\n\t[foreach(char, replaceStr,\"\",\"\"), CODE:{\n\t\t[token(tok):token.name = replace(token.name, \"\\\\\"+char, replacementChar)]\n\t}]\n}]\n\n[h:chkDollar\t= getFindCount(strfind(cleanTokList,\"\\\\\\$\"))]\n[h,if(chkDollar):broadcast(\"All tokens have been fixed, except the ones with dollar signs in their name. This cannot be fixed automatically. You will need to mannually change these tokens. You can run this macro again to get a list.\")]",
        "maxWidth": "",
        "tooltip": "<html>There are certain characters e.g. @ # & that, when used in a token name,<br> can potentially break a macro IF that macro uses that token name. An obvious<br> example is getTokenNames(\",\") which returns a , seperated list. Should one of<br> the tokens in that list be called e.g. \"Fire Elemental, Giant\" than the list<br> would thus consist out of \"Fire Elemental\" and \"Giant\". <br><br> This macro tracks these tokens down and reports them in the chat. You then have<br> the choice to either fix them automatically or not.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "796deb6d-73b9-4c86-9886-ea782a18ab39",
          "commandChecksum": "54ad58c362b6df21bff66d5159a6183c",
          "propsChecksum": "47238df247d7f18e07ed2c4d2dc77082"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "42",
        "index": 138,
        "label": "deferBroadcast",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- bot_deferBroadcast ---------------------------------------- -->']\n[dialog(\"Chat Window\", \"input=1\"):{[r:arg(0)]}]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1a6ec13e-a4a8-4456-82b8-e1855c9e3735",
          "commandChecksum": "b90db030e5945092a58fee3d691cbaeb",
          "propsChecksum": "b78040a4fda381bad2970fc7f36d67a5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "51",
        "index": 140,
        "label": "deferMessage",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: link = macroLinkText(\"deferMessageLink@Lib:OnTokenMove\", \"self\", arg(0))]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4b11434e-548d-4e5a-b598-e567beb00947",
          "commandChecksum": "02c02f900c45bd1b49516ee178e1036f",
          "propsChecksum": "25ba3fe38a2a5b758f4e1dbc43910ef1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "51",
        "index": 141,
        "label": "deferMessageLink",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:broadcast(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "43ef91aa-937f-4c4e-b616-eed50fc6aab1",
          "commandChecksum": "f870cb37bd044b5e59287d1fa3f1ec9a",
          "propsChecksum": "02f84e9d9ecca818db05be42e075e9ce"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "31",
        "index": 142,
        "label": "deleteProps",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- DELETE RPOPS -->']\n<!-- <html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!! -->\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:allAtOnce\t= 0]\n\n[h:abort(input(\n\t\"junk|<html><b><font color='red'>THIS WILL DELETE TOKEN PROPERTIES OF THE FOLLOWING SELECTED TOKENS<\/font><br><font color='blue'>\"+toks+\"<\/font><\/b><br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"sure|Quit, Choose properties to delete (NONE preselected), Choose properties to delete (ALL preselected), Delete all properties|Pre-select properties?|RADIO|SELECT=0\",\n\tif(listCount(toks) > 1, \"allAtOnce|Choose properties to delete per token, Choose once and delete for all selected tokens|All tokens at once?|RADIO|SELECT=1\",\"\")\n))]\n\n[h:assert(isGm()&&sure, \"Reset ABORTED. Either you're not the GM or you're not sure\",0)]\n\n<!-- if all at once, make choice once and then do the rest seperately. Else create input per token -->\n[h,if(allAtOnce && sure!=3): tmpToks = listGet(toks, 0) ; tmpToks = toks]\n\n[r, foreach(tok, tmpToks,\"<br><br>\"), CODE:{\n\t[h:switchToken(tok)]\n\t[h:allProps = getPropertyNamesRaw()]\n\tThe following properties of <b>[r:token.name]<\/b> have been deleted:\n\n\t[r,switch(sure),CODE:\n\t\tcase 1: {\n\t\t\t[h:inputStr = \"[]\"]\n\t\t\t[h:inputStr = json.append(inputStr,\"junk|<html><b>CHECK those properties you wish TO DELETE<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t[h,foreach(prop, allProps): inputStr = json.append(inputStr, \"prop\"+roll.count+\"|0|\"+prop+\"|CHECK\")]\n\t\t\t[h:abort(input(json.toList(json.evaluate(inputStr),\"##\")))]\n\t\t\t\n\t\t\t[h:'<!-- delete selected props -->']\n\t\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t\t};\n\t\tcase 2: {\n\t\t\t[h:inputStr = \"[]\"]\n\t\t\t[h:inputStr = json.append(inputStr,\"junk|<html><b>CHECK those properties you wish TO DELETE<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t[h,foreach(prop, allProps): inputStr = json.append(inputStr, \"prop\"+roll.count+\"|1|\"+prop+\"|CHECK\")]\n\t\t\t[h:abort(input(json.toList(json.evaluate(inputStr),\"##\")))]\n\t\t\t\n\t\t\t[h:'<!-- delete selected props -->']\n\t\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t\t};\n\t\tcase 3: {\n\t\t\t[h,foreach(prop, allProps):resetProperty(prop)]\n\t\t\t[r:allProps]\n\t\t\t[h:allAtOnce = 0]\n\t\t};\n\t\tdefault: {[assert(\"0,\"You made an impossible choice\",0\")]}\n\t]\n}]\n\n[r,if(allAtOnce), CODE:{\n\t[h:remToks\t= listDelete(toks, 0)]\n\t<br><br>\n\t[r, foreach(tok, remToks,\"<br><br>\"), CODE:{\n\t\t[h:switchToken(tok)]\n\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\tThe following properties of <b>[r:token.name]<\/b> have been deleted:\n\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!!",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4e9760d-a5dd-498d-a36b-b432b56362c0",
          "commandChecksum": "a15f7ef57965f5e0483ebafe1ff070b8",
          "propsChecksum": "73978a8cd1ca48a9e050d19abc6a0111"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "41",
        "index": 144,
        "label": "isFullScreen",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- isFullScreen ---------------------------------------- -->']\n[h:FSM = getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")]\n[h:macro.return = if(!isNumber(FSM), 0, FSM)]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cac855da-a565-4987-824c-f0d50f087aab",
          "commandChecksum": "7767276ee8ffa69b86f4deac15e5c9ed",
          "propsChecksum": "f9269c1966fba2f190be815ff95361f5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "30",
        "index": 145,
        "label": "manFunctionsTxt",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:output =  \"<font color=red><b><u>BOT FUNCTION DOCUMENTATION<\/u><\/b><br><\/font>\n<p>\nThis function manual exists out of three sections:<br>\n\t\t<b>- GENERAL MACROS<\/b><br>\n\t\t<b>- MESSAGE MACROS<\/b><br>\n\t\t<b>- GEOMETRIC MACROS<\/b><br>\n<\/p>\n\n\t<p>\n\t\t<br>\n\t\t<u><b>GENERAL MACROS<\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_animateText<\/b><\/font><i>(text[, title, position, html-header, width, height, delay, upper])<\/i><br />\n\t\tThese are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the 'Bag of Tricks macro panel'. When the text animation is activated a frame will pop-up on every attached client pc printing the text.<br />\n\t\t<b>- text<\/b>: The text you enter here will be animated in a frame<br />\n\t\t<b>- title<\/b>: The title of the frame<br />\n\t\t<b>- position<\/b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won't be animated<br />\n\t\t<b>- html-header<\/b>: Here you can set some basic make up for the frame itself. If you enter 'Default' it will show a black-green frame with courier font<br />\n\t\t<b>- width & height<\/b>: The dimensions of the Frame<br />\n\t\t<b>- delay<\/b>: Amount of delay per character printed in ms.<br />\n\t\t<b>- upper<\/b>: Print the animated text in UPPER CASE<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_animateMove<\/b><\/font><i>(0. tokenID, 1. x, 2. y [, 3. relative, 4. onImpact(-1:bounce; 0=continue; 1=stop), 5. layer(json.object), 6. vbl(1; 0), 7 delay(ms),  8. distance, 9. macro (to run after 1 move), 10. rotation, 11. rotation step size])<\/i><br />\n\t\tWith this function you can choose to use the input panel by selecting a token and clicking 'Animate Move' in the 'Animation' window. However this is a bit cumbersome for e.g. casting a fireball. The 'better' way is by calling the macro directly.If you give at least the token Id and the x and y coordinates then this function will run automatically with the following 'default' settings: relative=0, onImpact=0, layer='[]', vbl=0, delay=0.<br />\n\t\t<b>- X (#cells)<\/b>: The destination X coord of the token, either absolute or relative to its current position<br />\n\t\t<b>- Y (#cells)<\/b>: Dito X, but then Y<br />\n\t\t<b>- Relative (1/0)<\/b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br />\n\t\t<b>- onImpact - Bounce (-1)<\/b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An 'obstacle' is defined by the below settings.<br />\n\t\t<b>- onImpact - Continue (0)<\/b>: the token is moved to its destination no matter what<br />\n\t\t<b>- onImpact - Stop (1)<\/b>: the animation stop as soon as it meets an obstacle<br />\n\t\t<b>- Token (and the other) layer(s)<\/b>: 'The 'checked' layers will be searched for obstacles' where the token can run into while its moving<br />\n\t\t<b>- Vision Blocking Layer<\/b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc.<br />\n\t\t<b>- Delay (ms)<\/b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br />\n\t\t<b>- Distance (#cells)<\/b>: Distance in cells to travel, regardless of end position<br />\n\t\t<b>- Macro <\/b>: A macro that will be run after every iteration/step/move (e.g. '[runme()]'), set to 0 or '' if unused<br />\n\t\t<b>- R (#degrees)<\/b>: How many degrees the token rotates<br />\n\t\t<b>- R-Stepsize (#degrees)<\/b>: The amount of degrees per step. The higher the number, the faster the rotation<br />\n\t\t<br />\n\t\tNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.\t<br />\n\t\t<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\t[bot_animateMove('Dragon', 12, 12, 1, -1, '["token","object"]', 1, 0, 0, '[broadcast("One step for this Dragon...")]', 360, 10)]<\/i>\n\t\t<\/p>\n\n\t<p>\n\t\t<font color=red><b>bot_createSplices<\/b><\/font><i>(list or array)<\/i><br />\n\t\tThis function can be used for foreach() loops where the entered list contains (potentially) more then 1000 items. This will normally create an error as maximum 1000 items are allowed. This function will return an array with lists, eacht list consisting out of exactly 1000 items so: "1,2,..,1099" will return ["1,2,..1000", "1001, 1002,..1099"]. Then you can use two foreach loops to cycle through the list.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_delay<\/b><\/font>(time)<br />\n\t\tdelays the function with 'time' ms<br />\n\t\t<b>- time: <\/b>milli seconds, so 1second is 1000.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_debugInfo<\/b><\/font><i>(vars [, oneLine, showTok, pause, macroName, macroLocation])<\/i><br />\n\t\tbroadcasts all the listed variables and their current values either on one line (1) or beneath eachother (0)<br />\n\t\t<b>- vars<\/b>:\t\t\tlist of variables you want to track while debuggin<br />\n\t\t<b><i>Optional Arguments<\/i><\/b><br />\n\t\t<b>- oneLine<\/b>:\t\t(0) all variables in one column; (1) (default) all variables on one line<br />\n\t\t<b>- showTok<\/b>:\t\t(0) show nothing; (1) (default) show current token and impersonated token<br />\n\t\t<b>- pause<\/b>:\t\t\t(0) dont pause on debug line; (1) pause on debug line AND show a frame with the debug results<br />\n\t\t<b>- macroName<\/b>:\t\tto make use of this you need to enter <i>getMacroName()<\/i> as argument<br />\n\t\t<b>- macroLocation<\/b>: to make use of this you need to enter <i>getMacroLocation()<\/i> as argument<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\t[bot_debugInfo( 'X, Y, Name, Strength', 0, 1, 1, getMacroName(), getMacroLocation() )]<\/i>\n\t\t\n\t<p>\n\t\t<font color=red><b>bot_execAllPlayers <\/b><\/font><i>(macroNname, arguments[, players, output to])<\/i><br />\n\t\tThis macro executes the macro 'macroName' on ALL SELECTED clients.<br />\n\t\t<b>- macroName<\/b>: name of the macro to execute: e.g. runThisMacro@lib:token<br />\n\t\t<b>- arguments<\/b>: the arguments to pass on to that macro (in the form of an json array)<br />\n\t\t<b>- players<\/b>: a list of PLAYER names where to execute on (so not their token names). Defaults to 'all'<br />\n\t\t<b>- output to<\/b>: Send resulting output of macro to whom (self, gm, all, none, gm-self, list). Defaults to 'none'\n\t\t<\/p>\n\t\t\n\t<p>\n\t\t<font color=red><b>bot_findDuplicates<\/b><\/font>()<br />\n\t\treturns ALL duplicate token (names) from ALL layers on the current map.<\/p>\n\n\t<p>\n\t\t<font color=red><b>bot_frameOpen, bot_frameClose<\/b><\/font>()<br />\n\t\tBy Nildik.\n\t\tThese functions can be used to create a frame around a piece of text, with the sole purpose of making it neater.<br>\n\t\tTo use them you have to decide which frame you wish to use. To get an overview of all available frames run the macro 'Frame Overview'<br>\n\t\t<i><b>Example use:<\/b><br>\n\t\t[R: bot_frameOpen(1,'This is the Title','WHITE')]<br>\n\t\t\tall the html text that is placed between these two functions is shown in a nice frame, in this case Frame Type: 1. <br>\n\t\t\tThe tile of the frame will be : 'This is the Title' and the color of the title will be WHITE. <br>\n\t\t[R: bot_frameClose(1)]\n\t\t<\/i>\t\t\n\t\t<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getCTokDistance<\/b><\/font>(<i>[token1, corner1, token2, corner2, units]<\/i>)<br/>\n\t\t<b>- token1:<\/b> name or id of first token.<br />\n\t\t<b>- corner1:<\/b> distance FROM corner of token1: <i>top_right, top_left, bottom_left or bottom_right<\/i>.<br />\n\t\t<b>- token2:<\/b> name or id of second token.<br />\n\t\t<b>- corner2:<\/b> distance TO corner of token2 <i>top_right, top_left, bottom_left or bottom_right<\/i>.<br />\n\t\t<b>- units:<\/b> units of distance to returns, either: 0 - distance in cells ; 1 - distance in pixels ; 2 - distance in 'distance per cell'.<br />\n\t\treturns a json object e.g.: {'dx':12,'dy':15}.<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\tassume: token1 on 0,0 and token 2 on 10,0 (cell coordinates); pixels per cell: 50; distance per cell 5<br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'top_left', 'Elf', 'bottom_Right', 0)]<br>\n\t\treturns: {'dx':11,'dy':1} <br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'top_left', 'Elf', 'top_left', 1)]<br>\n\t\treturns: {'dx':50,'dy':0} <br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'bottom_right', 'Elf', 'top_left', 2)]<br>\n\t\treturns: {'dx':45,'dy':5} <br />\n\t\t<\/i>\t\t\n\t\t<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getGridSize<\/b><\/font>()<br />\n\t\treturns current size of grid in pixels per cell.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getTokenFacing<\/b><\/font>(<i>[token, type]<\/i>)<br />\n\t\tall settings are optional<br />\n\t\t<b>- token:<\/b> name or id of token. Leave blank for currentToken<br />\n\t\t<b>- type:<\/b> <br />\n\t\t(0=default) convert angle from (-180 to 180) to (0-360) So 0=EAST;90=NORTH; 180=WEST and 270=SOUTH. This results in an angle according to mathematical polar coordinates convention (also used in Java) <br />\n\t\t(1) Does the same as the above but also inverts rotation to CW and gives an offset of +90 so 'no token facing' ends up to be 0 instead of 270. An 'unrotated' or 'facing cleared' token faces SOUTH. With the default option this would thus result in 270. With this option it results in 0. In this case thus: 0=SOUTH; 90=EAST;180=NORTH and 270=WEST.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getPath<\/b><\/font>(<i>[showPath, units, id]<\/i>)<br />\n\t\tall settings are optional<br />\n\t\tThis function returns ALL points where the direction of the tokens' path changed. For an unsnapped token these are the way points, for a snapped token also the points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction. In addition it can *show* the path by placing feet tokens on it path.<br />\n\t\t<b>- showPath: <\/b> (0) (default):do not show the path (just return the waypoint); (1) show the path (with feet token) and REMOVE the last shown path , (2)  show the path (with feet token) and DO NOT REMOVE the last shown path, (3) REMOVE the last path shown on the map<\/b> <br />\n\t\t<b>- units: <\/b> (0) return the coordinates in cells ; (1) (default) return the coordinates in pixels<br />\n\t\t<b>- id: <\/b>token id or name<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_getTokensPath<\/b><\/font>(<i>token1, token2[, staircasing, units]<\/i>)<br />\n\t\tThis function returns an json array containing the coordinates of all the cells (including the tokens positions) between the two given tokens.<br />\n\t\t<b>- token1: <\/b>starting token name or Id, its coordinates will be the first coord in the array<br />\n\t\t<b>- token2: <\/b>ending token name or Id, its coordinates will be the last coord in the array<br />\n\t\t<b>- staircasing:<\/b>(1) (default) no diagonal connection between cells so the 'next' cell will always be n/s/e/w of the current cell. (0) diagonal connection allowed, so ne/nw/se/sw are allowed as well. <br />\n\t\t<b>- units: <\/b>(1) return coordinates in pixels; (0) (default) return coordinates in cells<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_getValidTokens<\/b><\/font><i>(useCurrentMap, conditions, use_none, startsWithTxt)<\/i><br />\n\t\tALL arguments are optional<br />\n\t\tThis function does not return anything but operates in the same scope and will create several types of lists of tokens from the BASE map. For every list there is also a 'graphic' list accompanyin it giving it the option to use for the input LIST function. Have a look at 'summonToken' function to better understand its workings.<br />\n\t\t<b>- useCurrentMap<\/b>: (0) use BASE map ; (1) use CURRENT map<br />\n\t\t<b>- conditions<\/b>: read the wiki conditions for getTokenNames(), defaults to '{}'<br />\n\t\t<b>- use_None<\/b>: will add 'None' as first option for all lists, defaults to 1<br />\n\t\t<b>- startsWithTxt<\/b>: allows for a partial search string to return. Defaults to ""<\/p>\n\t<p>\n\t\t<font color=red><b>bot_ids2Names<\/b><\/font><i>(tokList)<\/i><br />\n\t\tThis function returns a list of token names.<br />\n\t\t- <b>tokList<\/b>: a list of token ID's.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_inStr<\/b><\/font><i>(string, searchStr)<\/i><br />\n\t\tThis function returns 0 when searchStr is NOT found within string, ELSE it will return a number not 0.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_startInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_endInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_seeInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_sawInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_purgeInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_purgedInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_anullInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_annuledInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\tThese functions can be used as direct macro or made part of your own custom macro. A full explanation can be found in the (other) Manual.\n\t\t- OPTIONAL: <b>tokList<\/b>: a list of token ID's or names. If no argument is given it applies on all selected tokens. <\/p>\n\t<p>\n\t\t<font color=red><b>bot_rotateGroup<\/b><\/font><i>(degrees [, tokens])<\/i><br />\n\t\tthis rotates a group of tokens in respect of eachother, regardless of size. The one condition is that the tokens must NOT be set tofreesize.<\/p>\n\t\t<b>- degrees<\/b>: multiples of +/-90 degrees, where + is CCW and - CW<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- tokens<\/b>: List of tokens to rotate. Defaults to currently selected tokens<\/p>\n\t<p>\n\t\t<font color=red><b>bot_round2Grid<\/b><\/font><i>(coordinate [, gridsize])<\/i><br />\n\t\tthis rounds a coordinate exactly to the current gridsize. E.g. in a 50 size grid, the argument 55, will return 50. 122 will return 100 etc.<\/p>\n\t\t<b>- coordinate<\/b>: any number, usually a coordinate to which a function is applied<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- gridsize<\/b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_round2Grid(70)] - will return 50 for a 50 gridsize map, 75 for a 25 gridsize map and 100 for a 100 gridsize map.<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_ppc2GridCoord<\/b><\/font><i>(coordinate [, gridsize])<\/i><br />\n\t\tThis will translate a 'pixel per cell' coordinate in a 'grid cell' coordinate. E.g. on a 50 pixel per grid size map (so ppC is 50) the coordinate 150 will return 3 (third grid cell)<\/p>\n\t\t<b>- coordinate<\/b>: a coordinate in pixels per cell, usually a multiple of the gridsize<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- gridsize<\/b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_ppc2GridCoord(100)] - will return 2 for a 50 gridsize map, 4 for a 25 gridsize map and 1 for a 100 gridsize map.<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_seekToken<\/b><\/font><i> ([returnArg(0/1), findStr(string), layers(json object), maps(list), libTokens(0/1), jsonOutput(0/1)])<\/i><br />\n\t\tThis macro searches ALL maps and ALL tokens and returns a list of those tokens of which their name (partially) matches with the entered search string.<br />\n\t\tALL arguments are optional. IF only one map then this function returns a list of found tokens, IF multiple maps, then this function will return a json object with the map as key.<br />\n\t\t- <b>returnArg<\/b>: (1) the given arguments are used and NO input screen will pop-up. Basically if you want to use this as a function you need to start it with '1'<br />\n\t\t- <b>findstr<\/b>: the string to look for in the token, default is ""<br />\n\t\t- <b>layers<\/b>: to look in, default is ["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"],<br />\n\t\t- <b>maps<\/b>: the maps to look into, default is current map<br />\n\t\t- <b>libTok<\/b>: (0) (default) is do NOT return any found lib tokens; 1 is DO return any libtokens.<\/p>\n\t\t- <b>jsonOutput<\/b>: (0) (default) is only 1 map is listed the output will be a list. If multiple maps are listed the output is a json construct. Setting this to 1 will force a json output regardless of the number of maps listed.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_setTokenFacing<\/b><\/font>(angle [, token,type])<br />\n\t\tThis function sets the token facing according to the 'normal' polar coordinate system, instead of the rather convoluted MT system.<br />\n\t\t<b>- angle:<\/b> angle in degrees<br />\n\t\t<b>- token:<\/b> token id<br />\n\t\t<b>- type<\/b>: <br />\n\t\t\t(0=default) 0=EAST;90=NORTH; 180=WEST and 270=SOUTH. This results in an angle according to mathematical polar coordinates convention (also used in Java) <br />\n\t\t\t(1) inverts rotation to CW and gives an offset of +90 so 'no token facing' ends up to be 0 instead of 270. An 'unrotated' or 'facing cleared' token faces SOUTH. With the default (0) option you would thus use 270. With this alternative (1) option you use 0. In this case thus: 0=SOUTH; 90=EAST;180=NORTH and 270=WEST.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_showHTML<\/b><\/font><i>(string)<\/i><br />\n\t\tThis function will pop-up two forms, one with the <html> code and the other with the result. This is purely for debug purposes and works best when followed by a pause().<\/p>\n\t<p>\n\t\t<font color=red><b>bot_snapAngle<\/b><\/font><i>(token [,divider, align])<\/i><br />\n\t\tThis function aligns the facing of a token to the closest angle given along a divider and returns the new angle<br />\n\t\te.g a divider of 4 will face a token to either -90 0 90 or 180 depending on where its closest at<br />\n\t\tyou can also turn off the align and just return the closest angle<br />\n\t\ttoken: id of the token<br />\n\t\tdivider: the number of allowed facing angles<br />\n\t\talign: 1 is set the token facing to the closest divider angle, 0 is just return the closest angle. Defaults to 1<\/p>\n\t<p>\n\t\t<font color=red><b>bot_sortTokByProp<\/b><\/font><i>(propertyName[,sortOder, tokenList)<\/i><br />\n\t\tReturns an array token Ids or Names of given or selected tokens, sorted by given property.<br />\n\t\t<b>- propertyName:<\/b> name of the property, e.g. 'Strength'<br />\n\t\t<b>- sortOrder:<\/b> 'asc' or 'desc' (defaults to asc)<br />\n\t\t<b>- tokenList:<\/b> list or array of token names or ids (defaults to selected tokens)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_switchMap<\/b><\/font><i>([mapName [,playerNames]])<\/i><br />\n\t\tSwitches the users listed in playerNames to the map mapName.<br />\n\t\t<b>- mapName:<\/b> name of the map to switch to<br />\n\t\t<b>- playerNames<\/b> EITHER: a list of users that are logged in OR 1. The latter switches ALL connected users to the new map.\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_switchMap()] - gives pop-up where you can select map and the user(s) to switch<br>\n\t\t[bot_switchMap('Fair Haven')] - gives pop-up where you can select map ('Fair Haven' is pre selected) and the user(s) to switch<br>\n\t\t[bot_switchMap('Fair Haven', 'Carry, Tom, Burt')] - moves Carry, Tom and Burt to the new map<br>\n\t\t[bot_switchMap('Fair Haven', 1)] - moves ALL players to the new map<br>\n\t\t<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_travelAngle<\/b><\/font><i>(x1,y1,x2,y2)<\/i><br />\n\t\tReturns the angle (within a resolution of 45 degrees) in which the token is travelling.<br />\n\t\t<b>- x1,y1:<\/b> coordinate where the token starts<br />\n\t\t<b>- x2,y2:<\/b> coordinate where the token ends<\/p>\n\t<p>\n\t\t<font color=red><b>mod<\/b><\/font>(<i>number, modNumber<\/i>)<br />\n\t\treturn the modNumber modulus of number<\/p>\n\t<p>\n\t\t<font color=red><b>odd<\/b><\/font><i>(number)<\/i><br />\n\t\treturns 1 is the number is odd else 0.<\/p>\n\t<p>\n\t\t<font color=red><b>pause<\/b><\/font><i>(variable1, variable2, etc.)<\/i><br />\n\t\tthis stops the running code and shows the current value of the variable. Note the "quotes" which are required!<\/p>\n\t\t<br>\n\t\t<br>\n\t\t<u><b>MESSAGE MACROS<\/b><\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_message<\/b><\/font><i>(0:message [, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:target, 6:broadcast, 7:width])<\/i><br>\n\t\tBroadcasts a preformatted message to all users (default). The message consists out of a black (bg) and white (txt) header (default) and a delimited textbox below it, containing the message. When the message is left empty ('') only the header will be displayed. bot_message contains the following optional parameters (only message is required):<br />\n\t\t<b>- message:<\/b> The message displayed<br />\n\t\t<b>- headerText:<\/b> This defaults to: ''. The text in the header, note that the 'token' parameter is set in the header as well on the left side. E.g. when token='Wolf' and headerTxt='Attacks' the header will read 'Wolf Attacks'.<br/>As an extra option you can add ':width=150px' (where 150 obviously is arbitrary) at the end of the header string. This will get filtered out from the header text and used to set the width of the entire message box (which defaults to 100%). Note that if argument 7 (width) is used that argument 7 will overwrite the width you set here. <br>\n\t\t<b>- color:<\/b> This defaults to 'black-white'. Here you can set the backgroundcolor-textcolor of the header. You can choose also to only set the backgroundcolor. Some examples: 'red', 'black-yellow', yellow-red'.<br />\n\t\t<b>- userlist:<\/b> Defaults to all(). Here you can set to whom the message should be send. You can either fill in a user name yourself (NOT TOKEN NAME!) e.g. 'Frank' or you can make use of one of the user functions defined here below, e.g. all(), gm(), ownergm().<br />\n\t\t<b>- token:<\/b> Defaults to ''. Here you can give the name of the token to which the message reflects. The effect is that the image and name of the token appears left in the header<br />\n\t\t<b>- target:<\/b> Defaults to ''. Here you can give the name of another token to which the message reflects. The effect is that the image of tha token appears right in the header<br />\n\t\t<b>- broadcast:<\/b>: (0) the message is NOT broadcasted but the entire structure is returned. This is usefull is you want to e.g. embed the result in another message; (1) (default) the message is immediately broadcasted<br>\n\t\t<b>- width:<\/b>: defaults to 100%. The message is actually an html table. This parameter sets the width of that table. <br>\n\t\t<i><b>Examples Use:<\/b><br>\n\t\t[resultMsg = bot_message('Hello world', 'Header', 'black-white', bot_all(), 'Wolf', 'Wolf', '', 0, '150px')]<br>\n\t\t[bot_message("Hallow word")]<br>\n\t\t[bot_message("this message is shown to gm only", "GM Only:width=110px", "red-yellow", bot_gm())]<br>\n\t\t[bot_message("this message is shown to all but gm", "The rest", "yellow-red", bot_ngm())]<br>\n\t\t[bot_message(token.name+" Takes damage", "is attacked", "black", all(), 'Harmless Bunny', 'Tim The Enchanter')]<br>\n\t\t<\/i><\/p>\n\t\t<br>\n\t\tThe following functions can be used in conjunction with bot_message() and return a JSON ARRAY (e.g. ["Frank","Jim","Suzy"])<br>\n\t\t<b>- <font color=red>bot_all<\/font>():<\/b> all users<br />\n\t\t<b>- <font color=red>bot_gm<\/font>():<\/b> gm(s) only<br />\n\t\t<b>- <font color=red>bot_ngm<\/font>():<\/b> all but NOT gm(s)<br />\n\t\t<b>- <font color=red>bot_self<\/font>():<\/b> initiator of the macro<br />\n\t\t<b>- <font color=red>bot_nself<\/font>():<\/b> all but NOT initiator of the macro<br />\n\t\t<b>- <font color=red>bot_selfgm<\/font>():<\/b> gm(s) and initiator of the macro<br />\n\t\t<b>- <font color=red>bot_nselfgm<\/font>():<\/b> all but NOT gm(s) and initiator of the macro<br />\n\t\t<b>- <font color=red>bot_ownergm<\/font>():<\/b> gm(s) and owners of the currentToken. So NOT the token that you might give as a parameter to the bot_message() function but the token that is currentToken() at that moment.<br />\n\t\t<b>- <font color=red>bot_nownergm<\/font>():<\/b> all but NOT gm(s) and owners of the current token<\/p>\n\t\t<br>\n\t\t<br>\n\t\tThe 'bot_' prefixes in all these function are added as a precaution to make sure that there are no conflicts with a framework in which you use the BoT. If you however want to use these 'retrieve user' functions but without the 'bot_' prefix you need to create your own set of user defined functions. To do this paste the following piece of code in any onCampaignLoad macro in your framework:<br>\n\t\t<br><i>\n\t\t[H: '<!-- ONTOKENMOVE MACROS -->']<br>\n\t\t[defineFunction("self", "self@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nself", "nself@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("all", "all@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("gm", "gm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("ngm", "ngm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("selfgm", "selfgm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nselfgm", "nselfgm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("ownergm", "ownergm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nownergm", "nownergm@lib:OnTokenMove",1,1)]<br>\n\t<\/i><\/p>\n\t\n\t<p>\n\t\t<br>\n\t\t<u><b>GEOMETRIC MACROS<\/b><\/u><\/p>\n\t<p>\n\t\tThe Geometric functions allow you to:<br>\n\t\t- create shapes on the map (<b>bot_show...<\/b>), <br>\n\t\t- check whether a point or token is on the shape (<b>bot_pointOn...<\/b>) and <br>\n\t\t- select all tokens within the shape (<b>bot_selectOn...<\/b>). <br>\n\t\t<br>\n\t\tfor different types of shapes:<br>\n\t\t- <b>Circle<\/b>,<br>\n\t\t- <b>Cone<\/b>, <br>\n\t\t- <b>Triangle<\/b>, <br>\n\t\t- <b>Square<\/b> and<br>\n\t\t- <b>Line<\/b><br>\n\t\t<br>\n\t\tSome of these functions can be passed on different types of parameter, depending on what you want. For example bot_pointOnCircle can be passed a point (xp,yp) as parameter or a token (tok). The function checks in this case the number of parameters passed on and from that number derives which type of parameters you submitted. <br>\n\t\t<br>\n\t\tThe following parameters are used<br>\n\t\t- <b>xp,yp<\/b>: these are GRID coordinates e.g. 0,0 is the origin of the map. These are coordinates that are checked whether they are on the shape. The function will thus return true (1) or false (0)<br>\n\t\t- <b>x1,y1,x2,y2,x3,y3<\/b>: these are also GRID coordinates e.g. 3,5 or 2,6. These form the edge or the shape. E.g. for a line x1,y1 is the beginning of the line and x2,y2 the end. x3,y3 is only used to define the triangle.<br>\n\t\t- <b>me<\/b>: this is the centre token, e.g. when drawing a circle, then the circle will be centered around me. When checking whether tok is on the circle, then me is again the centre of that circle<br>\n\t\t- <b>range<\/b>: this is the distance from the centre of the shape (e.g. me) to the edge. The distance is in CELLS (so not in distance per cell)<br>\n\t\t- <b>arc=angle<\/b>: this is the angle of the arc of the triangle or cone in degrees. Typical numbers are 30, 45, 60 and 90 degrees. Here 90 degrees is a quarter of a circle. <br>\n\t\t- <b>drawToken<\/b>: when the shapes are drawn on the map a token is used to draw the shape. This token is copied on the background and the ids of the copied token are returned (so you can easily delete them later on). drawToken is the NAME of the token. Note that this token has to be on the BASE map. E.g. 'Boom'.<br>\n\t\t<br>\n\t\t\t\n\t\t<font color=red><b>bot_pointOnCircle<\/b><\/font><i> (xp,yp, me, range)<\/i> OR <font color=red><b>bot_pointOnCircle<\/b><\/font><i> (tok, me, range) <\/i><br>\n\t\tChecks if a point (p) or token (tok) is on a circle centered on me with range r<br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnCircle<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showCircle<\/b><\/font><i> (me, range, arc=angle, drawToken)  <\/i><br>\n\t\tThis is a completely redundant functions as everything is done by bot_getCircleCoords, but for function name consistancy this is added. Returns coordinates of the circle and does NOT draw it when drawToken=='' ;  returns the ids of the copied tokens and DOES draw it, when drawToken !='' <br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnCone<\/b><\/font><i> (xp,yp, me, range, arc=angle)  <\/i> OR <font color=red><b>bot_pointOnCone<\/b><\/font><i> (tok, me, range, arc=angle)  <\/i><br>\n\t\tChecks if a point is on a cone, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnCone<\/b><\/font><i> (me, range, arc=angle)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showCone<\/b><\/font><i> (tok, range, arc=angle, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the cone. Draws the cone on grid if option set true<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnSquare<\/b><\/font><i> (xp,yp, me, range)  <\/i> OR <font color=red><b>bot_pointOnSquare<\/b><\/font><i> (tok, me, range)  <\/i><br>\n\t\tChecks if a point (p) is within range of me, assuming a square area with range (me, edge square) <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnSquare<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showSquare<\/b><\/font><i> (me, range, drawToken)  <\/i> OR <font color=red><b>bot_showSquare<\/b><\/font><i> (x1,y1, x2,y2, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the square draws the square on grid (if option set true)<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnLine<\/b><\/font><i> (xp,yp, x1,y1, x2,y2)  <\/i> OR <font color=red><b>bot_pointOnLine<\/b><\/font><i> (xp,yp, me, range)  <\/i> OR <font color=red><b>bot_pointOnLine<\/b><\/font><i> (tok, me, range)  <\/i><br>\n\t\tChecks if a point (p) or token (tok) is on a line between 2 points (1 and 2) or on a line casted from me, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnLine<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showLine<\/b><\/font><i> (x1,y1, x2,y2, drawToken)  <\/i> OR <font color=red><b>bot_showLine<\/b><\/font><i> (me, range, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the line. Draws the line on grid (if option set true)<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (xp,yp, x1,y1, x2,y2, x3,y3)  <\/i> OR <font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (xp,yp, me, range, arc=angle)  <\/i> OR <font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (tok, me, range, arc=angle)  <\/i><br>\n\t\t<br>\n\t\tChecks if a point is between three points, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnTriangle<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showTriangle<\/b><\/font><i> (x1,y1, x2,y2, x3,y3, drawToken)  <\/i> OR <font color=red><b>bot_showTriangle<\/b><\/font><i> (me, range, arc=angle, drawToken)  <\/i><br>\n\t\tReturns coordinates of the triangle and draws it on grid if options set true <br>\n\t<\/p>\n\t\n\t<p>\n\t\t<u><b>Some functions that are not of my hand but as there was a need for them I implemented them into the BoT<\/b><\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_pi<\/b><\/font>()<\/p>\n\t<p>\n\t\t<font color=red><b>bot_cos<\/b><\/font>(radians)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_sin<\/b><\/font>(radians)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_toRadians<\/b><\/font>(degrees)<\/p>\n\n\t\"]\n\n\t[r, if(bot_isFullScreen()), CODE:{\n\t\t[r,dialog(\"BoT Functions Manual\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n\t};{\n\t\t[r,frame(\"BoT Functions Manual\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n\t}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c3c2b86a-299a-4bc2-a336-e4b86b7e70d1",
          "commandChecksum": "2c162b9c1a4379c7a7681cadec57591d",
          "propsChecksum": "5bb4ee18485b5ffe7ab981073ffc9d0b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "20",
        "index": 147,
        "label": "movementLock",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- movementLock ------------------------------------------------>']\n[h:assert(isGM(),\"This macro may only be executed by the GM\",0)]\n\n[h:toggles\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[H: movementLock = 1 - movementLock]\n\n[h:toggles = setStrProp(toggles, \"movementLock\", movementLock)]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\n\t\n[H: broadcast(\"<b>Server Movement Lock is <font color=blue>\"+if(movementLock,\"ON\",\"OFF\")+\"<\/font><\/b>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e684b701-de56-4dc4-9c13-5952867d381a",
          "commandChecksum": "41d4419b5f5bc4c86e21d93024c8b318",
          "propsChecksum": "b9eed54557160ba65399d2f8a0c740ae"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "23",
        "index": 148,
        "label": "popUpHandout",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[id\t= arg(0)]\n[w\t= arg(1) + 40]\n[h\t= w]\n[text\t= arg(2)]\n\n[dialog(\"Token Handout\", \"width=\"+w+\"; height=\"+h+\"; temporary=1; input=0; noframe=1\"): {\n\t<table align='center' valign='center'>\n\t\t<tr><td>\n\t\t\t<img src='[r:id]'><\/img>\n\t\t<\/td><\/tr><tr><td>\n\t\t\t[r:text]\n\t\t<\/td><\/tr>\n\t<\/table>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e8a04ad3-a2b1-4169-a313-0859dbfebe68",
          "commandChecksum": "dc187d33beb93dbe754bf6f901abce74",
          "propsChecksum": "8ec3992ee87a08a0dc254f0910ec9d61"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "16",
        "index": 149,
        "label": "remTrunkImages",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- remTrunkImages ------------------------------------------------>']\n\n[h:tokenList = getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n[h:canopyList = \"\"]\n[h: allTokensJson = json.fromList(tokenList)]\n[h: maxCount = json.length(allTokensJson)]\n\n[h:'<!-- create json splices to prevent the 1000 loop limit -->']\n[h: splices = \"\"]\n[h: from = 0]\n[h: to = from + 499]\n[h, while(to >= 0), code: {\n    [if(to >= maxCount): to = -1]\n    [thisSplice = json.get(allTokensJson, from, to)]\n    [splices = json.append(splices, thisSplice)]\n    [from = from + 500]\n    [if(to != -1):to = from + 499]\n}]\n\n[h:'<!-- loop through them and create a tokenlist consisting out of special pads only-->']\n[h: cleanTokenList = \"\"]\n[h, foreach(splice, splices, \"\"), code: {\n    [foreach(tok, splice, \"\"):  cleanTokenList = if(startsWith(tok, \"Canopy\"), listAppend(cleanTokenList, tok), cleanTokenList)]\n    }]\n}]\n\n[h:'pause(\"cleanTokenList\",\"numTokens\",\"mainCount\",\"restCount\")']\n[h:tokenList = cleanTokenList]\n\n[h,foreach(token,tokenList,\"\"): setTokenHandout()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "727d8a76-0fd6-4ab4-b14c-72d1485bab33",
          "commandChecksum": "ec65af3415349dff1b21cb6a1e4dc18a",
          "propsChecksum": "647b5e3a472dfe0a164478ea1b102b66"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "15",
        "index": 150,
        "label": "removeP20",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:tokList = getSelected()]\n[h, foreach(tok,tokList), CODE:{\n\t[token(tok): token.name = replace(token.name,\"%20\", \" \")]\n}]",
        "maxWidth": "",
        "tooltip": "This macro replaces %20 with spaces \" \" in the selected token names",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3d8256d0-1ff0-4764-87ca-d15b64c55b3e",
          "commandChecksum": "5ccb309be665429aea6293d3cc71d2c8",
          "propsChecksum": "988d7958f6eee9f62c0370d41a04761e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "63",
        "index": 151,
        "label": "removeTokens",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------- removeTokens ---------------------------------------- -->']\n\n[if(argCount() < 1): toks\t= \"\"\t; toks = arg(0)]\n[splices\t= bot_createSplices(toks)]\n<!-- loop through the splices and create an array of the coords of all the tokens -->\n[foreach(splice, splices, \"\"), code: {\n\t[foreach(tok, splice, \"\"):  removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "55cce77a-a92c-4e4d-8be8-14a115382f29",
          "commandChecksum": "d3052e4567c0eb83f5b299c7676e92f7",
          "propsChecksum": "b31b385fc08c499c6626f4ea06ada6e9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "61",
        "index": 152,
        "label": "renumberToks",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- renumberToks -->']\n[h:'<!-- THREE CODE LEVELS METHOD USED -->']\n[h,if(argCount()>0): tokenName = arg(0); tokenName = \"\"]\n[h,if(argCount()>1): allToks = arg(1); allToks = \"\"]\n\n[h:specNameList = \"Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop\"]\n\n[h, if(tokenName == \"\"): abort(input(\"tokenName|\"+specNameList+\"|Choose the special tokens on this map to renumber?|LIST|VALUE=STRING\"))]\n[h, if(allToks == \"\"): allToks = json.toList(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\"))))]\n\nold Names<br>\n[r:allToks]\n[h:allToks = listSort(allToks, \"N-\")]\n\n[h:'<!-- loop through the splices and create an array of the coords of all the tokens -->']\n[h:splices = bot_createSplices(allToks)]\n[h:i=1]\n[h, foreach(splice, splices, \"\"), CODE:{\n\t[foreach(tok, splice, \"\"), CODE:{\n\t\t[if(startsWith(tok, tokenName + \" \")), CODE:{\n\t\t\t[token(tok):token.name = tokenName + \" \" + i]\n\t\t\t[i = i + 1]\n\t\t''\n\t\t}; {}]\n\t''\n\t}]\n''\n}]\n\n[h:allToks = json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\"))))]\n\n<br><br>\nNew Names<br>\n[r:allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c1dd4f99-cfab-4e42-9f5b-29c4e2fcd8fb",
          "commandChecksum": "39f1d9d75f7f4c28a2f9ac97b48461b2",
          "propsChecksum": "987946a3717b183458c74c8768b1ab28"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "12",
        "index": 153,
        "label": "setDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:assert(listCount(getSelected()), \"make sure (only) one token is selected\",0)]\n[h:switchToken(getSelected())]\n[h:drawOrder = getTokenDrawOrder()]\n[h:input(\"drawOrder|\"+drawOrder+\"|Set Draw Order\")]\n[h:setTokenDrawOrder(DrawOrder)]",
        "maxWidth": "",
        "tooltip": "<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d2fd8332-ee1f-40a0-89f2-04d9b3ed34a4",
          "commandChecksum": "7dad47b02cabad6b675db5cf39d0b4b8",
          "propsChecksum": "eda0e654037096ecbd93e756f93dfbab"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "16",
        "index": 154,
        "label": "setLightSource",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- SETLIGHTSOURCE ------------------------------------------------>']\n\n<!-- Check if at least one token is selected -->\n[h: selToks\t\t\t\t= getSelectedNames()]\n[h: assert(listCount(selToks),\"Please make sure at least one token is selected\",0)]\n[h: me\t\t\t\t\t= listGet(selToks, 0)]\n[h: switchToken(me)]\n\n<!-- get lightsources from campaignproperties -->\n[h:source\t\t\t\t= getInfo(\"campaign\")]\n[h:lightSource\t\t\t= json.get(source, \"light sources\")]\n[h:lightTypeList\t\t= listSort(json.fields(lightSource),\"A+\")]\n\n<!-- remove light types not wanted, can be set through the settings -->\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes', 'lib:EventMacros')]\n[h,foreach(light,excludeLightTypes): lightTypeList = listDelete(lightTypeList, listFind(lightTypeList, light))]\n\n<!-- construct lists of light -->\n[h:i\t\t\t\t\t= 0]\n[h:inputStr\t\t\t\t= \"\"]\n\n[h, foreach(lightType, lightTypeList), CODE:{\n\t[inputStr\t\t\t= listAppend(inputStr,\"tab\"+i+\" | \"+lightType+\" || TAB\")]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"divider | | <html><b>The Wolph42 Light Editor<\/b><\/html>| LABEL | text=none\")]\n\t[lights\t\t\t\t= json.get(lightSource,lightType)]\n\t[lightSet\t\t\t= lightType]\n\t[lightList\t\t\t= \"\"]\t\t\n\t[foreach(light, lights):lightList\t= listappend(lightList, json.get(light, \"name\"))]\n\t[lightSetList\t\t= listSort(lightList,\"N+\")]\n\t[nlightSetList\t\t= listCount(lightSetList)]\n\t[h,count(nlightSetList),CODE:{\n\t\t[light\t\t\t= listGet(lightSetList,roll.count)]\n\t\t[newStr\t\t\t= \"Lamp\"+i+\"S\"+roll.count+\"|\"+hasLightSource(lightSet, light)+\"| \"+light+\" | CHECK\"]\n\t\t[inputStr\t\t= listAppend(inputStr, newStr)]\n\t}]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"divider2 | ------ | ------------------------------ | LABEL\")]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"removeAll | 0 | REMOVE ALL LIGHTS? | CHECK\")]\n\t[i\t\t\t\t\t= i + 1]\n}]\n\n<!-- ask for input -->\n[H: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\")]\n\n<!-- create the dialog -->\n[H: status\t\t\t\t= eval(inputStr)]\n[H: abort(status)]\n\n<!-- set the the lights -->\n[h: i\t\t\t\t\t= 0]\n[h, foreach(lightType, lightTypeList), CODE:{\n\t[lights\t\t\t\t= json.get(lightSource,lightType)]\n\t[lightSet\t\t\t= lightType]\n\t[lightList\t\t\t= \"\"]\t\t\n\t[foreach(light, lights):lightList\t= listappend(lightList, json.get(light, \"name\"))]\n\t[lightSetList\t\t= listSort(lightList,\"N+\")]\n\t[nlightSetList\t\t= listCount(lightSetList)]\n\t[h,COUNT(nlightSetList),CODE:{\n\t\t[j\t\t\t\t= roll.count]\n\t\t[light\t\t\t= listGet(lightSetList,j)]\n\t\t[foreach(tok, selToks): bot_applyLightSource()]\n\t}]\n\t[i\t\t\t\t\t= i + 1]\n}]\n\n<!-- if removeAll was checked, clear all lights -->\n[H, if(removeAll), CODE:{\n\t\t\t[foreach(tok, selToks), CODE:{[token(tok): clearLights()]}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "812cdc4b-963b-4100-bddf-ab975b89025f",
          "commandChecksum": "2ce1ec46a909f5f8f0f4130130593c8e",
          "propsChecksum": "7050e959a2b141a75b27776ddf73d8a7"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "11",
        "index": 155,
        "label": "setTokSize",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- setTokSize -->']\n\n[h:tok = getSelectedNames()]\n[h:assert(listCount(tok)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(tok)]\n[h:bot_determineTokSize()]",
        "maxWidth": "",
        "tooltip": "<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3955a358-54ca-4fed-b491-f6eb10a67622",
          "commandChecksum": "f0ab7c6d654bff88e055861a9a32c9b8",
          "propsChecksum": "98b033c50a69668271204af268a54730"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "23",
        "index": 157,
        "label": "showHandout",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- showHandout (0/1=return image ID) ------------------------------------------------>']\n<!-- <html> Pops up a dialog showing the handout of the selected token on all selected clients -->\n[h,if(argCount() > 0): returnID\t= arg(0) ; returnID = 0]\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:me\t\t\t= getSelected()]\n[h:assert(listCount(me)==1, \"Make sure (only) one token is selected\",0)]\n[h:userList\t\t= if(returnID, \"\", getAllPlayerNames())]\n\n[h, token(me),CODE:{\n\t[image\t\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenImage()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Image<\/td>\t<\/tr><\/table><\/html>\"]\n\t[portrait\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenPortrait()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Portrait<\/td>\t<\/tr><\/table><\/html>\"]\n\t[handout\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenHandout()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Handout<\/td>\t<\/tr><\/table><\/html>\"]\n}] \n\n[H: inputStr\t= \"[]\"]\n[H: inputStr\t= json.append(inputStr,\"junk|<html><b>Choose picture to show to players:<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[H: inputStr\t= json.append(inputStr,\"picChoice|\"+image+\",\"+portrait+\",\"+handout+\"|Which picture|RADIO|ORIENT=H SELECT=2\")]\n[H: inputStr\t= json.append(inputStr,\"picSize|500|Size of picture (px)\")]\n[h,if(!returnID), CODE:{\n\t[H: inputStr\t= json.append(inputStr,\"text|<enter handout-text here>|Handout text (html)\")]\n\t[H: inputStr\t= json.append(inputStr,\"junk|<html><b>Select Players<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[H,FOREACH(player, userList): inputStr = json.append(inputStr,\"player\"+roll.count+\"|1|\"+player+\"|CHECK\")]\n};{}]\n\n[H: inputStr\t= json.evaluate(inputStr)]\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n[h:playerList = \"\"]\n[H,FOREACH(player, userList), CODE:{\t\n\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n}]\n\n[h,token(me), if(picChoice == 0): handoutID = getTokenImage(picSize)]\n[h,token(me), if(picChoice == 1): handoutID = getTokenPortrait(picSize)]\n[h,token(me), if(picChoice == 2): handoutID = getTokenHandout(picSize)]\n\n[h,if(returnID):\n\tmacro.return = handoutID\n;\n\tbot_execAllPlayers(\"popUpHandout@lib:OnTokenMove\",json.append(\"\",handoutID,picSize,text), playerList)\n]",
        "maxWidth": "",
        "tooltip": "<html> Pops up a dialog showing the handout of the selected token on all selected clients",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2aaf9030-9af9-4683-b739-b924dd4594bc",
          "commandChecksum": "0a7f9337061d617966a78b99cf46ecd3",
          "propsChecksum": "96d4f5e5dce13bbd95bc022c1a459c00"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "42",
        "index": 158,
        "label": "toggleFullScreen",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------- toggle full screen mode ----------------------------------------------------- -->']\n<!-- <html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted. -->\n\n<!-- retrieve current setting -->\n[FSM = getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")]\n\n<!-- initialize setting if not done so before -->\n[if(FSM == \"\"): FSM = 1]\n<!-- toggle the setting -->\n[FSM = 1- FSM]\n\n<!-- save it -->\n[h:setLibProperty(\"fullScreenMode\", FSM , \"Lib:EventMacros\") ]\n\n<!-- send message to user -->\n[h:message = if(FSM, \"Full Screen Mode is now turned ON\", \"Full Screen Mode is now turned OFF\")]\n[h:bot_message(\"\",message)]\n\n<!-- send virtual bot menu to the full screen in dialog form -->\n[closeDialog(\"Bag Of Tricks Macros\")]\n[closeFrame(\"Bag Of Tricks Macros\")]\n[bot_MacroButtonsOTMUtils()]\n\n[h, if(isFrameVisible(\"Bag Of Tricks Macros\")): bot_MacroButtonsOTMUtils()]\n\n<!-- make sure there's no output to chat -->\n[abort(0)]\n\n<!-- ---------------------------------------------------------------------------------->\n<!-- ---------------------code to add to depending functions ----------------------- -->\n<!-- ---------------------------------------------------------------------------------->\n\n[if(getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "67f8836a-5af5-458b-8709-da8dcd15d293",
          "commandChecksum": "9d035610a633da522c04be7a21cc90b1",
          "propsChecksum": "98b5408fbe493303609e458d89c9099a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "62",
        "index": 159,
        "label": "toggleSpecial",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- toggleSpecial -->']\n[h:useAltImage = getLibProperty('useAltImage', 'lib:EventMacros')]\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\n[h:selectedTokens\t= getSelectedNames()]\n[h, if(selectedTokens == \"\"):\n\tallToks\t\t\t= json.toList(json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\")))))\n; \n\tallToks\t\t\t= selectedTokens\n]\n[h:roofToks\t\t\t= \"\"]\n\n[h:specNameList = \"Canopy, Foliage, Roof, Linked\"]\n[h:abort(input(\"tokenName|\"+specNameList+\"|Choose the special tokens on this map to toggle on or off?|LIST|VALUE = STRING\"))]\n[h,foreach(tok, allToks), CODE:{\n\t[if(startsWith(tok, tokenName)), CODE:{\n\t\t[roofToks = listAppend(roofToks, tok)]\n\t\t[setProperty(\"w42.bot.tokens.onHouse\", \"\", tok)]\n\t}; {}]\n}]\n\n[h:assert(roofToks != \"\", \"No \"+tokenName+\" tokens found \"+if(selectedTokens!=\"\", \"in selection\", \"on map\"), 0)]\n[h:tmpTok = listGet(roofToks, 0)]\n\n[h: switchToken(tmpTok)]\n[h, if(getTokenHandout() != \"\"): noRoofImg = getTokenHandout(); noRoofImg = tblImage(\"tbl_Image\",1)]\n[h: currentImg = getTokenImage()]\n[h, if(currentImg != noRoofImg): noRoof = 1; noRoof = 0]\n\n[h:'pause(\"allToks\", \"roofToks\", \"tmpTok\", \"noRoof\", \"currentImg\", \"noRoofImg\")']\n\n[h,if(noRoof), CODE:{\n\t[h, foreach(tok, roofToks), CODE:{\n\t\t[switchToken(tok)]\n\t\t[w\t\t\t= getTokenWidth()]\n\t\t[h\t\t\t= getTokenHeight()]\n\t\t[isArray\t= if(json.type(getTokenVBL())==\"ARRAY\",1,0)]\n\t\t[if(isArray):transferVBL(1,1)]\t\t\n\t\t[setProperty(\"w42.bot.tokens.onHouse\",\"\")]\n\t\t[if(getTokenHandout() != \"\"): noRoofImg = getTokenHandout(); noRoofImg = tblImage(\"tbl_Image\",1)]\n\t\t[roofImg \t= getTokenImage()]\n\t\t[if(roofImg != noRoofImg):setProperty(\"w42.bot.image.original\", roofImg)]\n\n\t\t[setTokenImage(noRoofImg)]\n\t\t[setTokenWidth(w)]\n\t\t[setTokenHeight(h)]\n\t\t[transferVBL(0,1)]\t\t\n\t}]\n}; {\n\t[h, foreach(tok, roofToks), CODE:{\n\t\t[switchToken(tok)]\n\t\t[w\t\t= getTokenWidth()]\n\t\t[h\t\t= getTokenHeight()]\n\t\t[transferVBL(1,1)]\t\t\n\t\t[setProperty(\"w42.bot.tokens.onHouse\",\"\")]\n\t\t[setTokenImage(getProperty(\"w42.bot.image.original\"))]\n\t\t[setHalo(\"None\")]\n\t\t[setTokenWidth(w)]\n\t\t[setTokenHeight(h)]\n\t\t[transferVBL(0,1)]\t\t\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "44e64d89-d612-4409-9607-8dca021db48a",
          "commandChecksum": "c9e4064b72d2b9d6a884e6bfc23ee09c",
          "propsChecksum": "cfed29983d6ca1c0b034bed03c72c5e9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "20",
        "index": 160,
        "label": "tokenLock",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- tokenLock ------------------------------------------------>']\n<!-- <html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!<\/html> -->\n[ids\t= getSelected()]\n[assert(listCount(ids == 1), \"Make sure that at least one token is selected\", 0)]\n\n[h,foreach (id, ids), CODE:{\n\t[switchToken(id)]\n\t[assert(isGM(),\"This macro may only be executed by the GM\",0)]\n\t[lockMovement\t= if(getProperty(\"w42.bot.lockMovement\") == 1, 0, 1)]\n\t[setProperty(\"w42.bot.lockMovement\",lockMovement)]\n\t[broadcast(\"<b>The movement for \"+token.name+\" has been <font color=blue>\"+if(lockMovement,\"LOCKED\",\"UNLOCKED\")+\"<\/font><\/b>\")]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a0903a1a-66e3-4ded-8cbb-29c0eda61b6e",
          "commandChecksum": "5d92bd63e64677cd64d015107705692c",
          "propsChecksum": "55c0022e08b747d916b24b761d2c6029"
        }
      },
            {
        "autoExecute": true,
        "color": "gray",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 161,
        "label": "Launch Dice Box",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- CODE ORIGINALLY FROM RUMBLE'S DICEBOX. REWRITTEN BY WOLPH42-->\n<!-- <html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually. -->\n[h: maxFrames\t= 10]\n[h: frameNum\t= maxFrames + 1]\n[h,count(maxFrames), CODE:{\n\t[frameName = \"Dice Box \"+roll.count]\n\t[if(!isFrameVisible(frameName)):frameNum = min(frameNum, roll.count)]\n}]\n[h:assert(frameNum <= maxFrames, \"You already have the maximum number of frames open\",0)]\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\n[h:frameName = \"Dice Box \"+frameNum]\n\n[h: dbArgs = json.set(\"{}\", \"mod\", 0, \"tn\", 0, \"d4s\", 0, \"d5s\", 0, \"d6s\", 0, \"d8s\", 0, \"d10s\", 0, \"d12s\", 0, \"d20s\", 0, \"d100s\", 0, \"showTo\", \"all\", \"breakdown\", \"totalRoll\", \"frameName\", frameName)]\n\n[macro(\"NDB@this\"):dbArgs]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9ce075af-24b7-4c80-b385-90194c9afc5e",
          "commandChecksum": "7731f22f13bc20486b734b29b5246202",
          "propsChecksum": "1ce59609e2447584c07a07a95de58508"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 162,
        "label": "NDB",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- NDB ----------------------------->']\n[h:dbArgs = macro.args]\n\n<!-- Basic Variables from Library Properties-->\n<!-- dbArgs = \"mod\", 0, \"tn\", 0, \"d4s\", 0, \"d5s\", 0, \"d6s\", 0, \"d8s\", 0, \"d10s\", 0, \"d12s\", 0, \"d20s\", 0, \"d100s\", 0, \"showTo\", \"all\", \"breakdown\", \"totalRoll\" -->\n[h,if(json.contains(dbArgs, \"explodeDice\")): explodeCode = if(json.get(dbArgs, \"explodeDice\") !=0 ,\"CHECKED\",\"\"); explodeCode = \"\"]\n<!-- turn all the json keys into variables -->\n[h:varsFromStrProp(json.toStrProp(dbArgs))]\n\n[h:frameNum\t\t= replace(frameName, \"Dice Box \", \"\")]\n[h:dieList \t\t= getLibProperty(\"dieList\"+frameNum, \"Lib:EventMacros\")]\n[h:optionsList \t= getLibProperty(\"optionsList\"+frameNum, \"Lib:EventMacros\")]\n\n<!-- showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=eachRoll ;  -->\n[h:varsFromStrProp(optionsList)]\n\n[if(dieList == \"\"): dieList \t\t= \"4,5,6,8,10,12,20,100\"]\t\t\n\n[h: showAll\t\t= if(showTo == \"all\", \"CHECKED\", \"\")]\n[h: showGMSelf\t= if(showTo == \"gm-self\", \"CHECKED\", \"\")]\n[h: showGM\t\t= if(showTo != \"all\" && showTo != \"gm-self\", \"CHECKED\", \"\")]\n[h: showTotals\t= if(breakdown == \"totalRoll\", \"CHECKED\", \"\")]\n[h: showEach\t= if(breakdown != \"totalRoll\", \"CHECKED\", \"\")]\n\n<!-- Common Variables for the Form-->\n[h:action\t\t= macroLinkText(\"NDBUpdate@this\",\"all\")]\n[h:d4img\t\t= tableImage(\"tbl_Image\",16)]\n[h:d5img\t\t= tableImage(\"tbl_Image\",17)]\n[h:d6img\t\t= tableImage(\"tbl_Image\",18)]\n[h:d8img\t\t= tableImage(\"tbl_Image\",19)]\n[h:d10img\t\t= tableImage(\"tbl_Image\",20)]\n[h:d12img\t\t= tableImage(\"tbl_Image\",21)]\n[h:d20img\t\t= tableImage(\"tbl_Image\",22)]\n[h:d100img\t\t= tableImage(\"tbl_Image\",23)]\n[h:clearAllLink\t= macroLink(\"(Clear All)\", \"NDBCall@\"+getMacroLocation(), \"none\")]\n\n<!-- head of frame -->\n[h:diceBoxStr\t= \"\n\t<html><head><title>%{frameName}<\/title><\/head><body><form name='%{frameName}' method='json' action='%{action}'>\n\t<table align='left' color='black' cellpadding='1'><tr><td valign='centre' align='left'>\n\t\t<table cellpadding='1' border='0' valign='centre'><tr><td>\n\t\t<input type='hidden' name='frameName' value='%{frameName}'>\n\"]\n\n<!-- dice part of the frame -->\n<!-- initialize all dice types, this needs to be done in case the options are changed-->\n[h,foreach(dice, \"4,5,6,8,10,12,20,100\"): diceBoxStr = diceBoxStr + \"<input type='hidden' name='d\"+dice+\"s'\tvalue=0>\"]\n\n<!-- only list the dice that have been listed in the options -->\n<!-- \tforeach content:\n\t\t'-' Button: lower #dice in NDBUpdate\t\t\t\t\n\t\timage of die\t\t\t\t\t\t\t\n\t\t'+' Button: up #dice in NDBUpdate \t\t\t\t\t\t\t\n\t\ttext box showing dice result\t\t-->\n[h,foreach(dice, dieList): diceBoxStr = diceBoxStr + \"\n\t\t\t<input type='submit' value='<html>-<!-- \"+dice+\" -->'\tname='clickedButton'>\t<\/td><td>\t\n\t\t\t<img src='%{d\"+dice+\"img}'><\/img>\t\t\t\t\t<\/td><td>\t\n\t\t\t<input type='submit' value='<html>+<!-- \"+dice+\" -->'\tname='clickedButton'>\t<\/td><td>\t\n\t\t\t<input type='text' name='d\"+dice+\"s'\tvalue='%{d\"+dice+\"s}' size='2'><\/td><\/tr><tr><td>\n\"]\n\n<!-- options part of the frame and the cancel roll buttons-->\n[h:diceBoxStr\t= diceBoxStr + \"\n\t\t<\/td><\/tr><\/table>\n\t\t<\/td><td align='left' valign='top' style='font-size:small; '>\n\n\t\t<table cellpadding='1' border='0'><tr><td>\"\n\t\t\t+\tif(showMod,\t\t\"<b>Modifier<\/b>:\t<\/td><td>\t<input type='text'\t\tname='mod'\tvalue='%{mod}' size='3'>\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='mod'\t\t\tvalue='\"+modifier+\"'>\")\n\t\t\t+\tif(showTarget,\t\"<b>Target <\/b>:\t<\/td><td>\t<input type='text'\t\tname='tn'\tvalue='%{tn}' size='3'>\t\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='tn'\t\t\t\tvalue='\"+target+\"'>\")\n\t\t\t+\tif(showExplode,\t\"<b>Explode?<\/b>:\t<\/td><td>\t<input type='checkbox'\tname='explodeDice'  %{explodeCode}>\t\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='explodeDice'\tvalue='\"+explode+\"'>\")\n\t\t+\"<\/table>\"\n\n\t\t+ if(showResults, \"<b>Show Results To:<\/b>\n\t\t<table  cellpadding='3' border='0'><tr><td>\n\t\t\t<input type='radio' name='showTo' value='all'\t\t%{showAll}><\/input>\t\t<\/td><td> All\t\t\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='showTo' value='gm'\t\t%{showGM}><\/input>\t\t<\/td><td> GM Only\t\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='showTo' value='gm-self'\t%{showGMSelf}><\/input>\t<\/td><td> You and GM\t<\/tr><tr><td>\n\t\t<\/table>\", \"<input type='hidden' name='showTo' value='\"+showGMOption+\"'>\")\n\t\t\n\t\t+ if(showTooltip, \"<b>Tooltip Info:<\/b>\n\t\t<table  cellpadding='3' border='0'><tr><td>\n\t\t\t<input type='radio' name='breakdown' value='totalRoll'\t%{showTotals}>\t<\/td><td> Totals\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='breakdown' value='eachRoll'\t%{showEach}>\t<\/td><td> Each Die\t<\/tr><tr><td>\n\t\t<\/table>\",\"<input type='hidden' name='breakdown' value='\"+eachRollOption+\"'>\")\n\t+\"<\/td><\/tr><\/table>\n<input type='submit' width='40' name='clickedButton' value='Roll'>\t\t  \n<input type='submit' width='40' name='clickedButton' value='Clear'>\t\t  \n<input type='submit' width='40' name='clickedButton' value='Options'>\n\n\t<\/form><\/body><\/html>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(frameName,\"width=250; height=350; temporary=0; input=1\"):\t{ [r:strformat(diceBoxStr)] }]\n};{\n\t[frame(frameName,\"width=250; height=350; temporary=0; \"):\t\t\t{ [r:strformat(diceBoxStr)] }]\n}]\n\n[h:abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6fc42271-9915-40ea-ae43-92988ec4ed74",
          "commandChecksum": "39c780f9db425b30ab369eed6232e442",
          "propsChecksum": "d98c544cbb14f6825d438398397a909b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 163,
        "label": "NDBUpdate",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- NDBUpdate ----------------------------->']\n\n[h:dbArgs\t\t= macro.args]\n[h:frameName\t= json.get(dbArgs, \"frameName\")]\n\n[h:clickedButton = json.get(dbArgs, \"clickedButton\")]\n[h,switch(clickedButton), CODE:\n\tcase \"Clear\":{\n\t\t[dbArgs = json.set(\"{}\", \"mod\", 0, \"tn\", 0, \"d4s\", 0, \"d5s\", 0, \"d6s\", 0, \"d8s\", 0, \"d10s\", 0, \"d12s\", 0, \"d20s\", 0, \"d100s\", 0, \"showTo\", \"all\", \"breakdown\", \"totalRoll\", \"frameName\", frameName)]\n\t\t[macro(\"NDB@this\"): dbArgs]\n\t}; \n\tcase \"Options\":{\n\t\t[frameNum\t\t= replace(frameName, \"Dice Box \", \"\")]\n\t\t[dieList \t\t= getLibProperty(\"dieList\"+frameNum, \"Lib:EventMacros\")]\n\t\t[optionsList \t= getLibProperty(\"optionsList\"+frameNum, \"Lib:EventMacros\")]\n\t\t<!-- showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=eachRoll ;  -->\n\t\t[varsFromStrProp(optionsList)]\n\n\t\t<!-- convert form values to options -->\n\t\t[showGMOption\t= listFind(\"all,gm, gm-self\", showGMOption)]\n\t\t[eachRollOption\t= if(eachRollOption == \"eachRoll\", 1, 0)]\n\n\t\t[abort(input(\n\t\t\t\"junk|<html><b>Check the dice to show on the form<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"Di4|\"+listContains(dieList, 4)+\"|Show D4|CHECK\",\n\t\t\t\"Di5|\"+listContains(dieList, 5)+\"|Show D5|CHECK\",\n\t\t\t\"Di6|\"+listContains(dieList, 6)+\"|Show D6|CHECK\",\n\t\t\t\"Di8|\"+listContains(dieList, 8)+\"|Show D8|CHECK\",\n\t\t\t\"Di10|\"+listContains(dieList, 10)+\"|Show D10|CHECK\",\n\t\t\t\"Di12|\"+listContains(dieList, 12)+\"|Show D12|CHECK\",\n\t\t\t\"Di20|\"+listContains(dieList, 20)+\"|Show D20|CHECK\",\n\t\t\t\"Di100|\"+listContains(dieList, 100)+\"|Show D100|CHECK\",\n\t\t\t\"junk|<html><b>Check the options you want to show on the form<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"showMod|\"+showMod+\"|Show the 'set modifer' box|CHECK\",\n\t\t\t\"showTarget|\"+showTarget+\"|Show the 'set succes target' box|CHECK\",\n\t\t\t\"showExplode|\"+showExplode+\"|Show the 'explode die' check box|CHECK\",\n\t\t\t\"showResults|\"+showResults+\"|Show the 'show results to' options|CHECK\",\n\t\t\t\"showTooltip|\"+showTooltip+\"|Show the 'show tooltip' options|CHECK\",\n\t\t\t\"junk|<html><b>IF certain options are HIDDEN, THEN what should they be set to<br><\/b>These settings will be ignored if the options are NOT hidden<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"modifier|\"+modifier+\"|Modifier\",\n\t\t\t\"target|\"+target+\"|Target\",\n\t\t\t\"explode|\"+explode+\"|Explode|CHECK\",\n\t\t\t\"showGMOption|All, GM Only, You and GM|Show result to?|RADIO|Select=\"+showGMOption,\n\t\t\t\"eachRollOption|Totals, Each die|Tooltip info|RADIO|Select=\"+eachRollOption\n\t\t))]\n\t\t<!-- convert options to values for form -->\n\t\t[showGMOption\t= listGet(\"all,gm, gm-self\", showGMOption)]\n\t\t[eachRollOption\t= if(eachRollOption, \"eachRoll\", \"totalRoll\")]\n\t\t\n\t\t[allDice = \"4,5,6,8,10,12,20,100\"]\n\t\t[dieList = \"\"]\n\t\t[foreach(dice, allDice):dieList = if(eval(\"Di\"+dice),listAppend(dieList, dice), dieList)]\n\n\t\t[optionsList\t= StrPropFromVars(\"showMod,showTarget,showExplode,showResults,showTooltip,modifier,target,explode,showGMOption,eachRollOption\",\"UNSUFFIXED\")]\n\n\t\t['pause(\"frameNum\", \"dieList\", \"optionsList\")']\n\t\t[setLibProperty(\"dieList\"+frameNum, dieList, \"Lib:EventMacros\")]\n\t\t[setLibProperty(\"optionsList\"+frameNum, optionsList, \"Lib:EventMacros\")]\n\t\t[macro(\"NDB@this\"): dbArgs]\n\t}; \n\tcase \"Roll\":{\n\t\t[macro(\"RollDice@this\"):dbArgs] \n\t\t[abort(0)]\n\t}; \n\tdefault:{ \n\t\t<!-- Retrieve die number: dice names look like follows: <html>-<!-- 4 --> -->\n\t\t['assert(startsWith(clickedButton, \"<html>\"), \"\"Error in die roller for value clickedButton: \"+clickedButton\",0)']\n\t\t[sign\t= getGroup(strfind(clickedButton, \"(?<=html\\>)[-+]\"), 1, 0))]\n\t\t[dice\t= getGroup(strfind(clickedButton, \"(?<=--\\\\s)[0-9]+\"), 1, 0))]  \n\t\t<!-- dbArgs = json.set(dbArgs, \"d4s\", max(0,json.get(dbArgs, \"d4s\")-1)) -->\n\t\t[dbArgs\t= eval(strformat(\"json.set(dbArgs, 'd%{dice}s', max(0,number(json.get(dbArgs, 'd%{dice}s'))%{sign}1))\"))]\n\t\t[macro(\"NDB@this\"):dbArgs]\n\t}\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6c48e7d2-5ed3-402e-ae50-3b056a37f405",
          "commandChecksum": "727616c36e874c44805ef49faa32d239",
          "propsChecksum": "95e5852c0860cdc7f9824b7e8981a78b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 164,
        "label": "RollDice",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- RollDice ----------------------------->']\n[h:dbArgs\t\t= macro.args]\n[h:numD4\t= json.get(dbArgs, \"d4s\")]\n[h:numD5\t= json.get(dbArgs, \"d5s\")]\n[h:numD6\t= json.get(dbArgs, \"d6s\")]\n[h:numD8\t= json.get(dbArgs, \"d8s\")]\n[h:numD10\t= json.get(dbArgs, \"d10s\")]\n[h:numD12\t= json.get(dbArgs, \"d12s\")]\n[h:numD20\t= json.get(dbArgs, \"d20s\")]\n[h:numD100\t= json.get(dbArgs, \"d100s\")]\n[h:mod\t\t= json.get(dbArgs, \"mod\")]\n[h:breakout\t= json.get(dbArgs, \"breakdown\")]\n[h:target\t= json.get(dbArgs, \"tn\")]\n[h:showTo\t= json.get(dbArgs, \"showTo\")]\n[h,if(json.contains(dbArgs, \"explodeDice\")): exp = if(json.get(dbArgs, \"explodeDice\") !=0 ,\"e\",\"\"); exp=\"\"]\n\n[h:d4array\t= \"\"]\t[h:d4roll\t= 0]\n[h:d5array\t= \"\"]\t[h:d5roll\t= 0]\n[h:d6array\t= \"\"]\t[h:d6roll\t= 0]\n[h:d8array\t= \"\"]\t[h:d8roll\t= 0]\n[h:d10array\t= \"\"]\t[h:d10roll\t= 0]\n[h:d12array\t= \"\"]\t[h:d12roll\t= 0]\n[h:d20array\t= \"\"]\t[h:d20roll\t= 0]\n[h:d100array= \"\"]\t[h:d100roll\t= 0]\n\n[h,if(breakout==\"eachRoll\"),CODE:{\n\t[h,count(numD4), CODE: {\n\t\t[thisD4 \t= eval(\"1d4\"+exp)]\n\t\t[d4roll \t= d4roll + thisD4]\n\t\t[d4array\t= listAppend(d4array, thisD4)]\n\t}]\n\t[h,count(numD5), CODE: {\n\t\t[thisD5 \t= eval(\"1d5\"+exp)]\n\t\t[d5roll \t= d5roll + thisD5]\n\t\t[d5array\t= listAppend(d5array, thisD5)]\n\t}]\n\t[h,count(numD6),CODE:\t{\n\t\t[thisD6 \t= eval(\"1d6\"+exp)]\n\t\t[d6roll \t= d6roll + thisD6]\n\t\t[d6array\t= listAppend(d6array, thisD6)]\n\t}]\n\t[h,count(numD8),CODE:\t{\n\t\t[thisD8 \t= eval(\"1d8\"+exp)]\n\t\t[d8roll \t= d8roll + thisD8]\n\t\t[d8array\t= listAppend(d8array, thisD8)]\n\t}]\n\t[h,count(numD10),CODE:\t{\n\t\t[thisD10 \t= eval(\"1d10\"+exp)]\n\t\t[d10roll \t= d10roll + thisD10]\n\t\t[d10array\t= listAppend(d10array, thisD10)]\n\t}]\n\t[h,count(numD12),CODE:\t{\n\t\t[thisD12 \t= eval(\"1d12\"+exp)]\n\t\t[d12roll \t= d12roll + thisD12]\n\t\t[d12array\t= listAppend(d12array, thisD12)]\n\t}]\n\t[h,count(numD20),CODE:\t{\n\t\t[thisD20 \t= eval(\"1d20\"+exp)]\n\t\t[d20roll \t= d20roll + thisD20]\n\t\t[d20array\t= listAppend(d20array, thisD20)]\n\t}]\n\t[h,count(numD100),CODE:{\n\t\t[thisD100\t= eval(\"1d100\"+exp)]\n\t\t[d100roll\t= d100roll + thisD100]\n\t\t[d100array\t= listAppend(d100array,thisD100)]\n\t}]\n\n\t[h:rolledDice =\n\t\t\tif(d4roll !=0,\t\tnumD4+\"d4\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d5roll !=0,\t\tnumD5+\"d5\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d6roll !=0,\t\tnumD6+\"d6\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d8roll != 0,\t\tnumD8+\"d8\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d10roll !=0,\t\tnumD10+\"d10\"+exp+\"+\",\t\"\")\n\t\t+\tif(d12roll !=0,\t\tnumD12+\"d12\"+exp+\"+\",\t\"\")\n\t\t+\tif(d20roll != 0,\tnumD20+\"d20\"+exp+\"+\",\t\"\")\n\t\t+\tif(d100roll != 0,\tnumD100+\"d100\"+exp+\"+\",\t\"\")\n\t\t+\tif(mod != 0,\t\tmod+\"+\",\t\t\"\")\n\t]\n\t[h:assert(rolledDice != \"\",\"No dice selected\",0)]\n\t<!-- remove the , -->\n\t[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]\n\t\n\t[h:Values = \n\t\t\tif(d4roll == 0,\t\t\"\",\td4roll+\"(\"+d4array+\")\"+\"+\")\n\t\t+\tif(d5roll == 0,\t\t\"\",\td5roll+\"(\"+d5array+\")\"+\"+\")\n\t\t+\tif(d6roll == 0,\t\t\"\",\td6roll+\"(\"+d6array+\")\"+\"+\")\n\t\t+\tif(d8roll == 0,\t\t\"\",\td8roll+\"(\"+d8array+\")\"+\"+\")\n\t\t+\tif(d10roll == 0,\t\"\",\td10roll+\"(\"+d10array+\")\"+\"+\")\n\t\t+\tif(d12roll == 0,\t\"\",\td12roll+\"(\"+d12array+\")\"+\"+\")\n\t\t+\tif(d20roll == 0,\t\"\",\td20roll+\"(\"+d20array+\")\"+\"+\")\n\t\t+\tif(d100roll == 0,\t\"\",\td100roll+\"(\"+d100array+\")\"+\"+\")\n\t\t+\tif(mod == 0,\t\t\"\",\tmod+\"+\")\n\t]\n\t[h:Values = substring(Values, 0,length(Values)-1)]\n}; {\n\t[h:d4roll\t= if(numD4 == \"0\",\t0,\teval(numD4+\"d4\"+exp))]\n\t[h:d5roll\t= if(numD5 == \"0\",\t0,\teval(numD5+\"d5\"+exp))]\n\t[h:d6roll\t= if(numD6 == \"0\",\t0,\teval(numD6+\"d6\"+exp))]\n\t[h:d8roll\t= if(numD8 == \"0\",\t0,\teval(numD8+\"d8\"+exp))]\n\t[h:d10roll\t= if(numD10 == \"0\",\t0,\teval(numD10+\"d10\"+exp))]\n\t[h:d12roll\t= if(numD12 == \"0\",\t0,\teval(numD12+\"d12\"+exp))]\n\t[h:d20roll\t= if(numD20 == \"0\",\t0,\teval(numD20+\"d20\"+exp))]\n\t[h:d100roll\t= if(numD100 == \"0\",0,\teval(numD100+\"d100\"+exp))]\n\t[h:mod\t\t= number(mod)]\n\n\t[h:rolledDice =\n\t\t\tif(d4roll !=0,\t\tnumD4+\"d4\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d5roll !=0,\t\tnumD5+\"d5\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d6roll !=0,\t\tnumD6+\"d6\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d8roll != 0,\t\tnumD8+\"d8\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d10roll !=0,\t\tnumD10+\"d10\"+exp+\"+\",\t\"\")\n\t\t+\tif(d12roll !=0,\t\tnumD12+\"d12\"+exp+\"+\",\t\"\")\n\t\t+\tif(d20roll != 0,\tnumD20+\"d20\"+exp+\"+\",\t\"\")\n\t\t+\tif(d100roll != 0,\tnumD100+\"d100\"+exp+\"+\",\t\"\")\n\t\t+\tif(mod != 0,\t\tmod+\"+\",\t\t\"\")\n\t]\n\t[h:assert(rolledDice != \"\",\"No dice selected\",0)]\n\t<!-- remove the , -->\n\t[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]\n\n\t[h:Values = \n\t\t\tif(d4roll == 0,\t\t\"\", d4roll+\"+\")\n\t\t+\tif(d5roll == 0,\t\t\"\", d5roll+\"+\")\n\t\t+\tif(d6roll == 0,\t\t\"\", d6roll+\"+\")\n\t\t+\tif(d8roll == 0,\t\t\"\", d8roll+\"+\")\n\t\t+\tif(d10roll == 0,\t\"\", d10roll+\"+\")\n\t\t+\tif(d12roll == 0,\t\"\", d12roll+\"+\")\n\t\t+\tif(d20roll == 0,\t\"\", d20roll+\"+\")\n\t\t+\tif(d100roll == 0,\t\"\", d100roll+\"+\")\n\t\t+\tif(mod == 0,\t\t\"\",\tmod+\"+\")\n\t]\n\t[h:Values = substring(Values, 0,length(Values)-1)]\n}]\n\n[h:roll = d4roll+d6roll+d5roll+d8roll+d10roll+d12roll+d20roll+d100roll+mod]\n[h,if(target > 0 && roll > target): success = \"Success!\"; success=\"Failed!\"]\n\n<!-- showto = gm, all, gmyou -->\n[r:dbxOutputTo(showTo,\t\"<span><i>Rolling \"+rolledDice+\"<\/i>:<b> <span title='\"+Values+\"'>\"+roll+\"<\/b><\/span> \"+if(target > 0, success, \"\")+\"<\/span>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a8a6765b-5bd3-4c87-8a8d-0b52995e8917",
          "commandChecksum": "16e75a929c1daef9c004b33e99af1c60",
          "propsChecksum": "5779003a70e7ea67e9b1df7f16090cb5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 165,
        "label": "dbxConditionalOutput",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[r: json.get(macro.args, 'toSend')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "323635af-d737-40cf-938f-bdb4f2f1180a",
          "commandChecksum": "574b446cde592a874916bcfd6064b1d2",
          "propsChecksum": "2469e7a5e5ba41d8e0861efec42d9640"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "",
        "index": 166,
        "label": "dbxOutputTo",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: toSend = '{}']\n[h: argTest = json.type(arg(0))]\n[h, if(argTest=='ARRAY'), code:\n{\n    [h: toWho = 'list']\n    [h: toSend = json.set(toSend, 'mlOutputList', arg(0))]\n}; {\n    [h: toWho = arg(0)]\n}]\n\n[h: toSend = json.set(toSend, 'toSend', arg(1))]\n[h: conditionalOutput = macroLinkText('dbxConditionalOutput@this', toWho, toSend)]\n[h: execLink(conditionalOutput, 1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8e9c39d0-62e0-414d-a1b5-9794fa445d64",
          "commandChecksum": "cad3ab6161fed25af7e65a6441d648fa",
          "propsChecksum": "d2c53b3534ce46a4985676f4054dce40"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "3",
        "index": 167,
        "label": "MassVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- MassVBL -------------------------------------------------- -->']\n<!-- <html>This function draws VBL crosses on all tokens that match a search string -->\n\n[h:optionList\t= \"Canopy, Roof, Selection, All, Search String\"]\n[h:scaleList\t= \"Number of Cells, Token Size\"]\n[h:gridSize \t= bot_getGridSize()] \n[h:currentMap\t= getCurrentMapName()]\n\n<!-- initiate last settigns -->\n[h:lastSettings\t= getLibProperty(\"lastMassVBLSettings\", \"Lib:EventMacros\")]\n[h,if(lastSettings == \"\"): lastSettings = \"option=0 ; searchStr=tree ; doTokenLayer=0 ; doObjectLayer=1 ; doHiddenLayer=0 ; doBackgroundLayer=1 ; scaleOption=0 ; scale=0.5 ; storeVBL=0 ; vblName=maptrees ; \"]\n[h:varsFromStrProp(lastSettings)]\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Set VBL Stamp<\/b><\/html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. For this to work you will need to turn on VBL support<br>in the settings.<br>|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'option|'+optionList+'|<html><span title=\"<html>Tokens to which the VBL layer will be applied.<br><b>Canopy<\/b> will select all tokens with <i>Canopy<\/i> in their name, same for<br><b>Roof<\/b> and <b>Search string<\/b>. with the latter you need to enter a search<br>string in the text box here below.<br><b>All<\/b> will select ALL tokens<br><b>Selection<\/b> will limit to the currently selected tokens.<br><br>Note that the LAYER filter is applied to all except <b>Selection<\/b>. <br><\/html>\">Add VBL to which tokens<\/html><\/span><\/html>|RADIO|SELECT='+option)]\n[h:inputStr \t= json.append(inputStr, 'searchStr|'+searchStr+'|<html><span title=\"<html>If you choose <i>other<\/i> from the radion buttons, enter the search string here.<br>Note that ANY token whos name partialy matches this search string will be added<br>to the VBL list. E.g. <i>can<\/i> will return token named <i>cans<\/i>, <i>canopy<\/i>, <i>cantine<\/i>, etc.<br>One way to limit the results is by adding a whitespace at the start or end of the <br>name if appropriate. E.g. "can " will NOT return the above examples.<\/html>\">Search string<\/html><\/span><\/html>')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Check layers to include<\/html>|<html>The VBL will only be applied to tokens that are on the layers you check here.|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, 'doTokenLayer|'+doTokenLayer+'|<html><span>Token Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doHiddenLayer|'+doHiddenLayer+'|<html><span>Hidden Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doObjectLayer|'+doObjectLayer+'|<html><span>Object Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doBackgroundLayer|'+doBackgroundLayer+'|<html><span>Background Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Scale<\/b><\/html>|<html>|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'scaleOption|'+scaleList+'|<html><span title=\"<html><b>Number of Cells:<\/b> 0.5 is half a (grid) cell, 1 is 1 cell, 2 is 4 cells, etc.<br><b>Token size:<\/b> 0.5 means half the size of the token, 2 means twice the size of the token.<\/html>\">Scaling in terms of<\/html><\/span><\/html>|RADIO|SELECT='+scaleOption)]\n[h:inputStr \t= json.append(inputStr, 'scale|'+scale+'|<html><span title=\"<html>Depends on the radio choice<\/html>\">Scale of VBL shape<\/html><\/span><\/html>')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Saving the VBL<\/b><\/html>|<html>Checking the box will save the VBL as a result of this macro|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'storeVBL|'+storeVBL+'|<html><span title=\"<html>When you check this the VBL will be stored on a lib:token<br>This will allow you to toggle the VBL on or off<\/html>\">Store the VBL<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'vblName|'+vblName+'|<html><span title=\"<html>This will only work if you have checked the <i>Store the VBL<\/i> checkbox.<br>The VBL data will be linked to this map and the name you enter allowing you<br>to toggle this specific VBL on or off. Only use alphanumeric characters for<br>the name<\/html>\">Name of VBL to store<\/html><\/span><\/html>')]\n\n<!-- run the input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- assertion -->\n[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, \"Check at least one of the (Token, Hidden, Object, Background) layer boxes\",0)]\n\n<!-- save settigns -->\n[h:setLibProperty(\"lastMassVBLSettings\", strPropFromVars(\"option, searchStr, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer, scaleOption, scale, storeVBL, vblName\",\"UNSUFFIXED\"), \"lib:EventMacros\")]\n\n[h:'<!-- {layer:[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]} -->']\n[h:chosenLayers = \"[]\"]\n[h,if(doTokenLayer):\t\tchosenLayers = json.append(chosenLayers, \"TOKEN\")]\n[h,if(doObjectLayer):\t\tchosenLayers = json.append(chosenLayers, \"OBJECT\")]\n[h,if(doHiddenLayer):\t\tchosenLayers = json.append(chosenLayers, \"HIDDEN\")]\n[h,if(doBackgroundLayer):\tchosenLayers = json.append(chosenLayers, \"BACKGROUND\")]\n\n[h, if(option == 0): searchStr\t= \"Canopy \"]\n[h, if(option == 1): searchStr\t= \"Roof \"]\n<!-- selection -->\n[h, if(option == 2): allToks\t= getSelectedNames()]\n[h, if(option == 3): allToks\t= getTokenNames(\",\", json.set(\"{}\", \"layer\", chosenLayers))]\n<!-- ALL -->\n[h, if(option < 2 || option == 4):\tallToks = bot_seekToken(1, searchStr, chosenLayers)]\n\n[h:shape\t\t= \"cross\"]\n[h:jsonVBL\t\t= \"[]\"]\n\n['pause(\"allToks\")']\n<!-- Top left Centre Coords of the trunk. This is done by: offset of position of entire token + centre of token - half gridsize (so you get the top left corner of the centre) -->\n[h, if(scaleOption), CODE:{\n\t<!-- scale in terms of token size, e.g. 1 is size of token -->\n\n\t[foreach(tok, allToks): \n\t\tjsonVBL\t= json.append(\n\t\t\tjsonVBL, \n\t\t\tstrformat(\n\t\t\t\t'{\"shape\":\"cross\",\"w\":%s,\"h\":%s,\"x\":%s,\"y\":%s,\"scale\":%{scale}}', \n\t\t\t\tgetTokenWidth(tok),\n\t\t\t\tgetTokenHeight(tok),\n\t\t\t\tgetTokenX(2, tok), \n\t\t\t\tgetTokenY(2, tok)\n\t\t\t)\n\t\t)\n\t]\n};{\n\t<!-- scale in terms of grid cells e.g. 1 is one cell large VBL -->\n\t[w\t\t\t= gridSize * scale]\n\t[h\t\t\t= w]\n\t[half\t\t= round(w/2)]\n\t\n\t[foreach(tok, allToks): \n\t\tjsonVBL\t= json.append(\n\t\t\tjsonVBL, \n\t\t\tstrformat(\n\t\t\t\t'{\"w\":%{w},\"shape\":\"cross\",\"h\":%{h},\"x\":%s,\"y\":%s}', \n\t\t\t\tgetTokenX(2, tok) + round(getTokenWidth(tok)/2) - half, \n\t\t\t\tgetTokenY(2, tok) + round(getTokenHeight(tok)/2) - half\n\t\t\t)\n\t\t)\n\t]\n}]\n\n<!-- remove '' from strformat result, which will turn it into a json object -->\n[h:jsonVBL\t= replace(jsonVBL, \"'\", \"\")]\n\n<!-- draw all the vbl -->\n[h:drawVBL(jsonVBL)]\n\n<!-- save VBL -->\n[h,if(storeVBL), CODE:{\n\t<!-- get currently stored VBL -->\n\t[storedVBL\t\t= getLibProperty(\"storedVBL\", \"lib:EventMacros\")]\n\t[if(json.type(storedVBL)==\"UNKNOWN\"):\t\tstoredVBL\t\t= \"{}\"]\n\t[thisMapVBL\t\t= json.get(storedVBL, currentMap)]\n\t[if(json.type(thisMapVBL)==\"UNKNOWN\"):\t\tthisMapVBL\t\t= \"{}\"]\n\t[thisMapVBLOn\t= json.get(storedVBL, currentMap+\"_ON\")]\n\t[if(json.type(thisMapVBLOn)==\"UNKNOWN\"):\tthisMapVBLOn\t= \"{}\"]\n\t\n\t<!-- add this VBL -->\n\t[thisMapVBL\t\t= json.set(thisMapVBL, vblName, jsonVBL)]\n\t[thisMapVBLOn\t= json.set(thisMapVBLOn, vblName, 1)]\n\t[storedVBL\t\t= json.set(storedVBL, currentMap, thisMapVBL, currentMap+\"_ON\", thisMapVBLOn)]\n\t[setLibProperty(\"storedVBL\", storedVBL, \"lib:EventMacros\")]\n};{}]\n\n<!-- output to chat -->\n[h:broadcast(\"VBL has been added to the following tokens: \"+ allToks)]",
        "maxWidth": "",
        "tooltip": "<html>This function draws VBL crosses on all tokens that match a search string",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1db49968-3151-441b-80f9-8cee9041af94",
          "commandChecksum": "ba60afeb5bb4fa542d681383bc92b6d5",
          "propsChecksum": "b1d5db9d0d0e84defd1f715547ed25a0"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "3",
        "index": 168,
        "label": "VBLGrenade",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- VBLGrenade (tokOnly (1/0), clearVBL(1/0), tok): returns the VBL -------------------------------------------------- -->']\n<!--\tSelect one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared. \n\t\ttokOnly (default 0) allows to automatically clear the VBL over the selected token\n\t\tclearVBL (default 1) will erase the VBL automatically\n-->\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h,if(argCount()>0): tokOnly\t= arg(0) ; tokOnly\t= 0]\n[h,if(argCount()>1): clearVBL\t= arg(1) ; clearVBL\t= 1]\n[h,if(argCount()>2): allToks\t= arg(2) ; allToks\t= getSelected()]\n\n[h,if(tokOnly), CODE:{\n\t<!-- do not ask input just take the token area for the VBL operation -->\n\t[radius\t\t= 0]\n\t[sides\t\t= 0]\n};{\n\t[assert(listCount(allToks),\"You need to select at least one token for this to work\",0)]\n\t[abort(input(\n\t\t\"junk|<html><b>Clear VBL around selected tokens<\/b><\/html>|<html>The radius (in grid cells) you choose will be used to clear the VBL directly around the token |LABEL|SPAN=TRUE\",\n\t\t\"radius|1|Radius of VBL to clear around the token (Cells)\",\n\t\t\"junk|<html><b>Sides of VBL clearance circle<\/b><\/html>|<html>A regular polygon will be used as 'circle' here you set how many sides the 'circle' should have|LABEL|SPAN=TRUE\",\n\t\t\"sides|3,4,5,6,7,8,9,10,11,12|Radius of VBL to clear around the token|LIST|Select=5 value=string\",\n\t\t\"tokOnly|0|Override the above and only clear VBL covered by token|CHECK\"\n\t))]\n}]\n<!-- initialize vars -->\n[h:w\t\t= 0]\n[h:h\t\t= 0]\n[h:facing\t= 0]\n[h:shape\t= if(tokOnly, \"rectangle\", \"circle\")]\n[h:radius\t= bot_getGridSize() * radius]\n\n<!-- create json structure of VBL objects to erase -->\n[h:jsonVBL\t\t= \"[]\"]\n[h,foreach(tok, allToks), CODE: {\n\t[if(tokOnly), CODE:{\n\t\t[x\t\t= getTokenX(2,tok)]\n\t\t[y\t\t= getTokenY(2,tok)]\n\t\t[w\t\t= getTokenWidth(tok)]\n\t\t[h\t\t= getTokenHeight(tok)]\n\t\t[facing\t= getTokenFacing(tok)]\n\t\t[if(facing == \"\"): facing = -90]\n\t};{\n\t\t[x\t\t= getTokenX(2, tok) + round(getTokenWidth(tok)/2)]\n\t\t[y\t\t= getTokenY(2, tok) + round(getTokenHeight(tok)/2)]\n\t}]\n\n\t[jsonVBL\t= json.append(jsonVBL, strformat('{\"shape\":\"%{shape}\",\"fill\":1,\"radius\":%{radius},\"sides\":%{sides}, \"facing\":%{facing},\"x\":%{x},\"y\":%{y},\"w\":%{w},\"h\":%{h}}'))]\n}]\n\n<!-- draw all the vbl -->\n[h:macro.return\t= getVBL(jsonVBL)]\n[h,if(clearVBL):eraseVBL(jsonVBL)]",
        "maxWidth": "",
        "tooltip": "Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d60e8279-0214-4f6e-88a0-b4dbe01fcc1f",
          "commandChecksum": "1437d6407d011ce705b5134ddaff278a",
          "propsChecksum": "555ed4c0b7ac025534118803a5e581b3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "6",
        "index": 169,
        "label": "createVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- createVBL ([tok,check,isDoor]) ---------------------------------------------->']\n[debug\t\t= 0]\n\n<!-- ignore output SAME SCOPE -->\n<!-- this macro defines the types coords etc of a VBL object based on the stored info on the token -->\n<!-- it erases the old VBL and defines the new one -->\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n<!-- check if the area to be drawn contains VBL already -->\n[if(argCount() > 1): check\t= arg(1) ; check\t= 0]\n<!-- do NOT scale the VBL beyon the token in case of a door, cause this will mess up double doors!! -->\n[if(argCount() > 2): isDoor\t= arg(2) ; isDoor\t= 0]\n\n<!-- define the following vars: applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset -->\n[varsFromStrProp(getProperty(\"w42.bot.vblSetup\", me))]\n\n<!-- apply VBL on token and save it -->\n[typeList\t= \"cross, rectangle, circle, polygon, polygon, polygon\"]\n[shape\t\t= listGet(typeList, VBLType)]\n[thickness\t= max(1, thickness)]\n[points\t\t= \"[]\"]\n[w\t\t\t= getTokenWidth(me)]\n[h\t\t\t= getTokenHeight(me)]\n[d\t\t\t= max(w,h)]\n[x\t\t\t= getTokenX(2, me)]\n[y\t\t\t= getTokenY(2, me)]\n[facing\t\t= getTokenFacing(me)]\n\n[radius\t\t= 0]\n[vblVars\t= \"shape, VBLType, x, y, w, h, radius, points, scale, thickness, sides, fill, close, offsetX, offsetY, resetFoW, rxOffset, ryOffset\"]\n\n<!-- centre offset 1: align centre shape with centre token ; 0. align top left shape with top left token -->\n[switch(VBLType), CODE:\n\tcase 0: {\n\t\t<!-- CROSS default aligns centre with centre of the token -->\n\t\t[if(!centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX + ceil((scale-1)*w/2)]\n\t\t\t[offsetY\t= offsetY + ceil((scale-1)*w/2)]\n\t\t}]\n\t};\n\tcase 1: {\n\t\t<!-- RECTANGLE default aligns top left with top left of the token -->\n\t\t[if(centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX - ceil((scale-1)*w/2)]\n\t\t\t[offsetY\t= offsetY - ceil((scale-1)*h/2)]\n\t\t}]\n\t};\n\tcase 2: {\n\t\t<!-- CIRCLE per default aligns centre with top left token -->\n\t\t[if(centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX + round(w/2) +1]\n\t\t\t[offsetY\t= offsetY + round(h/2) +1]\n\t\t};{}]\n\n\t\t<!-- calculate radius of circle -->\n\t\t[radius\t\t= floor(min(w,h)/2)]\n\t};\n\tcase 3: {\n\t\t<!-- HORIZONTAL LINE -->\n\t\t[if(centreOffset): offsetX= offsetX - ceil((scale-1)*w/2)]\n\t\t\n\t\t[x1\t\t\t= x + offsetX]\n\t\t[x2\t\t\t= x1 + round(scale*w)]\n\t\t[y1\t\t\t= y + round(h/2)]\n\t\t\n\t\t[points\t\t= strformat(\"[{'x':%{x1},'y':%{y1}},{'x':%{x2},'y':%{y1}}]\")]\n\t};\n\tcase 4: {\n\t\t<!-- VERTICAL LINE -->\n\t\t[if(centreOffset): offsetY= offsetY - ceil((scale-1)*h/2)]\n\t\t\n\t\t[y1\t\t\t= y + offsetY]\n\t\t[x1\t\t\t= x + round(w/2)]\n\t\t[y2\t\t\t= y1 + round(scale*h)]\n\n\t\t[points\t\t= strformat(\"[{'x':%{x1},'y':%{y1}},{'x':%{x1},'y':%{y2}}]\")]\n\t};\n\tcase 5: {\n\t\t<!-- CURRENT VBL (shape 5)-->\n\t\t<!-- Simply grab the VBL that covers the token. Using the same parameters.-->\n\t\t[x\t\t\t= x + offsetX]\n\t\t[y\t\t\t= y + offsetY]\n\n\t\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x, \"y\", y, \"w\", w, \"h\", h, \"fill\", 1, \"scale\", scale)] \n\t\t[bot_saveFgVBL(me, rectVBL)]\n\t\t<!-- also save the bgVBL else youll get an error message the first time you move the token -->\n\t\t[bot_saveBgVBL(me,rectVBL)]\n\t};\n\tdefault: {\n\t\t[assert(0,\"it appears you try to create an unknown shape: \"+VBLType, 0)]\n\t}\n]\n\n<!-- set and store the parameters for the bgVBL shape -->\n<!-- increase the scale of the BG save to take the thickness of the line and the offset of the shape into account -->\n[if(isDoor): vblBgScale = 1 ; vblBgScale = 1.5 * max(1,scale) * ( 1 + thickness/20 + max(abs(offsetX), abs(offsetY))/d )]\n[setProperty(\"w42.bot.vblBgScale\", vblBgScale, me)]\n<!-- centreOffset makes sure that the bgVBL rectangle remains centred on the token when its fgshape is scaled -->\n[if(isDoor): vblBgOffsetX = 0 ; vblBgOffsetX\t= ceil((max(vblBgScale,1)-1)*if(h>w && !isDoor, h*h/w, w)/2)]\n[if(isDoor): vblBgOffsetY = 0 ; vblBgOffsetY\t= ceil((max(vblBgScale,1)-1)*if(w>h && !isDoor, w*w/h, h)/2)]\n\n[setProperty(\"w42.bot.vblBgOffsetX\", vblBgOffsetX, me)]\n[setProperty(\"w42.bot.vblBgOffsetY\", vblBgOffsetY, me)]\n\n[if(VBLType != 5), CODE:{\n\t<!-- handle offsets and bgVBL for shapes 0 to 4 -->\n\n\t<!-- Get the VBL currently under Token to erase UNROTATED!!-->\n\t<!-- create the rectVBL to save the Bg VBL -->\n\t<!-- offsetX and Y have already been added earlier, so they need to be remove here! -->\n\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x-vblBgOffsetX, \"y\", y-vblBgOffsetY, \"w\", d, \"h\", d, \"fill\", 1, \"scale\", vblBgScale)]\n\t\n\t<!-- build the json structure for the shape -->\n\t<!-- add the shape offset to the coords to get the x,y of the shape -->\n\t[x\t\t\t= x + offsetX]\n\t[y\t\t\t= y + offsetY]\n\n\t[VBLData\t= json.fromStrProp(strPropFromVars(vblVars, \"UNSUFFIXED\"))]\n\t[jsonVBL\t= json.append(\"\", VBLData)]\n\t\n\t<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n\t[h,if(debug == 1), CODE:{\n\t\t[bot_debugInfo(\"me, vblVars, VBLData, jsonVBL, rectVBL, vblBgScale, vblBgOffsetX, vblBgOffsetY, offsetX, offsetY, d\",0,1,0, getMacroName(), getMacroLocation())]\n\t};{}]\n\n\t[if(check), CODE:{\n\t<!-- cannot get this to work properly for doors so skip for now -->\n\t\t[rx\t\t\t\t= round(w/2)]\n\t\t[ry\t\t\t\t= round(h/2)] \n\t\t[VBLDataC\t\t= json.set(VBLData,\"rx\", rx, \"ry\", ry,\"tx\", x, \"ty\", y)]\n\t\t[jsonVBLC\t\t= json.append(\"\", VBLDataC)]\n\t\t[checkVBL\t\t= json.get(json.get(getVBL(jsonVBLC,0),0),\"points\")]\n\t\t[macro.return\t= if(!json.isEmpty(checkVBL), jsonVBLC, \"{}\")]\n\t};{\n\t\t<!-- the VBL stamp is created -->\n\t\t<!-- save background -->\n\t\t[bot_saveBgVBL(me,rectVBL)]\n\t\t<!-- clear all VBL at token -->\n\t\t[eraseVBL(rectVBL)]\n\t\t<!-- draw fg vbl at token NO FACING -->\n\t\t[drawVBL(jsonVBL)]\n\t\t<!-- save it -->\n\t\t[bot_saveFgVBL(me, rectVBL)]\n\t\t<!-- redraw the background vbl..if any. -->\n\t\t[bot_drawBgVBL(me)]\t\n\t\t<!-- drawBG erases the rect. so the fg needs to be redrawn! WITH FACING-->\n\t\t[bot_drawFgVBL(me)]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dda6ecd5-6874-4653-8058-d230beb91218",
          "commandChecksum": "091a1dfaea7a2a0295019c037a993fda",
          "propsChecksum": "2b7667fb69e62b32652e03cdb0dedce9"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "8",
        "index": 170,
        "label": "drawBgVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- drawBgVBL ([tok]) ---------------------------------------------->']\n[debug\t\t= 0]\n\n<!--\tif the token has moved, then you wish to restore the VBL on the old spot, this you do by retrieving the old rect vbl \n\t\terase the area below and then redraw the stored bginfo\n-->\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[vblData\t= getProperty(\"w42.bot.bgVBL\", me)]\n[rectVBL\t= getProperty(\"w42.bot.rectVBL\")]\n[eraseVBL(rectVBL)]\n[points\t\t= json.get(json.get(vblData, 0),\"points\")]\n[if(!json.isEmpty(points)):drawVBL(vblData)]\n\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[if(debug == 1): bot_debugInfo(\"me, VBLData, rectVBL, points\",0,1,0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "beafa0fc-6d5c-4f60-adca-66a65070a482",
          "commandChecksum": "5e40b54e67ba2636b796beb898308191",
          "propsChecksum": "ce1302a2b3e3aa8e65594d6d8b7b17af"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "8",
        "index": 171,
        "label": "drawFgVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- drawFgVBL ([toks, drawBg]) ---------------------------------------------->']\n[h:debug\t\t\t= 0]\n\n[h,if(argCount() > 0): toks\t\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:assert(listCount(toks), \"Make sure you have at least one token selected\",0)]\n\n[h,if(argCount() > 1): drawBg\t= arg(1) ; drawBg\t= 1]\n\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[h,if(debug == 1): bot_debugInfo(\"toks\",0,1,0, getMacroName(), getMacroLocation())]\n\n[h:w42.bot.final\t= '[ ]']\n[h,foreach(me,toks), CODE:{\n\t[switchToken(me)]\n\t<!-- Get token location, size, etc -->\n\t[x\t\t= getTokenX()]\n\t[y\t\t= getTokenY()]\n\t[w\t\t= getTokenWidth()]\n\t[h\t\t= getTokenHeight()]\n\t[facing\t= getTokenFacing()]\n\t[if(facing == \"\"): facing = -90]\n\n\t[if(drawBg), CODE:{\n\t\t<!-- restore old bg vbl on original spot -->\n\t\t[bot_drawBgVBL(me)]\n\t\t<!-- save bgvbl on new spot -->\n\t\t[bot_saveBgVBL(me)]\n\t};{}]\n\n\t<!-- get the fgvbl -->\n\t[fgVBL\t= getProperty(\"w42.bot.fgVBL\")]\n\n\t<!-- \n\tdeduct the translation from the rotational offset first\n\tThe reason for this is that drawVBL FIRST rotates the VBL using the rotational offset and THEN translates it. Thus it rotates the VBL while on the wrong spot. So the rotational offset needs to be done WITHOUT the translation\n\t-->\n\t[rx\t\t\t\t= getTokenX()+round(getTokenWidth()/2) - x]\n\t[ry\t\t\t\t= getTokenY()+round(getTokenHeight()/2) - y] \n\n\t<!-- fgVBL is already in proper JSON format for \"points\" so we can use tx,ty to transpose to new coords -->\n\t[w42.bot.shape = json.set(\"{ }\", \"shape\", \"polygon\", \"fill\", 1, \"close\", 1, \"thickness\", 0, \"tx\", x, \"ty\", y, \"rx\", rx, \"ry\", ry, \"facing\", facing, \"points\", fgVBL)]\n\t[w42.bot.final = json.append(w42.bot.final, w42.bot.shape)]\n\n\t<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n\t[h,if(debug == 1): bot_debugInfo(\"me, fgVBL, w42.bot.final\",0,1,0, getMacroName(), getMacroLocation())]\n}]\n\n[h,if(!json.isEmpty(w42.bot.final)): drawVBL(w42.bot.final)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ba279b27-508f-472f-8b83-3b2ae3728b64",
          "commandChecksum": "1e8f63fb337735b4854636d6095dff0c",
          "propsChecksum": "7027611441997d91196b107f20d76b6b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "7",
        "index": 172,
        "label": "extendPoint",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- extendPoint (coordinate, endPolygon) ---------------------------------------------->']\n<!-- IGNORE OUTPUT, NO NEW SCOPE -->\n\n[coordinate\t= arg(0)]\n[endPolygon\t= arg(1)]\n\n[xFP\t\t= json.get(coordinate, \"x\")]\n[yFP\t\t= json.get(coordinate, \"y\")]\n[x0\t\t\t= xFP]\n[y0\t\t\t= yFP]\n\n[if(xFP == x1 && (yFP == y1 || yFP == y2) || xFP == x2 && (yFP == y1 || yFP == y2)), CODE:{\n\t<!-- if x/y are in the corner then the extension depends on the direction it takes, which is decided by the Second point-->\n\t[offset\t\t\t= if(endPolygon, json.length(newPoints)-2, 1)]\n\t[secondCoord\t= json.get(newPoints, offset)]\n\t[xSP\t\t\t= json.get(secondCoord, \"x\")]\n\t[ySP\t\t\t= json.get(secondCoord, \"y\")]\n\t[yDirection\t\t= if(xFP == xSP, 1,0)]\n\t[xDirection\t\t= if(yFP == ySP, 1,0)]\n['pause(\"xFP\",\"yFP\",\"xSP\",\"ySP\",\"offset\",\"newPoints\",\"coordinate\",\"secondCoord\",\"x1\",\"x2\",\"y1\",\"y2\",\"xDirection\",\"yDirection\")']\n\t\n\t[if(xDirection && !yDirection), CODE:{\n\t\t[if(xFP == x1):\tx0\t= x1 - extendPx]\n\t\t[if(xFP == x2):\tx0\t= x2 + extendPx]\n\t\t[y0\t= yFP]\n\t};{ <!-- if its a diagonal then do not extend --> }]\n\t[if(yDirection && !xDirection), CODE:{\n\t\t[if(yFP == y1):\ty0\t= y1 - extendPx]\n\t\t[if(yFP == y2):\ty0\t= y2 + extendPx]\n\t\t[x0\t= xFP]\n\t};{ <!-- if its a diagonal then do not extend --> }]\n};{\n\t<!-- if x/y are at the edge but NOT in the corder, simply expand -->\n\t[if(xFP == x1), CODE:{\n\t\t[x0\t= x1 - extendPx]\n\t\t[y0\t= yFP]\n\t};{}]\n\t[if(xFP == x2), CODE:{\n\t\t[x0\t= x2 + extendPx]\n\t\t[y0\t= yFP]\n\t};{}]\n\t[if(yFP == y1), CODE:{\n\t\t[x0\t= xFP]\n\t\t[y0\t= y1 - extendPx]\n\t};{}]\n\t[if(yFP == y2), CODE:{\n\t\t[x0\t= xFP]\n\t\t[y0\t= y2 + extendPx]\n\t};{}]\n}]\n['pause(\"xFP\",\"yFP\",\"x1\",\"x2\",\"y1\",\"y2\",\"x0\",\"y0\")']\n\n[macro.return\t= json.set(\"{}\",\"x\", x0, \"y\", y0)]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2a7e2a6a-a0c6-451a-9dcc-666e44a5e446",
          "commandChecksum": "3ae080029f0155882d1e942efaaea15f",
          "propsChecksum": "976aacddc98a704bb06c0efc2d6815f6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "7",
        "index": 173,
        "label": "moveStamp",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- moveStamp(token) ------------------------------------------------->']\n\n[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{\n\t[if(argCount()>0): me\t= arg(0) ; me = getSelected()]\n\t<!-- draw bg where the tokens was -->\n\t[bot_drawBgVBL(me)]\t\n\t<!-- save background where token is -->\n\t[bot_saveBgVBL(me)]\n\t<!-- draw fg vbl at token -->\n\t[bot_drawFgVBL(me)]\n\n\t[toks\t= getTokens(\",\", '{ pc:1 }')]\n\t[if(toks != \"\"):selectTokens(toks,1,\",\")]\n\t[exposeFOW()]\n\t[selectTokens(me)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a5ad9994-2a32-4b4b-b74c-3067533c4277",
          "commandChecksum": "1e802b786d752e75fb6590ada6b2136a",
          "propsChecksum": "92df944be38540f0d636a3f66671c28d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "6",
        "index": 174,
        "label": "removeVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------------- removeVBL (token) -------------------------------------------- -->']\n<!-- this macro removes ALL VBL data from a token -->\n[me\t\t\t\t= arg(0)]\n<pre>\n[if(hasProperty(\"w42.bot.vblSetup\",me)): resetProperty(\"w42.bot.vblSetup\", me)]\n[if(hasProperty(\"w42.bot.rectVBL\",me)): resetProperty(\"w42.bot.rectVBL\", me)]\n[if(hasProperty(\"w42.bot.bgVBL\",me)): resetProperty(\"w42.bot.bgVBL\", me)]\n[if(hasProperty(\"w42.bot.fgVBL\",me)): resetProperty(\"w42.bot.fgVBL\", me)]\n[if(hasProperty(\"w42.bot.vblBgOffsetX\",me)): resetProperty(\"w42.bot.vblBgOffsetX\", me)]\n[if(hasProperty(\"w42.bot.vblBgOffsetY\",me)): resetProperty(\"w42.bot.vblBgOffsetY\", me)]\n[if(hasProperty(\"w42.bot.vblBgScale\",me)): resetProperty(\"w42.bot.vblBgScale\", me)]",
        "maxWidth": "",
        "tooltip": "this macro removes ALL VBL data from a token. So NOT the VBL itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9cd503f7-03b8-4d45-b00f-3733c2832036",
          "commandChecksum": "ee342c9ff37cbc0b0f8ddf9bdf7b9709",
          "propsChecksum": "f39e72669de21475d3f7b7a13202e2ad"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "8",
        "index": 175,
        "label": "saveBgVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- saveBgVBL ([tok, rectVBL]) ---------------------------------------------->']\n[debug\t= 0]\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[x\t\t\t= getTokenX()]\n[y\t\t\t= getTokenY()]\n[d\t\t\t= max(getTokenWidth(), getTokenHeight())]\n[facing\t\t= getTokenFacing()]\n[if(facing == \"\"): facing = -90]\n\n<!-- Get the VBL currently under Token, shape expanded 1 pixel in all directions to capture complete token w/h -->\n[if(argCount() > 1), CODE: {\n\t[rectVBL\t= arg(1)]\n\t[if(debug == 1): scale = 1]\n};{\n\t<!-- scale -->\n\t[scale \t\t\t= getProperty(\"w42.bot.vblBgScale\", me)]\n\t[vblBgOffsetX\t= getProperty(\"w42.bot.vblBgOffsetX\", me)]\n\t[vblBgOffsetY\t= getProperty(\"w42.bot.vblBgOffsetY\", me)]\n\n\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x-vblBgOffsetX, \"y\", y-vblBgOffsetY, \"w\", d, \"h\", d, \"fill\", 1, \"scale\", scale)]\n}]\n\n[vblData\t= getVBL(rectVBL)]\n\n[setProperty(\"w42.bot.bgVBL\", vblData)]\n[setProperty(\"w42.bot.rectVBL\", rectVBL)]\n\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[h,if(debug == 1): bot_debugInfo(\"me, vblData,rectVBL,scale\",0,1,0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b14e69dc-ce1a-4e2c-9262-2c6aaed91e3e",
          "commandChecksum": "5457a4194b15fde370e089ed162dc130",
          "propsChecksum": "b63a2ef21266de8864f6f61124387158"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "8",
        "index": 176,
        "label": "saveFgVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- saveFgVBL ([tok, rectVBL]) ---------------------------------------------->']\n[h:debug\t\t= 0]\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[x\t\t\t\t= getTokenX()]\n[y\t\t\t\t= getTokenY()]\n[w\t\t\t\t= getTokenWidth()]\n[h\t\t\t\t= getTokenHeight()]\n[facing\t= getTokenFacing()]\n[if(facing == \"\"): facing = -90]\n\n<!-- Get the VBL currently under Token, shape expanded 1 pixel in all directions to capture complete token w/h -->\n[if(argCount() > 1): \n\trectVBL\t\t= arg(1) \n; \n\trectVBL\t\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x, \"y\", y, \"w\", w, \"h\", h, \"fill\", 1, \"facing\", facing)\n] \n[vblData\t\t= getVBL(rectVBL, 1)]\n\n[if(argCount() < 2):pause()]\n\n[points='[ ]']\n<!-- Loop through and subtract x,y from all Short to reset as if tile was at 0,0 for a common reference point -->\n<!-- then add an offset string which later on can be used to be replaced by use of regex -->\n[len\t\t\t= json.length(vblData)]\n[for(i, 0, len, 2), CODE :{\n\t[x2\t\t\t= json.get(vblData, i)]\n\t[y2\t\t\t= json.get(vblData, i+1)]\n\t[vblData\t= json.set(vblData, i, x2 - x)]\n\t[vblData\t= json.set(vblData, i+1, y2 - y)]\n\t\n\t[newPoints\t= json.set(\"{ }\", \"x\", x2 - x, \"y\", y2 - y)]\n\t[points\t\t= json.append(points, newPoints) ]\n}]\n\n[h:setProperty(\"w42.bot.fgVBL\", points)]\n\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[h,if(debug == 1): bot_debugInfo(\"me, x, y, vblData, points\", 0, 1, 0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c2d06e0c-dbb9-4a3c-845c-95433b7544d4",
          "commandChecksum": "c1a018fc47e50a8a80b558de55f378d4",
          "propsChecksum": "f5b5ac8d8ffd892bcfdf719ebdf85ff4"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "5",
        "index": 177,
        "label": "setVBLStamp",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- setVBLStamp ---------------------------------------------->']\n<!-- <html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it. -->\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h:allToks\t\t= getSelected()]\n[h:assert(listCount(allToks), \"Make sure that you have at least one token selected. On which you want to apply the VBL stamp\",0)]\n[h:typeList\t\t= \"Cross, Rectangle, Circle, Horizontal Line, Vertical Line, Current VBL\"]\n[h:sideList\t\t= \"\"]\n<!-- create sides list ranging from 3 to 12 -->\n[h,count(10): sideList = listAppend(sideList, roll.count+3)]\n[h:gs\t\t\t= bot_getGridSize()]\n\n<!-- get previous settings (if any) from FIRST selected token ELSE use default settings -->\n[h:tok\t\t\t= listGet(allToks, 0)]\n[h:fgVBL\t\t= getProperty(\"w42.bot.fgVBL\", tok)]\n[h:vblPresent\t= if(json.type(fgVBL)==\"ARRAY\", 1, 0)]\n[h:vblSetup\t\t= if(vblPresent, getProperty(\"w42.bot.vblSetup\", tok), \"applyVBL=0;VBLType=0;scaleX=100;scaleY=100;offsetX=0;offsetY=0;thickness=1;fill=0;scale=1;close=0;sides=6;centreOffset=1;resetFoW=1;rxOffset=0;ryOffset=0\")]\n[h:varsFromStrProp(vblSetup)]\n[h:sides\t\t= sides - 3]\n\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, 'junk|<html><b>Set VBL Stamp (This line contains a tooltip)<\/b><br><font color=red>Keep in mind that the VBL layer only moves with<br>the token when its on the TOKEN layer<\/font><br><br><\/html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. <br><br>The chosen shape will be applies to ALL selected tokens. The <i>Current VBL<\/i><br>option will grab ALL VBL that covers the token and uses that as stamp. |LABEL|SPAN=TRUE')]\n[h:inputStr \t= json.append(inputStr, 'applyVBL|'+applyVBL+'|<html><span title=\"<html>When you check this a VBL layer will be added to the token<\/html>\">Apply a VBL Stamp to token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'VBLType|'+typeList+'|<html><span title=\"<html>Shape of the VBL layer that will be applied<\/html>\">Shape of VBL<\/html><\/span><\/html>|RADIO|SELECT='+VBLType)]\n[h:inputStr \t= json.append(inputStr, 'offsetX|'+offsetX+'|<html><span title=\"<html>X (left/right) Offset in pixels from top left corner<\/html>\">X offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'offsetY|'+offsetY+'|<html><span title=\"<html>Y (top/down) Offset in pixels from top left corner<\/html>\">Y offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'rxOffset|'+rxOffset+'|<html><span title=\"<html>RX (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RX is the offset of that rotational centre<\/html>\">RX offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'ryOffset|'+ryOffset+'|<html><span title=\"<html>RY (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RY is the offset of that rotational centre<\/html>\">RY offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'thickness|'+thickness+'|<html><span title=\"<html>Thickness of the VBL line in pixels<\/html>\">Thickness of VBL Line<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'scale|'+scale+'|<html><span title=\"<html>Scale 1 is actual size, 0.5 is half, 2 is 2x as big, etc.<\/html>\">Scale VBL shape<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'fill|'+fill+'|<html><span title=\"<html>Checked results in a solid (filled) shape, unchecked in a hollow shape<\/html>\">Solid shape<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'centreOffset|'+centreOffset+'|<html><span title=\"<html><b>UNCHECKED<\/b>: will align the TOP LEFT corner of the VBL to the TOP LEFT corner of the token<br>(in case of the circle this means that its centre will be aligned to the top left corner)<br><b>CHECKED<\/b>: will align the CENTRE of the VBL to the CENTRE of the token.<\/html>\">Align with Centre of token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Circle Only<\/b><\/html>|<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'sides|'+sideList+'|<html><span title=\"<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides<\/html>\">Number of sides<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+sides)]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>General<\/b><\/html>|<html>-|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'resetFoW|'+resetFoW+'|<html><span title=\"<html>When you check this the Fog of War will be reset entirely and cleared<br>for the current line of sight of the player tokens everytime the VBL<br> token is moved. <\/html>\">Reset FoW after moving token<\/html><\/span><\/html>|CHECK')]\n\n<!-- run the input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n[h: vblSetup = strPropFromVars(\"applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset\",\"UNSUFFIXED\")]\n\n<!-- apply settings to ALL selected tokens -->\n[h, foreach(me, allToks), CODE:{\n\t<!-- the setup variables get changed with in the foreach loop so they need to be reset with every loop -->\n\t[varsFromStrProp(vblSetup)]\n\t[if(applyVBL), CODE:{\n\t\t<!-- save settings on token-->\n\t\t[setProperty(\"w42.bot.vblSetup\", vblSetup, me)]\n\n\t\t<!-- get the new VBL settigns and apply the new VBL cross to its current position -->\n\t\t[bot_createVBL(me)]\n\t};{\n\t\t<!-- erase any current vbl -->\n\t\t[bot_drawBgVBL(me)]\n\t\t[bot_removeVBL(me)]\n\t}]\n}]\n\n[if(resetFoW): exposePCOnlyArea()]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a6b81f84-e792-4461-a70e-f952cc3b241f",
          "commandChecksum": "557a671672a214735bd50152b44efced",
          "propsChecksum": "f4d4d935a1e23e1bcb55f1e615cb300b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - VBL",
        "includeLabel": false,
        "sortBy": "3",
        "index": 178,
        "label": "toggleMassVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- toggleMassVBL -------------------------------------------------- -->']\n<!-- <html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off -->\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:storedVBL\t= getLibProperty(\"storedVBL\", \"lib:EventMacros\")]\n[h,if(json.type(storedVBL)==\"UNKNOWN\"): storedVBL = \"{}\"]\n[h:thisMapVBL\t= json.get(storedVBL, currentMap)]\n[h:thisMapVBLOn\t= json.get(storedVBL, currentMap+\"_ON\")]\n[h,if(json.type(thisMapVBLOn)==\"UNKNOWN\"):\tthisMapVBLOn\t= \"{}\"]\n\n[h:assert(json.type(thisMapVBL)!=\"UNKNOWN\",\"This map contains no stored VBL\", 0)]\n\n[h:vblList\t\t= json.fields(thisMapVBL)]\n\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Toggle Mass VBL Layer<\/b><\/html>|<html>Here you can turn on or off the stored Mass VBL resulting from the Mass VBL macro.<br>|LABEL|SPAN=TRUE\")]\n[h, foreach(vblName, vblList): inputStr\t= json.append(inputStr, vblName+'_ON|Deactivated, Activated, Delete from list|'+vblName+'|RADIO|ORIENT=H SELECT='+json.get(thisMapVBLOn, vblName))]\n\n<!-- run the input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- filter changes -->\n[vblChangedList = \"\"]\n[h, foreach(vblName, vblList), CODE:{\n\t[if(eval( vblName+'_ON') != json.get(thisMapVBLOn, vblName)): vblChangedList = listAppend(vblChangedList, vblName)]\n}]\n\n[h,foreach(vblName, vblChangedList), CODE:{\n\t<!-- draw all the vbl -->\n\t[jsonVBL\t\t= json.get(thisMapVBL, vblName)]\n\t[if(eval(vblName+'_ON')): drawVBL(jsonVBL) ; eraseVBL(jsonVBL)]\n\t<!-- save changes -->\n\t[thisMapVBLOn\t= json.set(thisMapVBLOn, vblName, eval(vblName+'_ON'))]\n\t[storedVBL\t\t= json.set(storedVBL, currentMap+\"_ON\", thisMapVBLOn)]\n}]\n\n[setLibProperty(\"storedVBL\", storedVBL, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1abedb71-a48c-42cf-922b-53ccab05589c",
          "commandChecksum": "706352ef00da1c14157fae1dbf65a305",
          "propsChecksum": "72c80b9d99dafe0d9da209073c87c877"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "35",
        "index": 179,
        "label": "SelectAndCentre",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------------------- SelectAndCentre ----------------------------------------->']\n[h:me = arg(0)]\n[h:switchToken(me)]\n[h:assert(findToken(me) != \"\", Me+\" cannot be found on the map\",0)]\n[h:'<!-- prevent loop! -->']\n[h, if(getSelected() != me):selectTokens(me)]\n[h:goto(me)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7b9e244a-6cd4-4082-9144-d2cb2b7f9cf8",
          "commandChecksum": "e9fb0c705d4a42b7ccae308c45e887a1",
          "propsChecksum": "13af9348d821ad2abcbf68170e6af7b2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "",
        "index": 180,
        "label": "SwitchFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ SwitchFrame ----------------------------------->']\n<!-- <html>\nThis macro activates a frame. As long as that frame is open the following functions are active:<br>\n- Door Switches (user can click them to open doors) <br>\n- Event Buttons (user can click them to activate linked macro) <br>\n- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>\n- Group select tokens (user can select one token and the rest is auto-selected)<br>\n-->\n\n[h:me = getSelected()]\n\n[frame(\"Door Buttons and Full Screen Checker\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: macroLinkText(\"buttonHandler@Lib:OnTokenMove\", \"none\", me)]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\tPlease leave this frame open. While this frame is open the following functions are activated:<br>\n\t\t\t- Door Switches (user can click them to open doors) <br>\n\t\t\t- Event Buttons (user can click them to activate linked macro) <br>\n\t\t\t- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>\n\t\t\t- Group select tokens (user can select one token and the rest is auto-selected)<br>\n\t\t\t- Force token selection (token that gm selects on his client is also selected on a player client)<br>\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7a5c728d-fc13-4da6-b4ee-2c6388f2cb2c",
          "commandChecksum": "3f072eb275e26161622a62db9b93b979",
          "propsChecksum": "e26f9f6689c2b67a4a1c9c361f4c5e16"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "",
        "index": 181,
        "label": "buttonHandler",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ BUTTON && FULSCREEN HANDLER ----------------------------------->']\n\n[h:'<!-- retrieve: doFullScreenMode, canSelectShadowTok -->']\n[h:varsFromStrProp(getLibProperty(\"toggles\", \"lib:EventMacros\"))]\n\n[h: tokenId\t= getSelectedNames()]\n\n<!-- check full screen mode. This can't be done in b87 so the json will return \"\".  -->\n[h:IFS\t\t= json.get(getInfo(\"client\"),\"isFullScreen\")]\n[h,if(isNumber(IFS) && doFullScreenMode),CODE:{\n\t[if(IFS != getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")): bot_toggleFullScreen()]\n};{}]\n\n<!-- check if (only) ONE token is selected and has the ISBUTTON state -->\n[h, if(listCount(tokenId) !=1 ): abort(0)]\n\n<!-- TIMER -->\n<!-- build in delay to make sure the open door macro is called only once as the token select event will fire 2 to 4 times when you select a token -->\n[h, if(bot_timeOut(1)), CODE:{\n\t[bot_resetTimer(1)]\n}; {\n\t<!-- SHADOW TOKENS -->\n\t<!-- due to the macro fring off 2 to 4 times, the main token can get deselected. This prevents that.  -->\n\t[h, if(getProperty(\"w42.bot.isShadowToken\", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(tokenId, 0, length(tokenId) - 7))]\n\t\n\t[abort(0)]\n}]\n\n<!-- GROUP TOKENS -->\n<!-- if its a group token, open the group move menu -->\n[h,token(tokenId),if(startsWith(token.label,\"group\")), CODE:{\n\t[if(getLibProperty('showGroupPanelOnSelect','lib:EventMacros') && !isFrameVisible(\"Group Move Macros\")):bot_MacroButtonsGroupMove()]\n}]\n\n<!-- SHADOW TOKENS -->\n<!-- the token has the shadow property then select its shadow token -->\n\t[h,token(tokenId), if(getProperty(\"w42.bot.isShadowToken\", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(token.name, 0,length(token.name) - length(\" shadow\")))]\n\n<!-- FORCE SELECT CLIENT -->\n<!-- selects the same token on the client as the gm selects on his client. -->\n[h,if(isGM() && forceSelectClient !=\"\"), CODE:{\n\t[broadcast(macroLink(\"<span  style='text-decoration:none'>  <\/span>\", 'SelectAndCentre@this', 'none', tokenId ), forceSelectClient)]\n}]\n\n\t\n<!-- TOKEN BUTTON & FORCE ON TOP -->\n<!-- check if it has buttonArgs property and thus is a button -->\n[h:tokButton\t= hasProperty(\"buttonArgs\", tokenId)]\n\n<!-- check if there is a gm client called 'forceButtons' (used for always on top) -->\n[h:forceButtons\t= if(isGM() && getPlayerName() != \"forceButtons\" && json.contains(getLibProperty(\"gmNames\",\"Lib:EventMacros\"), \"forcebuttons\"),1,0)]\n<!-- abort if no button token, or for full screen token select you need to be gm. -->\n[h: abort(tokButton + forceButtons)]\n\n[h, if(tokButton), CODE:{\n\t[buttonArgs = getProperty(\"buttonArgs\", tokenId)]\n\t[varsFromStrProp(buttonArgs)]\n\n\t<!-- call the macro that is in the buttonArgs deferred -->\n\t[macroLink = macroLinkText(macroToCall, \"none\", buttonArgs)]\n\t[execLink(macroLink, 1)]\n}; {}]\n\n[h, if(forceButtons), CODE:{\n\t<!-- for use with 'always on top': check if there is a gm client called forceButtons, which selects the token you just selected so the correct macro panel is shown on the full screen panel -->\n\t[broadcast(macroLink(\"<span  style='text-decoration:none'>  <\/span>\", 'SelectAndCentre@this', 'none', tokenId ),\"forceButtons\")]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3812d889-9e75-4c99-a01c-e4b2ae9becd1",
          "commandChecksum": "05eef6061cf349003264f97694695aa5",
          "propsChecksum": "6c276ca1726b3827c57cde8b8c8ee129"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "maroon",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "22",
        "index": 182,
        "label": "openFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- openFrame ------------------------------------------------>']\n<!-- <html> Turns on door switches at selected players. This will allow players to use doorswitches -->\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'<!-- input string -->']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'<!-- ask for input-->']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n[h:bot_resetTimer(1)]\n[h:bot_execAllPlayers(\"SwitchFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>Turns on door switches at selected players. This will allow players to use doorswitches",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "07ad37e6-b0d0-4799-bcf6-ad03f5355258",
          "commandChecksum": "d5cae4ce29ac4294c945cb30b983a95b",
          "propsChecksum": "b8ec2652f8c50d8f414ceded192fe646"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "",
        "index": 183,
        "label": "operateLever",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ OPERATE LEVER -------------------------- -->']\n\n<!-- arg(0): leverToken (ID), mainDoor (Name), proximity (Range in cells), macroToCall (operateLever@This) -->\n[h:varsFromStrProp(arg(0))]\n[h:switchToken (mainDoor)]\n[h:leverToken = getSelected()]\n[h:closeEnough= 1]\n[h:operator = \"\"]\n[h:tokenList = \"\"]\n<!-- proximity check -->\n[h,if(proximity), CODE:{\n\t['tokenList\t\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"range\",json.set(\"{}\",\"token\",leverToken, \"upto\", proximity)))']\n\t[tokenList\t\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"pc\", 1, \"range\",json.set(\"{}\",\"token\",leverToken, \"upto\", proximity)))]\n\n\t[tokenList\t\t= listDelete(tokenList, listFind(tokenList,getName(mainDoor)))]\n\t[closeEnough\t= 0]\n\t[player\t\t\t= getPlayerName()]\n\t[foreach(tok, tokenList), CODE:{\n\t\t[if(isOwner(player, tok)): closeEnough = 1]\n\t\t[if(isOwner(player, tok)): operator = tok]\n\t}]\n}; {\n\t['tokenList\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"range\",json.set(\"{}\",\"token\",leverToken)))']\n\t[ tokenList\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"pc\", 1, \"range\",json.set(\"{}\",\"token\",leverToken)))]\n\t[operator\t= listGet(getOwned(getPlayerName()),0)]\n\t[if(operator != \"\"): operator = getName(operator)]\n}]\n\n<!-- flip the lever -->\n[h,if(getTokenFacing(leverToken)==\"\"):setTokenFacing(-90,leverToken)]\n[h, if(closeEnough): setTokenFacing(180+getTokenFacing(leverToken), leverToken)]\n\n<!-- Handle the Door -->\n[h: bot_toggleDoor(mainDoor, closeEnough, operator, tokenList)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a0679593-d8c7-4e89-a7a2-b4ca08f36b83",
          "commandChecksum": "67e54a03b4d4e70479e08b4806f104ab",
          "propsChecksum": "1767ebc6ed83cf8096379d9bd99f6025"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "",
        "index": 184,
        "label": "toggleLock",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ toggleLock -------------------------- -->']\n[h:'<!-- check if (only) ONE token is selected and has the ISBUTTON state -->']\n[h:tokenId = getSelected()]\n[h:assert(listCount(tokenId)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(tokenId)]\n\n[h:setState('Locked', 1-getState('Locked'))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ce16ca4c-bee9-46ba-8db4-0ee320b8e0bf",
          "commandChecksum": "9f268309c184a07046c9f1e3712acc33",
          "propsChecksum": "63c88a6315e1a8cad8bbda821d5c6560"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "z. Version",
        "includeLabel": false,
        "sortBy": "42",
        "index": 188,
        "label": "getFullInfo",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:broadcast(\"\n\tServer:\n\t<pre>\"+json.indent(getinfo(\"server\"),1)+\"\n\t_________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tClient:<br>\n\t<pre>\"+json.indent(getinfo(\"client\"),1)+\"\n\t_________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tCampaign:<br>\n\t<pre>\"+json.indent(getinfo(\"campaign\"),1)+\"\n\t__________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tCurrent Map:<br>\n\t<pre>\"+json.indent(getinfo(\"map\"),1)\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "47e1d881-5315-418b-a9e2-0659f7a36f01",
          "commandChecksum": "c7ece7820f26de648ba4db06353fa291",
          "propsChecksum": "5ad00def9e2bbe9286c87d374c4dbfdb"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "20",
        "index": 189,
        "label": "all",
        "fontSize": "1.00em",
        "minWidth": "20",
        "playerEditable": false,
        "command": "[h:macro.return=json.fromList(getAllPlayerNames())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f1c4128d-5a5d-4487-a065-035d8c7b8670",
          "commandChecksum": "482a799bc5b3ccf4f6b4f2db7bd9c295",
          "propsChecksum": "06553043532c375fa2b510d1c21b2581"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "30",
        "index": 190,
        "label": "gm",
        "fontSize": "1.00em",
        "minWidth": "20",
        "playerEditable": false,
        "command": "[h:macro.return=getLibProperty(\"gmNames\", \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "74572423-693a-413a-973c-d1978b1295d7",
          "commandChecksum": "e40ee4f6bbcbcbb4125473ef05d9f5c5",
          "propsChecksum": "17180d30be3907db8573f0526e18f8ee"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "10",
        "index": 191,
        "label": "message",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- BOT_message ------------------------------------------------>']\n<!-- \n0:message, \nOPTIONAL\n1:headertxt, \n2:color (bgcolor-txtcolor), \n3:userList, \n4:token, \n5:target,\n6:broadcast, \n7:width of message table\n8:token only, dont show the name just the image\n-->\n\n<!-- ignore output , new scope -->\n\n<!-- arguments -->\n[h:message\t\t= arg(0)]\n\n<!-- Optional arguments -->\n[h,if(argCount() > 1): headerText\t= arg(1) ; headerText\t= \"\"]\n[h, if (indexOf(headerText, \":width=\") != -1), CODE:{\n\t<!-- this will get overwritten by argument 7 should that argument be used.  -->\n\t[break\t\t= indexOf(headerText, \":width=\")]\n\t[width\t\t= substring(headerText, break + 7)]\n\t[headerText\t= substring(headerText, 0, break)]\n};{}]\n\n[h,if(argCount() > 2): color \t\t= arg(2) ; color\t\t= \"black\"]\n[h,if(indexOf(color, \"-\")+1), CODE:{\n\t[break\t\t= indexOf(color, \"-\")]\n\t[bgColor\t= substring(color, 0, break)]\n\t[textColor\t= substring(color, break + 1)]\n}; {\n\t[bgColor\t= color]\n\t[textColor\t= \"white\"]\n}]\n\n[h,if(argCount() > 3): userList\t\t= arg(3) ; userList\t\t= \"[]\"]\n\n[h,if(argCount() > 4 ), CODE:{\n\t[h,if(arg(4) != \"\"), CODE:{\n\t\t[me\t\t\t= arg(4)]\n\t\t[token(me): meImage\t= getTokenImage()]\n\t\t[me\t\t\t= strformat(\"<b>%{me}<\/b> \")]\n\t\t[meImage\t= strformat(\"<img src='%{meImage}' height='20' width='20' alt='%{me}'/>\")]\n\t}; {\n\t\t[me\t\t\t= \"\"]\n\t\t[meImage\t= \"\"]\n\t}] \n};{\n\t[me\t\t\t= \"\"]\n\t[meImage\t= \"\"]\n}]\n\n[h,if(argCount() > 5), CODE:{\n\t[target\t= arg(5)]\n\t[if(target != \"\"), CODE:{\n\t\t[token(target):\ttargetImage\t= getTokenImage()]\n\t\t[targetImage\t= strformat(\"<img src='%{targetImage}' height='20' width='20' alt='%{target}'/>\")]\n\t}; {\n\t\t[targetImage\t= \"\"]\n\t}]\n}; {\n\t[target\t\t\t= \"\"]\n\t[targetImage\t= \"\"]\n}] \n\n[h,if(argCount() > 6): bc\t\t\t= arg(6) ; bc\t\t= 1]\n\n[h,if(argCount() > 7): width\t\t= arg(7) ; width\t= \"100%\"]\n\n[h,if(argCount() > 8): me = if(arg(8), \"\", me)] <!-- token only, dont show the name just the image -->\n\n<!-- the actual code -->\n[h:txtResult\t= strformat(\"\n\t<table bgcolor='%{bgColor}' width='\"+width+\"' cellpadding='3' cellspacing='0'><font color = '%{textColor}'>\n\t\t<tr>\n\t\t\t<td>\n\t\t\t\t%{meImage}\n\t\t\t<\/td>\n\t\t\t<td align='middle'>\n\t\t\t\t%{me}%{headerText}\n\t\t\t<\/td>\n\t\t\t<td align='right'>\n\t\t\t\t%{targetImage}\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/font><\/table>\"+\n\tif(message != \"\", \"\n\t\t<table bgcolor='%{bgColor}' width='\"+width+\"' cellpadding='1' cellspacing='0'>\n\t\t\t<table bgcolor='White' width='100%'>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t%{message}\n\t\t\t\t\t<\/td>\n\t\t\t\t<\/tr>\n\t\t\t<\/table>\n\t\t<\/table>\n\t\", \"\")\n))]\n\n[h, if(bc), CODE:{\n\t[if(!json.isEmpty(userList)): broadcast(txtResult, userList); broadcast(txtResult)]\n\t<!-- retrieve: doFullScreenMode, used to store the last message and update the macro frame with it. -->\n\t[varsFromStrProp(getLibProperty(\"toggles\", \"lib:EventMacros\"))]\n\t[if(doFullScreenMode),CODE:{\n\t\t[isFullScreen\t= json.get(getInfo(\"client\"),\"isFullScreen\")]\n\t\t[frameVisible\t= isFrameVisible(\"Bag Of Tricks Macros\") + isDialogVisible(\"Bag Of Tricks Macros\")]\n\t\t[if(isFullScreen == 1 && frameVisible), CODE:{\n\t\t\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t\t\t[r:bot_createMacroButtonsOTMUtils(txtResult)]\n\t\t\t''\n\t\t\t}]\n\t\t''\n\t\t};{}]\n\t''\n\t};{}]\n''\n}; {\n\t[macro.return = txtResult]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ace1fa2a-01bf-4382-89a6-937d88243fd4",
          "commandChecksum": "b26a452243683d7fba86424b041e71bb",
          "propsChecksum": "3f5f2da6a14340b95cc5d3acdda44de6"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "31",
        "index": 193,
        "label": "ngm",
        "fontSize": "1.00em",
        "minWidth": "23",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), getLibProperty(\"gmNames\", \"lib:EventMacros\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "46f1d49c-621a-4ed1-90d2-52ecd47b45c5",
          "commandChecksum": "fe21b549bf4fe31468021854d6ba787a",
          "propsChecksum": "2ec3afa32a9d61ab53510f97c0cca75b"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "52",
        "index": 194,
        "label": "nownergm",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = json.difference(getAllPlayerNames(\"json\"), getLibProperty(\"gmNames\", \"lib:EventMacros\"))]\n};{\n\t[h,if(isOwnedByAll(tok)):\t\n\t\tmacro.return = []\n\t; \n\t\tmacro.return = json.difference(getAllPlayerNames(\"json\"), bot_ownergm())\n\t]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f309380c-d9ce-4516-8ebc-73316984a8be",
          "commandChecksum": "daa1e4a5582e255a6e1434d7f54cd4b9",
          "propsChecksum": "d74129afa9b2a39838a418e72ac45eb8"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "41",
        "index": 195,
        "label": "nself",
        "fontSize": "1.00em",
        "minWidth": "38",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), json.fromList(getPlayerName()))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "00f52d9b-c3cb-4dcc-8f20-a7871df805a0",
          "commandChecksum": "2ef7b99d54bb1737dd19c1278a49165b",
          "propsChecksum": "be620d279225b0f5452ecfabbf6665d8"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "43",
        "index": 196,
        "label": "nselfgm",
        "fontSize": "1.00em",
        "minWidth": "39",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), json.union(getLibProperty(\"gmNames\", \"lib:EventMacros\"), json.fromList(getPlayerName())))]",
        "maxWidth": "",
        "tooltip": "returns all but self and gm",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "392d2d35-2de9-4c88-bb7a-64b29d9ee8df",
          "commandChecksum": "9fdd9fa1bb4df719447dd354e88b6b2b",
          "propsChecksum": "8d8a4e3f695f071ae1203595ba699b54"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "53",
        "index": 197,
        "label": "owner",
        "fontSize": "1.00em",
        "minWidth": "38",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = \"\"]\n};{\n\t[if(isOwnedByAll(tok)):\t\n\t\tmacro.return = getAllPlayerNames() \n\t; \n\t\tmacro.return = getOwners(\"json\",tok)\n\t]\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "40ac5786-b314-4ece-a4e0-1dede38989e3",
          "commandChecksum": "162eb8d97bb5e62aaccc84d234a46158",
          "propsChecksum": "cf8d722b2d6a7a21cb208d069b8d1aa5"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "40",
        "index": 198,
        "label": "self",
        "fontSize": "1.00em",
        "minWidth": "38",
        "playerEditable": false,
        "command": "[h:macro.return=json.fromList(getPlayerName())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "122e79e0-70a3-4e4e-8a2f-269414a0ad08",
          "commandChecksum": "ba8b2f8207f773b301579d1018bccccc",
          "propsChecksum": "bb299b4437fa662a020e7e6e698b7c9a"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "42",
        "index": 199,
        "label": "selfgm",
        "fontSize": "1.00em",
        "minWidth": "39",
        "playerEditable": false,
        "command": "[h:macro.return = json.union(getLibProperty(\"gmNames\", \"lib:EventMacros\"), json.fromList(getPlayerName()))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e79575b5-541b-4ef7-be12-bff382fa1cfc",
          "commandChecksum": "62c055709201b66da435ddab61257171",
          "propsChecksum": "6283faf49cc278ecc1b4858eecb8483a"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "16",
        "index": 200,
        "label": "altInitMap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------------------ ALTINITMAP -------------------------------------------------------------->']\n\n[h: assert(getImpersonated() == \"\", \"Make sure no token is impersonated while running this macro\", 0)]\n[h,if(argCount()>0): allToks = arg(0); allToks = \"\"]\n[h:map = getCurrentMapName()]\n\n[h:libCoordName\t= strformat(\"lib:Coords %{map}\")]\n[h:libCoordSize = getLibProperty(\"libCoordSize\", \"lib:EventMacros\")]\n[h:existTok\t\t= findToken(libCoordName)]\n[h,if(existTok != \"\"): initRun = getLibProperty(\"initRun\", libCoordName); initRun = 0]\n[h,if(initRun == \"\"): initRun = 0]\n[h:baseMapName\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h,if(initRun == 0 && existTok != \"\"), CODE:{\n\t[message = \"It seems you have Initialized this map before, if there are any lib:Coords XxYy tokens on the map, press Cancel and delete these first.<br>These tokens can typically be found at the 0,0 coordinate.<br>If there are no lib:Coords XxYy on the map, press ok to continue\"]\n\t[pause(\"message\")]\n}]\n\n[h,if(initRun > 0), CODE:{\n\t[h:'<!-- initRun is a number indicating that this concerns multiple runs to initialize this map. -->']\n\t[h:numMinX = 0]\n\t[h:numMinY = 0]\n\t[h:numMaxX = 0]\n\t[h:numMaxY = 0]\n}; {\n\t[h:'<!-- if initRun has no value or 0 then this is the first time the map is initialized -->']\n\t[h:'<!-- create the coord libs -->']\n\t[h:specNameList = \"Canopy, Foliage, InterPad, PadStart, PadEnd, InterPadBorder, PadStartBorder, PadEndBorder, PadJump, InterJump, PadJumpBorder, InterJumpBorder, MappedPad, Roof, EventPad, Ward\"]\n\t[h, if(allToks == \"\"): allToks = json.toList(json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\")))))]\n\n\t[h:tokList = \"\"]\n\t[h, foreach(tok, allToks), CODE:{\n\t\t[padName = getGroup(strfind(tok, \"[A-z]+\"), 1,0)]\n\t\t[if(listContains(specNameList, padName)): tokList = listAppend(tokList, tok)]\n\t}]\n\n\t[h:numToks = listCount(tokList)]\n\t[h:assert(numToks <= 1000, \"Fatal error: The number (\"+numToks+\") of special pads on this map is more than 1000. This tool can handle upto 1000 special pads. Please remove \"+(numToks - 1000)+\" pads from this map\",0)]\n\n\t[h:tok = listGet(tokList, 0)]\n\t[h:switchToken(tok)]\n\t[h:xMin=getTokenX(0)]\n\t[h:yMin=getTokenY(0)]\n\n\t[xSize\t= getProperty(\"w42.bot.xSize\")]\n\t[ySize\t= getProperty(\"w42.bot.ySize\")]\n\t[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]\n\t[h:xMax=xMin + xSize]\n\t[h:yMax=yMin + ySize]\n\n\t[h, foreach(tok, tokList), CODE:{\n\t\t[switchToken(tok)]\n\n\t\t[xSize\t= getProperty(\"w42.bot.xSize\")]\n\t\t[ySize\t= getProperty(\"w42.bot.ySize\")]\n\t\t[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]\n\t\t\n\t\t[h:x = getTokenX(0)]\n\t\t[h:y = getTokenY(0)]\n\t\t[h:xMin = min(xMin, x)]\n\t\t[h:yMin = min(yMin, y)]\n\t\t[h:xMax = max(xMax, x + xSize)]\n\t\t[h:yMax = max(yMax, y + xSize)]\n\t}]\n\t\n\tUpper left\t= ([r:xMin], [r:yMin])<br>\n\tLower Right\t= ([r:xMax], [r:yMax])<br><br>\n\t[h:numMinX = floor(xMin/libCoordSize)]\n\t[h:numMinY = floor(yMin/libCoordSize)]\n\t[h:numMaxX = floor(xMax/libCoordSize)+1]\n\t[h:numMaxY = floor(yMax/libCoordSize)+1]\n\n\t[h:'pause(\"xMin\",\"yMin\",\"xMax\",\"yMax\",\"numMinX\",\"numMinY\",\"numMaxX\",\"numMaxY\",\"libCoordSize\")']\n\n\t[h:initRun = 1]\n}]\n\n[h:'<!-- here the lib:coords are actually created. if this is a second run then numMin[n] are all set to 0 -->']\n[h,if(existTok != \"\"): createdCoordLibs = getLibProperty(\"createdCoordLibs\", libCoordName); createdCoordLibs = \"\"]\n[h,for(x, numMinX, numMaxX,1, \"<br>\"),CODE:{\n\t[r,for(y, numMinY, numMaxY, 1, \"<br>\"),CODE:{\n\t\t[h:xCoord = x*libCoordSize]\n\t\t[h:yCoord = y*libCoordSize]\n\t\t[h:name = strformat(\"lib:Coords %{map} X%{xCoord}Y%{yCoord}\")]\n\t\t[h:existTok = findToken(name)]\n\t\t[h,if(existTok != \"\"):removeToken(existTok)]\n\t\t[h:updates = '{\"name\":\"[r: name]\", \"useDistance\":\"0\", \"x\":\"[r:x]\", \"y\":\"[r:y]\"}']\n\t\t[r:createdCoordLibs = listAppend(createdCoordLibs, getName(copyToken(\"lib:Coords\", 1, baseMapName, updates)))] \n\t}]\n}]\nCreated: [r:createdCoordLibs]\n\n[h:'<!-- a pause break is necessary for the copy tokens, else the coordinates will be discarded. This only needs to be done if there are actually lib:tokens created this run -->']\n[r, if(initRun == 1), CODE:{\n\t[h:existTok = findToken(libCoordName)]\n\t[h,if(existTok != \"\"):removeToken(existTok)]\n\t[h:x = numMinX - 1]\n\t[h:y = numMinY - 1]\n\t[h:updates = '{\"name\":\"[r: libCoordName]\", \"useDistance\":\"0\", \"x\":\"[r:x]\", \"y\":\"[r:y]\"}']\n\t<br>[r:getName(copyToken(\"lib:Coords\", 1, baseMapName, updates))] Created<br>\n\t[h:answer\t= input(\"junk|<html>This break is necessary for the just created lib:Coords tokens.<br>Click ok to continue.<br><br>his is also a good moment to mention that it is VITAL that FREESIZE<br>(or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize<\/b> special pad tokens, its advisable (but<br>not necessary) to set the size of these tokens before you run this macro.<br>To do this select the token and click the set size macro. If you don't<br>do this up front this macro will pop-up the size request for each of<br>these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads<\/b> you'll need to<br>initialize the campaign 'normally' first so they get setup properly.<br>This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <br>b>delete the lib:coords files<\/b> that have just been created and check<br>the tokens you're not sure of and/or run the 'normal' initialize pads.<\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(answer == 0), CODE:{\n\t\t<!-- if process is aborted delete the created coord tokens -->\n\t\t[foreach(tok, createdCoordLibs): removeToken(tok)]\n\t\t[removeToken(libCoordName)]\n\t\t[assert(0,\"Alt. init. Process aborted\",0)]\n\t};{}]\n\n\t[message = \"This break is necessary for the just created lib:Coords tokens. Click ok to continue.<br><br>This is also a good moment to mention that it is VITAL that FREESIZE (or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize<\/b> special pad tokens, its advisable (but not necessary) to set the size of these tokens before you run this macro. To do this select the token and click the set size macro. If you don't do this up front this macro will pop-up the size request for each of these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads<\/b> you'll need to initialize the campaign 'normally' first so they get setup properly. This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <b>delete the lib:coords files<\/b> that have just been created and check the tokens you're not sure of and/or run the 'normal' initialize pads.\"]\n[pause(\"message\")]\n\n\t[h:setLibProperty(\"initRun\", initRun, libCoordName)]\n\t[h:setLibProperty(\"libCoordSize\", libCoordSize, libCoordName)]\n}]\n[h:setLibProperty(\"createdCoordLibs\", createdCoordLibs, libCoordName)]\n\n[h:'<!-- Here starts the process of mapping the special pads on the cell coordinates. To do this the location and size of each pad is determined and from there the coordinates of the cells it actually covers are calculated. These coordinates are used to create a property on lib:Coords and contain the name of the special pad. -->']\n\n[r,if(initRun == 1), CODE:{\n\t[h:numToks \t\t\t= listCount(tokList)]\n\t[h:maxPadsPerRun \t= getLibProperty(\"maxPadsPerRun\", \"lib:EventMacros\")]\n\t[h:numRuns \t\t\t= ceil(numToks/maxPadsPerRun)]\n\t[h:tokList \t\t\t= json.fromList(tokList)]\n\n\t[h,for(i, 1, numRuns+1), CODE:{\n\t\t[runToksname = \"runToks\"+i]\n\t\t[if(i < numRuns):\tset(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, i * maxPadsPerRun - 1))); \n\t\t\t\t\t\t\tset(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, -1)))\n\t\t]\n\t\t[setLibProperty(runToksname, eval(runToksname), libCoordName)]\n\t}]\n\n\t[h:setLibProperty(\"numRuns\", numRuns, libCoordName)]\n\t[h:tokList = runToks1]\n\t[h:'pause(\"runToks1\",\"runToks2\",\"runToks3\",\"runToks4\",\"numRuns\", \"tokList\")']\n\n}; {\n\t[h:tokList = getLibProperty(\"runToks\"+initRun, libCoordName)]\n}]\n\nRun [r:initRun]:\n[h: bot_abortProcess(1)]\n[h: link = macroLinkText(\"deferInitialize@Lib:OnTokenMove\", \"self\", json.append(\"\",listCount(tokList), tokList))]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a5c823ca-006b-42b2-8bb8-8e7c6bdba083",
          "commandChecksum": "8f8c3167a6f5bd5e9adbd7afbec41bbd",
          "propsChecksum": "5d6c080940e943a0c65edc7644762a01"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "11",
        "index": 201,
        "label": "checkInterPads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- checkInterPads (no new scope)-->']\n\n[h,if(json.contains(interPadCheckList, fullPadName)), CODE:{\n\t[tmp = json.get(interPadCheckList, fullPadName)]\n\n\t[if(json.contains(tmp, \"map1\")), CODE:{\n\t\t[map1 = 1]\n\t\t[map1Name = json.get(tmp, \"map1\")]\n\t}; {\n\t\t[map1 = 0]\n\t}]\n\n\t[if(json.contains(tmp, \"map2\")), CODE:{\n\t\t[map2 = 1]\n\t\t[map2Name = json.get(tmp, \"map2\")]\n\t}; {\n\t\t[map2 = 0]\n\t}]\n\n\t[if(map1 && map2), CODE:{\n\t\t[txtOutPut = txtOutPut + \"<font color='red'>Error: found three (or more) identical <u>\"+padName+\" \"+tmpNum+\"<\/u> on maps \" + map1Name + \", \" + map2Name + \" and \" + currentMap + \"<br><\/font>\"]\n\t\t[error = 1]\n\t}; {}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ae457ebf-5735-4ec7-ba27-fb4dda3778e9",
          "commandChecksum": "aa59133e608903d8d53a439f26800373",
          "propsChecksum": "3724ccbfd1de27457c5a25199e750f2a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "12",
        "index": 202,
        "label": "chkMoveStop",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- CHKMOVESTOP -->']\n[h:pathPadList = bot_path2pads(json.get(lastPath,1,-2))]\n[h:moveStopList = \"Ward\"]\n\n[r,foreach(item, moveStopList), if(bot_inStr(pathPadList, item)), CODE:{\n\t[h:newLastPath = \"[]\"]\n\t[h:clear = 1]\n\t[h:edgePoint = \"\"]\n\t[h,foreach(step, lastPath), CODE:{\n\t\t[pads = bot_path2pads(step)]\n\t\t[if(clear): newLastPath = json.append(newLastPath, step)]\n\t\t[foreach(item, moveStopList): clear = if(bot_inStr(pads, item),0, clear)]\n\t\t[h:'<!-- in this line x and y are defined as vars -->']\n\t\t[if(!clear && edgePoint == \"\"): edgepoint = varsFromStrProp(json.toStrProp(step))]\n\t}]\n\t[r:lastPath = newLastPath]\n\t[h,if(!clear): moveToken(x,y,0)]\n\t[h:'<!-- build a new pathPadList for the next foreach UNLESS its the last check -->']\n\t[if(roll.count < 1 && !clear):pathPadList = bot_path2pads(json.get(lastPath,1,-2))]\n}; {\n\t[h:clear = 1]\n\t[r:lastPath]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1a6b3726-cc48-4595-a64e-b7a89762f15c",
          "commandChecksum": "2b02b6ca3c891b530875cf5f884a01dc",
          "propsChecksum": "f101bdc7910eddf314e0f5891679d9e3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "9",
        "index": 203,
        "label": "deferFinishInit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------------------ deferFinishInit -------------------------------------------------------------->']\n[h:map \t\t\t\t= getCurrentMapName()]\n[h:libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h:numRuns \t\t\t= getLibProperty(\"numRuns\", libCoordName)]\n[h:initRun \t\t\t= getLibProperty(\"initRun\", libCoordName)]\n[h:createdCoordLibs = getLibProperty(\"createdCoordLibs\", libCoordName)]\n[h:closeFrame(\"Progress Bar\")]\n[h:done = if(initRun == numRuns, 1, 0)]\n\n[h: message = if(done, \"Map is initialized\", \"There are a total of \"+numRuns+ \" runs necessary to complete the initialization. This is run \"+initRun+\". Run the macro again for Run \"+(initRun + 1))]\n\n[h, if(!done): initRun = initRun + 1]\n[h:setLibProperty(\"initRun\", initRun, libCoordName)]\n[r:message]\n\n[h:'<!-- Now gather all the properties from all the libCoords tokens and concatenate them and at the same time create variables from each of them -->']\n[h: allProps = \"[]\"]\n[h,foreach(tok,createdCoordLibs), CODE:{\n\t[props = getPropertyNamesRaw (\"json\", tok)]\n\t[foreach(prop, props):set(prop, getProperty(prop, tok))]\n\t[allProps = json.merge(allProps, props)]\n}]\n\n[h:'<!-- use strPropsFromVars to turn the concatenated list in one go into a strProp list and save that to the lib:Coord file -->']\n[h:mappedCoords = strPropFromVars( json.toList(allProps), \"UNSUFFIXED\")]\n[h:'<!-- it turns out that there occur spaces in the strProps due to: X_31Y_31 =Canopy 81, Canopy 61 ; . The space \", \" needs to be removed -->']\n[h:mappedCoords = replace(mappedCoords, \", \", \",\")]\n[h:setLibProperty(\"mappedCoords\", mappedCoords, libCoordName)]\n[h:setLibProperty(\"allCoordsArray\", allProps, libCoordName)]\n\n[h:'<!-- delete the  lib:CoordXY files -->']\n\n[h,if(done), CODE:{\n\t[foreach(tok, createdCoordLibs): removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "10820aed-9745-4560-a7db-204fc9d1b451",
          "commandChecksum": "ee320fcdc40885ccf69f0f2237cfa914",
          "propsChecksum": "88712a646d6278cafeb06b048ca8ee62"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "8",
        "index": 204,
        "label": "deferInitialize",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------------------------------------ DEFERINITIALIZE --------------------------------------------------------------------------->']\n[h:assert(getLibProperty(\"abortProcess\", \"lib:EventMacros\")!=0, \"Process Aborted\", 0))]\n\n[h:totalIteration = arg(0)]\n[h:tokList = arg(1)]\n[h:currentIteration = totalIteration - listCount(tokList)]\n\n[h:output = \"\n\t<table width=305px bgcolor='red'>\n\t\t<tr><td>\n\t\t\t[h:prog.percentage = floor(100*currentIteration/totalIteration)]\n\t\t\t<table width=[r:3*prog.percentage]px bgcolor = 'green' color='white'>\n\t\t\t\t<tr><td>\n\t\t\t\t\t[r:prog.percentage]%  \" + if(band(currentIteration,1), '0', 'o') + \"\n\t\t\t\t<\/td><\/tr>\n\t\t\t<\/table>\n\t\t<\/td><\/tr>\n\t<\/table>\n\n\t  \n\t<table width=100px bgcolor='black' cellpadding='1'>\n\t\t<table width=100% bgcolor='red'><td align='center')>\n\t\t\t<td>\n\t\t\t\t<span  style='text-decoration:none; color:yellow'>\n\t\t\t\t\t\" + macroLink('Abort process', 'abortProcess@this', '', 0) + \"\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n\t<\/table>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Progress Bar\", \"width=410; height=20; temporary=1; ouptut=1\"): {[r:output]}]\n};{\n\t[frame(\"Progress Bar\", \"width=410; height=20; temporary=1\"): {[r:output]}]\n}]\n\n[h:'<!----------------------------- here you can do your calculations -------------------------->']\n\n[h:tok\t\t\t= listGet(tokList, 0)]\n[h:tokList\t\t= listDelete(tokList, 0)]\n[h:xSize\t\t= getProperty(\"w42.bot.xSize\", tok)]\n[h:ySize\t\t= getProperty(\"w42.bot.ySize\", tok)]\n[h:map\t\t\t= getCurrentMapName()]\n[h:libCoordSize\t= getLibProperty(\"libCoordSize\", strformat(\"lib:Coords %{map}\"))]\n[h:'<!-- output to chat -->']\n[r, token(tok):token.name] \n(\n\t[r, token(tok):xTok = getTokenX(0)] \n\t[r, token(tok):yTok = getTokenY(0)] \n)\n<br>\n[h:'<!-- /output to chat -->']\n[h:'e.g: lib:Coords Grasslands X-50Y-50']\n[h, for(x, xTok, xTok + xSize), CODE:{\n\t[for(y, yTok, yTok + ySize), CODE:{\n\t\t[xCoord\t\t= floor(x/libCoordSize)*libCoordSize]\n\t\t[yCoord\t\t= floor(y/libCoordSize)*libCoordSize]\n\t\t[if(x<0):xn = replace(x,\"-\",\"_\"); xn = x]\n\t\t[if(y<0):yn = replace(y,\"-\",\"_\"); yn = y]\n\t\t[coordName\t= strformat(\"X%{xn}Y%{yn}\")]\n\t\t[libName \t\t= strformat(\"lib:Coords %{map} X%{xCoord}Y%{yCoord}\")]\n\t\t[setLibProperty(coordName, listAppend(getLibProperty(coordName, libName),tok), libName)]\n\t}]\n}]\n\n[h:'<!----------------------------- /here you can do your calculations -->']\n\n[h, if(listCount(tokList)):\texecLink(macroLinkText(\"deferInitialize@Lib:OnTokenMove\", \"self\", json.append(\"\",totalIteration, tokList)),1); \n\t\t\t\t\t\t\texecLink(macroLinkText(\"deferFinishInit@Lib:OnTokenMove\", \"self\"),1)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8ed34621-4f14-4cb9-9ab3-2e674716725a",
          "commandChecksum": "5faf3dea44609f7aec0dfecc71ea9c92",
          "propsChecksum": "16568d74da67d6c9b5d607c87b638381"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "4",
        "index": 205,
        "label": "deferOnMultipleTokensMove",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- deferOnMultipleTokensMove ------------------------------------------------->']\n[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']\n<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->\n<!-- VARS: tok,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort -->\n\n[h: varsFromStrProp(arg(0))]\n\n<!-- define the following vars:  doGroups,doResetFoW,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove -->\n[h: varsFromStrProp(arg(1))]\n\n<!-- The reason for this big gap (yes its a gap cause theres more code way down) is because of the similarity with deferOntokenMove, all the code that is the same are on the same line number.  -->\n\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n<!-- AMs VBL Checker -->\n[h,if(doVBLCheck), CODE:{\n\t[foreach(tok,toks):bot_moveVBLToken(tok, eval(\"lastPath\"+roll.count))]\n}; {}]\n\n<!-- Align VBL Stamps with moved token-->\n\n[h,if(doVBLStamp), CODE:{\n\t<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->\n\t<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->\n\t<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->\n\t[foreach(tok,toks), CODE:{\n\t\t[hasVBL\t= if(json.type(getProperty(\"w42.bot.fgVBL\", tok))==\"ARRAY\",1,0)]\n\t\t[if(hasVBL): \tbot_moveStamp(tok)]\n\t}]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n<!-- abort if special pads are turned off -->\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = \"Canopy 12\" -->\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t<!-- if token has not moved but just \"wobbled\" there will be 1 coordinate == listSize(2) abort in this case -->\n\t[token(json.get(toks,0)):lastPPath = getLastPath(0)]\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\n\t\n\t<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->\n\t<!-- @@MULTIPLE TOKEN MOVE SPECIFIC CODE-->\n\t<!-- combine all coordinates of the lastpaths of all the tokens that moved and then create the padList. -->\n\t[Path\t\t= '[]']\n\t[firstPoint = '[]']\n\t[lastPoint\t= '[]']\n\t[foreach(tok, toks), CODE:{\n\t\t[token(tok):lastPPath = getLastPath(0)]\n\t\t<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path and move token to the (new) edge -->\n\t\t[if(!oneStepOnly && doInnerPointsPath): bot_chkMoveStop()]\n\t\t[if(!oneStepOnly): Path = json.union(Path, json.get(lastPPath,1,-2)); Path = \"[]\"]\n\t\t[firstPoint\t= json.union(firstPoint,json.get(lastPPath,0,0))]\n\t\t[lastPoint\t= json.union(lastPoint,\tjson.get(lastPPath,-1,-1))]\n\t}]\n\t[lastPointPadList\t= bot_path2pads(lastPoint)]\n\t<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->\n\t\n\t<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START, MIDDLE AND END -->\n\t[if(doFirstPointPath), CODE:{\n\t\t<!-- check if token is on a relevant token when leaving -->\n\t\t[firstPointPadList\t\t= bot_path2pads(firstPoint)]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t<!-- check if a token walks over a relevant pad -->\n\t\t[pathPadList \t\t\t= bot_path2pads(Path)]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t<!-- if the list is build traditionally -->\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']\n\n<!-- SPECIAL AREAS -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n<!-- LINKED PADS @@@ NOT WORKING FOR MULTIPLE TOKENS MOVE-->\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h:doLinkedPads\t\t\t\t= if(!json.isEmpty(linkedPads),1,0)]\n[h,if(doLinkedPads), CODE:{\n\t[lastLinkId\t\t\t\t= getLibProperty(\"lastLinkId\",\"lib:EventMacros\")]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[actList\t\t\t\t= \"startLinkId=;endLinkId=\"]\n\t[foreach(id, linkedIdList): actList = setStrProp(actList, \"activated\"+id, 0)]\n};{}]\n\n<!-- retrieve current location of token-->\n<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->\n[h:numToks = listCount(toks)-1]\n[h,foreach(tok, toks), CODE:{\n\t<!-- /@@MULTIPLE TOKEN MOVE SPECIFIC CODE-->\n\t[h:doAbort\t\t\t\t\t= if(roll.count == numToks, 0,1)]\n\t[h:switchToken(tok)]\n\t[h:lastPath\t\t\t\t\t= eval(\"lastPath\"+roll.count)]\n\t[h:tok\t\t\t\t\t\t= eval(\"tok\"+roll.count)]\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\t[h:startingLocation\t\t\t= eval(\"startingLocation\"+roll.count)]\n\t[h:currentLocation\t\t\t= eval(\"currentLocation\"+roll.count)]\n\t<!-- reset all linkedpad variables for every token -->\n\t[h,if(doLinkedPads):varsFromStrProp(actList)]\n\n\t<!-- handle SPECIAL AREAS -->\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks,\"<br>\"):bot_EventArea()]\n\n\t<!-- handle all starting position pads-->\n\t[h,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all Path related pads-->\n\t[h,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all ending position pads-->\n\t[h,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\n\t<!-- execute a linked event from the settings -->\n\t[h, if(eventMacroPostMultipleTokensMove != \"<none>\"), CODE:{[macro(eventMacroPostMultipleTokensMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads)):setLibProperty(\"lastLinkId\", endLinkId, \"lib:EventMacros\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d0690702-c22c-4043-a7fc-a2e2237df40e",
          "commandChecksum": "0e91037cea8264951b9af9f1e26060a5",
          "propsChecksum": "cfaf1fdb72500d0294a50f991a65a1ad"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "3",
        "index": 206,
        "label": "deferOnTokenMove",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------ deferOnTokenMove - this macro is run automatically if ONE token is moved ---------------------------- -->']\n[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']\n<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->\n<!-- VARS: tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,doShowPath, doSnap2Grid -->\n[h: vars\t\t\t\t= arg(0)]\n[h: varsFromStrProp(vars)]\n[h: switchToken(tok)]\n\n<!-- define the following vars:  doGroups,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,doInvisibility,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,doVBLStamp -->\n[h: varsFromStrProp(arg(1))]\n\n<!-- group movement -->\n[h,if(doGroups && startsWith(token.label,\"group\")), CODE:{\n\t[groupName\t\t\t= token.label]\n\t[startingLocation\t= json.toList(json.get(lastPath,0,0))]\n\t[currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[xDiff\t\t\t\t= json.get(currentLocation, \"x\") - json.get(startingLocation, \"x\")]\n\t[yDiff\t\t\t\t= json.get(currentLocation, \"y\") - json.get(startingLocation, \"y\")]\n\t[tokList\t\t\t= getProperty(\"w42.boT.\"+token.label)]\n\t[foreach(tmpTok,tokList), CODE:{\n\t\t[token(tmpTok), if(findToken(tmpTok) != \"\"):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]\n\t}]\n}]\n\n<!-- AMs VBL Checker -->\n[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]\n\n<!-- Invisibility Purge -->\n[h,if(doInvisibility):bot_checkInvisibility()]\n\n<!-- snap to grid option -->\n[h,if(doSnap2Grid):bot_snapToGrid(tokId)]\n\n<!-- Align VBL Stamps with moved token-->\n[h: doVBLStamp = if(doVBLStamp && json.type(getProperty(\"w42.bot.fgVBL\"))==\"ARRAY\", 1, 0)]\n[h,if(doVBLStamp), CODE:{\n\t<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->\n\t<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->\n\t<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->\n\t[bot_moveStamp(tok)]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n<!-- put small feet in the moved path -->\n[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]\n\n<!-- follow me tokens -->\n[h:'[h,if(1):bot_followMe(tok,lastPath)]']\n\n<!-- abort if special pads are turned off -->\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = \"Canopy 12\" -->\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t\n\t<!-- if token has not moved but just \"wobbled\" there will be 1 coordinate == listSize(2) abort in this case -->\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\t\n\n\t<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->\n\t<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path -->\n\t<!-- this macro also runs pathPadList = bot_path2pads(json.get(lastPPath,1,-2)), which needs to be rebuild is !clear -->\n\n\t\n\t\n\t\n\t\n\t\n\t\t[if(!oneStepOnly && doInnerPointsPath):\tbot_chkMoveStop(); pathPadList = \"\"]\n\t\t<!-- added clear = 0 as its clearly not initialized. Need more infor on clear as its unclear what it does... god the pun... -->\n\t\t[if(oneStepOnly):\tclear = 1 ; clear = 0]\n\n\t\t\n\t[lastPointPadList\t\t= bot_path2pads(json.get(lastPPath,-1,-1))]\n\n\t\n\t<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START OR MIDDLE. End is checked for all!! -->\n\t[if(doFirstPointPath), CODE:{\n\t\t<!-- check if token is on a relevant token when leaving -->\n\t\t[firstPointPadList\t\t= bot_path2pads(json.get(lastPPath,0,0))]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t<!-- check if a token walks over a relevant pad -->\n\t\t[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t<!-- if the list is build traditionally -->\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']\n\n<!-- SPECIAL AREAS -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n<!-- LINKED PADS -->\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h,if(!json.isEmpty(linkedPads)), CODE:{\n\t[lastLinkId\t\t\t\t= getLibProperty(\"lastLinkId\",\"lib:EventMacros\")]\n\t[startLinkId\t\t\t= \"\"]\n\t[endLinkId\t\t\t\t= \"\"]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[foreach(id, linkedIdList): set(\"activated\"+id, 0)]\n};{}]\n\n<!-- retrieve current location of token, if the token has not actually moved abort if that toggle is turned off in the settings-->\n[h:resetMove\t\t\t\t\t= 0]\n\t\n\n\t\n\t\n\n\t\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\n\t<!-- handle SPECIAL AREAS -->\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks): bot_EventArea()]\n\t<!-- handle all starting position pads-->\n\t[r,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all Path related pads-->\n\t[r,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all ending position pads-->\n\t[r,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- Centre of Token -->\n\t[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]\n\t<!-- execute a linked event from the settings -->\n\t[h,if(eventMacroPostTokenMove != \"<none>\"), CODE:{[macro(eventMacroPostTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads)):setLibProperty(\"lastLinkId\", endLinkId, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ab97f7d9-5f4d-4a27-9bd4-205baab0ddba",
          "commandChecksum": "0daeb0bb2df2756ce1ac562aa587d4ca",
          "propsChecksum": "f9265cc03c5656f8f128cff24592077d"
        }
      },
            {
        "autoExecute": true,
        "color": "silver",
        "fontColor": "red",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "3",
        "index": 207,
        "label": "deferOnTokenMove TMP",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- deferOnTokenMove - this macro is run automatically if ONE token is moved -->']\n[h:'<!-- -----------------------------------INITIALIZE-----------------------------------------------']\n<!-- The reason for the strange layout of this code is so that it aligns with onMultipleOntokenmove, which makes it easier to compare the two codes-->\n<!-- VARS: tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,doShowPath -->\n[h: vars\t\t\t\t= arg(0)]\n[h: varsFromStrProp(vars)]\n<!-- @@@@This is a work around due to a varsfromstrpop bug where in case of e.g. an id 000010000 is truncated to 100000 -->\n[h: tokId\t= string(getStrProp(vars, \"tokId\"))]\n\n[h: switchToken(tok)]\n\n<!-- define the following vars:  doGroups,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok,doSpecialPads,doFirstPointPath,doInnerPointsPath,limitMovement,eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,doVBLStamp -->\n[h: varsFromStrProp(arg(1))]\n\n<!-- group movement -->\n[h,if(doGroups && startsWith(token.label,\"group\")), CODE:{\n\t[groupName\t\t\t= token.label]\n\t[startingLocation\t= json.toList(json.get(lastPath,0,0))]\n\t[currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[xDiff\t\t\t\t= json.get(currentLocation, \"x\") - json.get(startingLocation, \"x\")]\n\t[yDiff\t\t\t\t= json.get(currentLocation, \"y\") - json.get(startingLocation, \"y\")]\n\t[tokList\t\t\t= getProperty(\"w42.boT.\"+token.label)]\n\t[foreach(tmpTok,tokList), CODE:{\n\t\t[token(tmpTok), if(findToken(tmpTok) != \"\"):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]\n\t}]\n}]\n\n<!-- execute a linked event from the settings -->\n[r, if(eventMacroOnTokenMove != \"<none>\"), CODE:{[macro(eventMacroOnTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok)]}; {}]\n\n<!-- AMs VBL Checker -->\n[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]\n\n<!-- Align VBL Stamps with moved token-->\n[h: doVBLStamp = if(doVBLStamp && json.type(getProperty(\"w42.bot.fgVBL\"))==\"ARRAY\", 1, 0)]\n[h,if(doVBLStamp), CODE:{\n\t<!-- any token with the label VBLStamp will have a VBL cross that moves with the token -->\n\t<!-- if a VBL cross is already there, remove it first (its params are stored on the token) -->\n\t<!-- createVBL defines x, y,etc. and vblPresent is its stored on token -->\n\t[bot_moveStamp(tok)]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n<!-- put small feet in the moved path -->\n[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]\n\n<!-- abort if special pads are turned off -->\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t<!-- turn all mapped coordinates of the special tokens into active variables e.g. X1Y5 = \"Canopy 12\" -->\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t\n\t<!-- if token has not moved but just \"wobbled\" there will be 1 coordinate == listSize(2) abort in this case -->\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\t\n\n\t<!-- GET THE PADS OVER WHICH THE TOKEN MOVED, START, MIDDLE AND END -->\n\t<!-- if the token walks over a pad that stops it in its path, then discard the remainder of the path -->\n\t<!-- this macro also runs pathPadList = bot_path2pads(json.get(lastPPath,1,-2)), which needs to be rebuild is !clear -->\n\n\t\n\t\n\t\n\t\n\t\n\t\t[if(!oneStepOnly && doInnerPointsPath):\tbot_chkMoveStop(); pathPadList = \"\"]\n\t\t<!-- added clear = 0 as its clearly not initialized. Need more infor on clear as its unclear what it does... god the pun... -->\n\t\t[if(oneStepOnly):\tclear = 1 ; clear = 0]\n\n\t\t\n\t[lastPointPadList\t\t= bot_path2pads(json.get(lastPPath,-1,-1))]\n\n\t\n\t<!-- FILTER OUT ONLY THOSE PAD THAT NEEDS TO BE CHECKED FOR EITHER START OR MIDDLE. End is checked for all!! -->\n\t[if(doFirstPointPath), CODE:{\n\t\t<!-- check if token is on a relevant token when leaving -->\n\t\t[firstPointPadList\t\t= bot_path2pads(json.get(lastPPath,0,0))]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t<!-- check if a token walks over a relevant pad -->\n\t\t[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t<!-- if the list is build traditionally -->\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'<!-- -----------------------------------/INITIALIZE------------------------------------------------->']\n\n<!-- SPECIAL AREAS -->\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t<!-- distance per cell e.g. 5ft per cell then walking 2 cells will result in 10 -->\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n<!-- LINKED PADS -->\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h,if(!json.isEmpty(linkedPads)), CODE:{\n\t<!-- lastLinkSettings:\"currentMap=;lastLinkId=\" -->\n\t[lastLinkSettings\t\t= getLibProperty(\"lastLinkSettings\",\"lib:EventMacros\")]\n\t[varsFromStrProp(lastLinkSettings)]\n\t[startLinkId\t\t\t= \"\"]\n\t[endLinkId\t\t\t\t= \"\"]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[if(getCurrentMapName() != currentMap), CODE:{\n\t\t<!-- this routine only takes place when swapping from maps -->\n\t\t[currentMap\t\t\t= getCurrentMapName()]\n\t\t[lastLinkId\t\t\t= \"\"]\n\t\t[lastLinkSettings\t= strPropFromVars(\"currentMap, lastLinkId\",\"UNSUFFIXED\")]\n\t\t[foreach(id, linkedIdList): lastLinkSettings = setStrProp(lastLinkSettings, \"activated\"+id, 0)]\n\t\t<!-- then make sure that the activated variables are defined -->\n\t\t[varsFromStrProp(lastLinkSettings)]\n\t\t<!-- retrieve the variables in the strproplist as a list -->\n\t\t[strPropList\t\t= listAppend(json.fields(json.fromStrProp(lastLinkSettings)), \"strPropList\")]\n\t\t<!-- and add it to the settings -->\n\t\t[lastLinkSettings\t= setStrProp(lastLinkSettings, \"strPropList\", strPropList)]\n\t\t<!-- result: currentMap=BASE ; lastLinkId= ; activated1=0 ; activated2=0 ; activated3=0 ; strPropList=lastLinkId,currentMap,activated1,activated2,activated3 -->\n\t}]\n\t[foreach(id, linkedIdList): set(\"activated\"+id, 0)]\n\t['pause(\"activated1\", \"activated2\", \"linkedIdList\")']\n};{}]\n\n<!-- retrieve current location of token, if the token has not actually moved abort if that toggle is turned off in the settings-->\n[h:resetMove\t\t\t\t\t= 0]\n\t\n\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\n\t<!-- handle SPECIAL AREAS -->\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks): bot_EventArea()]\n\n\t<!-- handle all starting position pads-->\n\t[r,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all Path related pads-->\n\t[r,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- handle all ending position pads-->\n\t[r,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t<!-- Centre of Token -->\n\t[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]\n\t<!-- execute a linked event from the settings -->\n\t[h,if(eventMacroPostTokenMove != \"<none>\"), CODE:{[macro(eventMacroPostTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads) && lastLinkId != endLinkId), CODE:{\n\t\t[lastLinkId\t\t\t= endLinkId]\n\t\t[lastLinkSettings\t= strPropFromVars(strPropList,\"UNSUFFIXED\")]\n\t\t[setLibProperty(\"lastLinkSettings\", lastLinkSettings, \"lib:EventMacros\")]\n\t};{}]\n['pause(\"linkedPads\",\"lastLinkId\",\"startLinkId\",\"endLinkId\",\"lastLinkSettings\",\"strPropList\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cfaaaee3-4f4d-47eb-8f77-f610b1c5a967",
          "commandChecksum": "c1b9530215d882bee711444798396ab9",
          "propsChecksum": "aee9667c053d9415e2edc5e7f59980fc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "10",
        "index": 208,
        "label": "determineTokSize",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------- DETERMINETOKSIZE--------------------------- -->']\n\n[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{\n\t<!-- if new functions are allowed -->\n\t[h:gridSize\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n\t[xtmp\t= getTokenWidth()]\n\t[ytmp\t= getTokenHeight()]\n\n\t<!-- this is used for canopy and in that case its usefull to enlarge it by one cell  -->\n\t[xSize\t= round(xtmp/gridSize) + 1]\n\t[ySize\t= round(ytmp/gridSize) + 1]\n\n\t[setProperty(\"w42.bot.xSize\", xSize,tok)]\n\t[setProperty(\"w42.bot.ySize\", ySize,tok)]\n};{\n\t<!-- if not, it has to be done manually -->\n\t[sizeList = \"Fine=1; Diminutive=1; Tiny=1; Small=1; Medium=1; Large=2; Huge=3; Gargantuan=4; Colossal=6\"]\n\t[xSize = getProperty(\"w42.bot.xSize\",tok)]\n\t[ySize = getProperty(\"w42.bot.ySize\",tok)]\n\n\t<!-- old method -->\n\t[if(xSize == \"\"): xSize = getProperty(\"w42.mtt.xSize\",tok)]\n\t[if(ySize == \"\"): ySize = getProperty(\"w42.mtt.ySize\",tok)]\n\n\t[size = getSize()]\n\t[if(size == \"\"), CODE:{\n\t\t[abort(input(\n\t\t\t\"xSize|\"+xSize+\"|The size of token: \"+tok+\" is unknown, pls enter the width (from left to right) in number of cells\",\n\t\t\t\"ySize|\"+ySize+\"|The size of token: \"+tok+\" is unknown, pls enter the length (from top to bottom) in number of cells\"\n\t\t))]\t\t\n\t}; {\n\t\t[xSize = getStrProp(sizeList, size, \"\")]\n\t\t[ySize = getStrProp(sizeList, size, \"\")]\n\t}]\n\n\t[setProperty(\"w42.bot.xSize\", xSize,tok)]\n\t[setProperty(\"w42.bot.ySize\", ySize,tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "83ad5795-135f-42ba-87ef-fdb5ac0cbc30",
          "commandChecksum": "3546c02d35b7ea631ad31b041ecb25ab",
          "propsChecksum": "c84603ac57b226b893fdc1c83ebbc449"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "7",
        "index": 209,
        "label": "initializeMap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------------- initializeMap ([initialize]) --------------------------------------------------------------- -->']\n\n[h,if(argCount() > 0): initialize\t= arg(0) ; initialize = 0]\n\n[h,if(!initialize), CODE:{\n\t[currentMap\t\t\t= getCurrentMapName()]\n\t[padNameList \t\t= getLibProperty(\"padNameList\", \"lib:EventMacros\")]\n\t[numericIdOnly\t\t= getLibProperty(\"numericIdOnly\", \"lib:EventMacros\")]\n\t[doCanopy\t\t\t= 0]\n\t[interPadCheckList\t= \"{}\"]\n\t[txtOutPut\t\t\t= \"<u>Found the following special pads:<br><\/u>\"]\n};{}]\n\n[h:linkedList\t\t= \"\"]\n[h:linkedPadList\t= \"\"]\n[h:padCounter.json\t= '{}']\n[h:tokenList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\n<!-- check if this map is alt. initialized. If so warn the user to either exclude this map in the settings of remove the lib:coords -->\n[h: libCoordName\t= strformat(\"lib:Coords %{currentMap}\")]\n[h: error\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h,if(error): txtOutPut\t= txtOutPut + \"<font color='red'>Error: <u>\"+libCoordName+\"<\/u> found on map \"+currentMap+\". This means that the alternative initialization method is used for this map and that is NOT compatible with the normal initialization. So either:<br>- remove ALL lib:coords from this map (should only be one), which is usually located at coord 0,0. Or<br>- exclude this map from initialization in the settings --> exclusions --> check: <i>\"+currentMap+\"<br><br><\/i><\/font>\"]\n\n<!-- initialize list variables -->\n[h, foreach(padName, padNameList), CODE:{\n\t[set(\"lst\"+padName, \"\")]\n\t[set(\"lstName\"+padName, \"\")]\n}]\n[h:newList\t\t= \"\"]\n[h:canopyList\t= \"\"]\n\n<!-- regex routine done by the_meek; few rewrites by W42\n\t1. create a json.array of ALL tokens on the map\n\t2. Loop through all special pads. Lets take 'PadStart x' as example. Keep in mind that its an array thus \"\",\"\",\"\" and the pad will thus start with \"\n\t3. Matches checks if a search string matches with the string. If it returns 0 then there are no PadStart x on this map so you can skip this in the loop.\n\t4. sort the token array alphabetically in ascending order\n\t5. look for the current padname e.g. 'PadStart 2' \n\t6. remove all items that come before PadStart 2\n\t7. sort in descending order\n\t8. again remove all items that come before Padstart 2\n\t9. what is left are all the 'PadStart' tokens in the list.\n -->\n \n<!-- step 1. -->\n[h: allTokensJson\t= json.fromList(tokenList)]\n[H: cleanTokenJSON\t= \"[]\"]\n\n<!-- step 2. -->\n[H, FOREACH(padName, padNameList), CODE: {\n\t<!-- step 3. .*PadStart .* -->\n\t[tempRegex = '.*\"' + padName + '\\\\s.*']\n\t[IF(matches(allTokensJson, tempRegex)), CODE:{\n\t\t<!-- step 4., 5. and 6. -->\n\t\t[tempRegex\t\t= '\\\\[(.*?)(\"' + padName + '\\\\s.*)']\n\t\t[tempJSON\t\t= replace(json.sort(allTokensJson, \"a\"), tempRegex, '[\\$2')]\n\t\t<!-- step 7. and 8. -->\n\t\t[tempJSON\t\t= replace(json.sort(tempJSON, \"d\"), tempRegex, '[\\$2')]\n\t\t<!-- step 9. ; and add them to cleanTokenJSON -->\n\t\t[cleanTokenJSON\t= json.sort(json.merge(cleanTokenJSON, tempJSON),\"a\")]\n['pause(\"tempJSON\",\"cleanTokenJSON\",\"allTokensJson\", \"PadName\", \"padnamelist\")']\n\t};{}]\n}]\n\n[h:'pause(\"cleanTokenJSON\")']\n[h:tokenList\t= json.toList(cleanTokenJSON)]\n\n[h:numToks\t\t= listCount(tokenList)]\n[h:assert(numToks <= 1000, \"Fatal error: The number (\"+numToks+\") of special pads on map (\"+currentMap+\") is more than 1000. This tool can handle upto 1000 special pads. Please remove \"+(numToks - 1000)+\" pads from \" + currentMap,0)]\n\n[h,foreach(token,tokenList,\"\"), CODE:{\n\t[pos\t= indexOf(token, \" \")]\n\n\t<!-- check if token exists -->\n\t[assert(findToken(token) != \"\", strformat(\"Error (Process aborted): could not find token <u>%{token}<\/u> on the current map. This might happens when you e.g. create a token with a reserverd name as partial string. For example '<b>The<\/b> Roof 1', will result in a token list with 'Roof 1' which does not exist, or when you accidentily use trailing spaces ' ', e.g. 'Roof 1 '. So check the map for this and correct it.\"),0)]\n\t\n\t[isPad\t= 0]\n\t[if(pos != -1), CODE:{\n\t\t[padName\t= substring(token, 0, pos)]\n\t\t[padId\t\t= substring(token, pos)]\n\t\t<!-- if numericId only is checked, then only pads with a number as identifier should be parsed. The rest should be ignored -->\n\t\t[isPad\t\t= if((isNumber(padId) || !numericIdOnly) && listContains(padNameList, padName),1,0)]\n\t}; {\n\t\t<!-- make sure value is initiated cause its used in one of the if statements -->\n\t\t[padName\t= \"\"]\n\t}]\n\t\n\t[if(isPad && startsWith(padName, \"Linked\")), CODE:{\n\t\t<!-- with 'Linked 1 Canopy 2' pads you want to know that this concerns a Canopy pad -->\n\t\t<!-- Linked is a special case that requires a strict format. If this format is NOT met then isPad is set to 0 -->\n\t\t<!-- Linked 1 Roof 2, Match1 Match2 Match3 Match4 -->\n\t\t[regId\t\t= strfind(token, \"[^\\\\s]+\")]\n\t\t[nPieces\t= getFindCount(regId)]\n\t\t[error\t\t= if(nPieces != 4, 1, 0)]\n\t\t[if(error): txtOutPut\t= txtOutPut + \"<font color='red'>Error: <u>\"+token+\"<\/u> found on map \"+currentMap+\" is incorrectly named. A linked pad should ALWAYS consist out of 4 pieces 'Linked ID PadTyp ID', e.g. 'Linked 1 Canopy 2'. This name consists out of \"+nPieces+\" pieces.<br><\/font>\"]\n\t\t[if(error): PadType\t\t= padName ; PadType = getGroup(regId, 3, 0)]\n\t\t[if(error): isPad\t\t= 0]\n\n\t\t<!-- add link id to the list and also create a full list of all linked pads-->\n\t\t[if(!error): linkedList \t= listAppend(linkedList, getGroup(regId, 2, 0))]\n\t\t[if(!error): linkedPadList\t= listAppend(linkedPadList, token)]\n\t}; {\n\t\t[PadType\t= padName]\n\t}]\n\n\t\t\n['pause(\"pos\",\"padName\",\"isPad\",\"padNameList\",\"padName\",\"padId\")']\n\t[if(isPad), CODE:{\n\t\t<!-- this is the main part where the json structure is build from which onTokenMove retrieves its values -->\n\t\t[tmpNum\t\t= padId]\n\t\t[tmpLst\t\t= eval(\"lst\"+padName)]\n\t\t[tmpLstName\t= eval(\"lstName\"+padName)]\n\t\t\n\t\t[if(listContains(tmpLst, tmpNum)): error = 1]\n\t\t[if(listContains(tmpLst, tmpNum)): txtOutPut = txtOutPut + \"<font color='red'>Error: duplicate <u>\"+padName+\" \"+tmpNum+\"<\/u> found on map \"+currentMap+\"<br><\/font>\"]\n\t\t\n\t\t<!-- create two lists, one with numbers only one with the full names-->\n\t\t[set(\"lst\"+padName, listAppend(tmpLst, tmpNum))]\n\t\t[set(\"lstName\"+padName, listAppend(tmpLstName, token))]\n\t}; {}]\n\t\n\t[if(isPad && startsWith(padName, \"Inter\")), CODE:{\n\t\t<!-- interpads must be checked through all the maps: checkInterpads checks if there are 3 interpads with the same number -->\n\t\t[if(bot_inStr(token, \"Drop\")): fullPadName = replace(token,\"Drop\",\"Jump\"); fullPadName \t= token]\n\t\t\n\t\t[bot_checkInterPads()]\n\t\t[if(json.contains(interPadCheckList, fullPadName)):\t\n\t\t\tinterPadCheckList = json.set(interPadCheckList, fullPadName, json.set(json.get(interPadCheckList, fullPadName), \"map2\", currentMap))\n\t\t; \n\t\tinterPadCheckList = json.set(interPadCheckList, fullPadName, json.set('{}', \"map1\", currentMap))\n\t\t]\n\t}; {}]\n\n\t[if(isPad && (padType == \"Canopy\") && doCanopy), CODE:{\n\t\t<!-- canopy needs extra work cause the token handout gets a trunk image assigned -->\n\t\t<!-- get an random asset id of one of the tree trunks -->\n\t\t[treeTrunkkAssetID = listGet(treeTrunkImages, roll(1,numTrunkImages) - 1)]\n\t\t[token(token): handout = getTokenHandout()]\n\t\t[token(token), if(handout == \"\"): setTokenHandout(treeTrunkkAssetID); canopyList = listAppend(canopyList, tmpNum)]\n\t}]\n\n\t[if(isPad && padName == \"Roof\"), CODE:{\n\t\t<!-- extra check for roofs, which should NOT be snapped to grid -->\n\t\t[if(isSnapToGrid(token)): error = 1]\n\t\t[if(isSnapToGrid(token)): txtOutPut = txtOutPut + \"<font color='red'>Error: <u>\"+padName+\" \"+tmpNum+\"<\/u> found on map \"+currentMap+\" is snapped to grid. Make certain its unsnapped<br><\/font>\"]\n\t}]\n['pause(\"cleanTokenJSON\",\"padNameList\", \"padName\", \"token\", \"tokenList\", \"isPad\", \"tmpLstName\")']\n}]\n\n[h, if(listCount(canopyList)): txtOutPut = txtOutPut + \"The following Canopy Pads already had an image in the Token Handout Section. No (new) trunk image has been set for <b><u>Canopy<\/u><\/b> : \"+canopyList+\"<br>\"]\n\n<!-- loop through all the special pads names and generate output to the text -->\n[h:result = \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{currentMap}", "%s", "3", "0", "0"]'>%s<\/a>\"]\n[h, foreach(padName, padNameList,\"\"), CODE:{\n\t<!-- list of numbers of special pads found e.g. 1,2,3,etc-->\n\t[tmpLst = listSort(eval(\"lst\"+padName),\"N+\")]\n\t<!-- list of full padnames e.g. Canopy 1, Canopy 2, etc -->\n\t[tmpLstName = listSort(eval(\"lstName\"+padName),\"N+\")]\n\t\n\t[if(tmpLst != \"\"), CODE:{\n\t\t[txtOutPut = txtOutPut + \"<b>\"+padName+\"<\/b>: \"]\n\t\t[tmpURLList = \"\"]\n\t\t[foreach(pad, tmpLst): tmpURLList\t= listAppend(tmpURLList, strformat(result, padName + \" \" + pad, pad))]\n\t\t[txtOutPut = txtOutPut + tmpURLList + \"<br>\"]\n\t};{}]\n\t<!-- build the json object, add the list of full padnames and their numbers e.g. Canopy 1, Canopy 2, etc. -->\n\t<!-- do not add padDrop and interDrop -->\n\t[isDrop = if(startsWith(padName,\"PadDrop\") || startsWith(padName, \"InterDrop\"), 1, 0)]\n\t[if(!isDrop):padCounter.json = json.set(padCounter.json, padName, tmpLstName)]\n['pause(\"padNameList\", \"padName\", \"padCounter.json\", \"tmpLstName\")']\n}]\n\n<!-- check if there are an equal amount of starting teleports and ending teleports on one map and if the numbers match -->\n[h:startPads= eval(\"lstPadStart\")]\n[h:endPads\t= eval(\"lstPadEnd\")]\n[h:numStart\t= listCount(startPads)]\n[h:numEnd\t= listCount(endPads)]\n\n[h, if(numStart != numEnd), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadStart(\"+numStart+\")<\/b> and <b>PadEnd(\"+numEnd+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, startPads), CODE:{\n\t\t[exists = findToken(\"PadEnd \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadStart \"+pad+\"<\/b> does not have a <b>PadEnd \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, endPads), CODE:{\n\t\t[exists = findToken(\"PadStart \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadEnd \"+pad+\"<\/b> does not have a <b>PadStart \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n<!-- check if there are an equal amount of starting teleport borders and ending teleport borders on one map and if the numbers match -->\n[h:startPadBorders\t= eval(\"lstPadStartBorder\")]\n[h:endPadBorders\t= eval(\"lstPadEndBorder\")]\n[h:numStartBorder\t= listCount(startPadBorders)]\n[h:numEndBorder\t\t= listCount(endPadBorders)]\n\n[h, if(numStart != numEnd), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadStartBorder(\"+numStartBorder+\")<\/b> and <b>PadEndBorder(\"+numEndBorder+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, startPadBorders), CODE:{\n\t\t[exists = findToken(\"PadEndBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadStartBorder \"+pad+\"<\/b> does not have a <b>PadEndBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, endPadBorders), CODE:{\n\t\t[exists = findToken(\"PadStartBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadEndBorder \"+pad+\"<\/b> does not have a <b>PadStartBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n<!-- check if there are an equal amount of jump teleports and drop teleports on one map and if the numbers match -->\n[h:jumpPads\t= eval(\"lstPadJump\")]\n[h:dropPads\t= eval(\"lstPadDrop\")]\n[h:numJump\t= listCount(jumpPads)]\n[h:numDrop\t= listCount(dropPads)]\n\n[h, if(numJump != numDrop), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadJump(\"+numJump+\")<\/b> and <b>PadDrop(\"+numDrop+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, jumpPads), CODE:{\n\t\t[exists = findToken(\"PadDrop \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadJump \"+pad+\"<\/b> does not have a <b>PadDrop \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, dropPads), CODE:{\n\t\t[exists = findToken(\"PadJump \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadDrop \"+pad+\"<\/b> does not have a <b>PadJump \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n[h:jumpBorderPads\t= eval(\"lstPadJumpBorder\")]\n[h:dropBorderPads\t= eval(\"lstPadDropBorder\")]\n[h:numJumpBorder\t= listCount(jumpBorderPads)]\n[h:numDropBorder\t= listCount(dropBorderPads)]\n\n[h, if(numJumpBorder != numDropBorder), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadJumpBorder(\"+numJumpBorder+\")<\/b> and <b>PadDropBorder(\"+numDropBorder+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, JumpBorderPads), CODE:{\n\t\t[exists = findToken(\"PadDropBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadJumpBorder \"+pad+\"<\/b> does not have a <b>PadDropBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, DropBorderPads), CODE:{\n\t\t[exists = findToken(\"PadJumpBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadDropBorder \"+pad+\"<\/b> does not have a <b>PadJumpBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n<!-- process linked lists -->\n[h:linkedJson\t\t= '{}']\n<!-- retrieve all linked pads for this map -->\n[h:allLinksList\t= json.get(padCounter.json, \"Linked\")]\n[h,if(listCount(linkedList)), CODE:{\n\t[foreach(linkId, linkedList), CODE:{\n\t\t[regex\t\t= strformat(\"(?i)([^,]*(Linked %{linkId})[^,]*)\")]\n\t\t[resultList\t= \"\"]\n\t\t[id\t\t\t= strfind(allLinksList, regex)]\n\t\t[numFound\t= getFindCount(id)]\n\t\t[count(numFound):\tresultList\t= listAppend(resultList, getGroup(id, roll.count+1, 0))]\n\t\t[linkedJson\t= json.set(linkedJson, linkId, resultList)]\n\t}]\n};{}]\n\n<!-- set the main json object for this map -->\n[h,if(initialize):newMapsPads\t\t= json.set(newMapsPads, currentMap, padCounter.json)]\n\n<!-- set the linked json object for this map -->\n[h,if(initialize):linkedMappedPads\t= json.set(linkedMappedPads, currentMap, linkedJson)]\n\n[h:'pause(\"newMapsPads\",\"padCounter.json\")']\n[h, if(error): txtOutPut = txtOutPut + \"Error detected, please fix first, else errors will occur on this map (\"+currentMap+\") will work<br>\"; \"No errors detected, pads have been initialized<br>\"]\n\n[h,if(!initialize), CODE:{\n\t<!-- create the frame -->\n\t[frame(\"Special Tokens on \"+currentMap, \"width=300; height=400; temporary=1\"): {\n\t\t<html>\n\t\t\t<head>\n\t\t\t<\/head>\n\t\t\t<body>\n\t\t\t\t<form action='[r:macroLinkText(\"initializeMap@Lib:OnTokenMove\", \"none\")]' method=\"json\">\n\t\t\t\t[r:txtOutPut]\n\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Refresh\"\t>\n\t\t\t<\/form>\n\t\t\t<\/body>\n\t\t<\/html>\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "Show overview of special pads on map",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "117598cb-ac6d-4e41-a688-5e12e9af237b",
          "commandChecksum": "7f7f058f7f4f7a209b1202d297f3be86",
          "propsChecksum": "31b0aba9a88cbe2f662da158805ec73f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "6",
        "index": 210,
        "label": "initializePads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------- initializePads --------------------------------->']\n<!-- 3 CODE LEVELS -->\n[h, if(argCount()):passResult = arg(0); passResult = 0]\n[h:mapList\t\t\t= getAllMapNames(\"json\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:'<!-- make certain that ward and eventpad are dealt with first!! -->']\n[h:padNameList \t\t= getLibProperty(\"padNameList\", \"lib:EventMacros\")]\n[h:newMapsPads\t\t= '{}']\n[h:allMappedPads\t= '{}']\n[h:linkedMappedPads\t= '{}']\n<!-- reset the lastlinksettings so the linke activepads are rebuild when ontokenmove is used -->\n[h:setLibProperty(\"lastLinkSettings\", \"currentMap=;lastLinkId=\", \"lib:EventMacros\")]\n[h:txtOutput\t\t= \"<b><u><font color='red'>INITIALIZE PADS<\/font><\/u><\/b><br><br>\"]\n[h:interPadCheckList= \"{}\"]\n[h:treeTrunkImages\t= getLibProperty(\"treeTrunkImages\", \"lib:EventMacros\")]\n[h:numTrunkImages\t= listCount(treeTrunkImages)]\n[h:doCanopy\t\t\t= 0]\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:numericIdOnly\t= getLibProperty(\"numericIdOnly\", \"lib:EventMacros\")]\n\n<!-- doSwitchInterMap (if set to 2 then store x/y coords of interpads on eachother)-->\n[h:toggles\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:tmpList\t\t\t= json.toList(mapList)]\n[h, if(listContains(tmpList, baseMapName)), CODE:{\n\t[h, if(numTrunkImages), CODE:{\n\t\t[txtOutput\t= txtOutput  + \"'Trunk' images have been found and are initialized<br>\"] \n\t\t[doCanopy\t= 1]\n\t}; {\n\t\t[txtOutput\t= txtOutput  + \"<font color='red'><b>No 'Trunk' images have been set (Run 'Choose Trunks' do so), so 'Canopy Tokens' will not be initialized!<\/b><\/font><br>\"]\n\t}]\n}; {\n\t[txtOutput\t= txtOutput  + \"<b><font color='red'>No map called \"+ baseMapName +\" found, so 'Canopy Tokens' will not be initialized! Also the Token Buttons (door switches) wont work correctly (you can set the correct name in the settings.)<\/b><\/font><br>\"]\n}]\n\n[h:'<!-- check all tokens on all maps -->']\n[h:excludedMaps\t= getLibProperty(\"excludedMaps\", \"lib:EventMacros\")]\n[h:txtOutput\t= txtOutput  + \"The following maps will not be initialized (see settings): <b><u>\"+json.toList(excludedMaps)+\"<\/b><\/u><br><br>\"]\t\n[H:activeMaps\t= json.difference(mapList,excludedMaps)]\n\n[H,foreach(currentMap,activeMaps), CODE:{\n<!-- 3 CODE LEVELS -->\n\t[setCurrentMap(currentMap)]\n\t[txtOutput\t\t= txtOutput  + \"<b><u>\"+currentMap+\"<\/b><\/u.<br>\"]\t\n\t[bot_initializeMap(1)]\n\t\n\t<!-- initializeMappedPads -->\n\t[allMappedPads\t= json.set(allMappedPads, currentMap, lstMappedPad)]\n\t[txtOutput\t\t= txtOutput  + \"<br>\"]\t\n\t\n\t<!-- linked id are all added resulting in e.g. 1,1,1,2,2,2,3,3,3 change into 1,2,3 -->\n\t[h:linkedList\t= json.toList(json.unique(json.fromList(linkedList)))]\n\t\n\t<!-- reset any properties concerning linked pads on the tokens -->\n\t[h,foreach(tok,tokenList,\"\"), CODE:{\n\t\t[resetProperty(\"w42.bot.linked\",\t\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedBridge\",\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedTunnel\",\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedSpecial\",\ttok)]\n\t''\n\t}]\n\t\n\t<!-- initialize Linked Pads -->\n\t<!-- create list per linked type -->\n\t[h,foreach(linkId, linkedList), CODE:{\n\t\t[linkedAll\t\t= \"\"]\n\t\t[linkedBridge\t= \"\"]\n\t\t[linkedTunnel\t= \"\"]\n\t\t[linkedSpecial\t= \"\"]\n\t\t\n\t\t[foreach(pad, linkedPadList), if(startsWith(pad, \"Linked \"+linkId)), CODE:{\n\t\t\t[linkedAll\t\t= listAppend(linkedAll, pad)]\n\t\t\t[if(bot_inStr(pad, \"Bridge\")):\tlinkedBridge\t= listAppend(linkedBridge, pad)]\n\t\t\t[if(bot_inStr(pad, \"Tunnel\")):\tlinkedTunnel\t= listAppend(linkedTunnel, pad)]\n\t\t\t<!-- for now only work for roof, canopy and foliage. Ignore the rest -->\n\t\t\t[PadType\t= getGroup(strfind(pad, \"[^\\\\s]+\"), 3, 0)]\n\t\t\t[if(listContains(\"roof, canopy, foliage\", PadType)):\tlinkedSpecial\t= listAppend(linkedSpecial, pad)]\n\t\t''\n\t\t};{}]\n\t\t[set(\"linkedAll\"\t\t+ linkId, linkedAll)]\n\t\t[set(\"linkedBridge\"\t\t+ linkId, linkedBridge)]\n\t\t[set(\"linkedTunnel\"\t\t+ linkId, linkedTunnel)]\n\t\t[set(\"linkedSpecial\"\t+ linkId, linkedSpecial)]\n\t''\n\t}]\n\t<!-- assign entire linked type to each linked token -->\n\t[h,foreach(linkId, linkedList), CODE:{\n\t\t[linkedAll\t\t= eval(\"linkedAll\"\t\t+linkId)]\n\t\t[linkedBridge\t= eval(\"linkedBridge\"\t+linkId)]\n\t\t[linkedTunnel\t= eval(\"linkedTunnel\"\t+linkId)]\n\t\t[linkedSpecial\t= eval(\"linkedSpecial\"\t+linkId)]\n\t\t\n\t\t[foreach(pad, linkedPadList), if(startsWith(pad, \"Linked \"+linkId)), CODE:{\n\t\t\t[setProperty(\"w42.bot.linked\",\t\t\tlinkedAll, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedBridge\",\tlinkedBridge, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedTunnel\",\tlinkedTunnel, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedSpecial\",\tlinkedSpecial, pad)]\n\t\t''\n\t\t};{}]\n\t''\n\t}]\n''\n}]\n\n[h:'<!-- initializeInterPads -->']\n[h, foreach(pad, interPadCheckList), CODE:{\n\t[padMaps\t\t= json.get(interPadCheckList, pad)]\n\t[if(json.contains(padMaps, \"map1\")), CODE:{\n\t\t[map1\t\t= 1]\n\t\t[mapName1 = json.get(padMaps, \"map1\")]\n\t''\n\t};{[map1\t\t= 0][error\t= 1]}]\n\n\t[if(json.contains(padMaps, \"map2\")), CODE:{\n\t\t[map2\t\t= 1]\n\t\t[mapName2\t= json.get(padMaps, \"map2\")]\n\t''\n\t};{[map2\t\t= 0][error\t= 1]}]\n['if(!map1 || !map2):pause(\"map1\",\"map2\",\"pad\",\"interPadCheckList\",\"mapName1\",\"mapName2\", \"padMaps\")']\n\t[if(!map1): txtOutPut\t= txtOutPut + \"<font color='red'>Error: found only one <u>\"+pad+\"<\/u> on map \" + mapName2 + \"<br><\/font>\"]\n\t[if(!map2): txtOutPut\t= txtOutPut + \"<font color='red'>Error: found only one <u>\"+pad+\"<\/u> on map \" + mapName1 + \"<br><\/font>\"]\n\n\t[if(map1 && map2 && doSwitchInterMap == 2), CODE:{\n\t\t[if(startsWith(pad, \"InterJump\")): pad = replace(pad, \"Jump\", \"Drop\")]\n\t\t<!-- doSwitchInterMap (if set to 2 then store x/y coords of interpads on eachother)-->\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[x1\t= getTokenX(0,pad)]\n\t\t\t[y1\t= getTokenY(0,pad)]\n\t\t\t<!-- get the width and height of the pad in grid cell coords (so not in Pixels per cell) -->\n\t\t\t[wX\t= getTokenWidth(pad)]\n\t\t\t[w1\t= bot_ppc2GridCoord(wX)]\n\t\t\t[h1\t= bot_ppc2GridCoord(getTokenHeight(pad))]\n\t\t''\n\t\t};{[x1=0][y1=0][w1=0][h1=0] <!-- required for interjump/drop where one pad is not registered -->}]\n\n\t\t[setCurrentMap(mapName2)]\n\t\t[if(startsWith(pad, \"InterDrop\")): pad = replace(pad, \"Drop\", \"Jump\")]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[setProperty(\"w42.bot.pairedMap\", mapName1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadX\", x1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadY\", y1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadW\", w1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadH\", h1, pad)]\n\t\t\t[x2\t= getTokenX(0,pad)]\n\t\t\t[y2\t= getTokenY(0,pad)]\n\t\t\t[w2\t= bot_ppc2GridCoord(getTokenWidth(pad))]\n\t\t\t[h2\t= bot_ppc2GridCoord(getTokenHeight(pad))]\n\t\t''\n\t\t};{[x2=0][y2=0][w2=0][h2=0] <!-- required for interjump/drop where one pad is not registered -->}]\n\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[setProperty(\"w42.bot.pairedMap\", mapName2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadX\", x2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadY\", y2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadW\", w2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadH\", h2, pad)]\n\t\t''\n\t\t};{}]\n\t''\n\t};{}]\n\t\n\t[if(map1 && map2 && doSwitchInterMap != 2), CODE:{\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"):setProperty(\"w42.bot.pairedMap\", mapName2, pad)]\n\t\t[setCurrentMap(mapName2)]\n\t\t[if(findToken(pad) != \"\"):setProperty(\"w42.bot.pairedMap\", mapName1, pad)]\n\t''\n\t};{}]\n}]\n\n[h:'<!-- initializeMappedPads -->']\n<!-- build input string (allMappedPads contains all the mappedPads)-->\n[h,FOREACH(mapJSON, allMappedPads), CODE:{\n\t[setCurrentMap(mapJSON)]\n\t[lstMapped\t= json.get(allMappedPads, mapJSON)]\n\t<!-- get user input -->\n\t[inputStr\t= \"[]\"]\n\t[inputStr\t= json.append(inputStr,\"junk|<html><b>Map the pads for map: \"+mapJSON+\"<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t= json.append(inputStr,\"junk|<html><b>enter numbers or dicerolls only!!<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[foreach(iMap, lstMapped), CODE:{\n\t\t[MappedPad\t= getProperty(\"w42.bot.MappedPad\", \"MappedPad \"+iMap)]\n\t\t[inputStr\t= json.append(inputStr, \"MappedPad\"+iMap+\"|\"+MappedPad+\"|Link MappedPad \"+iMap+\" to which other MappedPad\")]\n\t}]\n\t[if(lstMapped != \"\"):hasInput = abort(input(json.toList(inputStr,\"##\")))]\n\t<!-- store the chosen values onto the pads -->\n\t[foreach(iMap, lstMapped):\tsetProperty(\"w42.bot.MappedPad\", eval(\"MappedPad\"+iMap), \"MappedPad \"+iMap)]\n}]\n[h:'<!-- return to original map and set the lib token var -->']\n[h:setCurrentMap(oldMap)]\n\n[h:'<!-- optimize the lists per map for fast processing on onTokenMove, this will destroy the json structure per padtype and makes lists from them -->']\n[h:'<!-- newMapsPads is the entire json structure -->']\n[h:oldMapsPads\t= newMapsPads]\n[h,FOREACH(mapJSONKey, oldMapsPads), CODE:{\n\t[pathPadList\t= \"\"]\n\t[mapJSON\t\t= json.get(oldMapsPads, mapJSONKey)]\n\t[foreach(padType, padNameList), CODE:{\n\t\t[tmpList\t= json.get(mapJSON, padType)]\n\t\t[if(tmpList != \"\"): pathPadList\t= listAppend(pathPadList, tmpList)]\n\t}]\n\t[newMapsPads\t= json.set(newMapsPads, mapJSONKey, pathPadList)]\n}]\n[h:'pause(\"newMapsPads\",\"oldMapsPads\")']\n[h:'<!-- if the initialize is run onCampaignLoad, it must only be set on the map where the lib token is currently situated, thus pass the result instead of setting it -->']\n[h, if(passResult), CODE:{\n\t[macro.return = newMapsPads]\n};{\n\t[setLibProperty(\"allMapsPads\", newMapsPads,\"lib:EventMacros\")]\n\t[setLibProperty(\"allMapsPadsJson\", oldMapsPads,\"lib:EventMacros\")]\n\t[setLibProperty(\"linkedMappedPads\", linkedMappedPads,\"lib:EventMacros\")]\n}]\n\n[r,if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Initialization result\",\"input=1\")\t:{[r:txtOutPut]}]\n};{\n\t[r,frame(\"Initialization result\")\t\t\t\t:{[r:txtOutPut]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "16eaa1a2-dd8c-4270-aa4b-0c32b8271233",
          "commandChecksum": "c8d693e0a97d56a871e98255f6a251af",
          "propsChecksum": "cc7643170b53ce57c7b0ba9cca0de67d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "15",
        "index": 211,
        "label": "moveVBLToken",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------- moveVBLToken ---------------------------------------->']\n<!-- NO NEW SCOPE -->\n[H: id = arg(0)]\n[H: path = arg(1)]\n[H: switchToken(id)]\n[H: pathLength = json.length(path)]\n[H: hasVision = if(isPC(),1,0)]\n<!-- Calc Size and center of token -->\n<!-- Test FreeSize and make sure it works correctly -->\n[H: tokenSizes = json.append(\"\",\"Medium\",\"Large\",\"Huge\",\"Gargantuan\",\"FreeSize\",\"Colossal\")]\n[H: tokenSizeMod = max(1,json.indexOf(tokenSizes,getSize(id))+1)]\n[H: gridSize = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]\n[H: sizeInPixels = gridSize * tokenSizeMod]\n[H: offset = round(sizeInPixels/2)]\n\n<!-- Move token to first position -->\n[H: firstPosition = json.get(path,0)]\n[H: x = json.get(firstPosition,\"x\")]\n[H: y = json.get(firstPosition,\"y\")]\n[H: moveToken(x,y,1,id)]\n\n<!-- Check if map clears soft fog on move -->\n[H: clearSoftFog = doResetFoW]\n\n<!-- loop through each step to verify it can be seen -->\n[H: canSee = 1]\n[H: counter = 0]\n[H: movementStopped = -1]\n[H, while(canSee && movementStopped), code: {\n   [H, if(counter < pathLength): next = json.get(path,counter)]\n   [H: x = json.get(next,\"x\")]\n   [H: y = json.get(next,\"y\")]\n   [H: canSee = isVisible(x+offset,y+offset)]\n   [H, if(canSee), code: {\n      [H: moveToken(x,y,1,id)]\n      [H, if(hasVision): exposeFOW()]\n   }; {\n      [H, if(counter < pathLength): movementStopped = counter]\n   }]\n   [H, if(counter >= pathLength): canSee = 0]\n   [H: counter = counter + 1]\n}]\n\n<!-- Check to teleport token to last position for GM move -->\n[H: tport = 0]\n[H: hasInput = 0]\n[H, if(isGM() && movementStopped >= 0 && isPC()): hasInput = input(\n\tstrformat(\"header|<html><font size=+3><b>%s<\/b><\/font><\/html> %s||LABEL|SPAN=TRUE ICON=TRUE\",getName(),getTokenImage()),\n\tstrformat(\"tip|<html><HR /><font size=+2 color=blue><b>        Movement was stopped at step %{movementStopped}        <\/b><\/font><HR /><BR /><\/html>||LABEL|SPAN=TRUE\"),\n\t\"tport|<html><font size=+1 color=red><b>NO<\/b><\/font>                                                            <\/html>,<html><font size=+1 color=green><b>YES<\/b><\/font><\/html>|<html><font size=+1><b>T-port to final position?<\/b><\/html>|RADIO|ORIENT=H SELECT=1\",\n\tstrformat(\"clearSoftFog|<html><font size=+1 color=red><b>NO<\/b><\/font>                                                            <\/html>,<html><font size=+1 color=green><b>YES<\/b><\/font><\/html>|<html><font size=+1><b>Clear Soft Fog on T-port?<\/b><\/html>|RADIO|ORIENT=H SELECT=%{clearSoftFog}\")\n)]\n[H, if(tport && hasInput && isPC()), code: {\n   [H: lastPosition = json.get(path,pathLength-1)]\n   [H: x = json.get(lastPosition,\"x\")]\n   [H: y = json.get(lastPosition,\"y\")]\n   [H: moveToken(x,y,1,id)]\n   [H, if(hasVision), code: {\n      [H, if(clearSoftFog): exposePCOnlyArea(); exposeFOW()]\n   }; {}]\n}; {\n    [H, if(isNPC() && isGM()), code: {\n      <!-- Force NPCs to final location -->\n      [H: lastPosition = json.get(path,pathLength-1)]\n      [H: x = json.get(lastPosition,\"x\")]\n      [H: y = json.get(lastPosition,\"y\")]\n      [H: moveToken(x,y,1,id)]\n   }; {}]\n   [H, if(clearSoftFog && isPC() && hasVision): exposePCOnlyArea()]\n}]\n\n[H, if(movementStopped != -1 && ! isGM()): broadcast(\"<b>Movement stopped by VBL.  Try using [spacebar] to set way points.  You can not clip corners.<\/b>\")]\n\n<!-- This is needed to override the tokens.denyMove when using moveToken (draw order problem) -->\n[H: z = eval(\"0\"+getProperty(\"elevation\"))]\n<!-- set draw order based on x, y, z and token size -->\n[H: drawOrder = (y + offset) * 1000 + (x + offset) - (tokenSizeMod -1) * gridSize + floor(z/5) * gridSize]\n[H: setTokenDrawOrder(drawOrder,id)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "45329a7a-b9ba-4969-a37f-97a771710e4c",
          "commandChecksum": "d64190e35ffbec77a295f5a7e51e5399",
          "propsChecksum": "28807b58305b029c4682b0b7754d9669"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "2",
        "index": 212,
        "label": "onMultipleTokensMove",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------- onMultipleTokenMove - this macro is run automatically if ONE token is moved ---------------------------------------------- -->']\n[h: toks \t\t\t\t= macro.args]\n[h: tok\t\t\t\t\t= getName(json.get(toks, 0))]\n\n[h:'<!-- retrieve: movementLock, doVBLCheck, doSwitchInterMap, doScaleTeleport, roofHaloColor, doResetFoW -->']\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:'<!-- execute a linked event from the settings -->']\n[h, if(eventMacroPreTokenMove != \"<none>\"), CODE:{[macro(eventMacroPreTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, getLastpath(0), getLastpath(1))]}; {}]\n\n[h:'<!-- check Lock if Lock Movement is on tokens.denymove does not work cause then all the tokens are moved back.-->']\n[h,if(doLockMovement), CODE:{\n\t[tmpToks\t= \"[]\"]\n\t[foreach(id, toks), CODE:{\n\t\t[token(id),if(getProperty(\"w42.bot.lockMovement\", id)==1): moveToken(json.get(json.get(getLastPath(), 0),\"x\"), json.get(json.get(getLastPath(), 0),\"y\"))]\n\t\t[if(getProperty(\"w42.bot.lockMovement\", id)!=1):tmpToks\t= json.append(tmpToks, id)]\n\t}]\n\t[toks\t= tmpToks]\n};{}]\n\n[h:'<!-- abort if a special pad was moved (only check first token) -->']\n[h: abort(!listContains(excludePropertyTypes, getPropertyType(tok)))]\n\n[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']\n[h: map\t\t\t\t\t= getCurrentMapName()]\n[h: libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h: isAltInit\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h: doAbort\t\t\t\t= 0]\n\n[h:'<!-- buld a list of variables that contains the path info for each token -->']\n[h: arguments \t\t\t= strPropFromVars(\"toks,map,libCoordName,isAltInit,doAbort\",\"UNSUFFIXED\")]\n[h,foreach(tok, toks, \"\"), CODE:{\n\t[h: switchToken(tok)]\n\t[h: lastPath \t\t= getLastPath(1)]\n\t[h: startingLocation= json.toList(json.get(lastPath,0,0))]\n\t[h: currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[h:\tusedMove\t\t= getMoveCount()]\n\n\t[h: set(\"tok\"\t\t\t\t+roll.count, getName(tok))]\n\t[h: set(\"lastPath\"\t\t\t+roll.count, lastPath)]\n\t[h: set(\"startingLocation\"\t+roll.count, startingLocation)]\n\t[h: set(\"currentLocation\"\t+roll.count, currentLocation)]\n\t[h: set(\"usedMove\"\t\t\t+roll.count, usedMove)]\n\n\t<!-- @@@HACK TO FIX BUG NEEDS CLOSER LOOK -->\n\t[h:lastPPath\t\t= getLastPath(0)]\n\t\n\t[h, if(isAltInit): \n\t\tset(\"lastPPath\"\t\t\t+roll.count, getLastPath(0))\n\t; \n\t\tset(\"lastPPath\"\t\t\t+roll.count, \"[]\")\n\t]\n\n\t[h: tmpStrprop\t\t= strPropFromVars(strformat(\"tok%{roll.count}, lastPath%{roll.count}, startingLocation%{roll.count}, currentLocation%{roll.count}, usedMove%{roll.count}, lastPPath\"), \"UNSUFFIXED\")]\n\t[h: arguments\t\t= listAppend(arguments, tmpStrProp, \"; \")]\n\t[h:'<!-- movement limiter (uses doAbort) -->']\n\t[h,if(limitMovement !=0):bot_limitMovement()]\n}]\n[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']\n[H, if(doVBLCheck): tokens.denyMove = 1]\n[h, if(movementLock && !isGM() || doAbort), CODE:{\n\t[tokens.denyMove\t= 1]\n\t[if(!doAbort): broadcast(\"<b>Movement is locked by GM.<\/b>\")]\n}; {\n\t<!-- restore FoW, this is also checked in doVBLCheck -->\n\t[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]\n\t[link\t\t\t\t= macroLinkText(\"deferOnMultipleTokensMove@\"+getMacroLocation(),\"none\",json.append(\"\",arguments,toggles))]\n\t[execLink(link,1)]\n\n\t<!-- execute a linked event from the settings -->\n\t[if(eventMacroOnMultipleTokensMove != \"<none>\"), CODE:{[macro(eventMacroOnMultipleTokensMove+\"@Lib:EventMacros\"): json.append(\"\", toks, lastPPath, lastPath)]}; {}]\n\n\n\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c3d242f0-0d48-4e44-b48d-33a7fdc683ad",
          "commandChecksum": "18370bdd5927a91b4b0c63f8f2d19e04",
          "propsChecksum": "1fbee43c21788a82e2e44a1a337dbfda"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "1",
        "index": 213,
        "label": "onTokenMove",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------- ONTOKENMOVE - this macro is run automatically if ONE token is moved ---------------------------------------------- -->']\n[h,if (tokens.moveCount > 1): abort(0)]\n\n[h: tokId\t\t\t\t\t= getSelected()]\n[h:'<!-- retrieve: movementLock, doVBLCheck, doSwitchInterMap, doScaleTeleport, roofHaloColor, doResetFoW -->']\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:'<!-- execute a linked event from the settings -->']\n[h, if(eventMacroPreTokenMove != \"<none>\"), CODE:{[macro(eventMacroPreTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tokId, getLastpath(0), getLastpath(1))]}; {}]\n\n\n[h:'<!-- check Lock if Lock Movement is on -->']\n[h,if(doLockMovement && getProperty(\"w42.bot.lockMovement\")==1), CODE:{\n\t[moveToken(json.get(json.get(getLastPath(), 0),\"x\"), json.get(json.get(getLastPath(), 0),\"y\"))]\n\t[abort(0)]\n};{}]\n\n[h:'<!-- draw area toggle is ON -->']\n[h, if(drawArea), CODE:{\n\t[token(tokId):area\t= getLastPath(1)]\n\t<!-- dont draw the last entry (or the drawing token will get drowned-->\n\t[area\t\t\t= json.get(area, 0,-2)]\n\t[area\t\t\t= json.unique(area)]\n\n\t<!-- remove all coords which already have been drawn -->\n\t[tmpDraWArea\t= getLibProperty(\"tmpDraWArea\", \"lib:EventMacros\")]\n\t[area\t\t\t= json.difference(area, tmpDrawArea)]\n\t<!-- store the new coords in a tmp -->\n\t[setLibProperty(\"tmpDraWArea\", json.union(area, tmpDrawArea), \"lib:EventMacros\")]\n\n\t[layer\t\t\t= getLayer(tokId)]\n\t[areaToken\t\t= getLibProperty(\"drawTokenName\", \"lib:EventMacros\")]\n\t[drawTokenMap\t= getLibProperty(\"drawTokenMap\", \"lib:EventMacros\")]\n\t[drawTokenName\t= getLibProperty(\"drawTokenName\", \"lib:EventMacros\")]\n\t\n\t[assert(!json.isEmpty(area), \"that area contains no coordinates\",0)]\n\t<!-- show all coords in the chat-->\n\t[h:broadcast(\"Area coordinates are: \"+json.indent(area,2))]\n\n\t<!-- put an drawTokenName on each coord for visualisation-->\n\t<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->\n\t[splices\t\t\t= bot_createSplices(area)]\n\t<!-- loop through the splices and copy a token on each coord -->\n\t[foreach(splice, splices, \"\"), CODE:{\n\t\t[foreach(coord, splice, \"\"): lastCopy = copyToken(drawTokenName, 1, drawTokenMap, json.set(coord,\"useDistance\", 1, \"layer\", layer))]\n\t}]\n\t<!-- quit -->\n\t[abort(0)]\n}]\n\n[h:'<!-- abort excluded property type is moved -->']\n[h: abort(!listContains(excludePropertyTypes, getPropertyType(tokId)))]\n\n[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']\n[h: map\t\t\t\t\t= getCurrentMapName()]\n[h: libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h: isAltInit\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h: doAbort\t\t\t\t= 0]\n\n\t[h: lastPath\t\t= getLastPath(1)]\n\t[h: startingLocation= json.toList(json.get(lastPath,0,0))]\n\t[h: currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[h:\tusedMove\t\t= getMoveCount()]\n\n\t[h, if(isAltInit): lastPPath = getLastPath(0); lastPPath = \"[]\"]\n\n\t[h:'<!-- movement limiter (uses doAbort) -->']\n\t[h,if(limitMovement != 0):bot_limitMovement()]\n\n[h:'<!-- when using AMs VBL check, the movement of the tokens need to be reset and the redone with the vblMove macro -->']\n[H, if(doVBLCheck): tokens.denyMove = 1]\n[h, if(movementLock && !isGM() || doAbort), CODE:{\n\t[tokens.denyMove \t= 1]\n\t[if(!doAbort): broadcast(\"<b>Movement is locked by GM.<\/b>\")]\n}; {\n\t<!-- restore FoW, this is also checked in doVBLCheck -->\n\t[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]\n\t[tok\t\t\t\t= getName(tokId)]\n\t[link\t\t\t\t= macroLinkText(\"deferOnTokenMove@\"+getMacroLocation(),\"none\",json.append(\"\",strPropFromVars(\"tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,startingLocation,currentLocation\",\"UNSUFFIXED\"),toggles))]\n\t[execLink(link,1)]\n\n\t<!-- execute a linked event from the settings -->\n\t[if(eventMacroOnTokenMove != \"<none>\"), CODE:{[macro(eventMacroOnTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\n\n\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "35babbc3-5c3f-4548-8fca-85cb7dcf0beb",
          "commandChecksum": "d6bf3b65d6f9b7ddca294438d6277a9b",
          "propsChecksum": "fd1da03a4b4b8a78a6a18d5f45da88d2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2. onTokenMove",
        "includeLabel": false,
        "sortBy": "13",
        "index": 214,
        "label": "path2pads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- PATH2PADS -->']\n<!-- NO NEW SCOPE, IGNORE OUTPUT -->\n<!-- this macro is fed by the path of the token and returns all the pads the token walked over in chronological order -->\n[h:'<!-- turn lastpath, e.g.: [{\"x\":-1,\"y\":0},{\"x\":-1,\"y\":1},{\"x\":-1,\"y\":2}] into an array, with - replaced for _, e.g.: [\"X_1Y0\",\"X_1Y1\",\"X_1Y2\"] -->']\n[h:lastPathJson\t\t= replace(arg(0), '-', '_')]\n[h:lastPathJson\t\t= replace(lastPathJson, '\\\\{\"x\":(.*?),\"y\":(.*?)\\\\}', '\"X\\$1Y\\$2\"') ] \n\n<!-- then extract only the coords from the lastpath where a special pad is mapped -->\n[h:pathIntersect\t= json.intersection(allCoordsArray, lastPathJson)]\n\n[h:'<!-- turn the json arrary path (pathIntersection) into an executable json object e.g. [\"X_1Y0\",\"X_1Y1\",\"X_1Y2\"] into [\"[r:X_1Y0]\",\"[r:X_1Y1]\",\"[r:X_1Y2]\"] -->']\n[h:pathResult\t\t= replace(pathIntersect, \t\t'\"(.*?)\"', '[r:\\$1]')] \n[h:pathResult\t\t= replace(pathResult,\t\t\t'\\\\[\\\\[(.*?)\\\\]\\\\]', '[\"[\\$1]\"]')] \n\n<!-- execute json and filter out any double found special pads -->\n[h:pathResult\t\t= json.evaluate(pathResult)]\n[h:pathResult\t\t= replace(pathResult,\t\t',', '\",\"')]\n[h:macro.return\t\t= json.toList(json.unique(pathResult))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0269ffda-a05c-48e1-ac22-d622c2e8338f",
          "commandChecksum": "dd939accea8690eef9754b53b6d68a4b",
          "propsChecksum": "41bd13589065f094d01b5036d3dd1b58"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "1",
        "index": 215,
        "label": "animateMove",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------- animateMove --------------------------------------------->']\n<!-- animateToken(OPTIONAL: 0.tokenID, 1.x, 2y, 3.relative,4.stopOnImpact(-1:bounce; 0=continue; 1=stop),5.layer(json.object),6.vbl(1; 0),7.delay(ms),8.distance,9.macroName (to run after 1 move),10.macroNameFinal (to run when animation is done),11.degrees rotation, 12.rotation steps, 13.move steps(in pixels, 0=in grid cells), 14.snap token to grid when done   ) -->\n[h, if(argCount()>0):me\t\t\t\t= arg(0); me\t\t\t= getSelected()]\n[h:assert(listCount(me)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(me)]\n[h, if(argCount()>3):relative\t\t= arg(3); relative\t\t= 0]\n[h, if(argCount()>4):stopOnImpact\t= arg(4); stopOnImpact\t= 0]\n[h, if(argCount()>5):layer\t\t\t= arg(5); layer\t\t\t= '[\"token\",\"object\"]']\n[h, if(argCount()>6):vbl\t\t\t= arg(6); vbl\t\t\t= 0]\n[h, if(argCount()>7):delay\t\t\t= arg(7); delay\t\t\t= 0]\n[h, if(argCount()>8):distance\t\t= arg(8); distance\t\t= 0][h:'<!-- set a distance to travel regardless of end postition. -->']\n[h, if(argCount()>9):runMacro\t\t= arg(9); runMacro\t\t= 0] \n[h, if(argCount()>10):runMacroFinal\t= arg(10); runMacroFinal= 0] \n[h, if(argCount()>11):dr\t\t\t= arg(11); dr\t\t\t= 0] \n[h, if(argCount()>12):rStep\t\t\t= arg(12); rStep\t\t= 5] \n[h, if(argCount()>13):dStep\t\t\t= arg(13); dStep\t\t= 0] \n[h, if(argCount()>14):snap2Grid\t\t= arg(14); snap2Grid\t= 0] \n\n[h:'<!-- this arg runs a macro after EVERY move step. With this you can plug in stuff like e.g scan area after move or move other tokens as well. Note that any output of this macro is ignored. Use broadcast if you want to send something to the chat the macro string should be a standard [runthis(arg, arg)] -->']\n[h, if(runMacro == \"\"):\t\t\trunMacro\t\t= 0]\n[h, if(runMacroFinal == \"\"):\trunMacroFinal\t= 0]\n\n[h, if(argCount()>2), CODE:{\n\t<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->\n\t[x1  = if(relative, arg(1) + getTokenX(dStep), arg(1))]\t  \n\t[y1  = if(relative, arg(2) + getTokenY(dStep), arg(2))]\t  \n}; {\n\t[abort(input(\t\n\t\t\t\t\t\"junk|<html><b>You have the following options, the Token travels:<br>- to the given coords (relative unchecked; distance=0)<br>- the relative distance (relative checked; distance=0)<br>- in the direction of the exact coords to distance=n (relative unchecked)<br>- in the direction of the relative coords to distance=n (relative checked)<br><\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\t\t\"x1|0|<html><b>X<\/b> New coordinate of token (in grid coords if D-stepsize=0, else in pixel coords)\",\n\t\t\t\t\t\"y1|0|<html><b>Y<\/b> New coordinate of token (dito X)\",\n\t\t\t\t\t\"dStep|0|<html><b>D-Stepsize<\/b> 0=step per cell, >0=per that many pixels\",\n\t\t\t\t\t\"dr|180|<html><b>R<\/b> Degrees it rotates\",\n\t\t\t\t\t\"rStep|5|<html><b>R-Stepsize<\/b> Degrees per step (the higher the faster)\",\n\t\t\t\t\t\"distance|0|<html><b>Distance<\/b> the token travels\",\n\t\t\t\t\t\"relative|1|<html><b>Relative<\/b> to current position|CHECK\",\n\t\t\t\t\t\"snap2Grid|0|<html><b>Snap token<\/b> to grid when done|CHECK\",\n\t\t\t\t\t\"stopOnImpact|Bounce, Continue, Stop|What should it do when it hits something|RADIO|SELECT=1\",\n\t\t\t\t\t\"delay|0|Set delay per step\",\n\t\t\t\t\t\"junk|<html><b>Which layers should be checked for bounce or stop on impact?<\/b><br><i>Note that checking the four 'Token' layers can slow the animation<br>down considerably<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\t\t\"Token|0|Token Layer|CHECK\",\n\t\t\t\t\t\"Hidden|0|Hidden Layer|CHECK\",\n\t\t\t\t\t\"Object|0|Object Layer|CHECK\",\n\t\t\t\t\t\"Background|0|Background Layer|CHECK\",\n\t\t\t\t\t\"vbl|1|Vision Blocking Layer (Token MUST have vision!!)|CHECK\"\n\t))]\n\t[stopOnImpact\t= stopOnImpact - 1]\n\t[layer \t\t\t= \"[]\"]\n\t[if(Token):\t\t\tlayer = json.append(layer, \"Token\")]\n\t[if(Hidden):\t\tlayer = json.append(layer, \"Hidden\")]\n\t[if(Object):\t\tlayer = json.append(layer, \"Object\")]\n\t[if(Background):\tlayer = json.append(layer, \"Background\")]\n\n\t[if(relative), CODE:{\n\t\t[x1  = x1 + getTokenX(dStep))]\t  \n\t\t[y1  = y1 + getTokenY(dStep))]\t  \n\t}; {}]\n}]\n\n[h:x0\t\t= getTokenX(dStep)]\t  \n[h:y0\t\t= getTokenY(dStep)]\n[h:r0\t\t= bot_getTokenFacing(me, 1)]\n[h:dx\t\t= abs(x1 - x0)]\n[h:dy\t\t= abs(y1 - y0)]\n[h:x\t\t= x0]\n[h:y\t\t= y0]\n[h:r\t\t= r0]\n[h:n \t\t= if(!distance, 1 + dx + dy, 0)]\n[h:xInc\t\t= if(x1 > x0, max(1, dStep - 1), -max(1, dStep - 1))]\n[h:yInc\t\t= if(y1 > y0, max(1, dStep - 1), -max(1, dStep - 1))]\n[h:error\t= dx - dy]\n[h:dx\t\t= 2 * dx]\n[h:dy\t\t= 2 * dy]\n[h:direction= \"\"]\n[h:lastDiag\t= 0]\n[h:steps\t= 0]\n[h,if(dr && !rStep): dr = 0]\n\n[h:check = if(dx < dy, \"X\", \"Y\")]\n[h:'<!-- set lastTime to 0 so that each client will get its own time!! -->']\n[h:lastTime = 0]\n[h:gridSize = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]\n\n[h:'<!-- initialize the animation on every pc/client/user -->']\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:initiator\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:oldOwners \t\t\t= isOwnedByAll()]\n[h,if(oldOwners): oldOwners = json.fromList(onlinePlayers); oldOwners = json.fromList(getOwners())]\n\n[h,if(animationPerClient), CODE:{\n\t[otherPlayers = listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]\n\t[setOwner(initiator, me)]\n\t[setOwnerOnlyVisible(1, me)]\n}; {\n\t[otherPlayers = \"\"]\n}]\n[h:mainMe = \"\"]\n\n[h:args = strPropFromVars(\"me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, dStep, rStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid\", \"UNSUFFIXED\")]\n\n[h,macro('deferAnimateMove@'+getMacroLocation()): args]\n\n[h:mainMe = me]\n[h,foreach(user, otherPlayers), CODE:{\n\t[me\t\t= getName(copyToken(mainMe))]\n\t[setOwnerOnlyVisible(1, me)]\n\t[setOwner(user, me)]\n\t[args\t= strformat(argString)]\t\n\t[broadcast(macroLink(\"<color='white'>\", 'deferAnimateMove@'+getMacroLocation(), 'none', args,user))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f9526124-6ec6-42ab-a9f8-9e7077b0ea86",
          "commandChecksum": "13310e47394e79ed43afd0bb579cdf4c",
          "propsChecksum": "dd8008e68b602ce46f9285bdc2c2ec69"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "6",
        "index": 216,
        "label": "animateText",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- animateText (text[, title, position, html-header, width, height, delay, upper]) -->']\n[h:numArgs = argCount()]\n[h:assert(numArgs, \"This function requires at least one parameter:<br>animateText <i>(text[, title, position, html-header, width, height, delay, upper])\",0)]\n\n[h:'<!-- the text to animate -->']\n[h:txt \t\t\t\t\t\t\t= arg(0)]\n[h:lastCharPos = length(txt)-1]\n\n[h:'<!-- This title will appear at the top of the frame, it will also be the name of the frame -->']\n[h, if(numArgs > 1): title\t\t= arg(1); title\t\t= \"Message\"] \n\n[h:'<!-- From which position in the text should the text animation start, the number you fill in is the amount of characters that will immediately appear in the frame, the rest of the text is animated -->']\n[h, if(numArgs > 2): position\t= arg(2); position\t= 0]\n[h:position = min(lastCharPos, position)]\n\n[h:'<!-- a html header which enables you to make up the frame -->']\n[h, if(numArgs > 3): html\t\t= arg(3); html\t\t= \"<html><head><\/head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>\"]\n[h, if(html == \"Default\"): html = \"<html><head><\/head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>\"]\n\n[h:'<!-- dimensions of the frame -->']\n[h, if(numArgs > 4): width\t\t= arg(4); width\t\t= 640]\n[h, if(numArgs > 5): height\t\t= arg(5); height\t= 480]\n\n[h:'<!-- how many ms between each printed character -->']\n[h, if(numArgs > 6): delay\t\t= arg(6); delay\t\t= 15]\n\n[h:'<!-- print the while text in upper case -->']\n[h, if(numArgs > 7): upper\t\t= arg(7); upper\t\t= 0]\n\n[h,if(upper): txt = upper(txt)]\n\n[h:output\t= html + substring(txt, position, position+1)]\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(title, \"width=\"+width+\"; height=\"+height+\"; temporary=1; input=1\"): {[r:output]}]\n};{\n\t[frame(title, \"width=\"+width+\"; height=\"+height+\"; temporary=1\"): {[r:output]}]\n}]\n\n[H:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h:ok=0]\n[h,while (!ok), CODE:{\n\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[if(currentTime+delay < newTime):ok=1]\n}]\n\n[h:position = min(lastCharPos, position + 1)]\n\n[h:varList = \"title, html, txt, position, delay\"]\n[h:args = strPropFromVars(varList, \"UNSUFFIXED\")]\n\n[h:link = macroLinkText(\"deferAnimateText@\"+getMacroLocation(),\"none\",args)]\n[h:execLink(link,1)]\n\n<!-- broadcast to the players -->\n[h:initiator\t\t\t= getPlayerName()]\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:otherPlayers\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]\n[h,foreach(user, otherPlayers), CODE:{\n\t[broadcast(macroLink(\"<color='white'>\", 'deferAnimateText@'+getMacroLocation(), 'none', args,user))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "964f05c8-48c0-4eaf-8bcd-b04ccabad8db",
          "commandChecksum": "a1b8665e1491bc52ceafb6cf69019aeb",
          "propsChecksum": "2f7a01e89607f47ee68f20bd621f1cc3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "5",
        "index": 217,
        "label": "animateTextInput",
        "fontSize": "1.00em",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:lastSettings\t= getLibProperty(\"lastAnimatedTextSettings\", \"lib:EventMacros\")]\n[h:varsFromStrProp(lastSettings)]\n\n[h:abort(input(\n\tstrformat(\"Animated text|text=%{text}; title=%{title}; html=%{html}||PROPS|SPAN=TRUE SETVARS=UNSUFFIXED\"), \n\t\"position|\"+position+\"|Start position of animation\", \n\t\"width|\"+width+\"|Width of the frame\", \n\t\"height|\"+height+\"|Heigth of the frame\", \n\t\"delay|\"+delay+\"|Delay per character (in ms)\", \n\t\"upper|\"+upper+\"|Print text in upper class?|CHECK\")\n)]\n\n[h:bot_animateText(text, title, position, html, width, height, delay, upper)]\n\n[h:varList \t\t= \"text, title, position, html, width, height, delay, upper\"]\n[h:lastSettings = strPropFromVars(varList, \"UNSUFFIXED\")]\n[h:setLibProperty(\"lastAnimatedTextSettings\", lastSettings, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "678ece70-c280-40dc-8936-1e235e838d38",
          "commandChecksum": "92a3e8b6a4a83fb82ff7bb232ac4b07f",
          "propsChecksum": "2f760505c42fc749fe72501bcbe21564"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "3",
        "index": 218,
        "label": "defOwners",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- defOwners-->']\n[h:varsFromStrProp(macro.args)]\n[h:setOwnerOnlyVisible(0, mainMe)]\n[h:setOwner(oldOwners, mainMe)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "594f7f6d-f212-4cbd-bdb0-65dcde9a581b",
          "commandChecksum": "3ae2d73f00c6507e90674326f7bb6fb5",
          "propsChecksum": "99fba13c373b278e1d80c9d495cb1163"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "2",
        "index": 219,
        "label": "deferAnimateMove",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- deferAnimateMove -->']\n[h:abort(1)]\n[h:varsFromStrProp(macro.args)]\n[h:switchToken(me)]\n[h:setHasSight(1)]\n[h:xMove = 0]\n[h:yMove = 0]\n[h:'broadcast(macro.args)']\n\n<!-- skip a step to prevent staircasing -->\n[h,if(direction != check), CODE:{\n\t<!-- if stop on impact or bounce, check if something is blocking the path, if so, quit -->\n\t<!-- getBlockType -->\n\t\n\t<!-- Initialize -->\n\t[xB \t\t\t= 0]\n\t[yB \t\t\t= 0]\n\t[cB \t\t\t= 0]\n\t[blockType\t\t= \"\"]\n\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- ---------------------------------STOP ON IMPACT CHECKS------------------------------>\n\t<!-- ------------------------------------------------------------------------------------>\n\t[if(stopOnImpact), CODE:{\n\t\t[if(vbl), CODE:{\n\t\t\t<!-- check for vision blocking layer isVisible only uses gridsize and looks at the actual give coordinates-->\n\t\t\t[if(xInc > 0):\txOffset = gridSize*1.5*xInc); xOffset = gridSize*0.5*xInc)]\n\t\t\t[if(yInc > 0):\tyOffset = gridSize*1.5*yInc); yOffset = gridSize*0.5*yInc)]\n\t\t\t[if(dx): \t\txB\t\t= if(isVisible( getTokenX(1) + xOffset, getTokenY(1)\t\t\t), 0,1)]\n\t\t\t[if(dy): \t\tyB\t\t= if(isVisible( getTokenX(1), \t\t\tgetTokenY(1) + yOffset\t), 0,1)]\n\t\t\t[if(dx && dy):\tcB\t\t= if(isVisible( getTokenX(1) + xOffset,\tgetTokenY(1) + yOffset\t), 0,1)]\n\t\t''\n\t\t}]\n\t\t\n\t\t[if(!json.isEmpty(layer)), CODE:{\n\t\t\t<!-- check for tokens on the different layers gettokens looks at the area offset to the current position of the token-->\n\t\t\t[if(dx && !xB): \t\txB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':0}]}}\")))]\n\t\t\t[if(dy && !yB): \t\tyB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':0,'y':%{yInc}}]}}\")))]\n\t\t\t[if(dx && dy && !cB):\tcB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':%{yInc}}]}}\")))]\n\t\t''\n\t\t}]\n\n\t\t[if(xB || yB || cB), CODE:{\n\t\t\t<!-- process blocking results -->\n\t\t\t<!-- x=left/right y=up/down c=corner -->\n\t\t\t[if(xB && !yB):blockType\t= \"x\"]\n\t\t\t[if(yb && !xB):blockType\t= \"y\"]\n\t\t\t[if((cB&&!xB&&!yB)||(!cB&&xB&&yB)||(cB&&xB&&yB)):blockType = \"c\"]\n\n\t\t\t<!-- stop on impact -->\n\t\t\t[if(stopOnImpact > 0 && blockType != \"\"), CODE:{\n\t\t\t\t[abort(0)]\n\t\t\t''\n\t\t\t};{\n\t\t\t\t<!-- Bounce -->\n\t\t\t\t[if(blockType == 'x' || blockType == 'c'), CODE:{\n\t\t\t\t\t[xInc = -xInc]\n\t\t\t\t\t[x = x + 2*xInc]\n\t\t\t\t''\n\t\t\t\t}]\n\t\t\t\t[if(blockType == 'y' || blockType == 'c'), CODE:{\n\t\t\t\t\t[yInc = -yInc]\n\t\t\t\t\t[y = y + 2*yInc]\n\t\t\t\t''\n\t\t\t\t}]\n\t\t\t''\n\t\t\t}]\n\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- ---------------------------------THE ACTUAL MOVE------------------------------------>\n\t<!-- ------------------------------------------------------------------------------------>\n\t\n\t<!-- skip the move if there is a block type OR if x AND y dont change or if n is 0 or smaller -->\n\t<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->\n\t[xMove = x - getTokenX(dStep)]\n\t[yMove = y - getTokenY(dStep)]\n\t[h, if((xMove || yMove) && n > 0), CODE:{\n\t\t<!-- delay -->\n\t\t[if(!lastTime):lastTime = json.get(getInfo(\"client\"),\"timeInMs\") - 2*delay]\n\t\t[continue = if(json.get(getInfo(\"client\"),\"timeInMs\") < (lastTime + delay),0,1)]\n\t\t[while(!continue): continue = if(json.get(getInfo(\"client\"),\"timeInMs\") < (lastTime + delay),0,1)]\n\n\t\t<!-- the actual animation -->\n\t\t<!-- if dStep = 0 get Grid Coord, is <> 0 get pixel coord -->\n\t\t[moveToken(x,y,dStep)]\n\t\t<!-- clock for the next delay -->\n\t\t[lastTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t\t<!-- count the distance travelled -->\n\t\t[steps = steps + max(1, dStep - 1)]\n\t''\n\t}]\n''\n};{\n\t<!-- if this is a 2nd time diagonal step is taken count an extra step and toggle the lastDiag -->\n\t[if(lastDiag): steps = steps + max(1, dStep - 1)]\n\t[lastDiag = 1- lastDiag]\n''\n}]\n\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- ---------------------------------ROTATION ANIMATION--------------------------------->\n\t<!-- ------------------------------------------------------------------------------------>\n[h, if(dr > 0), CODE:{\n\t['pause(\"rStep\", \"r\", \"dr\")']\n\t[dr\t= dr - rStep]\n\t[r\t= r + rStep + if(dr<0, dr,0)]\n\t[bot_setTokenFacing(r, me, 1)]\n\t[if(dr<0):dr=0]\n};{\n\t[if(dr < 0), CODE:{\n\t\t[dr\t= dr + rStep]\n\t\t[r\t= r - rStep - if(dr>0, dr,0)]\n\t\t[bot_setTokenFacing(r, me, 1)]\n\t\t[if(dr>0):dr=0]\n\t\t['pause(\"rStep\", \"r\", \"dr\")']\n\t}]\n}]\n\n<!-- ------------------------------------------------------------------------------------>\n<!-- ---------------------------------SET NEW DIRECTION --------------------------------->\n<!-- ------------------------------------------------------------------------------------>\n[h,if(error>0), CODE:{\n\t[x\t\t\t= x+xInc]\n\t[error\t\t= error-dy]\n\t[direction\t= \"X\"]\n}; {\n\t[y\t\t\t= y+yInc]\n\t[error\t\t= error+dx]\n\t[direction\t= \"Y\"]\n}]\n\n<!-- optionally run a macro after each step, this macro can be given as an argument in the call -->\n[h,if((runMacro != 0 && runMacro != \"\") && (xMove || yMove)): evalMacro(strformat(runMacro))]\n\n[h:n = n - max(1, dStep - 1)]\n[h,if(n > 0 || steps < distance || dr != 0), CODE:{\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- ----------------CONTINUE until either n (==dx+dy) is 0 or #steps == distance ------->\n\t<!-- ------------------------------------------------------------------------------------>\n\t[args = strPropFromVars(\"me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, rStep, dStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid\", \"UNSUFFIXED\")]\n\t[link = macroLinkText(\"deferAnimateMove@\"+getMacroLocation(),\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- --------------------------------- FINISHED ----------------------------------------->\n\t<!-- ------------------------------------------------------------------------------------>\n\t<!-- delete the animated token and make the main token visible again. but not if you are the initiator in which case me = main me and mainMe = \"\" -->\n\t[if(mainMe != \"\"), CODE:{\n\t\t[args = strformat(\"mainMe = %{mainMe}; oldOwners = %{oldOwners}\")]\n\t\t<!-- broadcast an update to the initiator to set the token owners back to previous setting -->\n\t\t[broadcast(macroLink(\"<color='white'>\", 'defOwners@'+getMacroLocation(), 'none', args, initiator))]\n\t\t[removeToken(me)]\n\t};{\n\t\t<!-- if your the initiator, snap mainme to grid (if required) -->\n\t\t[if(snap2Grid): bot_snapToGrid(me)]\n\t}]\n\t[if((runMacroFinal != 0)): evalMacro(strformat(runMacroFinal))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d2e295a5-57c0-4adb-8772-17af5ea11e33",
          "commandChecksum": "830db253adf72e57b5f5d33e53245d50",
          "propsChecksum": "4bd621271c8aa19a08a7af348ea888d6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "7",
        "index": 220,
        "label": "deferAnimateText",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- deferAnimateText -->']\n<!-- MORE THEN THREE CODE LEVELS 3 CODE LEVELS -->\n[debug = 0]\n\n[h:varsFromStrProp(macro.args)]\n\n[h,if(debug), CODE:{\n\t[args\t= macro.args]\n\t[bot_debugInfo(\"position, txt, args\",0)]\n};{}]\n\n[h,if(position <= length(txt)), CODE:{\n\t[h:output\t= html + substring(txt, 0, position)]\n\n\t[if(bot_isFullScreen()), CODE:{\n\t\t[dialog(title, \"width=215; height=460; temporary=0; input=1\"): {\n\t\t\t[r:output]\n\t\t[h:'']\n\t\t}]\n\t''\n\t};{\n\t\t[frame(title, \"width=215; height=460; temporary=0\"): {\n\t\t\t[r:output]\n\t\t[h:'']\n\t\t}]\n\t''\n\t}]\n\t\n\t[h:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[h:ok=0]\n\t[h,while (!ok), CODE:{\n\t\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t\t[if(currentTime+delay < newTime):ok=1]\n\t''\n\t}]\n\n\t[h:position = position + 1]\n\t\n\t[h:varList = \"title, html, txt, position, delay\"]\n\t[h:args = strPropFromVars(varList, \"UNSUFFIXED\")]\n\t\n\t[link = macroLinkText(\"deferAnimateText@\"+getMacroLocation(),\"none\",args)]\n\t[execLink(link,1)]\n''\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "485448f0-2523-4e7c-8827-d02694167198",
          "commandChecksum": "be53ce01384cbd3fd1ba366f342470db",
          "propsChecksum": "eee041dcf43b8ec138d87710b9ac3fc2"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "4",
        "index": 221,
        "label": "delay",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:delay = arg(0)]\n[H:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h:ok=0]\n[h,while (!ok), CODE:{\n\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[if(currentTime+delay < newTime):ok=1]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "84b3ecac-e3fd-4131-9bb3-9f450e1132e6",
          "commandChecksum": "1a991236c8dcbfbed805437b7b90f276",
          "propsChecksum": "3ced279d7f51cd0eb41513daf7c80394"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 222,
        "label": "assignArea",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- Assign Area----------------------------------------------------------------------->']\n<!-- ignore output, new scope -->\n<!-- <html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself -->\n\n<!-- ------------------------------- initialize values -------------------->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n[h:macroList\t\t= getMacros(\",\",\"lib:EventMacros\")]\n[h:setCurrentMap(oldMap)]\n[h:assert(macroList != \"\",\"First create at least one macro on the lib:EventMacro token with which this event area can be associated\",0)]\n\n<!-- ----------------------------------the areas -------------------------->\n[h:storedAreas\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n[h:assert(!json.isEmpty(storedAreas), \"No areas have been defined\", 0)]\n[h:linkedAreas\t\t= getLibProperty(\"linkedAreas\", \"Lib:EventMacros\")]\n[h:mapNames\t\t\t= json.fields(storedAreas)]\n[h:macroList\t\t= listAppend(\"<None>\", macroList)]\n\n<!-- first time use -->\n[h, if(json.type(linkedAreas) == \"UNKNOWN\"): linkedAreas = \"{}\"]\n\n[h:triggerTypeList\t= \"movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain\"]\n\n<!-- ---------------------------------Generate Input Screen based on found Areas -------------------->\n[h:tabNr\t\t= 0]\n[h:inputStr\t\t= \"\"]\n\n[h,foreach(mapName, mapNames), CODE: {\n\t<!-- create tabs with the areas sorted per mapName -->\n\t[inputStr \t= json.append(inputStr, 'tab'+tabNr+' |'+mapName+'|| TAB')]\n\t[inputStr\t= json.append(inputStr, 'junk|<html><b>LINK EVENT MACRO TO AN EVENT AREA<\/b><br><\/html><\/span><\/html>|-|LABEL|SPAN=TRUE')]\n\n\t[if(json.contains(linkedAreas, mapName)): \t\t\t\tthisMapLinks\t= json.get(linkedAreas, mapName)\t\t\t ; thisMapLinks = \"{}\"]\n\t[if(json.contains(linkedAreas, mapName+\".W42.Limit\")):\tthisMapLimits\t= json.get(linkedAreas, mapName+\".W42.Limit\") ; thisMapLimits = \"{}\"]\n\n\t[areaList\t= json.fields(json.get(storedAreas, mapName))]\n\t[listLength = listCount(areaList)-1]\n\t[i = 0]\n\t[foreach(area, areaList), CODE:{\n\t\t[if(json.type(thisMapLinks) == \"OBJECT\"):\t\tstrPropVars = json.get(thisMapLinks, area); strPropVars = \"\"]\n\t\t<!-- define:  \"eventMacro, eventTriggerList\" -->\n\t\t[if(strPropVars != \"\"):\t\t\t\t\t\tvarsFromStrProp(strPropVars)]\n\t\t[if(strPropVars != \"\"):\t\t\t\t\t\toldSelection = listFind(macroList, eventMacro) ; oldSelection = 0]\n\t\t[if(json.type(thisMapLimits) == \"OBJECT\"):\toldSelection = max(oldSelection,listFind(macroList, json.get(thisMapLimits, area)))\t\t\t\t\t]\n\t\t[inputStr \t= json.append(inputStr, 'assignedArea_'+tabNr+'_'+i+'|'+macroList+'|<html><span title=\"<html>When you move over a predefined Area you can have a certain<br>macro (event) triggered. Here you can link an Event Macro to<br>the predefined areas. The areas are sorted per map (in tabs).<br><br>Note that <i>Limit Movement<\/i> is a special and reserved<br>macro that is run BEFORE the pads are checked and based on<br>this outcome (and whether its turned on) the path of the<br>token is shortened to the maximum allowed steps.<br><br><b>Therefore the Event Triggers will be IGNORED for LIMIT MOVEMENT<\/b><br><br>You can turn <i>Limit Movement<\/i> on in the settings.<\/html>\"><b><font color=#FF0000>'+area+'<\/b><\/font><\/html><\/span><\/html>|LIST|SELECT='+oldSelection+' VALUE=STRING')]\n\n\t\t[varsFromStrProp(\"movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0\")]\n\t\t[if(strPropVars == \"\"):\teventTriggerList = \"\"]\n\t\t[foreach(event, eventTriggerList): set(event, 1)]\n\t\t\n\t\t[inputStr \t= json.append(inputStr, 'junk|<html><i>Which actions trigger this event area (all events are mutual exclusive):<\/i><\/html>|-|LABEL|SPAN=TRUE')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOn_'+tabNr+'_'+i+'|'\t\t+movedOn+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves onto this area<\/b>.<\/html>\">Token moves onto area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOff_'+tabNr+'_'+i+'|'\t+movedOff+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>leaves this area.<\/html>\">Token moves off area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOver_'+tabNr+'_'+i+'|'\t+movedOver+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves over this area.<\/html>\">Token moves over area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedNot_'+tabNr+'_'+i+'|'\t+movedNot+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>on this area is moved<br>from and back to the same postion on this area<br>without using waypoints.<\/b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.<\/html>\">Token does zero move on area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedReturn_'+tabNr+'_'+i+'|'\t+movedReturn+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves off this area<br>and back onto it, using waypoints.<\/html>\">Token leaves and returns onto area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedRemain_'+tabNr+'_'+i+'|'\t+movedRemain+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>is moved but remains<br>on the area the entire move.<\/html>\">Token moves but remains on area<\/html><\/span><\/html>|CHECK')]\n\t\t[if(i < listLength):inputStr \t= json.append(inputStr, 'junk|<html>_____________________________________________________<\/html>|-|LABEL|SPAN=TRUE')]\n\t\t[i = i + 1]\n\t}]\n\t[tabNr\t\t= tabNr +1]\n}]\n\n<!-- -----------------------------------ask for input ------------------------------------->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- --------------------------------- assign the events to the areas -------------------->\n[h:linkedAreas = \"{}\"]\n[h:tabNr = 0]\n[h,foreach(mapName, mapNames), CODE: {\n\t[areaList\t\t= json.fields(json.get(storedAreas, mapName))]\n\t[thisMapLinks\t= \"{}\"]\n\t[thisMapLimits\t= \"{}\"]\n\t[i = 0]\n\t[foreach(area, areaList), CODE:{\n\t\t[eventMacro = eval(\"assignedArea_\"+tabNr+\"_\"+i)]\n\t\t[if(eventMacro == \"Limit Movement\"): thisMapLimits\t= json.set(thisMapLimits, area, eventMacro)]\n\n\t\t[eventTriggerList = \"\"]\n\t\t[foreach(trigger, triggerTypeList), if(eval(trigger+'_'+tabNr+'_'+i)): eventTriggerList = listAppend(eventTriggerList, trigger)]\n\t\t<!-- only store if NOT liked to limit movement -->\n\t\t[if(eventMacro != \"Limit Movement\"): thisMapLinks = json.set(thisMapLinks, area, strPropFromVars(\"eventMacro, eventTriggerList\",\"UNSUFFIXED\"))]\n\t\t[i = i + 1]\n\t}]\n\t[linkedAreas\t= json.set(linkedAreas, mapName, thisMapLinks, mapName+\".W42.Limit\", thisMapLimits)]\n\t[tabNr\t\t\t= tabNr + 1]\n}]\n\n[h:setLibProperty(\"linkedAreas\", linkedAreas, \"Lib:EventMacros\")]\n[h:broadcast(\"The Event links have been created\")]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1baf4067-7368-4a76-a4b7-8871730b01a9",
          "commandChecksum": "f6fae60fe20f97f8033c5fbc701ef525",
          "propsChecksum": "b8b41a383504952b8dfe1f3cd149f5e0"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "9. Assigned Pads",
        "includeLabel": false,
        "sortBy": "1",
        "index": 227,
        "label": "assignPads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- Assign Pads----------------------------------------------------------------------->']\n<!-- <html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br> -->\n<!-- ----------------------------------find all assigned pads and filter them into seperate lists -------------------------->\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"))]\n[h:assPads\t\t= listSort(getTokenNames(\",\",conditions),\"A+\")]\n[h:allPads\t\t= \"\"]\n[h:padTypeList\t= \"\"]\n[h:padType\t\t= \"\"]\n[h:lstPads\t\t= \"\"]\n\n[h,foreach(tok,assPads),CODE:{\n\t[if(startsWith(tok, \"AssignedPad \")), CODE:{\n\t\t<!-- make a list of all the pads -->\n\t\t[allPads\t= listAppend(allPads, tok)]\n\t\t<!-- check if a group is defined eg AssignedPad Red 5 -->\n\t\t[hasPadType\t= if(getFindCount(strfind(tok, \"\\\\s\"))==2, 1,0)]\n\t\t<!-- if a group is defined eg AssignedPad Red 5, retrieve the type, in this case Red-->\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(tok, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t<!-- get the name of the pad, in this ex. 5 -->\n\t\t[padName\t= trim(getGroup(strfind(tok,\"^.*?(\\\\w+)\\\\Z\"),1,1))]\n\t\t<!-- check if the padType is already defined as a list -->\n\t\t[newType\t= if(hasPadType && !listContains(padTypeList, padType), 1,0)]\n\t\t<!-- if the padType is not already defined add it to the type list -->\n\t\t[if(newType): padTypeList = listAppend(padTypeList, padType)]\n\n\t\t<!-- one list with ungrouped pads called lstPads -->\n\t\t[if(padType == \"\")\t\t\t\t: lstPads = listAppend(lstPads, padName)]\n\n\t\t<!-- and one list per group type eg red, green or blue called lstPadRed, lstPadBlue etc. -->\n\t\t[if(newType)\t\t\t\t\t: set(\"lstPad\"+padType, padName)]\n\t\t[if(padType != \"\" && !newType)\t: set(\"lstPad\"+padType, listAppend(eval(\"lstPad\"+padType), padName))]\n['pause(\"assPads\", \"tok\", \"padType\", \"padName\", \"newType\", \"lstPad\"+padType, \"lstPads\")']\n\t}; {}] \n}]\n[h:assert(listCount(allPads), \"No AssignedPads found on map\", 0)]\n\n<!-- ----------------------------------find all tokens on map to assign to the pads -------------------------->\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\"))]\n[h:tokens\t\t= getTokenNames(\",\",conditions)]\n[h:tokList\t\t= \"<none>\"]\n\n[h,foreach(tok,tokens),CODE:{\n\t[if(!startsWith(tok, \"AssignedPad \")): tokList = listAppend(tokList, tok)]\n}]\n[h:tokList = listSort(tokList, \"A+\")]\n\n[h:assert(listCount(tokList), \"No tokens found on map\", 0)]\n\n<!-- ---------------------------------Generate Input Screen based on found pads-------------------->\n[h:tabNr = 0]\n[h,if(listCount(padTypeList)), CODE: {\n\t[inputStr = \"\"]\n\t<!-- create tabs with the pads sorted per type, starting with the ungrouped pads -->\n\t[h,if(listCount(lstPads)), CODE:{\n\t\t<!-- the next tab contains the individual checkboxes for ungrouped pads -->\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |Ungrouped|| TAB\", \"##\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Assign the tokens to the pads<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"##\")]\n\t\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|\"+tokList+\"|\"+pad+\" |LIST|SELECT=\"+listFind(tokList, getProperty(\"w42.bot.linkedToken\", \"AssignedPad \"+pad))+\" VALUE=STRING\", \"##\")]\n\t}; {}]\n\t\n\t<!-- and then the grouped pads -->\n\t[h,foreach(padType, padTypeList), CODE:{\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |\"+padType+\"|| TAB\", \"##\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Assign the tokens to the pads<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"##\")]\n\n\t\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t\t[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+padType+\"_\"+pad+\"|\"+tokList+\"|\"+pad+\" |LIST|SELECT=\"+listFind(tokList, getProperty(\"w42.bot.linkedToken\", \"AssignedPad \"+padType+\" \"+pad))+\" VALUE=STRING\", \"##\")]\n\t}]\n}; {\n\t<!-- if there are only ungrouped pads then create a single input listing all assigned pads-->\n\t[inputStr\t\t\t= \"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\", \"##\")]\n}]\n\n<!-- ask for input -->\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \", \", \"##\")]\n[H: abort(eval(inputStr))]\n\n<!-- --------------------------------- assign the tokens to the pads-------------------->\n[h, foreach(pad, lstPads): setProperty(\"w42.bot.linkedToken\", eval(\"AssignedPad_\"+pad), \"AssignedPad \"+pad )]\n[h,foreach(padType, padTypeList), CODE:{\n\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t[foreach(pad, lstGroupPads): setProperty(\"w42.bot.linkedToken\", eval(\"AssignedPad_\"+padType+\"_\"+pad), \"AssignedPad \"+padType+\" \"+pad )]\n}]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9d1d0b8c-4c27-40c6-b951-91baee8fbe8c",
          "commandChecksum": "936151c60ac1d4f7036ba8bde9497e38",
          "propsChecksum": "5f9a8e4da72e7d3c15ab58e305a3cbbf"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "9. Assigned Pads",
        "includeLabel": false,
        "sortBy": "1",
        "index": 228,
        "label": "execAssignPads",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------Execute Assigned Pads----------------------------------------------------------------------->']\n[h:debug = 0]\n\n<!-- optional argument: 1 to autoexec ALL -->\n[h,if(argCount()):\t\texecAll\t= arg(0); execAll = 0]\n[h,if(argCount() > 1):\tgroup\t= arg(1); group = \"\"]\n\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"))]\n[h:assPads\t\t= listSort(getTokenNames(\",\",conditions),\"A+\")]\n[h:allPads\t\t= \"\"]\n[h:padTypeList\t= \"\"]\n[h:padType\t\t= \"\"]\n[h:lstPads\t\t= \"\"]\n\n<!-- ----------------------------------find all assigned pads and filter them into seperate lists -------------------------->\n[h,foreach(tok,assPads),CODE:{\n\t[linkedToken = getProperty(\"w42.bot.linkedToken\", tok)]\n\t[if(startsWith(tok, \"AssignedPad \") &&  linkedToken != \"<none>\" && linkedToken != \"\"), CODE:{\n\t\t<!-- make a list of all the pads -->\n\t\t[allPads\t= listAppend(allPads, tok)]\n\t\t<!-- check if a group is defined eg AssignedPad Red 5 -->\n\t\t[hasPadType\t= if(getFindCount(strfind(tok, \"\\\\s\"))==2, 1,0)]\n\t\t<!-- if a group is defined eg AssignedPad Red 5, retrieve the type, in this case Red-->\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(tok, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t<!-- get the name of the pad, in this ex. 5 -->\n\t\t[padName\t= trim(getGroup(strfind(tok,\"^.*?(\\\\w+)\\\\Z\"),1,1))]\n\t\t<!-- check if the padType is already defined as a list -->\n\t\t[newType\t= if(hasPadType && !listContains(padTypeList, padType), 1,0)]\n\t\t<!-- if the padType is not already defined add it to the type list -->\n\t\t[if(newType): padTypeList = listAppend(padTypeList, padType)]\n\n\t\t<!-- one list with ungrouped pads called lstPads -->\n\t\t[if(padType == \"\")\t\t\t\t: lstPads = listAppend(lstPads, padName)]\n\n\t\t<!-- and one list per group type eg red, green or blue called lstPadRed, lstPadBlue etc. -->\n\t\t[if(newType)\t\t\t\t\t: set(\"lstPad\"+padType, padName)]\n\t\t[if(padType != \"\" && !newType)\t: set(\"lstPad\"+padType, listAppend(eval(\"lstPad\"+padType), padName))]\n\n\t\t[if(debug): bot_debugInfo(\"tok, padType, padName, newType, lstPads\",1)]\n\n\t\t}; {}] \n}]\n\n[h:assert(listCount(allPads), \"No AssignedPads found on map\", 0)]\n\n<!-- special case if the macro is called with the arg = 1 -->\n[h,if(execAll), CODE:{\n\t[foreach(pad, allPads), CODE:{\n\t\t[switchToken(pad)]\n\t\t[hasPadType\t= if(getFindCount(strfind(pad, \"\\\\s\"))==2, 1,0)]\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(pad, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t[linkedToken\t= getProperty(\"w42.bot.linkedToken\")]\n\t\t[if(group == \"\" || group == padType): moveToken(getTokenX(0), getTokenY(0), 0, linkedToken)]\n\t}]\n\t<!-- make sure no more code runs after this without using abort -->\n\t[padTypeList = \"\"]\n\t[lstPads = \"\"]\n}]\n\n<!-- ---------------------------------Generate Input Screen based on found pads-------------------->\n[h:tabNr = 0]\n[h,if(listCount(padTypeList)), CODE: {\n\t<!-- if there are pads with a group type e.g. red, green, blue. Then create a front tab where you can check/uncheck entire groups -->\n\t[inputStr\t\t\t= \"tab\"+tabNr+\" |Groups|| TAB\"]\n\t[tabNr\t\t\t\t= tabNr +1]\n\t[inputStr\t\t\t= listAppend(inputStr,\"junk|<html><b>Check the Groups to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t<!-- ungrouped pads -->\n\t[if(listCount(lstPads)): inputStr = listAppend(inputStr, \"ungroupedPads|1|Ungrouped pads|CHECK\") ; ungroupedPads = 0]\n\t<!-- grouped pads -->\n\t[foreach(padType, padTypeList): inputStr = listAppend(inputStr, \"group\"+padType+\"|1|\"+padType+\" | CHECK\")]\n\t\n\t<!-- next create tabs with the pads sorted per type, starting with the ungrouped pads -->\n\t[if(listCount(lstPads)), CODE:{\n\t\t<!-- the next tab contains the individual checkboxes for ungrouped pads -->\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |Ungrouped|| TAB\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n\t}; {}]\n\t\n\t<!-- and then the grouped pads -->\n\t[foreach(padType, padTypeList), CODE:{\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |\"+padType+\"|| TAB\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\n\t\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t\t[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+padType+\"_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n\t}]\n}; {\n\t<!-- if there are only ungrouped pads then create a single input listing all assigned pads-->\n\t[ungroupedPads = 1]\n\t[inputStr\t\t\t= \"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n}]\n\n<!-- ask for input -->\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\")]\n[H, if(!execAll): abort(eval(inputStr))]\n\n<!-- ---------------------------------Execute assigned pads-------------------->\n[h,if(ungroupedPads), CODE:{\n\t[foreach(pad, lstPads), CODE:{\n\t\t[switchToken(\"AssignedPad \"+pad)]\n\t\t[if(eval(\"AssignedPad_\"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty(\"w42.bot.linkedToken\"))]\n\t}]\n}; {}]\n\n[h,foreach(padType, padTypeList), if(eval(\"group\"+padType)), CODE:{\n\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t[foreach(pad, lstGroupPads), CODE:{\n\t\t[switchToken(\"AssignedPad \"+padType+\" \"+pad)]\n\t\t[if(eval(\"AssignedPad_\"+padType+\"_\"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty(\"w42.bot.linkedToken\"))]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "58f0f28f-de2b-4e1f-9fa9-169f53a5cedc",
          "commandChecksum": "3cc9f75663eeadb8b6c6ca1bbabd54fd",
          "propsChecksum": "69344bb699ed8981422d2e7d32801d1f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "a. Aliasmask Usediguise",
        "includeLabel": false,
        "sortBy": "4",
        "index": 229,
        "label": "autoDisguiseButton",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- autoDisguiseButton -------------------------------------------------------- -->']\n<!--\n<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>\n-->\n[H, if(json.isEmpty(macro.args)), CODE: {\n\t[propText\t\t= '*autoDisguiseButton:[macro(\"autoDisguiseButton@lib:OnTokenMove\"): currentToken()]']\n\t[input(\n\t\t\"label|<html><b>Copy text in to Token Property to auto load Disguise Button:<\/b><br><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50\")\n\t)]\n};{\n\t[id\t\t\t\t= json.get(macro.args,0)]\n\t[switchToken(id)]\n\t[disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\",getMacroLocation())]\n\t[setProperty(\"autoDisguiseButton\",\"\")]\n\t[if(!hasMacro(\"Use Disguise\")): createMacro(disguiseMacro)]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "02d729d0-d86d-4a15-8635-40d5db6d7b3e",
          "commandChecksum": "4d3901050fd3bc5ca82ef0f2488e7249",
          "propsChecksum": "ceac3f1a81c7abb9134967f158cd224f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "a. Aliasmask Usediguise",
        "includeLabel": false,
        "sortBy": "5",
        "index": 230,
        "label": "useDisguise",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- useDisguise (optional; tablename) -------------------------------------------------------- -->']\n\n[h:'<!-- \n<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html> \n-->']\n[h, if(argCount() > 1): tTableName = arg(1); tTableName = \"Polymorph\" ]\n\n[h:toks\t\t= getSelectedNames()]\n\n[h:imgList\t= \"\"]\n[h, if(bot_inStr(toks, \"image\")), CODE:{\n\t[me\t\t= \"\"]\n\t[foreach(tok, toks), CODE:{\n\t\t[if(bot_inStr(tok, \"image\")): imgList\t= listAppend(imgList, getImage(tok)) ; me = listAppend(me,tok)]\n\t}]\n\t[toks\t= me]\n};{}]\n\n[h:assert(listCount(toks)==1, \"Make sure (only) one token (other then an 'image:token') is selected\",0)]\n[h:switchToken(toks)]\n\n[h: jTables\t\t= json.get(getInfo(\"campaign\"),\"tables\") ]\n[h: hasTable\t= json.contains(jTables,tTableName) ]\n[h: jAll\t\t= \"[]\"]\n[h, if(hasTable): cntAll = table(tTableName, 0); cntAll = 0]\n[h, if(hasTable), for(i,1,cntAll+1): jAll = json.append(jALL, tableimage(tTableName, i))]\n\n[h: jVis\t\t= \"[]\"]\n[h: tTokens\t\t= json.difference(getVisibleTokens(\"json\"), json.fromList(toks))]\n[h, foreach( tok, tTokens ),CODE: {\n\t[TOKEN(tok): jVis = json.append(jVis, getTokenImage()) ]\n}]\n[jvis\t= json.unique(jvis)]\n\n[h: disguises\t= getProperty(\"am.bot.disguise\")]\n[h, if(json.isEmpty(disguises)): disguises\t= \"[]\"]\n[h, if(listCount(imgList)): disguises = json.union(disguises, json.fromList(imgList))]\n\n[h: tokenImg\t= getTokenImage()]\n[h: inputStr\t= \"Images available on selected token | Disguise | | TAB\"]\n[h, if(!json.contains(disguises,tokenImg)), CODE: {\n\t[disguises\t= json.append(disguises,tokenImg)]\n\t[inputStr\t= json.append(inputStr,\n\t\t\"label|<html><b>Token Image added to Disguise List:<\/b><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"tip|<html>%{tokenImg}<\/html>||LABEL|SPAN=TRUE ICONSIZE=100 ICON=TRUE\")\n\t)]\n};{\n\t[inputStr\t= json.append(inputStr,\"label|<html><b>Change Token Image to add to Diguise List<\/b><\/html>||LABEL|SPAN=TRUE\")]\n}]\n\n[h: nSelect\t\t= json.indexOf(disguises, tokenImg)]\n[h: menu\t\t= -1]\n\n[h, if(json.length(disguises) > 1): inputStr\t= json.append(inputStr,\n\tstrformat(\"Menu|Change Image, Delete Image||RADIO|SPAN=TRUE SELECT=%{menu}\")\n)]\n\n[h: inputStr\t= json.append(inputStr,strformat(\"image|%s||LIST|ICON=TRUE SPAN=TRUE ICONSIZE=40 VALUE=STRING SELECT=\"+nSelect,json.toList(disguises)),\n\t\"label|<html><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\")]\n\n[h:image2\t\t= \"\"]\n[H, if(! json.isEmpty(jVis)): \n\tinputStr = json.append(\n\t\tinputStr,\"Images from tokens visible on this map | Visible Map Images | | TAB\",\n\t   strformat(\"image2|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING\",(\" ,\"+json.toList(jVis))),\n\t   'label|<html><br><font color=red><i><b>Hit \"Cancel\" to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE'\n\t)\n]\n\n[h:image3\t\t= \"\"]\n[h:width\t\t= 0]\n[h:height\t\t= 0]\n[h, if(hasTable): \n\tinputStr\t= json.append(\n\t\tinputStr, \"Images from the table 'Polymorph' | \" + tTableName + \" Table Images | | TAB\",\n\t\tstrformat(\"image3|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING\",(\" ,\"+json.toList(jAll))),\n\t\t\"label|<html><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\",\n\t\t\"label|<html><b>Here you can change the size of the token.<br>0 = do not change.<\/b><br>Please note that below MT version 1.4.x<br>only sizes 1,2,3,4 and 6 will work!!<\/html>||LABEL|SPAN=TRUE\",\n\t\t\"width|0|Width of token in grid cells|text|width=3\",\n\t\t\"height|0|Height of token in grid cells|text|width=3\"\n\t)\n;\n\tinputStr\t= json.append(\n\t\tinputStr, \"Images from the table 'Polymorph' | \" + tTableName + \" Table Images | | TAB\",\n\t\tstrformat(\"label|<html>The table 'Polymorph' does not exist. You will need to create it first:<br>- open panel: menu-->window-->tables<br>- create new table Polymorph<br>- first entry 'range':0 'value': enter total nr of images in table<br>- the rest start with 'range' 1, leave 'value' blank and add an image.<br><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\")\n\t)\n]\n\n[h: hasInput\t= input(json.toList(inputStr,\"##\"))]\n\n[h, if(hasInput), CODE: {\n\t[if(image2 != \"\"):\t\t\t\t\t\t\t\t\timage\t\t= image2; \"\" ]\n\t[if(image3 != \"\"):\t\t\t\t\t\t\t\t\timage\t\t= image3; \"\" ]\n\t[if(menu == 0 || image2 != \"\" || image3 != \"\" ):\tsetTokenImage(image)]\n\t[if(menu == 0):\t\t\t\t\t\t\t\t\t\tsetTokenImage(image)]\n\t[if(menu == 1):\t\t\t\t\t\t\t\t\t\tdisguises\t= json.difference(disguises,json.append(\"\",image))]\n\t[if(!json.isEmpty(disguises)):\t\t\t\t\t\tsetProperty(\"am.bot.disguise\",json.difference(disguises,json.append(\"\",\"\")))]\n\t[macro(\"useDisguise@lib:OnTokenMove\"): \"\"]\n};{\n\t[if(!json.isEmpty(disguises)):\t\t\t\t\t\tsetProperty(\"am.bot.disguise\",json.difference(disguises,json.append(\"\",\"\")))]\n}]\n\t\n[h,if(width && width==height), CODE:{\n\t<!-- if width and height are set AND the same size then check if its a preset size -->\n\t<!-- medium(1), large(2), huge(3), gargantuan(4), colossal(6) -->\n\n\t[h,switch(width),code:\n\tcase 1: {\n\t\t[setSize(\"Medium\")]\n\t};\n\tcase 2: {\n\t\t[setSize(\"Large\")]\n\t};\n\tcase 3: {\n\t\t[setSize(\"Huge\")]\n\t};\n\tcase 4: {\n\t\t[setSize(\"Gargantuan\")]\n\t};\n\tcase 6: {\n\t\t[setSize(\"Colossal\")]\n\t};\n\tdefault: {\n\t\t[setTokenWidth(width*bot_getGridSize())]\n\t\t[setTokenHeight(width*bot_getGridSize())]\n\t}]\n};{\n\t[if(width):setTokenWidth(width*bot_getGridSize())]\n\t[if(height):setTokenHeight(height*bot_getGridSize())]\n}]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "81c4704c-99d4-44e4-8a8f-8093e57cee57",
          "commandChecksum": "cfe2b2ad564b823727721ceb937e3517",
          "propsChecksum": "8447e750981ec653e8da3fd3f34889ad"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "12",
        "index": 231,
        "label": "bringToFront",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- bringToFront (Current Selection) --------------------------------------->']\n\n<!-- bring current selection to front -->\n[h:ids\t\t\t= getSelectedNames(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n<!-- bring first entry to front, after that a deferred loop is required cause the z order is updated AFTER the routine is finished -->\n[h:bringToFront(json.get(json.get(jsonOrder, 0),\"id\"))]\n\n<!-- start deferred loop -->\n[h: link = macroLinkText(\"deferBtF@lib:OnTokenMove\", \"none\", jsonOrder)]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fff4c872-6959-45c2-816b-492ca9525ee9",
          "commandChecksum": "9e448b283afdbab11aeb82658f02dd48",
          "propsChecksum": "44507f9c74cc0026b63fd8f329db5065"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "11",
        "index": 232,
        "label": "decDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- decDrawOrder (Current Selection) --------------------------------------->']\n\n<!-- bring current selection to front -->\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n<!-- bring current selection to front -->\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): setTokenDrawOrder(json.get(item,\"order\")-1,json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens draw order have been increased with one step\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6fffa602-e2ab-4005-b256-1fd898a6d124",
          "commandChecksum": "d0ed537e34dc7dd116fb7da7a3932a8a",
          "propsChecksum": "116f9cf27656b0d05427801c28a2288d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "10",
        "index": 233,
        "label": "incDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- incDrawOrder (Current Selection) --------------------------------------->']\n\n<!-- bring current selection to front -->\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n<!-- bring current selection to front -->\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): setTokenDrawOrder(json.get(item,\"order\")+1,json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens draw order have been increased with one step\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "53fdae1d-07a4-402b-a227-e6db55a1eafd",
          "commandChecksum": "47a431e34944ae433caabd36b852365a",
          "propsChecksum": "61e03b64ebc39e1983faeac9a02178f3"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "1",
        "index": 234,
        "label": "openOrderFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- openOrderFrame ------------------------------------------------>']\n<!-- <html> Turns on door switches at selected players. This will allow players to use doorswitches -->\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'<!-- input string -->']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'<!-- ask for input-->']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n\n<!-- need to make certain that this value is initialized on lib eventmacros -->\n[h:bot_resetTimer(3)]\n[h:bot_execAllPlayers(\"orderFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "775b1868-9748-4e8e-8837-9090d44556d8",
          "commandChecksum": "a34c94ab47351dd35e086d37500b3583",
          "propsChecksum": "16291a149c3f498e79a805820c987b0a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "1",
        "index": 235,
        "label": "orderFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ orderFrame ----------------------------------->']\n[h:debug = 0]\n\n[h: doShape\t= getLibProperty('vblSupport','lib:EventMacros')]\n\n<!-- first order the selection in ascending z-order -->\n[h:currentSelection\t= getSelected(\"json\")]\n\n<!-- retrieve current layer -->\n[h:token\t\t= \"\"]\n[h:hidden\t\t= \"\"]\n[h:object\t\t= \"\"]\n[h:background\t= \"\"]\n\n<!-- retrieve last setting -->\n[h:degrees\t\t= getLibProperty('w42.bot.processOrder.degrees','lib:EventMacros')]\n[h,if(!isNumber(degrees)): degrees = 90]\n\n[h,if(json.length(currentSelection)):layer\t\t= getLayer(json.get(currentSelection,0));layer=\"TOKEN\"]\n[h,switch(layer):\n\tcase \"TOKEN\":\t\ttoken\t\t= \"selected\";\n\tcase \"HIDDEN\":\t\thidden\t\t= \"selected\";\n\tcase \"OBJECT\":\t\tobject\t\t= \"selected\";\n\tcase \"BACKGROUND\":\tbackground\t= \"selected\";\n\tdefault:\t\t\ttoken\t\t= \"selected\";\n]\n\n<!-- retrieve current shape (first token only) b89+ -->\n[h,if(doShape),CODE:{\n\t[h:TOPDOWN\t= \"\"]\n\t[h:CIRCLE\t= \"\"]\n\t[h:SQUARE\t= \"\"]\n\n\t[h,if(json.length(currentSelection)):shape\t\t= getTokenShape(json.get(currentSelection,0));shape=\"TOPDOWN\"]\n\t[h,switch(shape):\n\t\tcase \"Top down\":\tTOPDOWN\t\t= \"selected\";\n\t\tcase \"Circle\":\t\tCIRCLE\t\t= \"selected\";\n\t\tcase \"Square\":\t\tSQUARE\t\t= \"selected\";\n\t\tdefault:\t\t\tTOPDOWN\t\t= \"selected\";\n\t]\n};{}]]\n\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t\t= \"[]\"]\n[h,foreach(tok, currentSelection), CODE:{\n\t[jsonOrder\t\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n}]\n[h,if(debug): bot_debugInfo(\"jsonOrder\")]\n[h:jsonOrder\t\t= json.sort(jsonOrder,\"a\",\"order\")]\n<!-- create list of tokens with their order and find the lowest and highest value -->\n[h:orderString\t\t= \"<table border=1><tr><td>Token<\/td><td>Img<\/td><td>Z-Order\"]\n[h:numSelect\t\t= json.length(jsonOrder)]\n[h,if(numSelect), CODE:{\n\t[minOrder\t\t\t= json.get(json.get(jsonOrder,0), \"order\")]\n\t[maxOrder\t\t\t= json.get(json.get(jsonOrder,numSelect-1), \"order\")]\n\t[foreach(tok, jsonOrder), CODE:{\n\t\t[tokId\t= json.get(tok,\"id\")]\n\t\t[token(tokId): orderString\t= listAppend(orderString, strformat(\"%s<\/td><td><img height='20' width='20' src='%s'><\/img><\/td><td><input size='5' type='text' name=%{tokId} value=%s>\", getName(tokId), getTokenImage(), getTokenDrawOrder(tokId)), \"<\/td><\/tr><tr><td>\")]\n\t}]\n};{\n\t[minOrder\t\t\t= \"\"]\n\t[maxOrder\t\t\t= \"\"]\n}]\n[h:orderString\t\t= orderString + \"<\/td><\/tr><\/table>\"]\n[h,if(isFrameVisible(\"Group Select Panel\")), CODE:{\n\t[link\t\t= \"\" ]\n\t[groupTxt\t= \"<font color='red'>When you close the <b><u>Group Select Panel<\/u><\/b> you need to restart this order panel or it won't work<\/font>\"]\n};{\n\t[link\t\t= macroLinkText(\"orderHandler@Lib:OnTokenMove\", \"none\")]\n\t[groupTxt\t= \"\"]\n}]\n\n<!-- create the frame -->\n[frame(\"Draw Order\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<!-- only onchangeselect if the group order panel is NOT open. Else the group order panel will call this function itself -->\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: link]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\t<form action='[r:macroLinkText(\"processOrder@Lib:OnTokenMove\", \"none\")]' method=\"json\">\n\t\t\t<table  cellpadding='0' cellspacing='0'>\n\t\t\t\t<tr><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-1\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-10\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-100\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-1000\">\n\t\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+1\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+10\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+100\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+1000\">\n\t\t\t\t<\/td><\/tr><tr><td colspan=4 width=196>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reorder Selection\"\t> \n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reorder ALL\"\t>\n\t\t\t\t<\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<table border=1><tr><td>min<\/td><td>[r:minOrder] <\/td><td>max<\/td><td>[r:maxOrder] <\/td><td>Total<\/td><td>[r:numSelect] <\/td><td><input type=\"submit\" name=\"button\" value=\"Help\"\t><\/td><\/tr><\/table>\n\n\t\t\t<table cellpadding='0' cellspacing='0'><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"<- Rotate Tokens\"\t> \n\t\t\t\t<\/td><td>\n\t\t\t\t\tDegr:\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Tokens ->\"\t>\n\t\t\t<\/td><\/tr><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"<- Rotate Group\"\t\t> \n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"text\"\t\tname=\"degrees\"\tvalue=\"[r:degrees]\"\tsize=\"3\"> \n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Group ->\"\t\t>\n\t\t\t<\/td><\/tr><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Random\"\t\t\t> \n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Remove Rotation\"\t\t\t>\n\t\t\t<\/td><\/tr><tr><td colspan=\"3\" align=\"center\">\n\t\t\t\t\t________________________________\n\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Submit Change\"\t>\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reset Change\"\t\t>\n\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\tLayer\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\tShape\n\t\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t<select name=\"layer\" size=\"1\">\n\t\t\t\t\t\t<option \"[r:TOKEN]\">TOKEN<\/option>\n\t\t\t\t\t\t<option \"[r:HIDDEN]\">HIDDEN<\/option>\n\t\t\t\t\t\t<option \"[r:OBJECT]\">OBJECT<\/option>\n\t\t\t\t\t\t<option \"[r:BACKGROUND]\">BACKGROUND<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t[r,if(doShape),CODE:{\n\t\t\t\t\t\t<select name=\"shape\" size=\"1\">\n\t\t\t\t\t\t\t<option \"[r:TOPDOWN]\">TOP DOWN<\/option>\n\t\t\t\t\t\t\t<option \"[r:CIRCLE]\">CIRCLE<\/option>\n\t\t\t\t\t\t\t<option \"[r:SQUARE]\">SQUARE<\/option>\n\t\t\t\t\t\t<\/select>\n\t\t\t\t\t};{b89+ only}]\n\t\t\t<\/td><\/tr><\/table>\n\t\t\t<!--\tgetTokenShape()\n\t\t\t\t\tsetTokenShape(Shape) -->\n\t\t\t\n\t\t\t[r:orderString]\n\t\t\t[r:groupTxt]\n\t\t<\/form>\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9a35da32-6830-4fb7-a32b-a7315910ea71",
          "commandChecksum": "4caf763cd6ea14e5e3a45d8bca4525ef",
          "propsChecksum": "b79ccf738566c20cbf320475db27d1b1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "2",
        "index": 236,
        "label": "orderHandler",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- orderHandler () --------------------------------------->']\n[h:maxOrderSelect\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:currentSelection\t= getSelected(\"json\")]\n[h:numSelect\t\t= json.length(currentSelection)]\n[h,if(numSelect > maxOrderSelect), CODE:{\n\t[bot_orderWarning(numSelect)]\n\t[abort(0)]\n};{}]\n\n[h, if(bot_timeOut(3)), CODE:{\n\t[bot_resetTimer(3)]\n\t[bot_orderFrame()]\n\t[bot_resetTimer(3)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "77d002bc-724b-4ac3-b873-55d5be7d17b3",
          "commandChecksum": "23a3d1b5d9ddb4fd95f9ed6117108c8e",
          "propsChecksum": "fe202dc734b20ffb13f4ad91421a3e62"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "2",
        "index": 237,
        "label": "orderWarning",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ orderFrameWarning ----------------------------------->']\n[h: tooMany\t= arg(0)]\n\n[h,if(isFrameVisible(\"Group Order Panel\")): link = \"\" ; link = macroLinkText(\"orderHandler@Lib:OnTokenMove\", \"none\")]\n\n[frame(\"Group Order\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: link]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\tYou have currently too many tokens selected: [r:tooMany]\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "682c8ba0-40fa-40d5-a968-4bc762886886",
          "commandChecksum": "127ab0a446a569f18b8bacedc1ca0dbe",
          "propsChecksum": "f2c344811b6cfafb593005f408568d21"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "3",
        "index": 238,
        "label": "processOrder",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- processOrder () --------------------------------------->']\n[h:doShape\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:result\t\t= macro.args]\n['pause(\"result\")']\n[h:toks\t\t= json.fields(result)]\n\n<!-- remove the no tokens arguments results -->\n[h:toks\t\t= listDelete(toks, listFind(toks,\"degrees\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"button\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"layer\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"shape\"))]\n\n[h:output\t\t= \"\"]\n[h:degrees\t= json.get(result, \"degrees\")]\n[h:setLibProperty('w42.bot.processOrder.degrees',degrees, 'lib:EventMacros')]\n\n<!-- set layer -->\n[h:layer\t\t= json.get(result, \"layer\")]\n[h,if(listCount(toks)):oldLayer = getLayer(listGet(toks,0)) ; oldLayer = layer]\n[h,if(layer != oldLayer), CODE:{\n\t[foreach(tok, toks): setLayer(layer, tok)]\n};{}]\n\n<!-- set shape -->\n[h,if(doShape), CODE:{\n\t[shape\t\t= json.get(result, \"shape\")]\n\t[if(listCount(toks)):oldShape = getTokenShape(listGet(toks,0)) ; oldShape = shape]\n\t[if(shape != oldShape), CODE:{\n\t\t[foreach(tok, toks), CODE:{ \n\t\t\t[token(tok):setTokenShape(shape)]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n''\n};{}]\n\n<!-- do the buttons -->\n[h:button\t= json.get(result, \"button\")]\n\n<!-- apply new draw order -->\n[h,if(isNumber(button)), CODE:{\n\t[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok)+button, tok)]\n};{\n\t<!-- apply the other stuff -->\n\t[switch(button),code:\n\tcase \"Reorder Selection\": {\n\t\t[selected\t= getSelected(\"json\")]\n\t\t[bot_reOrderTokens(selected)]\n\t\t[selectTokens(selected, 0, \"json\")]\n\t};\n\tcase \"Reorder ALL\": {\n\t\t[selected\t= getSelected(\"json\")]\n\t\t[bot_reOrderTokens()]\n\t\t[selectTokens(selected, 0, \"json\")]\n\t};\n\tcase \"<- Rotate Tokens\" : {\n\t\t[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)+degrees, tok)]\n\t};\n\tcase \"Rotate Tokens ->\" : {\n\t\t[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)-degrees, tok)]\n\t};\n\tcase \"<- Rotate Group\" : {\n\t\t[bot_rotateCCW()]\n\t};\n\tcase \"Rotate Group ->\" : {\n\t\t[bot_rotateCW()]\n\t};\n\tcase \"Rotate Random\" : {\n\t\t[stepSize\t= round(360/degrees,0)]\n\t\t[foreach(tok, toks): bot_setTokenFacing(roll(1,stepSize)*degrees, tok)]\n\t};\n\tcase \"Remove Rotation\" : {\n\t\t[foreach(tok, toks): removeTokenFacing(tok)]\n\t};\n\tcase \"Submit Change\": {\n\t\t[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok), tok)]\n\t};\n\tcase \"Reset Change\": {\n\t};\n\tcase \"Help\": {\n\t\t[output\t= \"\n\t\tThis panel can be used for reordering the draw order (aka z-order) of the tokens on the map. If you select a couple of tokens you will notice that they appear below. Some pointers:<br>\n\t\t<br>\n\t\t<table><tr><td width='100'>\n\t\t\t<b>MIN/MAX/Total<\/b>\t\t<\/td><td>The min/max shows the minimum and maximum draw order of the current selection. <\/td><\/tr><tr><td>\n\t\t\t<b>Z-ORder<\/b>\t\t\t\t<\/td><td>You can enter a draw order number directly next to the token. When you click 'submit change' it will be applied<\/td><\/tr><tr><td>\n\t\t\t<b>reset change<\/b>\t\t\t<\/td><td>resets the changes you've just made (but does not undo applied changes)<\/td><\/tr><tr><td>\n\t\t\t<b>+/- 1/10/100/1000<\/b>\t<\/td><td>adds that number to the z-order of the current selection<\/td><\/tr><tr><td>\n\t\t\t<b>reorder all<\/b>\t\t\t<\/td><td>orders ALL TOKENS ON ALL LAYERS in consecutive order, starting at 0. Their relative order remains intact<\/td><\/tr><tr><td>\n\t\t\t<b>reorder selection<\/b>\t<\/td><td>orders all currently selected tokens consecutively, starting at the lowest value order. Their relative order remains intact. <\/td><\/tr><tr><td>\n\t\t\t<b><- Rotate Tokens<\/b>\t<\/td><td>Rotates the individual tokens the give amount of degrees Counter Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Tokens -><\/b>\t\t<\/td><td>Rotates the individual tokens the give amount of degrees Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b><- Rotate Group<\/b>\t<\/td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Counter Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Group -><\/b>\t\t<\/td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Random<\/b>\t\t<\/td><td>Rotates the individual tokens the give amount of degrees in random steps. So e.g. 90 degrees will rotate a token either 0,90,180,270 degrees<\/td><\/tr><tr><td>\n\t\t\t<b>Remove Rotations<\/b>\t\t<\/td><td>Clears token facing<\/td><\/tr><tr><td>\n\t\t\t<b>Layer<\/b>\t\t\t\t<\/td><td>Will set ALL selected tokens to the layer of your choice<\/td><\/tr><tr><td>\n\t\t\t<b>Shape<\/b>\t\t\t\t<\/td><td>(b89+) Will set ALL selected tokens to the shape of your choice.\n\t\t<\/td><\/tr><table>\n\t\t\"]\n\t};\n\tdefault: {}]\n\n}]\n[h,if(output != \"\"), CODE:{\n\t[frame(\"Group Order Help\", \"width=500; height=100; temporary=1\"): {[r:output]}]\n};{}]\n\n[h:bot_orderFrame()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "05b3e45c-712c-478b-a164-55d252324a88",
          "commandChecksum": "688ef4fa0922bb55347ae7595e040ce9",
          "propsChecksum": "95d53a87b2f364bfe8aeeb6c025ecfb2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "4",
        "index": 239,
        "label": "reOrderTokens",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- reOrderTokens ([array of tokens]) --------------------------------------->']\n\n<!-- \nget all tokens from map and store them in a json array as json objects with id and current order \nOR\nget all the tokens currently fed to the function\n-->\n[h: hasArg\t= argCount()]\n[h,if(hasArg): ids\t= arg(0) ; ids = getTokens(\"json\", json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")))]\n\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n<!-- set the new draw orders for all the tokens -->\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n<!-- if its a selection that needs to be reordered then start with the lowest entry of the selection. Else start at 0 -->\n[h:i\t\t= if(hasArg, json.get(json.get(jsonOrder, 0), \"order\"), 0)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group), CODE:{\n\t\t[id\t= json.get(item, \"id\")]\n\t\t[setTokenDrawOrder(i,id)]\n\t\t[i\t= i + 1]\n\t}]\n}]\n\n<!-- broadcast the old order -->\n[output\t= if(hasArg, \"The z-order of the selected tokens have been reordered\", \"The z-order of ALL the tokens on the entire map have been reordered\")]\n[h:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85d5646d-ff6e-42cc-8276-cac567d929da",
          "commandChecksum": "8b6470ab5376be1f1050fcc5dc0f6ef7",
          "propsChecksum": "c2a9ee244080bd5fcce9b1bfb82ee5ca"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "11. Order",
        "includeLabel": false,
        "sortBy": "13",
        "index": 240,
        "label": "sendToBack",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- sendToBack (Current Selection) --------------------------------------->']\n\n<!-- bring current selection to front -->\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n<!-- sort the json according to the current order -->\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n<!-- bring current selection to front -->\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): sendToBack(json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens have been send to back\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3e79abc8-e7a9-4265-a61a-457b95b13aa0",
          "commandChecksum": "f05b5963359fb46e73ca0069f5dd2c1d",
          "propsChecksum": "f3a5422f2ce94a6a6f2d082d5aebb6c7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "43",
        "index": 241,
        "label": "buildField",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- buildField --------------------------------------------------- -->']\n\n[h:closeDialog(\"Map Editor\")]\n[H:layer\t= json.get(macro.args, \"layer\")]\n[h:removeToken(json.get(macro.args, \"bound1\"))]\n[h:removeToken(json.get(macro.args, \"bound2\"))]\n\n[h:xmin\t= getLibProperty(\"mapField.xMin\", \"lib:EventMacros\")]\n[h:ymin\t= getLibProperty(\"mapField.yMin\", \"lib:EventMacros\")]\n[h:xmax\t= getLibProperty(\"mapField.xMax\", \"lib:EventMacros\")]\n[h:ymax\t= getLibProperty(\"mapField.yMax\", \"lib:EventMacros\")]\n[h:BASE\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h:fieldToks\t= \"\"]\n[h,for(x, xmin, xmax+1), CODE:{\n\t[for(y, ymin, ymax+1), CODE:{\n\t\t[lastCopy\t= copyToken(\"GridCoordMarker\", 1, BASE, json.set(\"{}\", \"x\", x, \"y\", y, \"layer\", layer))]\n\t\t[fieldToks\t= json.append(fieldToks, lastCopy)]\n\t}]\n}]\n\n[h:setLibProperty(\"fieldToks\", fieldToks, \"lib:EventMacros\")]\n[h:selectTokens(lastCopy)]\n[h:bot_fieldEditDialog()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3f4b9cf5-9695-4b08-b355-8b75804321e7",
          "commandChecksum": "46b889be87ae0b5c97e2bc61e2756149",
          "propsChecksum": "33ece882042c1ccc3590c6c9963d879d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "21",
        "index": 242,
        "label": "buildForest",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ------------------------------------- buildForest ------------------------------------------------------------------- -->']\n<!-- <html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area<\/html> -->\n[h: '<!-- check if tokens are selected -->']\n[h: tokList = getSelected()]\n[h: assert(tokList != \"\", \"No token(s) have been selected\")]\n[h: maxDensity = 20]\n[h: '<!-- input asking type of token to scatter (defaults to Canopy) has also the option NOT to use a special token -->']\n[h: '<!-- input also asks for several settings like size of area, rotation on off, density of tokens in that area -->']\n[h:specNameList = \"No special token, Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop\"]\n\n[h:densityList = \"\"]\n[h,count(maxDensity):densityList = listAppend(densityList,roll.count+1)]\n[h:layerList = \"TOKEN, HIDDEN, OBJECT, BACKGROUND\"]\n\n[h:'<!-- first check if the special token is freesize or not. If freesize retrieve its w42.size, if thats not set, set it to 1 -->']\n[h:tokChkList = \"\"]\n[h:i = 0]\n[h,foreach(tok, tokList), CODE:{\n\t[size = getSize(tok)]\n\t[if(size == \"\"), CODE:{\n\t\t[tokChkList = listAppend(tokChkList, tok)]\n\t\t[xSize = getProperty(\"w42.bot.xSize\", tok)]\n\t\t[ySize = getProperty(\"w42.bot.ySize\", tok)]\n\t\t[if(isNumber(xSize)):set(\"xSize\" + i, xSize); set(\"xSize\" + i, 1)]\n\t\t[if(isNumber(ySize)):set(\"ySize\" + i, ySize); set(\"ySize\" + i, 1)]\n\t\t[i = i + 1]\n\t}; {\n\t\t[switchToken(tok)]\n\t\t[bot_determineTokSize()]\n\t}]\n}]\n\n[h:'<!-- set the tok ids into names -->']\n[h:tokNameList = bot_ids2Names(tokChkList)]\n\n[h:'<!-- build the entire input string and ask for the token sizes IF theyre freesize-->']\n[h:inputStr = \"\"]\n[h:inputStr = listAppend(inputStr, \t\"junk|<html><b>make sure that freesize images are NOT snapped to grid!!<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"tokenName|\"+specNameList+\"|Type of token to scatter over the map?|LIST|VALUE=STRING SELECT=1\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"areaWidth|75|Width of designated area\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"areaLength|75|Length of designated area\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"density|\"+densityList+\"|Choose the density of the area (20 is the most dense)?|LIST|VALUE=STRING SELECT=14\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"layer|\"+layerList+\"|Choose the layer where the tokens are scattered?|LIST|VALUE=STRING SELECT=2\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"rotate|1|Rotate images when scattering?|CHECK\", \"@\")]\n\n[h, if(listCount(tokNameList)): inputStr\t= listAppend(inputStr, \"junk|<html><b>Set Size (in Cells) of Images<br><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n[H,FOREACH(tok, tokNameList), CODE:{\n\t[varNameX = \"xSize\"+roll.count]\n\t[varNameY = \"ySize\"+roll.count]\n\t[ inputStr = listAppend(inputStr, varNameX+\"|\"+eval(varNameX)+\"|Set size width (left to right)(in number of cells) of token: \"+tok, \"@\") ]\n\t[ inputStr = listAppend(inputStr, varNameY+\"|\"+eval(varNameY)+\"|Set size length (top to bottom)(in number of cells) of token: \"+tok, \"@\") ]\n}]\n\n[h:'<!-- create the dialog string -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[H,FOREACH(tok, tokNameList), CODE:{\n\t[varNameX = \"xSize\"+roll.count]\n\t[varNameY = \"ySize\"+roll.count]\n\t[setProperty(\"w42.bot.xSize\", eval(varNameX), tok)]\n\t[setProperty(\"w42.bot.ySize\", eval(varNameY), tok)]\n\n}]\n\n[h: '<!-- rename selected tokens to \"Canopy n\" -->']\n[h, if(tokenName == \"No special token\"): tokenName = \"\"]\n[h, foreach(tok, tokList), CODE:{\n\t[token(tok), if(tokenName != \"\"): token.name = tokenName + \" \" + token.name]\n}]\n[h:bot_renumberToks(tokenName, tokList)]\n\n[h: '<!-- calculate dialog settings for scatter function based on settings -->']\n[h: area = areaWidth * areaLength]\n[h: numToks = listCount(tokList)]\n\n[h: numCopies\t= floor(  area * (density / maxDensity) * (1 / numToks) * 1/4    )]\n[h: spread\t\t= maxDensity + 1 - density]\n[h: distNorth\t= floor(areaLength /2)]\n[h: distSouth\t= ceil(areaLength /2)]\n[h: distEast\t= floor(areaWidth /2)]\n[h: distWest\t= ceil(areaWidth /2)]\n[h: ids\t\t\t= json.fromList(tokList)]\n[h: multiToken\t= \"ofEach\"]\n[h: rotation\t= if(rotate, \"Free\", \"None\")]\n[h: sizeRange\t= -1]\n\n[h: '<!-- run scatter with selected and calculated settings -->']\n[h:args = json.set(\"{}\", \"numCopies\", numCopies, \"distNorth\", distNorth, \"distEast\", distEast, \"distSouth\", distSouth, \"distWest\", distWest, \"ids\", ids, \"spread\", spread, \"layer\", layer, \"rotation\", rotation, \"multiToken\", multiToken, \"sizeRange\", sizeRange, \"tokenName\", tokenName)]\n[r,macro(\"scatterImages@this\"): args]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f07dfd99-af8c-4701-b6aa-69b4334d47ce",
          "commandChecksum": "2e2ba26cce4dc1476e44a3f3556074d7",
          "propsChecksum": "7bf6a6ef57f44d2ea475deabdcbedb4f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "13",
        "index": 243,
        "label": "chooseCrowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- ------------------------------ chooseCrowd ---------------------------------------------- -->']\n<!-- \n\t<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html> \n-->\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:'<!-- no new scope -->']\n[h: bot_getValidCrowd(useCurrentMap)]\n\n[h:'<!-- build the entire input string -->']\n[h:inputStr\t= \"junk|<html><b>Choose the images you wish to use<br><\/html>|-|LABEL|SPAN=TRUE\"]\n[H,FOREACH(tok, fancyCrowdList), CODE:{\n\t[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',\"@\")]\n\t[ inputStr = listAppend(inputStr, \"tok\"+roll.count+\"|1|\"+tok+\"|CHECK\",\"@\")]\n}]\n\n[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h:crowd.tokens = \"[]\"]\n[H,FOREACH(id, crowdTokens), CODE:{\n\t[if(eval(\"tok\"+roll.count)): crowd.tokens = json.append(crowd.tokens, id)]\n}]\n\n[h:setLibProperty(\"crowd.tokens\", crowd.tokens,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3eb8e574-bde7-4a91-9cd7-6c77f9721cfd",
          "commandChecksum": "99b17274f7338946624d52129b5aced7",
          "propsChecksum": "f253aade55269ca1112259334e1ba2be"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "22",
        "index": 244,
        "label": "chooseTrunks",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- chooseTrunks -->']\n<!-- \"html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html> -->\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:'<!-- no new scope -->']\n[h: bot_getValidTrunks(useCurrentMap)]\n\n[h:'<!-- build the entire input string -->']\n[h:inputStr\t= \"junk|<html><b>Choose the trunks you wish to use<br><\/html>|-|LABEL|SPAN=TRUE\"]\n[H,FOREACH(treeTrunk, fancyTrunkList), CODE:{\n\t[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',\"@\")]\n\t[ inputStr = listAppend(inputStr, \"image\"+roll.count+\"|1|\"+treeTrunk+\"|CHECK\",\"@\")]\n}]\n\n[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h:treeTrunkImages = \"\"]\n[H,FOREACH(id, treeTrunkImageList), CODE:{\n\t[if(eval(\"image\"+roll.count)): treeTrunkImages = listAppend(treeTrunkImages, id)]\n}]\n\n[h:setLibProperty(\"treeTrunkImages\", treeTrunkImages,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d5ea51d7-9720-43f8-bc7c-244e7a90c56d",
          "commandChecksum": "94488fffbb7b29741733e1713964175d",
          "propsChecksum": "a24687780319cd94e9c86b633ca00e65"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "11",
        "index": 245,
        "label": "createCrowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[dialog(\"Create Crowd\", \"temp=1; closebutton=0; width=300; height=450\"): {\n    [macro(\"crowdDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eb17e6a8-21ce-4cd4-864f-6c5dc776a566",
          "commandChecksum": "be0b5985c3b04f42fcf72d427e8f0f8f",
          "propsChecksum": "0091b6bc5a1f82ee48608e7fa5fcd744"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "12",
        "index": 246,
        "label": "crowdDialog",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- CrowdDialog -->']\n[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']\n\n[h:selList\t\t= getLibProperty(\"crowd.tokens\", \"lib:EventMacros\")]\n[h:boundaryToks\t= getSelected(\"json\")]\n[h:boundaryChk\t= if(json.length(boundaryToks) == 2, 1,0)]\n\n[h,if(boundaryChk), CODE:{\n\t[boundaryTok0\t= json.get(boundaryToks, 0)]\n\t[boundaryTok1\t= json.get(boundaryToks, 1)]\n\t[x0\t\t\t\t= getTokenX(0, boundaryTok0)]\n\t[y0\t\t\t\t= getTokenY(0, boundaryTok0)]\n\t[x1\t\t\t\t= getTokenX(0, boundaryTok1)]\n\t[y1\t\t\t\t= getTokenY(0, boundaryTok1)]\n};{\n\t[boundaryTok0\t= \"\"]\n\t[boundaryTok1\t= \"\"]\n\t[x0\t\t\t\t= 0]\n\t[y0\t\t\t\t= 0]\n\t[x1\t\t\t\t= 0]\n\t[y1\t\t\t\t= 0]\n}]\n\n[h:xmin\t\t\t= min(x0,x1)]\n[h:ymin\t\t\t= min(y0,y1)]\n[h:xmax\t\t\t= max(x0,x1)]\n[h:ymax\t\t\t= max(y0,y1)]\n\n[h:setLibProperty(\"crowd.xMin\", xmin, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.yMin\", ymin, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.xMax\", xmax, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.yMax\", ymax, \"lib:EventMacros\")]\n\n<!-- upper left token -->\n[h:tokUL\t\t= if(xmin == x0, boundaryTok0, boundaryTok1) ]\n<!-- assert if upper left is actually upper left and not lower left -->\n\n[h:distNorth\t= 0]\n[h:distWest\t\t= 0]\n\n[h:distEast\t\t= xmax - xmin]\n[h:distSouth\t= ymax - ymin]\n\n<html>\n\t<head>\n\t\tCreate Crowd\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' \n\t\t\t\t\thref='[r:macroLinkText(\"createCrowd@this\")]'>\n\t<\/head>\n\t<body>\n\t<form name=in action=[r:macroLinkText(\"scatterImages@this\")] method=\"json\">\n\t\t<input type=\"hidden\" name=\"distNorth\"\t\tvalue='[r:distNorth]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distEast\"\t\tvalue='[r:distEast]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distSouth\"\t\tvalue='[r:distSouth]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distWest\"\t\tvalue='[r:distWest]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"ids\"\t\t\t\tvalue='[r:selList]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"boundaryToks\"\tvalue='[r:boundaryToks]'><\/input>\n\t\t<input type=\"hidden\" name=\"multiToken\"\t\tvalue='randomlySelected'><\/input>\n\t\t<input type=\"hidden\" name=\"map\"\t\t\t\tvalue='[r:getLibProperty(\"baseMapName\",\"Lib:EventMacros\")]'><\/input>\n\t\t<input type=\"hidden\" name=\"centreTok\"\t\tvalue='[r:tokUL]'>\t\t<\/input>\n\t\t<input type=\"hidden\" name=\"sizeRange\"\t\tvalue='0'>\t\t\t\t<\/input>\n\t\t<input type=\"hidden\" name=\"macro\"\t\t\tvalue='createCrowd'>\t<\/input>\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th width=70% align='right'>\n\t\t\t\t\t<label for=\"numCopies\">How many people:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=30%>\n\t\t\t\t\t<input name=\"numCopies\" value=\"100\"><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"rotation\">Facing of the crowd:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<select name=\"rotation\">\n\t\t\t\t\t\t<option value=\"Free\" selected=\"selected\">Free<\/option>\n\t\t\t\t\t\t<option value=\"SquareEdges\">Square (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"Square\">Square<\/option>\n\t\t\t\t\t\t<option value=\"VHexEdges\">Vertical Hex (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"VHex\">Vertical Hex<\/option>\n\t\t\t\t\t\t<option value=\"HHexEdges\">Horizontal Hex (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"HHex\">Horizontal Hex<\/option>\n\t\t\t\t\t\t<option value=\"None\">None<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<div title=\"This is my tooltip\"><label for=\"layer\">Layer to place crowd:<\/label><\/div>\n\t\t\t\t<\/th>\n\t\t\t\t<td>\n\t\t\t\t\t[h,if(json.isEmpty(boundaryToks)), code: {\n\t\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t\t} ; {\n\t\t\t\t\t\t[h: obj = json.get(boundaryToks, 0)]\n\t\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t\t}]\n\t\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"spread\">Spreading:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"spread\" value = 0><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"speed\">Flee Speed (#cells):<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"speed\" value = 2d6><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"antagonist\">Antagonists:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"antagonist\" value = '<enter list of tokens>'><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t\n\t\t\t[r,if(json.length(boundaryToks) == 2), CODE:{\n\t\t\t\t[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{\n\t\t\t\t\t<tr><td align='right'>Upper Left:\t\t<\/td><td>([r:xmin],[r:ymin])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Lower Right:\t<\/td><td>([r:xmax],[r:ymax])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Covered Area:\t<\/td><td>([r:distEast],[r:distSouth]) cells<\/td><\/tr>\n\t\t\t\t};{\n\t\t\t\t\t<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)<\/td><\/tr>\n\t\t\t\t}]\n\t\t\t};{\n\t\t\t\t<tr><td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the crowd scene.<\/td><\/tr>\n\t\t\t}]\n\t\t<\/table>\n\t\t<table width=33% align=center>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t[r,if(json.isEmpty(selList) != 1), code: {\n\t\t\t\t\t\t<input type=submit name=go value=\"Build Crowd\"><\/input>\n\t\t\t\t\t};{\n\t\t\t\t\t\t<font color='red'>No crowd tokens found. Use 'Choose Crowd' macro in the setup panel.<\/font>\n\t\t\t\t\t}]\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\t<b>Short Manual<\/b><br>\n\t\tYou can typically use this to emulate a square or bar where (e.g.) a 'fight goes down'. Especially if people start throwing grenades, the general public has the tendancy to move itself in the exact opposite direction.<br><br>\n\t\tAlternatively you can emulate a <i>Zombie Fest<\/i> where the the crowd is moving TOWARDS the event instead of away.<br>\n\t\tThat is what this tool does.<br><br>\n\t\tThe steps:<br>\n\t\t1. Put two tokens in the corners of the square you wish to populate (make sure that they are UPPER LEFT and LOWER RIGHT). Select (only!) the two tokens.<br>\n\t\t2. Enter the fields explained below<br>\n\t\t3. Hit the 'Move Crowd' or 'Move Crowd +' button on the campaign panel (or BoT panel) <br>\n\t\tThe former simply moves the crowd to the border or the area. The latter does the same but more intelligently. E.g A token stops when running into another and has 50% chance to fall prone (hence the requirement of the prone state). It also is removed when it crosses the border. Prone tokens stand up the next round.<br>\n\t\tIn terms of time: on an average computer it takes roughly 0.5 seconds to do 100 tokens with 'Move Crowd', while the '+' version takes about 13 seconds for the same 100 tokens. Both buttons can be used at all times, also alternately. They just calculate the current crowd differently. \n\t\t<br><br>\n\t\t<b>Note<\/b> that for now only ONE crowd per CAMPAIGN is allowed (so NOT per map), if you create a second crowd either on the same or other map, the original crowd settings will be overwritten.<br><br>\n\t\t\n\t\t<b>Explanation of the fields<\/b>\n\t\t<table border=1 cellpadding=2>\n\t\t<tr><td valign='top'>How many:\t\t\t\t\t<\/td><td>\tis simply the amount of tokens that will populate the square. Keep the number below 1000 !!.\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Facing:\t\t\t\t\t<\/td><td>\twhen the tokens are distributed there facing (rotation) can be set randomly. Determine the method.\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Layer to place the crowd:\t<\/td><td>\tI guess thats evident.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Spreading:\t\t\t\t\t<\/td><td>\t<b>-1<\/b> means, just drop the n tokens and leave them.<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>0<\/b> means that tokens that are on top of eachother are removed.<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>1 and higher<\/b> are the number of cells that will AT LEAST be between two tokens.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis is achieved by REMOVING tokens that are too close. Which means that if you don't enter -1 its most likely that the total crowd will consist out of less then the number you entered in the 'How Many' box.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Flee Speed: \t\t\t\t<\/td><td>\tWhen everything is setup, you can hit the 'Move Crowd' macro that will move each individual token a number of cells equal to the given number here. This CAN be code, like 2d6.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>Note:<\/b><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif you want to emulate a <i>'Zombie Fest'<\/i>, that is have the crowd move TOWARDS the antagonists, simply enter a negative number, e.g. -3d4.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Antagonist: \t\t\t\t<\/td><td>\tHere you enter one or more names of the token(s) from which 'The Crowd' is running from.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>Notes:<\/b><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- you can move this/these tokens during the crowd movement, which WILL influence their path!!<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- If you enter multiple token names, seperate their names by comma \",\". E.g. <i>Dragon, Dragon 1, Dragon 2, etc.<\/i>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t<\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1246ca22-8b0d-4d2e-a953-47faea4092a2",
          "commandChecksum": "d178a177ed8ae189c1083b9b31c9a58b",
          "propsChecksum": "c5d0a020075aa57ac5a3ae2df10bdfdd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "33",
        "index": 247,
        "label": "deferFinishScatter",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- deferFinishScatter -->']\n\n[h: tokenName\t\t= arg(0)]\n<!-- either createCrowd or scatterToken -->\n[h: macro\t\t\t= arg(1)]\n[h: remainingCopies = arg(2)]\n\n[h,if(macro == \"scatterToken\"), CODE:{\n\t[if(tokenName != 0): bot_renumberToks(tokenName)]\n\t[bot_initializePads()]\n};{\n\t[setLibProperty(\"crowd\", remainingCopies, \"lib:EventMacros\")]\n}]\n\n[h: broadcast(\"Spread Calculations are finished\")]\n[h: closeFrame(\"Progress Bar\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "faf85504-a221-4ee5-ab3e-b7121dd2baeb",
          "commandChecksum": "9705b93077e301be9c21202daae7b58c",
          "propsChecksum": "7cd80f638b16d26243f9e80d3a7a715c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "32",
        "index": 248,
        "label": "deferRemoveToken",
        "fontSize": "0.90em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ---------------------------------------------- deferRemoveToken ---------------------------------------------------- -->']\n\n[h:assert(getLibProperty(\"abortProcess\", \"lib:EventMacros\")!=0, \"Process Aborted\", 0))]\n\n[h: '<!-- the defer is needed cause in a foreach loop it will loop from 1 to n even if certain numbers have already been removed due to  the check. So foreach will not work, a defer where the first of the chklist is checked and then removed from that list INCLUDING every token that is removed in the check, does work.  -->']\n\n[h:copies\t\t\t= arg(0)]\n[h:layer\t\t\t= arg(1)]\n[h:spread\t\t\t= arg(2)]\n[h:tokenName\t\t= arg(3)]\n[h:totalCopies\t\t= arg(4)]\n[h:macro\t\t\t= arg(5)]\n[h:remainingCopies\t= arg(6)]\n\n[h:currentIteration = json.length(copies)]\n[h:broadcast(\"Tokens left to check: \" + currentIteration)]\n\n[h:prog.percentage = floor(100*currentIteration/totalCopies)]\n\n[h:output\t= \"\n\t<table width=305px bgcolor='red'><tr><td>\n\t\t<table width=\" + 3*prog.percentage + \"px bgcolor = 'green' color='white'><tr><td>\" + prog.percentage + \"%  \" + if(band(currentIteration,1), '0', 'o') + \"<\/td><\/tr><\/table>\n\t<\/td><\/tr><\/table>\n\t\n\t  \n\t<table width=100px bgcolor='black' cellpadding='1'>\n\t\t<table width=100% bgcolor='red'><td align='center')>\n\t\t\t<td>\n\t\t\t\t<span  style='text-decoration:none; color:yellow'>\n\t\t\t\t\t\" + macroLink('Abort process', 'abortProcess@lib:OnTokenMove', '', 0) + \"\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n\t<\/table>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Progress Bar\", \"width=410; height=10; temporary=0; input=1\"): {[r:output]}]\n};{\n\t[frame(\"Progress Bar\", \"width=410; height=10; temporary=0\"): {[r:output]}]\n}]\n\n[h:'<!----------------------------- ACTUAL LOOP -->']\n\n[h:'<!-- pick a random token from the list so if you scatter three different tokens the first wont dominate the field -->']\n[tok\t\t\t\t= json.get(copies,roll(1,json.length(copies))-1)]\n[if(findToken(tok) != \"\"), CODE:{\n\t[setTokenDrawOrder(1d1000, tok)]\n\t[conditions\t\t\t= \"{'layer':'\"+layer+\"', 'range':{'token':'\"+tok+\"', 'distancePerCell':0, 'upto':\"+spread+\"}}\"]\n\t[toRemove\t\t\t= bot_ids2NamesArray(getTokens(\"json\", conditions))]\n\t[FOREACH(remTok, toRemove), if(json.contains(remainingCopies, remTok)): removeToken(remTok)]\n\t[remainingCopies\t= json.difference(remainingCopies,toRemove)]\n\t[copies\t\t\t\t= json.difference(copies, toRemove)]\n};{}]\n[copies\t\t\t\t= json.difference(copies, json.append(\"[]\",tok))]\n\n['remainingCopies = json.sort(remainingCopies)']\n['copies = json.sort(copies)']\n['toRemove = json.sort(toRemove)']\n['pause(\"remainingCopies\",\"toRemove\", \"copies\", \"tok\")']\n[h:'<!----------------------------- /ACTUAL LOOP -->']\n\n[if(!json.isEmpty(copies)):\n\texecLink(macroLinkText(\"deferRemoveToken@lib:onTokenMove\",\"none\",json.append(\"\",copies,layer,spread,tokenName,totalCopies, macro, remainingCopies)),1)\n; \n\texecLink(macroLinkText(\"deferFinishScatter@lib:onTokenMove\",\"none\",json.append(\"\",tokenName,macro,remainingCopies)),1)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7dc9aa4c-4def-4bce-8258-73904d00aeb9",
          "commandChecksum": "bcf09f7bdff17c14bdc14bb2aabd4111",
          "propsChecksum": "d27e5f2eb60b0785a272506a5d073e84"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "44",
        "index": 249,
        "label": "fieldEditDialog",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- -------------------------------- fieldEditDialog ------------------------------------- -->']\n\n[h, if(bot_timeOut(4)), CODE:{\n\t[bot_resetTimer(4)]\n\n\t[h:selected\t\t= getSelectedNames(\"json\")]\n\t[assert(json.length(selected)==1, \"\",0)]\n\t[h:selTok\t\t= json.get(selected, 0)]\n\n\t[h:imgTok\t\t= macro.args]\n\t[h:x\t\t\t= 0]\n\t[h:y\t\t\t= 0]\n\n\t[h,if(startsWith(selTok, \"GridCoordMarker\")), CODE:{\n\t\t[coordToken = selTok]\n\t\t[existImg\t= if(findToken(imgTok) != \"\", 1, 0)]\n\t};{\n\t\t[coordToken = \"\"]\n\t\t[imgTok\t\t= selTok]\n\t\t[existImg\t= 1]\n\t}]\n\n\t[h:xmin\t= getLibProperty(\"mapField.xMin\", \"lib:EventMacros\")]\n\t[h:ymin\t= getLibProperty(\"mapField.yMin\", \"lib:EventMacros\")]\n\t[h:xmax\t= getLibProperty(\"mapField.xMax\", \"lib:EventMacros\")]\n\t[h:ymax\t= getLibProperty(\"mapField.yMax\", \"lib:EventMacros\")]\n\t[h:BASE\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n\t[if(coordToken != \"\" && findToken(imgTok) != \"\"), CODE:{\n\t\t[x\t= getTokenX(0, coordToken)]\n\t\t[y\t= getTokenY(0, coordToken)]\n\t\t['pause(\"x\",\"y\",\"coordToken\",\"imgTok\")']\n\t\t[tmpState\t= getState(\"editFieldMarker\",imgTok)]\n\t\t[setState(\"editFieldMarker\", 1, imgTok)]\n\t\t\t[newImgTok\t=\tgetName(copyToken(imgTok, 1, getCurrentMapName(), json.set(\"{}\", \"x\", x, \"y\", y)))]\n\t\t[setState(\"editFieldMarker\",tmpState, imgTok)]\n\t\t[imgTok\t\t\t= newImgTok]\n\t};{}]\n\n\t[if(existImg), CODE:{\n\t\t[switchToken(imgTok)]\n\t\t[imgTok\t\t= token.name]\n\t\t[htmlImg\t= \"<img src='\"+getTokenImage(100)+\"'><\/img>\"]\n\t};{\n\t\t[htmlMsg\t= \"Select ANY (not map field) token and the click on the field to auto-copy-paste it there\"]\n\t\t[imgTok\t\t= \"\"]\n\t}]\n\n\t[h:macroLink\t= macroLinkText(\"fieldEditDialog@this\", \"none\", imgTok)]\n\n\t[frame(\"Map Editor\", \"temp=1; closebutton=0; width=200; height=200\"): {\n\t\t<html>\n\t\t\t<head>\n\t\t\t\tMap Editor\n\t\t\t\t<link rel='stylesheet' type='text/css' \n\t\t\t\t<link rel='onChangeSelection' type='macro' href='[r:macroLink]')>\n\t\t\t<\/head>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr><td>Current edit token<\/td><\/tr>\n\t\t\t\t\t<tr><td>[r,if(existImg):htmlImg ; htmlMsg]\n\t\t\t\t\t<\/td><\/tr>\n\t\t\t\t<\/table>\n\t\t\t<\/body>\n\t\t<\/html>\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "94f9dcf1-6efb-4716-ac5b-c7cbb2ca6cc4",
          "commandChecksum": "a31c56d80fd78cadb58d3a3019d0066f",
          "propsChecksum": "0f7254d9ee836b8e3c7c0389ba3a9e82"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "14",
        "index": 250,
        "label": "getValidCrowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- getValidCrowd(useCurrentMap) -->']\n\n[H: '<!-- based on Orpheus WoD campaign macro -->']\n[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n[h, if(useCurrentMap):setCurrentMap(oldMap)]\n\n[h:conditions\t\t= '{\"layer\":\"TOKEN\"}']\n[h:tokenList\t\t= getTokenNames(\",\",conditions)]\n[h:tokenList \t\t= listSort(tokenList, \"N\")]\n\n[h:fancyCrowdList\t= \"\"]\n[h:crowdTokens\t\t= \"\"]\n\n[h:foundOne\t\t\t= 0]\n[H,FOREACH(tok, tokenList), CODE:{\n\t[h, if(startsWith(tok, \"Crowd\")), CODE:{\n\t\t[token(tok): assetID\t= getTokenImage()]\n\t\t[crowdTokens\t\t\t= listAppend(crowdTokens, tok)]\n\t\t[fancyCrowdList\t\t\t= listAppend(fancyCrowdList, '<html><span style=\"color:black; vertical-align:middle\"  >'+tok+'<\/span><img src=\"'+assetID+'\" height=\"100\" width=\"100\"><\/img><\/html>')]\n\t\t[foundOne\t\t\t\t= 1]\n\t};{}]\n}]\n\n[h:assert(foundOne,\"There are no tokens found which names start with 'Crowd' on THE TOKEN LAYER of map:\"+baseMapName+\". Make sure you have these images on the object layer of that map before running this macro\",0)]\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e1a2384a-81a8-4a4f-9f54-a4a1c76d1739",
          "commandChecksum": "1733cc0c399a01b5d8008d3154aa2759",
          "propsChecksum": "158fa322112e87bea1a15d3a3db751d7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "23",
        "index": 251,
        "label": "getValidTrunks",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- getValidTrunks(useCurrentMap) -->']\n[H: '<!-- based on Orpheus WoD campaign macro -->']\n[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h: oldMap = getCurrentMapName()]\n[h:baseMapName = getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n[h, if(useCurrentMap):setCurrentMap(oldMap)]\n\n[h:conditions\t= '{\"layer\":\"OBJECT\"}']\n[h:tokenList\t= getTokenNames(\",\",conditions)]\n[h:tokenList \t= listSort(tokenList, \"N\")]\n\n[h:fancyTrunkList\t= \"\"]\n[h:treeTrunkImageList\t= \"\"]\n\n[h:foundOne\t\t= 0]\n[H,FOREACH(tok, tokenList), CODE:{\n\t[h, if(startsWith(tok, \"Trunk\")), CODE:{\n\t\t[token(tok): assetID = getTokenImage()]\n\t\t[treeTrunkImageList = listAppend(treeTrunkImageList, assetID)]\n\t\t[fancyTrunkList = listAppend(fancyTrunkList, '<html><span style=\"color:black; vertical-align:middle\"  >'+tok+'<\/span><img src=\"'+assetID+'\" height=\"100\" width=\"100\"><\/img><\/html>')]\n\t\t[foundOne\t\t= 1]\n\t}; {}]\n}]\n[h:assert(foundOne,\"There are no tokens found which names start with 'Trunk' on THE OBJECT LAYER of map:\"+baseMapName+\". Make sure you have these images on the object layer of that map before running this macro\",0)]\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a86e0488-4504-4a51-9714-520f35db6db3",
          "commandChecksum": "b59945cb2177d145a0e72b778d71adf6",
          "propsChecksum": "6df7bef53542c483fd7590de534b2d3e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "41",
        "index": 252,
        "label": "mapEditor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[dialog(\"Map Editor\", \"temp=1; closebutton=0; width=330; height=600\"): {\n    [macro(\"mapEditorDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "196d9ce7-40dd-465d-89aa-854107db1b62",
          "commandChecksum": "41c7c8c494203bbddc5b1bb995b269e6",
          "propsChecksum": "31e0cb069c94edde46217d2011b0a64b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "42",
        "index": 253,
        "label": "mapEditorDialog",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- mapEditorDialog -->']\n\n[h:boundaryToks\t= getSelected(\"json\")]\n[h:boundaryChk\t= if(json.length(boundaryToks) == 2, 1,0)]\n\n[h,if(boundaryChk), CODE:{\n\t[boundaryTok0\t= json.get(boundaryToks, 0)]\n\t[boundaryTok1\t= json.get(boundaryToks, 1)]\n\t[x0\t\t\t\t= getTokenX(0, boundaryTok0)]\n\t[y0\t\t\t\t= getTokenY(0, boundaryTok0)]\n\t[x1\t\t\t\t= getTokenX(0, boundaryTok1)]\n\t[y1\t\t\t\t= getTokenY(0, boundaryTok1)]\n};{\n\t[boundaryTok0\t= \"\"]\n\t[boundaryTok1\t= \"\"]\n\t[x0\t\t\t\t= 0]\n\t[y0\t\t\t\t= 0]\n\t[x1\t\t\t\t= 0]\n\t[y1\t\t\t\t= 0]\n}]\n\n[h:xmin\t\t\t= min(x0,x1)]\n[h:ymin\t\t\t= min(y0,y1)]\n[h:xmax\t\t\t= max(x0,x1)]\n[h:ymax\t\t\t= max(y0,y1)]\n\n[h:setLibProperty(\"mapField.xMin\", xmin, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.yMin\", ymin, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.xMax\", xmax, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.yMax\", ymax, \"lib:EventMacros\")]\n\n<!-- upper left token -->\n[h:tokUL\t\t= if(xmin == x0, boundaryTok0, boundaryTok1) ]\n<!-- assert if upper left is actually upper left and not lower left -->\n\n<html>\n\t<head>\n\t\tBuild Map Editor Field\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' href='[r:macroLinkText(\"mapEditor@this\")]'>\n\t<\/head>\n\t\n\t<body>\n\t<form name=in action=[r:macroLinkText(\"buildField@this\")] method=\"json\">\n\t<input type=\"hidden\" name=\"bound1\"\t\tvalue='[r:boundaryTok0]'>\t<\/input>\n\t<input type=\"hidden\" name=\"bound2\"\t\tvalue='[r:boundaryTok1]'>\t<\/input>\n\n\t\t<table>\n\t\t\n\t\t\t<th align='right'>\n\t\t\t\t<div title=\"This is my tooltip\"><label for=\"layer\">Layer where you wish to edit:<\/label><\/div>\n\t\t\t<\/th>\n\t\t\t<td>\n\t\t\t\t[h,if(json.isEmpty(boundaryToks)), code: {\n\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t} ; {\n\t\t\t\t\t[h: obj = json.get(boundaryToks, 0)]\n\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t}]\n\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t<\/select>\n\t\t\t<\/td>\n\n\t\t\n\t\t\t[r,if(json.length(boundaryToks) == 2), CODE:{\n\t\t\t\t[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{\n\t\t\t\t\t<tr><td align='right'>Upper Left:\t\t<\/td><td>([r:xmin],[r:ymin])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Lower Right:\t<\/td><td>([r:xmax],[r:ymax])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'><input type=submit name=go value=\"Create Edit Field\"><\/input><\/td><td><\/td><\/tr>\n\t\t\t\t};{\n\t\t\t\t\t<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)<\/td><\/tr>\n\t\t\t\t}]\n\t\t\t};{\n\t\t\t\t<tr>\t<td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the part of the map that you can edit.<\/td><\/tr>\n\t\t\t}]\n\t\t<\/table>\n\t\t<b>Short Manual<\/b><br>\n\t\tThis editor works really simple. Just select two tokens (any will do) that outline the field you wish to edit. Make sure that one is the upper left and the other the lower right.<br>\n\t\tOnce you have done that you can hit the 'Create Edit Field' button. If you have no tokens selected, you will not see that button. Additionally you can choose on which layer you wish to edit. Personally I find the object layer the best spot.<br><br>\n\t\tAfter you hit that button, the outline tokens will be removed and a 'field' of transparent tokens will be put on the chosen layer. Note that the field will cover the spots of the outline tokens.<br><br>\n\t\tTo start editing select just ANY token (except one of the transparent tokens, although nothing will break when you do). That token will be your 'copy-paste' token. <br><br>\n\t\tNow just start selecting the transparent tokens and the previously selected token will be pasted there. Note that you can rotate, resize, add states, halos etc. and those will be copy pasted as well.<br><br>\n\t\tThats it. Post on the Bag of Tricks thread on the forum if you have any questions.\t<\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1508e07d-4c46-4678-8f4e-be6001b23e45",
          "commandChecksum": "32284be11514fc20ac2abe96ea9c8a0d",
          "propsChecksum": "4f6ac3545a6a943f95ffdd1a4d269e6e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "15",
        "index": 254,
        "label": "moveCrowd",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- -------------------------------------- moveCrowd ------------------------------------------------------- -->']\n[h:crowd\t\t= getLibProperty(\"crowd\",\"lib:EventMacros\")]\n[h:speed\t\t= getLibProperty(\"crowd.speed\",\"lib:EventMacros\")]\n[h:antagonists\t= getLibProperty(\"crowd.antagonist\",\"lib:EventMacros\")]\n\n[h:assert(findToken(json.get(crowd,0)) != \"\",\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n\n[h:xMin\t\t\t= getLibProperty(\"crowd.xMin\",\"lib:EventMacros\")]\n[h:yMin\t\t\t= getLibProperty(\"crowd.yMin\",\"lib:EventMacros\")]\n[h:xMax\t\t\t= getLibProperty(\"crowd.xMax\",\"lib:EventMacros\")]\n[h:yMax\t\t\t= getLibProperty(\"crowd.yMax\",\"lib:EventMacros\")]\n\n<!-- calculate the middle position of all antagonists -->\n[h:aX\t\t\t= 0]\n[h:aY\t\t\t= 0]\n[h, foreach(antagonist, antagonists), CODE:{\n\t[assert(findToken(antagonist) != \"\",\t\t\t\"Antagonist (\"+antagonist+\") NOT found. Make sure its on the map\",0)]\n\t[aX\t= aX + getTokenX(0, antagonist)]\n\t[aY\t= aY + getTokenY(0, antagonist)]\n}]\n[h:aX\t\t\t= round( aX/listCount(antagonists), 0 )]\n[h:aY\t\t\t= round( aY/listCount(antagonists), 0 )]\n\n<!--\n\tCxnew = Cx + e/|R| * (Cx-Ax)\n\te = run speed of crowd\n\t|R| = sqrt( (Cx-Ax)^2 + (Cy-Ay)^2  ) (length of the vector CA)\n\tC = Crowd\n\tA = Antagonist\n-->\n\n[h:'bot_startTime()']\n[h,foreach(poorSoul, crowd), CODE:{\n\t[moveToken(\n\t\tmin(xMax,max(xMin,round(getTokenX(0, poorSoul) + eval(string(speed))/max(1,sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2)) * (getTokenX(0, poorSoul) - aX),0))),\n\t\tmin(yMax,max(yMin,round(getTokenY(0, poorSoul) + eval(string(speed))/max(1,sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2)) * (getTokenY(0, poorSoul) - aY),0))),\n\t\t0,\n\t\tpoorSoul\n\t)]\n}]\n[h:'broadcast(json.length(crowd))']\n[h:'broadcast(bot_totalTime(1))']",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b7fd8d7e-3f10-459e-afe8-5ec8a4ba8802",
          "commandChecksum": "f37c5c10bdb12000a886769b25180609",
          "propsChecksum": "b534b5aac199689456cce4a226105632"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "15",
        "index": 255,
        "label": "moveCrowdPlus",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- -------------------------------------- moveCrowdPlus ------------------------------------------------------- -->']\n<!--\n<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)\n-->\n<!-- THREE CODE LEVELS -->\n[h:crowd\t\t= getLibProperty(\"crowd\",\"lib:EventMacros\")]\n[h:speed\t\t= getLibProperty(\"crowd.speed\",\"lib:EventMacros\")]\n[h:antagonists\t= getLibProperty(\"crowd.antagonist\",\"lib:EventMacros\")]\n\n[h:assert(json.length(crowd),\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n[h:assert(findToken(json.get(crowd,0)) != \"\",\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n\n[h:xMin\t\t\t= getLibProperty(\"crowd.xMin\",\"lib:EventMacros\")-2]\n[h:yMin\t\t\t= getLibProperty(\"crowd.yMin\",\"lib:EventMacros\")-2]\n[h:xMax\t\t\t= getLibProperty(\"crowd.xMax\",\"lib:EventMacros\")+2]\n[h:yMax\t\t\t= getLibProperty(\"crowd.yMax\",\"lib:EventMacros\")+2]\n\n<!-- calculate the middle position of all antagonists -->\n[h:aX\t\t\t= 0]\n[h:aY\t\t\t= 0]\n[h, foreach(antagonist, antagonists), CODE:{\n\t[assert(findToken(antagonist) != \"\",\t\t\t\"Antagonist (\"+antagonist+\") NOT found. Make sure its on the map\",0)]\n\t[aX\t= aX + getTokenX(0, antagonist)]\n\t[aY\t= aY + getTokenY(0, antagonist)]\n}]\n[h:aX\t\t\t= round( aX/listCount(antagonists), 0 )]\n[h:aY\t\t\t= round( aY/listCount(antagonists), 0 )]\n\n[h:'bot_startTime()']\n<!-- THREE CODE LEVELS -->\n[h:newCrowd = crowd]\n[h,foreach(poorSoul, crowd), CODE:{\n\t[if(getState(\"Prone\", poorSoul) == 1), CODE:{\n\t\t[setState(\"Prone\",0,poorSoul)]\n\t''\n\t};{\n\t\t<!-- get the first tokens that is in the way, if any, list will contain poorSoul as first -->\n\t\t[distance\t= eval(string(speed))]\n\t\t[inTheWays\t= bot_selectOnLine(\n\t\t\tpoorSoul,\n\t\t\tmin(xMax,max(xMin,round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0))),\n\t\t\tmin(yMax,max(yMin,round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0))),\n\t\t\t1\n\t\t)]\n\t\t[if(listCount(inTheWays) > 1), CODE:{\n\t\t\t[inTheWay\t= getName(listGet(inTheWays, 1))]\n\t\t\t<!-- if a token is in the way then stop the poorSoul one cell short -->\n\t\t\t[distance\t= getDistance(inTheWay,0,poorSoul) - 1]\n\t\t\t[if(1d100 < 51): setState(\"Prone\",1,poorSoul)]\n\t\t''\n\t\t};{\n\t\t\t[inTheWay = \"\"]\n\t\t''\n\t\t}]\n\t\t[poorSoulX\t= round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0)]\n\t\t[poorSoulY\t= round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0)]\n\t\t\n\t\t[if(poorSoulX >= xMax || poorSoulX <= xMin || poorSoulY >= yMax || poorSoulY <= yMin), CODE:{\n\t\t\t[removeToken(poorSoul)]\n\t\t\t[newCrowd\t= json.remove(newCrowd, json.indexOf(newCrowd,poorSoul))]\n\t\t''\n\t\t};{\n\t\t\t[moveToken(poorSoulX, poorSoulY, 0,poorSoul)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n}]\n[h:setLibProperty(\"crowd\", newCrowd, \"lib:EventMacros\")]\n[h:'broadcast(json.length(crowd))']\n[h:'broadcast(bot_totalTime(1))']",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a2ba0628-d355-4855-9a12-ebdf82f18472",
          "commandChecksum": "d82336fe7e89befd97d202d2aefe63fb",
          "propsChecksum": "bc5c683c86e7e3b408dc15ab739fdcf4"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "46",
        "index": 256,
        "label": "moveToHidden",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- moveToHidden --------------------------------------------------- -->']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks), CODE:{\n\t[shape\t= getTokenShape(tok)]\n\t[setLayer(\"HIDDEN\", tok)]\n\t[setTokenShape(shape, tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c1d55d6b-9088-4036-a9e7-6d8e61faf8a5",
          "commandChecksum": "33c001424f34453bfe236f281c13ceaf",
          "propsChecksum": "8d8fe799d5913827301202739584f086"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "46",
        "index": 257,
        "label": "moveToToken",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- moveToToken --------------------------------------------------- -->']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks), CODE:{\n\t[shape\t= getTokenShape(tok)]\n\t[setLayer(\"TOKEN\", tok)]\n\t[setTokenShape(shape, tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cc95034c-451e-4d26-88b3-9366790fd1fd",
          "commandChecksum": "4c9924d1e2c590e518ad8efa34559528",
          "propsChecksum": "16a779eb5ce145cfe97309a49ad0e0be"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "44",
        "index": 258,
        "label": "quitEditor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- quitEditor -->']\n\n[h:fieldToks\t= getLibProperty(\"fieldToks\",\"lib:EventMacros\")]\n[h,foreach(tok, fieldToks), if(findToken(tok) != \"\"):removeToken(tok)]\n[h:closeFrame(\"Map Editor\")]\n\n[h: '<!-- --------------------------------------- remove States --------------------------------------------------- -->']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks):setAllStates(0,tok)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "205e6483-cb3b-469a-8dc5-c4d251e4b07a",
          "commandChecksum": "abc7e240794778a1c7d6ed3d539a3c2c",
          "propsChecksum": "cfe61cbe32ffd7c040caaed8ddf3ffdf"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "1",
        "index": 259,
        "label": "scatter",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[dialog(\"ScatterDialog\", \"temp=1; closebutton=0; width=300; height=450\"): {\n    [macro(\"scatterDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "56af3b34-a3ee-4efc-9767-4ca60fff02c7",
          "commandChecksum": "3f46ebfe988b80af5d449c299453cc6b",
          "propsChecksum": "a282a202a154c8ae7a237b3218080f46"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "2",
        "index": 260,
        "label": "scatterDialog",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- scatterDialog -->']\n[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']\n\n[h: selList = getSelected(\"json\")]\n<html>\n\t<head>\n\t\tCopy and Scatter\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' \n\t\t\t\t\thref='[r:macroLinkText(\"scatter@this\")]'>\n\t<\/head>\n\t<body>\n\t\t<table width=33% align=center border=1>\n\t\t\t<tr>\n\t\t\t\t\t[r,if(json.isEmpty(selList)), code: {\n\t\t\t\t\t\t<br>Select A Token or Object<br><br><br>\n\t\t\t\t\t} ; {\n\t\t\t\t\t\t[h: rows = sqrt(json.length(selList))]\n\t\t\t\t\t\t[h: perRow = ceil(json.length(selList)/rows)]\n\t\t\t\t\t\t[h: count = 0]\n\t\t\t\t\t\t[r,foreach(obj, selList,\"\"), code: {\n\t\t\t\t\t\t\t[h: count = count +1]\n\t\t\t\t\t\t\t[r,if(count > perRow): \"<\/tr><tr>\"]\n\t\t\t\t\t\t\t[h,if(count > perRow): count=1]\n\t\t\t\t\t\t\t<td><img width=[r:round(100/perRow)] height=[r:round(100/perRow)] \n\t\t\t\t\t\t\t\t src='[r,token(obj): getTokenImage()]'><\/img><\/td>\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\t\t<form name=in action=[r:macroLinkText(\"scatterImages@this\")]\n\t\t\t\t\t\tmethod=\"json\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"numCopies\">Number of Copies<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"numCopies\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distNorth\">Distance North<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distNorth\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distEast\">Distance East<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distEast\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distSouth\">Distance South<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distSouth\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distWest\">Distance West<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distWest\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"spread\">Spreading<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"spread\" value=\"5\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"rotation\">Rotation<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"rotation\">\n\t\t\t\t\t\t\t\t<option value=\"Free\" selected=\"selected\">Free<\/option>\n\t\t\t\t\t\t\t\t<option value=\"SquareEdges\">Square (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Square\">Square<\/option>\n\t\t\t\t\t\t\t\t<option value=\"VHexEdges\">Vertical Hex (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"VHex\">Vertical Hex<\/option>\n\t\t\t\t\t\t\t\t<option value=\"HHexEdges\">Horizontal Hex (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"HHex\">Horizontal Hex<\/option>\n\t\t\t\t\t\t\t\t<option value=\"None\">None<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"sizeRange\">Range of Size<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"sizeRange\">\n\t\t\t\t\t\t\t\t<option value=\"-1\">Keep size of original<\/option>\n\t\t\t\t\t\t\t\t<option value=\"0\" selected=\"selected\">0<\/option>\n\t\t\t\t\t\t\t\t<option value=\"1\">1<\/option>\n\t\t\t\t\t\t\t\t<option value=\"2\">2<\/option>\n\t\t\t\t\t\t\t\t<option value=\"3\">3<\/option>\n\t\t\t\t\t\t\t\t<option value=\"4\">4<\/option>\n\t\t\t\t\t\t\t\t<option value=\"5\">5<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"layer\">Layer<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td>\n\t\t\t\t[h,if(json.isEmpty(selList)), code: {\n\t\t\t\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t\t\t\t} ; {\n\t\t\t\t\t\t\t\t[h: obj = json.get(selList, 0)]\n\t\t\t\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t}]\n\t\t\t\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"tokenName\">Special Token<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"tokenName\">\n\t\t\t\t\t\t\t\t<option value=\"0\">No<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Canopy\" selected=\"selected\">Canopy<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Foliage\">Foliage<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Roof\">Roof<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Ward\">Ward<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"EventPad\">EventPad<\/option>\n\t\t\t\t\t\t\t\t<option value=\"MappedPad\">MappedPad<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadStart\">PadStart<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadEnd\">PadEnd<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterPad\">InterPad<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadStartBorder\">PadStartBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadEndBorder\">PadEndBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterPadBorder\">InterPadBorder<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadJumpBorder\">PadJumpBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadDropBorder\">PadDropBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterJumpBorder\">InterJumpBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterDropBorder\">InterDropBorder<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadJump\">PadJump<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadDrop\">PadDrop<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterJump\">InterJump<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterDrop\">InterDrop<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\n\t\t\t\t\t[r,if(json.length(selList) > 1), code:{\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t\t<label for=\"mutiToken\">Number Copies <\/label>\n\t\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t\t<select name=\"multiToken\">\n\t\t\t\t\t\t\t\t\t<option value=\"ofEach\" selected=\"selected\">of each<\/option>\n\t\t\t\t\t\t\t\t\t<option value=\"randomlySelected\">randomly selected<\/option>\n\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t} ; { \n\t\t\t\t\t}]\n\t\t\t\t<\/table>\n\t\t\t\t<table width=33% align=center>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t[r,if(json.isEmpty(selList) != 1), code: {\n\t\t\t\t\t\t\t\t<input type=submit name=go value=\"Scatter\"><\/input>\n\t\t\t\t\t\t\t} ; {\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t<\/table>\n\t\t\t\t<input type=\"hidden\" name=\"ids\"\t\t\tvalue='[r:selList]'><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"map\"\t\t\tvalue='[r:getCurrentMapName()]'><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"centreTok\"\tvalue=''><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"macro\"\t\tvalue='scatterToken'><\/input>\n\t\t <\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2986a460-a4b6-4209-b0e3-59885325ddff",
          "commandChecksum": "51a4f4ffa062df9a5aa0291c47d4cc00",
          "propsChecksum": "4c1e59591def1d5e1692645aa5acc3a6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "14. Scatter",
        "includeLabel": false,
        "sortBy": "31",
        "index": 261,
        "label": "scatterImages",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- scatterImages --------------------------------------------------- -->']\n[h: '<!-- this macro is based on Craigs Scatter Drop-in -->']\n[h:closeDialog(\"Create Crowd\")]\n[h: numCopies\t= json.get(macro.args, \"numCopies\")]\n[h: distNorth\t= json.get(macro.args, \"distNorth\")]\n[h: distEast\t= json.get(macro.args, \"distEast\")]\n[h: distSouth\t= json.get(macro.args, \"distSouth\")]\n[h: distWest\t= json.get(macro.args, \"distWest\")]\n[h: ids\t\t\t= json.get(macro.args, \"ids\")]\n[h: spread\t\t= json.get(macro.args, \"spread\")]\n[h: speed\t\t= json.get(macro.args, \"speed\")]\n[h: antagonist\t= json.get(macro.args, \"antagonist\")]\n[h: sizeRange\t= json.get(macro.args, \"sizeRange\")]\n\n[h:setLibProperty(\"crowd.speed\", speed, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.antagonist\", antagonist, \"lib:EventMacros\")]\n\n[h: tokenName\t= json.get(macro.args, \"tokenName\")]\n[h: map\t\t\t= json.get(macro.args, \"map\")]\n[h: centreTok\t= json.get(macro.args, \"centreTok\")]\n<!-- either createCrowd or scatterToken -->\n[h: macro\t\t= json.get(macro.args, \"macro\")]\n\n[h:assert(isNumber(numCopies),\"Number Copies must be numeric\",0)]\n[h:assert(isNumber(distNorth),\"Distance North must be numeric\",0)]\n[h:assert(isNumber(distEast),\"Distance East must be numeric\",0)]\n[h:assert(isNumber(distSouth),\"Distance South must be numeric\",0)]\n[h:assert(isNumber(distWest),\"Distance West must be numeric\",0)]\n\n[h: layer\t\t= json.get(macro.args, \"layer\")]\n[h: rotation\t= json.get(macro.args, \"rotation\")]\n\n[h,switch(rotation):\n\tcase \"Free\": \t\trotStr\t= \"1d360-1\"; \n\tcase \"SquareEdges\":\trotStr\t= \"(1d4-1) * 90\"; \n\tcase \"Square\":\t\trotStr\t= \"(1d8-1) * 45\"; \n\tcase \"VHexEdges\":\trotStr\t= \"(1d6-1) * 60 + 30\"; \n\tcase \"VHexEdges\":\trotStr\t= \"(1d12-1) * 30\"; \n\tcase \"HHexEdges\":\trotStr\t= \"(1d6-1) * 60\"; \n\tcase \"HHexEdges\":\trotStr\t= \"(1d12-1) * 30\"; \n\tcase \"None\":\t\trotStr\t= \"\"; \n] \n\n<!-- either ofEach or randomlySelected -->\n[h: method\t= json.get(macro.args, \"multiToken\")]\n<!-- if you use the crowd macro use randomlySelected -->\n[h,if(method == \"\"): method\t= \"randomlySelected\")]\n\n[h:'<!-- Create an array of \"number of copies\" to use based on method -->']\n[h:numCopyArr\t= \"[]\"]\n[h: numIds\t\t= json.length(ids)]\n[h,if(method == \"ofEach\"), code: {\n\t[for(i, 0, numIds): numCopyArr\t= json.append(numCopyArr, numCopies)]\n} ; { \n\t<!-- create an array with the amounts of each id to scatter -->\n\t[for(i, 0, numIds): numCopyArr\t= json.append(numCopyArr, floor(numCopies/numIds))]\n\t<!-- because you round the amount the total amount might be less then was required. So get total of copies in array (sum of array) -->\n\t[sum\t= evalMacro(replace(replace(numCopyArr, \"\\\\[\", \"[r:\"), \",\", \"+\"))]\n\t[toAdd\t= max(0,numCopies - sum)]\n\t<!-- the amount still to add should ALWAYS be LESS then the total amount of scatter ids, hence just add one of each id until finished (but just add a limiter (min) just in case) -->\n\t[count(toAdd): numCopyArr\t= json.set(  numCopyArr, min(numIds,roll.count), json.get(numCopyArr, min(numIds,roll.count)) + 1  )]\n}]\n\n[h: sizeList\t= \"Fine, Diminutive, Tiny, Small, Medium, Large, Huge, Giant, Gargantuan, Colossal\"]\n[h, if(sizeRange == 5): sizeStr\t= \"[r:listGet(sizeList, 1d10-1)]\"); sizeStr\t= \"[r:listGet(sizeList, 1d\" + (2*sizeRange+1) + \"+\" + (3-sizeRange) + \")]\" ]\n[h, if(sizeRange == \"-1\"): sizeStr\t= \"\" ]\n[h: spreadChkList\t= \"[]\"]\n[h,for(i, 0, numIds), code: {\n\t[obj\t\t= json.get(ids, i)]\n\t[copies\t\t= json.get(numCopyArr, i)]\n\t<!-- crowd makes use of a centreTok, scatter uses the to copy tok as centre -->\n\t[centreX\t= getTokenX(0, if(centreTok == \"\", obj, centreTok))]\n\t[centreY\t= getTokenY(0, if(centreTok == \"\", obj, centreTok))]\n\n\t[xstr\t\t= \"centreX\" + (-1 * (distWest + 1)) + \"+ 1d\" + (distWest + distEast + 1)]\n\t[ystr\t\t= \"centreY\" + (-1 * (distNorth + 1)) + \"+ 1d\" + (distNorth + distSouth + 1)]\n\n\t[updates\t= json.set(\"{}\", \"layer\", layer)]\n\t[updates\t= json.set(updates, \"useDistance\", 0)]\n\t[if(rotStr != \"\"): updates\t= json.set(updates, \"facing\", \"[r:\" + rotStr + \"]\")]\n\t[updates\t= json.set(updates, \"x\", \"[r:\" + xstr + \"]\")]\n\t[updates\t= json.set(updates, \"y\", \"[r:\" + ystr + \"]\")]\n\t[if(sizeStr != \"\"): updates\t= json.set(updates, \"size\", sizeStr)]\n\t[copies\t\t= copyToken(obj, copies, map, updates)]\n\t[spreadChkList\t= json.merge(spreadChkList, copies)]\n\n\t['tmp\t= bot_ids2Names(spreadChkList)']\n\t['tmp1\t= bot_ids2Names(copies)']\n\t['pause(\"tmp\",\"tmp1\")']\n}]\n\n[spreadChkList\t\t= bot_ids2NamesArray(spreadChkList)]\n\n[h,if(spread > -1), CODE: {\n\t[txt\t= \"All the tokens have now been scattered in the designated area. Now the field will be checked for the 'spreading'. Any token closer than \"+spread+\" will be removed. Press cancel if you do not want this.<br><br><b>Note<\/b> that this will mean that the resulting amount of tokens will be less then the 'Number of Copies' you have set.<br><br>(also note that this pause is vital, so don't remove it from the code)\"]\n\t[pause(\"txt\")]\n\t[bot_abortProcess(1)]\n\t[link\t= macroLinkText(\"deferRemoveToken@lib:onTokenMove\",\"none\",json.append(\"\",spreadChkList,layer,spread,tokenName,json.length(spreadChkList),macro,spreadChkList))]\n\t[execLink(link,1)]\n}; {\n\t['broadcast(spreadChkList)']\n\t[if(macro == \"createCrowd\"):setLibProperty(\"crowd\", spreadChkList, \"lib:EventMacros\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a3774560-dfca-40bd-a2cf-d8f94e4bd1fa",
          "commandChecksum": "c379535dda4a912e7c97989c0df3bd17",
          "propsChecksum": "80bf2c134809eb9111fb7df052ecb985"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "b. bubblobill Input String Builder",
        "includeLabel": false,
        "sortBy": "",
        "index": 262,
        "label": "buildInputString",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------- buildInputString --------------------------------------------- -->']\n\n<!-- This macro helps to build input strings by putting the right bits in the right places. -->\n<!-- bubblobill original created 30.06.2014 -->\n<!-- last updated 05.07.2014 -->\n\n<!-- set up initial default variables -->\n[h,code:{\n[inData=macro.args][inType=''][inputDisplay=''][newString=''][prevStrings=json.fromList(\"\")][runFrom=getMacroLocation()]\n[TEXT=\"Text\"]\n\t[txtvarName=\"myTextVar\"][txtprompt=\"TextLabel\"][txtspan=\"\"][txtspanchk=\"\"][txtvalue=\"DefaultText\"][txtwidth=\"16\"]\n[LIST=\"Listbox\"]\n\t[lstvarName=\"myListVar\"][lstlabel=\"ListboxName\"][lstspan=\"\"][lstspanchk=\"\"][lstvalue=\"String, List, Example\"][lstindex=\"0\"][lststring=\"\"]\n[CHECK=\"Checkbox\"]\n\t[chkvarName=\"myCheckVar\"][chkprompt=\"CheckboxName\"][chkspan=\"\"][chkspanchk=\"\"][chkvalue=\"0\"]\n[RADIO=\"Radio button\"]\n\t[radvarName=\"myRadioVar\"][radprompt=\"RadioGroupName\"][radspan=\"\"][radspanchk=\"\"][radvalues=\"String, List, Example\"][radvalue=\"0\"][radstring=\"\"][radorient=\"\"]\n[LABEL=\"Label\"]\n\t[lblprompt=\"LabelName\"][lblvalue=\"<b>LabelContent<\/b>\"][lblspan=\"\"][lblspanchk=\"\"]\n[PROPS=\"Props\"]\n\t[propvarName=\"myPropVar\"][propprompt=\"PropListGroupName\"][propspan=\"\"][propspanchk=\"\"][propvalue=encode(\"String=Prop; List=example\")][propvar=\"\"][propvar_=\"\"]\n[TAB=\"Tab\"]\n\t[tabvarName=\"myTabVar\"][tabvalue=\"TabName\"][tabstart=\"\"]\n[SHOW=\"Show\"]\n}]\n\n<!-- test for first run, ie. have arguments been passed for processing -->\n[h,if(!json.isEmpty(macro.args)==1),code:{\n\n\t<!-- First run=FALSE, process form -->\n\n\t<!-- set switch value to the input type button that was pressed -->\n\t[types=\"TEXT,LIST,CHECK,RADIO,LABEL,PROPS,TAB,SHOW\"]\n\t[foreach(type,types):inType=add(inType,json.get(inData,type))]\n\n\t<!-- set variables from arguments -->\n\t[varList=json.fields(inData)]\n\t[foreach(var,varList),CODE:{\n\t\t[value = json.get(inData,var)]\n\t\t[set(var,value)]\n\t\t}]\n\t[propvalue=decode(propvalue)]\n\t[prevStrings=decode(prevStrings)]\n\n\t<!-- build input string from fields for appropriate type -->\n\t[switch(inType),code:\n\tcase \"Text\":\t{[newString=strformat(\"'%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}<\/html>|TEXT|WIDTH=%{txtwidth} %{txtspan}'\")]};\n\tcase \"Text\":\t{[newString=strformat(\"'%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}<\/html>|TEXT|WIDTH=%{txtwidth} %{txtspan}'\")] };\n\tcase \"Listbox\":\t{[newString=strformat(\"'%{newString}%{lstvarName}|%{lstvalue}|<html>%{lstlabel}<\/html>|LIST|%{lstspan} %{lststring} SELECT=%{lstindex}'\")]};\n\tcase \"Checkbox\":{[newString=strformat(\"'%{newString}%{chkvarName}|%{chkvalue}|<html>%{chkprompt}<\/html>|CHECK|%{chkspan}'\")]};\n\tcase \"Radio button\":\t{[newString=strformat(\"'%{newString}%{radvarName}|%{radvalues}|%{radprompt}|RADIO|SELECT=%{radvalue} %{radspan} %{radstring} %{radorient}'\")]};\n\tcase \"Label\":\t{[newString=strformat(\"'%{newString}junkvar|<html>%{lblvalue}<\/html>|%{lblprompt}|LABEL|%{lblspan}'\")]};\n\tcase \"Props\":\t{[newString=strformat(\"'%{newString}%{propvarName}|%{propvalue}|%{propprompt}|PROPS|%{propspan} %{propvar} %{propvar_}'\")]};\n\tcase \"Tab\":\t\t{[newString=strformat(\"'%{newString}%{tabvarName}|%{tabvalue}||TAB|%{tabstart} '\")]};\n\tcase \"Show\":\t{[newString=\" \")]}\n\t]\n\t\n\t\n\t<!-- append strings together into a display string and clean -->\n\t[if(prevStrings==\"\"): inputDisplay=newString; inputDisplay = strformat (\"'%{prevStrings}'%{newString}\")]\n\t[inputDisplay=replace(inputDisplay,\"&#\"+59,\";\")]\n\t[inputDisplay=replace(inputDisplay,\"<(.*?)>\",\"<\\$1>\")]\n\t[inputDisplay=replace(inputDisplay,\"''\",\" ## \")]\n\t};{\n\n\t<!-- First run=TRUE -->\n\t[h, if (runFrom == \"token\"):setSpeech(\"input\",\"\");\"\"]\n\n}]\n\n<!-- declare strings for putting together form -->\n[h:formLink = macroLinkText(\"buildInputString@lib:OnTokenMove\",\"\",\"\",\"\")]\n\n[h:CHECKED=string('CHECKED=\"CHECKED\"')][h:SPAN=string('SPAN=TRUE')][h:STRINGVALUE=string('VALUE=STRING')]\n\n<!-- set form checkboxes checked value from previous run -->\n[h,code:{\n[txtspanchk=if(txtspan==SPAN,CHECKED,\"\")]\n[lstspanchk=if(lstspan==SPAN,CHECKED,\"\")]\n[chkspanchk=if(chkspan==SPAN,CHECKED,\"\")]\n[radspanchk=if(radspan==SPAN,CHECKED,\"\")]\n[lblspanchk=if(lblspan==SPAN,CHECKED,\"\")]\n[propspanchk=if(propspan==SPAN,CHECKED,\"\")]\n[chkvaluechk=if(chkvalue==1,CHECKED,\"\")]\n[lststringchk=if(lststring==STRINGVALUE,CHECKED,\"\")]\n[radstringchk=if(radstring==STRINGVALUE,CHECKED,\"\")]\n[radorientchk=if(radorient==\"ORIENT=H\",CHECKED,\"\")]\n[propvarchk=if(propvar==\"SETVARS=UNSUFFIXED\", CHECKED,\"\")]\n[propvar_chk=if(propvar_==\"SETVARS=SUFFIXED\",CHECKED,\"\")]\n}]\n\n[h:css='<style>\ntable.mytable \t\t{ color:black }\ntable.mytable th \t{ background-color: #660066; font-weight:bold; color:white }\ntable.mytable tr\t{ background-color: #C0C0C0 }\ntable.mytable .alt \t{ background-color: #FFFFFF }\ntable.table2 tr td \t{ background-color: #FFFFEE; color: black }\ntable.table2 .note \t{ background-color: #FFFFFF; color: blue }\n<\/style>']\n\n<!-- create form HTML string for display -->\n[h:displayString='<html>\n<head>\n<title>Build input string<\/title>\n'+css+'\n<\/head>\n<form action=\"'+formLink+'\" method=json >\n\n<table width=100% class=\"mytable\">\n\t<tr>\n\t\t<th><\/th>\n\t\t<th>Variable name\t\t\t\t\t\t\t<\/th>\n\t\t<th>Label / Prompt / Tooltip\t\t\t\t<\/th>\n\t\t<th>Hide<br>label\t\t\t\t\t\t\t<\/th>\n\t\t<th colspan=2>Prefill / value\t\t\t\t<\/th>\n\t\t<th colspan=2 align=right width=80>Options\t<\/th>\n\t\t<th colspan=5>\t\t\t\t\t\t\t\t<\/th>\n\t\t<\/tr>\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"TAB\" value=\"Tab\">\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"tabvarName\" size=\"18\" maxlength=\"\" value=\"'+tabvarname+'\">\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"tabvalue\" size=\"18\" maxlength=\"\" value=\"'+tabvalue+'\">\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\tStarting tab\t\t<\/td><td><input type=\"checkbox\" name=\"tabstart\" value=\"SELECT=TRUE\"><\/td>\n\t\t<\/tr>\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"TEXT\" value=\"Text\">\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"txtvarName\" size=\"18\" maxlength=\"\" value=\"'+txtvarName+'\">\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"txtprompt\" size=\"18\" maxlength=\"\" value=\"'+txtprompt+'\">\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"txtspan\" value=\"SPAN=TRUE\" '+txtspanchk+'>\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"txtvalue\" size=\"18\" maxlength=\"\" value=\"'+txtvalue+'\">\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tField width\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t<input type=\"text\" name=\"txtwidth\" size=\"3\" maxlength=\"\" value=\"'+txtwidth+'\">\t\t\t\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"LIST\" value=\"Listbox\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lstvarName\" size=\"18\" maxlength=\"\" value=\"'+lstvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lstlabel\" size=\"18\" maxlength=\"\" value=\"'+lstlabel+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"lstspan\" value=\"SPAN=TRUE\" '+lstspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"lstvalue\" size=\"18\" maxlength=\"\" value=\"'+lstvalue+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tPreselect index\t\t<\/td><td><input type=\"text\" name=\"lstindex\" size=\"3\" maxlength=\"\" value=\"'+lstindex+'\">\t<\/td>\n\t\t<td align=right>\t\t\t\tSet string not no.\t<\/td><td><input type=\"checkbox\" name=\"lststring\" value=\"VALUE=STRING\" '+lststringchk+'>\t<\/td>\n\t\t<\/tr>\n\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"CHECK\" value=\"Checkbox\">\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"chkvarName\" size=\"18\" maxlength=\"\" value=\"'+chkvarName+'\">\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"chkprompt\" size=\"18\" maxlength=\"\" value=\"'+chkprompt+'\">\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"chkspan\" value=\"SPAN=TRUE\" '+chkspanchk+'>\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\tChecked\t\t\t\t<\/td><td><input type=\"checkbox\" name=\"chkvalue\"value=\"1\" '+chkvaluechk+'>\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"RADIO\" value=\"Radio button\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"radvarName\" size=\"18\" maxlength=\"\" value=\"'+radvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"radprompt\" size=\"18\" maxlength=\"\" value=\"'+radprompt+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"radspan\" value=\"SPAN=TRUE\" '+radspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"radvalues\" size=\"18\" maxlength=\"\" value=\"'+radvalues+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tPreselect index\t\t<\/td><td><input type=\"text\" name=\"radvalue\" size=\"3\" maxlength=\"\" value=\"'+radvalue+'\">\t<\/td>\n\t\t<td align=right>\t\t\t\tSet string not no.\t<\/td><td><input type=\"checkbox\" name=\"radstring\" value=\"VALUE=STRING\", '+radstringchk+'><\/td>\n\t\t<td align=right>\t\t\t\tHorizontal\t\t\t<\/td><td><input type=\"checkbox\" name=\"radorient\" value=\"ORIENT=H\" '+radorientchk+'>\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"LABEL\" value=\"Label\">\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lblprompt\" size=\"18\" maxlength=\"\" value=\"'+lblprompt+'\">\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"lblspan\" value=\"SPAN=TRUE\" '+lblspanchk+'>\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"lblvalue\" size=\"18\" maxlength=\"\" value=\"'+lblvalue+'\">\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"PROPS\" value=\"Props\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"propvarName\" size=\"18\" maxlength=\"\" value=\"'+propvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"propprompt\" size=\"18\" maxlength=\"\" value=\"'+propprompt+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"propspan\" value=\"SPAN=TRUE\" '+propspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"propvalue\" size=\"18\" maxlength=\"\" value=\"'+decode(propvalue)+'\">\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tSet variables (var)\t<\/td><td><input type=\"checkbox\" name=\"propvar\" value=\"SETVARS=UNSUFFIXED\" '+propvarchk+'>\t<\/td>\n\t\t<td align=right>\t\t\t\tSet variables (var_)<\/td><td><input type=\"checkbox\" name=\"propvar_\" value=\"SETVARS=SUFFIXED\" '+propvar_chk+'>\t<\/td>\n\t\t<\/tr>\n\t\t\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"SHOW\" value=\"Show\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t\t<td colspan=12>\n\t\t\t<!-- display complete string -->\n\t\t\t\t<table width=100% border=1>\n\t\t\t\t\t<table border=0 width=100% class=\"table2\">\n\t\t\t\t\t<td><\/td><td align=center><b>Input String<\/b><\/style><\/td><td><\/td>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td width=4%><\/td>\n\t\t\t\t\t\t\t<td width=92% border=1 height=90 class=\"note\" align=center><textarea name=\"prevStrings\" cols=\"104\" rows=\"7\">'+decode(inputDisplay)+'<\/textarea>\n\t\t\t\t\t\t\t<td width=4%><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><\/td><td><\/td><td><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<\/table>\n\t\t\t\t<\/table>\n\t\t\t<\/td>\n\t\t<\/tr>\n<\/table>\n<\/form>\n<\/html>']\n\n<!-- output to chat with ## separator and html -->\n[r:inputDisplay]\n[h:inString=replace(inputDisplay,\"<(.*?)>\",\"<\\$1>\")]\n[h:input(inString)]\n[h, if (runFrom == \"token\"):setSpeech(\"input\",inString);\"\"]\n<br>\n\n<!-- display completed dialog form -->\n[r,dialog('Input String Builder','width=1050; height=540; temporary=1;'):\n{\n[r:displayString]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "74a0fef7-bddf-44fd-a259-ab2fd80742c1",
          "commandChecksum": "fdbfcf874c568c7fa24b79b1b9d4d412",
          "propsChecksum": "6e6ef1f5a812faca1191f74143d37d52"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "2",
        "index": 263,
        "label": "clearGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,if(argCount()>0):switchToken(arg(0)); switchToken(listGet(getSelectedNames(),0))]\n[h:'assert(startsWith(token.label,\"group\"),\"This token does not belong to a group\",0)']\n[h:groupName = token.label]\n[h:tokList = getProperty(\"w42.boT.\"+token.label)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):resetProperty(\"w42.boT.\"+token.label)]\n\t[token(tmpTok):token.label=\"\"]\n}]\n[h:resetProperty(\"w42.boT.\"+token.label)]\n[h:token.label=\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eabf546c-1932-4c62-ad05-219cb714ccdd",
          "commandChecksum": "4d1913516da3a2d3b5adbfddcc4d9d16",
          "propsChecksum": "903b8484f6fbd899c1f4baac1828e3d3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "6",
        "index": 264,
        "label": "contractGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX()]\n[h:y0 = getTokenY()]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+round(0.5*(getTokenX()-x0),0), y0+round(0.5*(getTokenY()-y0),0))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e367e5d4-68fa-4a94-871d-3207f2352688",
          "commandChecksum": "fd592130b3ac283f4ca4eb97fab35c39",
          "propsChecksum": "30a6b051cc151ddd9a3fb15ba72869e0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "9",
        "index": 265,
        "label": "formationEchelon",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+roll.count, y0+roll.count, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "97697b46-4bd0-4b23-8320-d88802436240",
          "commandChecksum": "1a8fd46294599497d49f4dd3d8578928",
          "propsChecksum": "6318e3ea32e860c5632a63fafdc7ba86"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "9",
        "index": 266,
        "label": "formationLine",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+roll.count, y0, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6fcf20de-1143-47fa-be2c-bcd2a557d367",
          "commandChecksum": "97391d1f1e7e580f850bc05c835ad339",
          "propsChecksum": "ecae1aa9084ca7d2ba02de315c5df7c0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "7",
        "index": 267,
        "label": "formationPWedge",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:length\t\t= floor(numToks/4)]\n[h:tokCount\t= 0]\n[h,for(yF,0,length+2), CODE:{\n\t[for(xF,-yF,+yF+1), CODE:{\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "50ca0d93-2a41-4479-9a2f-f637f016891f",
          "commandChecksum": "0a09a38e1442c2c5f66095cbac329c27",
          "propsChecksum": "c2ccb47846a7087cfdc505cef23cbf77"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "9",
        "index": 268,
        "label": "formationSquare",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[yF = floor((roll.count) / width)]\n\t[xF = roll.count - yF*width]\n\t[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f1353501-67f0-4db7-a882-13d85313ed2b",
          "commandChecksum": "3d8787c2d7987f7bd683188430a9e3b1",
          "propsChecksum": "252917851557fbbc70febc8ec6661387"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "9",
        "index": 269,
        "label": "formationStagger",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+if(odd(roll.count),1,0), y0+roll.count, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b3b0afb1-7623-40ef-ae7f-1ae04ed0ff95",
          "commandChecksum": "75f0fe97ed1ae341c87a88fc9ec033e9",
          "propsChecksum": "ab1e3e31ba140cc25e6cc6728e0cbdb9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "8",
        "index": 270,
        "label": "formationWedge",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:selToks = getSelected()]\n[h:switchToken(listGet(selToks,0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = listDelete(selToks,listFind(selToks, currentToken()))]\n\n[h:numToks\t= listCount(tokList)]\n[h:length\t= floor(numToks-1/2)]\n[h:tokCount\t= 0]\n[h,for(yF,1,length+1), CODE:{\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0-yF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0+yF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "143bf232-fcb9-4b6d-99b2-9bcb4accfa5c",
          "commandChecksum": "29c8d523ae6f65153086d868a4f09924",
          "propsChecksum": "dbe74540c7ac5328f9342cfc76bbb022"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "3",
        "index": 271,
        "label": "rotateCCW",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_rotateGroup(90)]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d529896b-6189-4528-9c4d-d61096968f15",
          "commandChecksum": "2848b05ed40bcf92c58ebadf40b06767",
          "propsChecksum": "3a38eafe3e09fc2e459aefe6793272c6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "4",
        "index": 272,
        "label": "rotateCCW BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ROTATE GROUP COUNTER CLOCK WISE -->']\n[h:selected\t= getSelectedNames()]\n[h:switchToken(listGet(selected,0))]\n[h:x0\t\t= getTokenX()]\n[h:y0\t\t= getTokenY()]\n[h:SG\t\t= isSnapToGrid()]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h, if(SG), CODE:{\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken(getTokenY(1, tmpTok)-y0+x0, y0-getTokenX(1, tmpTok)+x0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+90, tmpTok)]\n\t}]\t\n};{\n\t[fDiff\t= 45]\n\t[fCurr\t= getTokenFacing()]\n\t[if(listCount(selected) == 1 && fCurr != \"\"), CODE:{\n\t\t[fOld\t= getProperty(\"w42.bot.oldFacing\")]\n\t\t[if(fOld == \"\"): fDiff = fCurr ; fDiff = fCurr - fOld)]\n\t\t[setProperty(\"w42.bot.oldFacing\", fCurr)]\n\t};{}]\t\n\t[a\t\t= bot_toRadians(fDiff)]\n\t[cos\t= bot_cos(a)]\n\t[sin\t= bot_sin(a)]\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken((getTokenX(1,tmpTok)-x0)*cos + (getTokenY(1,tmpTok)-y0)*sin + x0, -(getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+fDiff, tmpTok)]\n\t}]\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5d38ae77-8a43-4aca-b9b5-7ef8a1394927",
          "commandChecksum": "f5050d9fc368a9e2feafc65fc35ac1ef",
          "propsChecksum": "4fe9a84e2ab8fee53e4136cc0d22a394"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "3",
        "index": 273,
        "label": "rotateCW",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_rotateGroup(-90)]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bbfd0ba1-ad45-4383-999a-17bfe6e3a63f",
          "commandChecksum": "b8e785af60d14a727a32c149e028dea9",
          "propsChecksum": "c3c76f979b6da3aa22c6ca93a7afb15a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "3",
        "index": 274,
        "label": "rotateCW BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ROTATE GROUP CLOCK WISE -->']\n[h:selected\t= getSelectedNames()]\n[h:switchToken(listGet(selected,0))]\n[h:x0\t\t= getTokenX()]\n[h:y0\t\t= getTokenY()]\n[h:SG\t\t= isSnapToGrid()]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h, if(SG), CODE:{\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken(-getTokenY(1, tmpTok)+y0+x0, getTokenX(1, tmpTok)+y0-x0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-90, tmpTok)]\n\t}]\n};{\n\t[fDiff\t= 45]\n\t[a\t\t= bot_toRadians(fDiff)]\n\t[fCurr\t= getTokenFacing()]\n\t[if(listCount(selected) == 1 && fCurr != \"\"), CODE:{\n\t\t[fOld\t= getProperty(\"w42.bot.oldFacing\")]\n\t\t[if(fOld == \"\"): fDiff = fCurr ; fDiff = fCurr - fOld)]\n\t\t[fDiff\t= 360-fDiff]\n\t\t[a\t\t= bot_toRadians(fDiff)]\n\t\t[setProperty(\"w42.bot.oldFacing\", fCurr)]\n\t};{}]\t\n\t[cos\t= bot_cos(a)]\n\t[sin\t= bot_sin(a)]\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken((getTokenX(1,tmpTok)-x0)*cos - (getTokenY(1,tmpTok)-y0)*sin + x0, (getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-fDiff, tmpTok)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5bca8cdc-96b7-4dae-8177-aebf75bd6494",
          "commandChecksum": "e39198d8585459b22b36ccfdea8a35be",
          "propsChecksum": "1bed5d944894e6f9f4c3637a119916d4"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "",
        "index": 275,
        "label": "rotateGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------------- Rotate Group (degrees [,tokens]) ---------------------------------------------------------->']\n[debug=0]\n<!--\n\tthe idea is: \n\t- get the rotational offset (thats the centre of the centreTok)\n\t- translate all otherToks to the actual centre (by deducting the rotational offset)\n\t- then rotate the otherToks around the origin\n\t- then translate them back to the offset (by adding the rotational offset)\n\t- finally substract the size of the tok from eithe x or y (depending on the direction) to composate for the size of the tok. \n-->\n\n[rotation\t= arg(0)]\n[assert(rotation/90 == floor(rotation/90), \"You can only give multiples of 90 degrees\",0)]\n\n[if(argCount() > 1): toks\t= arg(1) ; toks\t= getSelectedNames()]\n[assert(listCount(toks) > 0, \"Make sure you have a centreTok AND its otherToks selected\",0)]\n\n<!-- seperate otherToks from centreTok and rotate all the token 90 degrees-->\n[foreach(tok,toks), CODE:{\n\t[bot_setTokenFacing(bot_getTokenFacing(tok) + rotation,tok)]\n}]\n[centreTok\t= listGet(toks, 0)]\n[otherToks\t= listDelete(toks,0)]\n\n<!-- get the rotational offset -->\n[X0\t= getTokenX(1, centreTok)\t+ round(getTokenWidth(centreTok)/2)]\n[Y0\t= getTokenY(1, centreTok)\t+ round(getTokenHeight(centreTok)/2)]\n\n<!-- \n\tthis function works for rotation steps of 90 degrees only.\n\tkeep in mind that the setpsize must be +/- according to the \n\trotation direction or the for loop wont work.\n -->\n[stepSize\t= if(rotation<0, -90, 90)]\n[for(rot, 0, rotation, stepSize), CODE:{\n[foreach(tok, otherToks), CODE:{\n\t\t<!-- while this is no point rotation but a cell rotation, youll need to take care of the doorsize as well. -->\n\t\t<!-- you never know the orientation of the tok and some tok tokens have a different height from width... -->\n\t\t[sizeDoor\t= round(max(getTokenWidth(tok),getTokenHeight(tok)))]\n\t\t<!-- get current position of tok -->\n\t\t[XD\t\t\t= getTokenX(1, tok)]\n\t\t[YD\t\t\t= getTokenY(1, tok)]\n\t\t<!-- translate tok to the correct position (-translate, rotate, +translate) -->\n\t\t[X\t\t\t= if(rotation < 0, -1, 1)*(YD-Y0) + X0 - if(rotation < 0, sizeDoor, 0)]\n\t\t[Y\t\t\t= if(rotation > 0, -1, 1)*(XD-X0) + Y0 - if(rotation > 0, sizeDoor, 0)]\n\t\t[if(debug == 1): pause(\"X0\",\"Y0\",\"XD\",\"YD\",\"X\",\"Y\",\"centreTok\",\"tok\",\"sizeDoor\")]\n\t\t[moveToken(X,Y,1,tok)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "86f7e347-83fb-4702-9367-ea61e9607dc3",
          "commandChecksum": "352c1f40d5beb0221fa35fa0532d4c66",
          "propsChecksum": "0db10b8359ff92d815394c954075f825"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "1",
        "index": 276,
        "label": "setGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- setGroup (token names, group name) -->']\n[h,if(argCount()): grpList = arg(0) ; grpList = getSelectedNames()]\n[h,if(argCount()>1): name = arg(1) ; name=\"name\"]\n[h,if(argCount()>1): askName = 0 ; askName = 1]\n\n<!-- first clear any group assignments still there, do grab the old name to provide in the input -->\n[h, foreach(tok, grpList), CODE:{\n\t[token(tok),if(startsWith(token.label, \"group_\")), CODE:{\n\t\t[name = substring(token.label, 6)]\n\t\t[bot_clearGroup(tok)]\t\n\t}; {}]\n}]\n\n<!-- if no name as argument was given, ask for it -->\n[h, if(askName):abort(input(\"name|\"+name+\"|Enter name (no spaces)\"))]\n<!-- for each tok in the selected group, set a token property with the list of all the tokens in the group -->\n[h, foreach(tok, grpList), CODE:{\n\t[switchToken(tok)]\n\t<!-- set groupname in the token label -->\n\t[token.label = \"group_\"+name]\n\t<!-- delete self from the token list -->\n\t[tmpList = listDelete(grpList, listFind(grpList, tok))]\n\t<!-- set the rest of the names of the tokens of the group in the property -->\n\t[setProperty(\"w42.boT.\"+token.label, tmpList)]\n}]\n[r:grpList+\" have grouped into one group names: \"+name]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e99aada6-4204-4e22-a38f-c67d0f2b6a77",
          "commandChecksum": "97f324a0df3eaff7f0300d77c85835eb",
          "propsChecksum": "230b6123b28bc40d495a478bc2aa83b3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "5",
        "index": 277,
        "label": "spreadGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX()]\n[h:y0 = getTokenY()]\n\n<!-- if the selected token belongs to a group, load the corresponding group, if it does not apply to currently selected tokens -->\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+2*(getTokenX()-x0), y0+2*(getTokenY()-y0))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "931a9e2a-4ab4-4a92-a5a2-ac6cb8b09010",
          "commandChecksum": "9427ff532e6eacf936e433895c793cda",
          "propsChecksum": "0e8e2192e8e5d118c8870e25dfd960b0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10. Group Select",
        "includeLabel": false,
        "sortBy": "5",
        "index": 278,
        "label": "clearSelectGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- clearSelectGroup () --------------------------------------->']\n<!-- \n<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group\n-->\n[h:tokenId\t= listGet(getSelected(),0)]\n[h:groupTokenLst\t= getProperty(\"w42.bot.groupToken\", tokenId)]\n[h, foreach(tok, groupTokenLst), if(findToken(tok)!=\"\"):resetProperty(\"w42.bot.groupToken\", tok)]\n\n[h:broadcast(\"Tokens have been ungrouped.\")]",
        "maxWidth": "",
        "tooltip": "<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b4b765f2-0606-4243-a11c-5fbd91b746ef",
          "commandChecksum": "3a1d0c699ad1eaec0b2e72da6b892e65",
          "propsChecksum": "fc18c03a9f22dcf8f554fd51d02a9b09"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "10. Group Select",
        "includeLabel": false,
        "sortBy": "2",
        "index": 279,
        "label": "groupFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ groupFrame ----------------------------------->']\n[h,if(argCount()): tooMany\t= arg(0) ; tooMany\t= 0]\n[frame(\"Group Select Panel\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: macroLinkText(\"groupHandler@Lib:OnTokenMove\", \"none\")]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\t[r:if(tooMany, \"Group Select Panel is deactivated cause their are currently too many tokens selected: \"+tooMany+\"<br>\", \"\")]\n\t\t\tPlease leave this frame open, it auto selects the 'siblings' of a 'select group'\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "94480973-a83a-49ad-a1ee-f72f403c4335",
          "commandChecksum": "c53cee85d725681865de412a70a2ec56",
          "propsChecksum": "f0516aa114b0a37d04555746a9a09792"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10. Group Select",
        "includeLabel": false,
        "sortBy": "3",
        "index": 280,
        "label": "groupHandler",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- groupHandler () --------------------------------------->']\n[h:currentSelection\t= getSelected(\"json\")]\n\n[h:maxGroupSelect\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:numSelect\t\t= json.length(currentSelection)]\n[h,if(numSelect > maxGroupSelect), CODE:{\n\t[bot_groupFrame(numSelect)]\n\t[abort(0)]\n};{}]\n\n<!-- build in delay to make sure the open door macro is called only once as the token select event will fire 2 to 4 times when you select a token -->\n[h, if(bot_timeOut(2)), CODE:{\n\t[bot_resetTimer(2)]\n\t[lastSelection\t= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]\n\t<!-- if the time out is too short then the selection gets reset to its original, this needs to be corrected -->\n\t[redoSelection\t= if(numSelect == 1 && json.length(lastSelection) > 1 && json.length(json.intersection(lastSelection, currentSelection)) == 1,1,0)]\n\t[if(redoSelection):newSelection\t= lastSelection ; newSelection\t= json.difference(currentSelection, lastSelection)]\n\t[if(json.length(newSelection) >= 1), CODE:{\t\n\t\t<!-- first create a complete json array of all tokens to be selected -->\n\t\t[toSelect\t= \"[]\"]\n\t\t[foreach(tok, newSelection): toSelect = json.union(toSelect, if(json.type(getProperty(\"w42.bot.groupToken\", tok))=='ARRAY', getProperty(\"w42.bot.groupToken\", tok), '[]')))]\n\t\t<!-- remove the already selected tokens -->\n\t\t[groupTokenLst\t= json.difference(json.unique(toSelect), currentSelection)]\n\t\t<!-- select the not already selected tokens of the group -->\n\t\t[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,\"json\")]\n\t};{}]\n\n\t[if(isFrameVisible(\"Draw Order\")), CODE:{\n\t\t[maxOrderSelect\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n\t\t[if(numSelect > maxOrderSelect): bot_orderWarning(numSelect) ; bot_orderFrame()] \n\t};{}]\n\n\t<!-- set time out again (cause the above could have take some time) and set last selection -->\n\t[bot_resetTimer(2)]\n\t[setLibProperty('lastSelection.GroupSelect', getSelected(\"json\"), 'lib:EventMacros')]\n}; {\n\t<!-- sometimes the former selection is negated (erratically) when this happens reselect ONLY the deselected tokens -->\n\t[lastSelection\t= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]\n\t[groupTokenLst\t= json.difference(lastSelection, currentSelection)]\n\t[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,\"json\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2ab468c6-f67f-48cf-9ce2-5c3a05b51c6e",
          "commandChecksum": "174cbc02d03ed0161d745421c3f77084",
          "propsChecksum": "576d59fb181b425409e44122a315489b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "10. Group Select",
        "includeLabel": false,
        "sortBy": "1",
        "index": 281,
        "label": "openGroupFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- openGroupFrame ------------------------------------------------>']\n<!-- <html> Turns on door switches at selected players. This will allow players to use doorswitches -->\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'<!-- input string -->']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'<!-- ask for input-->']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n\n<!-- need to make certain that this value is initialized on lib eventmacros -->\n[h:bot_resetTimer(2)]\n[h:setLibProperty('lastSelection.GroupSelect', '[]', 'lib:EventMacros')]\n\n[h:bot_execAllPlayers(\"groupFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c6d2b803-8a52-4896-8858-d3d50f2c70c7",
          "commandChecksum": "79db991374d118fcf81e05ce29f8adac",
          "propsChecksum": "a99e8c97e0b652972f028058124e3b22"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10. Group Select",
        "includeLabel": false,
        "sortBy": "4",
        "index": 282,
        "label": "setSelectGroup",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- setSelectGroup () --------------------------------------->']\n<!-- \n<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.\n--> \n\n[h:selected\t= getSelected(\"json\")]\n[h,foreach(tok, selected): setProperty(\"w42.bot.groupToken\", selected, tok)]\n[h:broadcast(\"Tokens have been grouped.\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6bf0a0fc-9cee-4f68-86a6-5aa953b4c114",
          "commandChecksum": "cbb4408215f9d78c7a15520fd9da6b97",
          "propsChecksum": "ea984a7b217c9d394b9f20c958edfb78"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "10",
        "index": 287,
        "label": "convertTrapPit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- convertTrapPit -->']\n[h, if(argCount()):passResult = arg(0); passResult = 0]\n[h:mapList = getAllMapNames(\"json\")]\n[h:oldMap = getCurrentMapName()]\n\n[h:tmpList = json.toList(mapList)]\n[h:excludedMaps = getLibProperty(\"excludedMaps\", \"lib:EventMacros\")]\n[H:activeMaps = json.difference(mapList,excludedMaps)]\n\n[r,foreach(currentMap,activeMaps), code: {\n\t[h:setCurrentMap(currentMap)]\n\t[h:allToks = getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\")))]\n\tFixed following tokens on map <b>{currentMap}<\/b>:\n\t[h:fixedList = \"\"]\n\t[h:i=1]\n\t[h,foreach(me,allToks), CODE:{\n\t\t[isTrap\t= if(startsWith(me,\"Trap \"),1,0)]\n\t\t[isPit\t= if(startsWith(me,\"Pit \"),1,0)]\n\t\t[fixIt\t= if(isPit || isTrap,1,0)]\n\t\t[if(fixIt): padNumber\t= substring(me, indexOf(me, \" \"))]\n\t\t['pause(\"isTrap\", \"isPit\", \"me\", \"padNumber\", \"allToks\")']\n\t\t[if(fixIt): fixIt\t\t= if(isNumber(padNumber),1,0)]\n\t\t\n\t\t[if(fixIt): switchToken(me)]\n\t\t[if(fixIt): token.name = \"EventPad \"+ i]\n\t\t[if(fixIt): i=i+1]\n\t\t\n\t\t[if(fixIt && isTrap): setProperty(\"w42.bot.eventTypeList\", \"movedOn, movedOver, movedReturn\")]\n\t\t[if(fixIt && isPit): setProperty(\"w42.bot.eventTypeList\", \"movedOn, movedOff, movedOver, movedReturn\")]\n\n\t\t[if(fixIt): fixedList = listAppend(fixedList, me)]\n\t}]\n\t{fixedList}\n}]\n[h:setCurrentMap(oldMap)]\n[r:bot_initializePads()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "06678cdc-00dd-4f04-8acc-329a4352ee41",
          "commandChecksum": "5f7de00db1392e000903380f8c98677c",
          "propsChecksum": "a63dace3c140e373ef4f5c9010908108"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "5",
        "index": 288,
        "label": "executeEvent",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------- executeEvent ----------------------------- -->']\n[h:'<!-- This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed -->']\n\n[h:'<!-- create a list of the macro groups -->']\n\n[h:oldMap = getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n[h:macroLabels\t= getMacros(\",\", \"lib:EventMacros\")]\n\n[h:groupList\t= \"\"]\n[h, foreach(macro, macroLabels, \"<br>\"), CODE:{\n\t[tmp\t\t= getMacroIndexes(macro, \",\", \"lib:EventMacros\")]\n\t[group\t\t= getStrProp(getMacroProps(tmp, \"; \", \"lib:EventMacros\"), \"group\")]\n\t[if(!listContains(groupList, group)): groupList = listAppend(groupList, group)]\n}]\n[h:groupList = listSort(groupList, \"N+\")]\n\n[h:'<!-- ---------------------------------Generate Input Screen based on found groups-------------------->']\n[h:inputStr\t\t= \"junk|<html><b>Select an event macro from the lists<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\n[h,foreach(group, groupList), CODE:{\n\t[groupName\t\t= \"group_\"+roll.count]\n\t[macroList\t\t= getMacroGroup(group, \",\", \"lib:EventMacros\")]\n\t[macroNameList\t= \"<none>\"]\n\t[foreach(macro, macroList,\"\"): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(macro, \"; \", \"lib:EventMacros\"), \"label\"))]\n\t[h:macroNameList\t= listSort(macroNameList, \"N+\")]\n\t[if(group == \"\"): group = \"~Ungrouped~\"]\n\t[inputStr\t\t= listAppend(inputStr, groupName+\"|\"+macroNameList+\"|\"+group+\" |LIST|VALUE=STRING\", \"##\")]\n}]\n[h:setCurrentMap(oldMap)]\n\n[h:'<!-- ask for input -->']\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \", \", \"##\")]\n[H: abort(eval(inputStr))]\n\n[h:'<!-- --------------------------------- execute chosen macro -------------------->']\n[h,foreach(group, groupList), CODE:{\n\t[choice\t\t= eval(\"group_\"+roll.count)]\n\t[if(choice != \"<none>\"), CODE:{[r,macro(choice+\"@Lib:EventMacros\"): \"\"]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4aaaffc-4c0b-4193-81c0-996cf8b21bb3",
          "commandChecksum": "4021fb2f445a5a9ce0100b5af0def126",
          "propsChecksum": "5c7597dbbff5ae5cc2ef426561acf814"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "10",
        "index": 289,
        "label": "getEventType",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------getEventType --------------------------------------------------- -->']\n<!-- NO NEW SCOPE ; IGNORE OUTPUT -->\n<!-- check which event type this token triggers this can be \n  trigger type (started, ended, moved, same length)\n- noInteraction\t(0000)\n- movedOn\t\t(0110)\n- movedOff \t\t(1010)\n- movedOver \t(0010)\n- movedNot\t\t(1101)\twhen you move the token but place it back on its original spot\n- movedReturn\t(1110)\twhen you move the token AND use way points AND leave the token but end the move onto the token\n- movedRemain\t(1111)\twhen you move but remain on the token during the entire move (both the path and the triggerpath are the same length)\nNote that ONLY ONE event will be TRUE the REST WILL BE FALSE\n- movedWard\t\t(1001)\twhen you move the token over or onto a Ward -->\n\n[pathLength\t\t= json.length(lastPath)]\n[triggerLength\t= json.length(eventPadTriggered)]\n\n[startedOnPad\t= if(json.contains(eventPadTriggered,startingLocation),1,0)]\n[endedOnPad\t\t= if(json.contains(eventPadTriggered,currentLocation),1,0)]\n[didMove\t\t= min(1, json.length(lastPath)-1)]\n[sameLength\t\t= if(pathLength == triggerLength, 1, 0)]\n\n<!-- get trigger type add the three results into a string e.g. 011 == movedOn-->\n[if(triggerLength):\ttriggerString = strformat(\"%{startedOnPad}%{endedOnPad}%{didMove}%{sameLength}\") ; triggerString = 0]\n[triggerTypeList\t= \"noInteraction, movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain, movedWard\"]\n[triggerStringList\t= \"0,110,1010,10,1101,1110,1111,1001\"]\n<!-- 'pause(\"startedOnPad\",\"endedOnPad\",\"didMove\",\"sameLength\", \"eventPadTriggered\",\"lastPath\", \"startingLocation\",\"currentLocation\",\"triggerString\",\"triggerLength\")' -->\n\n[if(listContains(triggerStringList, triggerString)): \n\ttriggerType\t\t= listGet(triggerTypeList, listFind(triggerStringList, triggerString))\n; \n\tassert(0,\"Error occured in getEventType: \"+triggerString+\" trigger (started, ended, moved, not left) string is unknown\",1)\n]\n\n[macro.return = triggerType]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b35d5739-7880-46d9-b405-164cd8137cb2",
          "commandChecksum": "2f4512dca4fc3017031eb00a84257fe9",
          "propsChecksum": "b412e79cd3c8118ba9e369298a7983a0"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "10",
        "index": 290,
        "label": "resetPit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h, token(getSelected()):  setTokenImage(getTokenPortrait())]",
        "maxWidth": "",
        "tooltip": "<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "35807f52-bf92-44bf-9391-8f3353953bf4",
          "commandChecksum": "54356cc226fc0fac3e9c1d0b96f69ca0",
          "propsChecksum": "905d4b8deeac22a5e9fa9284d6f198ee"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "8",
        "index": 291,
        "label": "setEventButton",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- setEventButton ----------------------------------------------->']\n[h:debug=0]\n[h:assert(isGM(),\"GM only!\",0)]\n<!-- <html>\nThis macro can be used to link an Event Macro to a Event Button.<br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>\ncode that is activated when the button, e.g. 'Switch To Map'<br>\n2. Select the button (any token will do) to which that macro should apply e.g. \"Switch to Fair Haven\"<br>\n3. Run this macro<br>\n4. Select \"Switch Map\" from the list<br>\n5. In the \"Give Arguments\" box enter the arguments as a stringproperty, e.g.\"toMap=Fair Haven\"<br>\n<br>\nHere it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>\ncontains ONLY alphanumeric  characters!<br>\nNote that you can give multiple arguments! Just seperate them with a ;.<br>\nE.g. toMap=Fair Haven;message=Going to Fair Haven.<br>\n<br>\n6. Click OK. Now everything is set up<br>\n<br>\nTo use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>\nbut it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>\nmake this pop-up small, but you cannot close it (else the buttons will not work).<br>\n<br>\nIf you now click on the button \"Switch to Fair Haven\" the macro \"Switch Map\" is activated.<\/html>\n-->\n\n[h:selectedTokens = getSelectedNames()]\n<!-- assert correct selected -->\n[h:assert(listCount(selectedTokens),\"Please select at least one token first before running this macro\",0)]\n\n<!-- initialize values -->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\n<!-- create macro list from the Event Button Macros group -->\n[h:macroIDList\t\t= getMacroGroup(\"Event Button macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n\n[h:setCurrentMap(oldMap)]\n\n[h:me\t\t\t\t= listGet(selectedTokens,0)]\n[h:all.buttonArgs\t= getProperty(\"buttonArgs\",me)]\n\n[h,if(getStrProp(all.buttonArgs, \"macroToCall\")==\"\"), CODE:{\n\t[macroToCall\t= \"name of macro\"]\n\t[buttonArgs\t\t= \"argumentName=give argument;\"]\n};{\n\t[macroToCall\t= getStrProp(all.buttonArgs, \"macroToCall\")]\n\t[buttonArgs\t\t= deleteStrProp(all.buttonArgs, \"macroToCall\")]\n\t<!-- remove @Lib:EventMacros from macroToCall -->\n\t[macroToCall\t= substring(macroToCall, 0, indexOf(macroToCall,\"@\"))]\n}]\n\n[h:assert(macroNameList != \"\",\"First create at least one macro on the lib:EventMacro token with which this eventPad can be associated\",0)]\n[h,if(listContains(macroNameList, macroToCall)):currentMacro = listFind(macroNameList,macroToCall) ; currentMacro = 0]\n\n[h,if(debug == 1):pause(\"macroToCall\", \"macroNameList\", \"currentMacro\", \"buttonArgs\")]\n\n<!-- ask for input -->\n[h:abort(input(\n\t'junk|<html><b>Associated Macro<\/b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'<\/u><br>Note that only the macros from the group: \"Event Button macros\" on \"Lib:EventMacros\" are in the drop downlist <\/html>|-|LABEL|SPAN=TRUE',\n\t'macroToCall|'\t+macroNameList\t+'|<html><span title=\"<html><b>Enter here the name of the macro that is used when the button is activated.<\/html>\">Name of associated macro<\/html><\/span><\/html>|LIST|SELECT='+currentMacro,\n\t'buttonArgs|'\t+buttonArgs\t+'|<html><span title=\"<html>Enter the argument(s) to be passed to the activated macro<br>as a stringproperty, e.g."toMap=Fair Haven"<br>Here it is important that both the the arguments name (toMap)<br>and the arguments (Fair Haven) contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap=Fair Haven;message=Going to Fair Haven.<br><\/html>\">Give arguments for macro<\/html><\/span><\/html>|TEXT|WIDTH=50',\n\t'removeLink|0|<html>Check to remove any macro linked to selected token(s).<\/html>|CHECK'\n))]\n\n[h:macroToCall\t= listGet(macroNameList, macroToCall)]\n[h:buttonArgs\t= setStrProp(buttonArgs, \"macroToCall\", macroToCall+\"@lib:EventMacros\")]\n<!-- set choices for all selected tokens -->\n[r,gm,if(removeLink), CODE:{\n\t[h,foreach(me, selectedTokens):resetProperty(\"buttonArgs\", me)]\n\t[r, gm:\"The Macro <u>\"+macroToCall+\"<\/u> is now <b>REMOVED<\/b> from the following token(s)<u> \"+selectedTokens+\"<\/u>.\"]\n};{\n\t[h,foreach(me, selectedTokens):setProperty(\"buttonArgs\", buttonArgs, me)]\n\t[r, gm:\"The Macro <u>\"+macroToCall+\"<\/u> is now linked to the following token(s)<u> \"+selectedTokens+\"<\/u>. This macro will be executed when this (or one of these) tokens are selected: <u>\"+selectedTokens+\"<\/u>. Keep in mind that you first need to run 'Activate Switches' before they work!\"]\n}]\n\n<!-- reselect the selected tokens -->\n[h:selectTokens(selectedTokens,1,\",\")]\n\n[h,if(debug==1), CODE:{\n\t[me\t\t\t= listGet(selectedTokens,0)]\n\t[butArgs\t= getProperty(\"buttonArgs\", me)]\n\t[bot_debugInfo(\"butArgs, me, selectedTokens\",1,1,0, getMacroName(), getMacroLocation() )]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. \"Switch to Fair Haven\"<br>3. Run this macro<br>4. Select \"Switch Map\" from the list<br>5. In the \"Give Arguments\" box enter the arguments as a stringproperty, e.g.\"toMap=Fair Haven\"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "96e67be7-71f4-49a9-b77d-ea672e5fe7a2",
          "commandChecksum": "9c42c3ca1c9ac104d5ef2d2304529110",
          "propsChecksum": "b29ad47eb4326a483ba0e21bd1b712db"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7b. Event Macros",
        "includeLabel": false,
        "sortBy": "8",
        "index": 292,
        "label": "setEventPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------- setEventPad ----------------------------------------------->']\n<!-- \n<html>\nThis macro can be used to link an Event Macro to an EventPad<br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group:<br>\n'Event Pad Macros', containing the code that is activated when the<br>\nEvent is triggered. For example 'Spear Trap<br>\n2. Select an 'Event token'. This is a token which name starts with<br>\n'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>\nThis token can be placed on any layer<br>\n3. Run the macro 'Set Event Pad'<br>\n4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>\n5. Then select the events on which this macro is triggered<br>\n7. Click OK <br>\n8. Run 'Initialize Maps'<br>\n<br>\nThe Event Pad is now set<br>\n-->\n\n[h:selectedTokens = getSelectedNames()]\n<!-- assert correct selected -->\n[h:assert(listCount(selectedTokens),\"Please select an EventPad first before running this macro\",0)]\n[h,foreach(me, selectedTokens):assert(startsWith(me, \"EventPad \"),\"Make sure only Eventpad(s) are selected\",0)]\n[h:me = listGet(selectedTokens,0)]\n[h:switchToken(me)]\n\n<!-- initialize values -->\n[h:oldMap = getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Pad Macros\", \",\", \"lib:EventMacros\")]\n\t<!-- create macro list from the Event Button Macros group -->\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain\"]\n[h:varsFromStrProp(\"movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0\")]\n[h, foreach(event, eventTypeList): set(event, 1)]\n[h:assert(macroNameList != \"\",\"First create at least one macro on the lib:EventMacro token with which this eventPad can be associated\",0)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n<!-- ask for input -->\n[h:abort(input(\n\t'junk|<html><b>Associated Macro<\/b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'<\/u><br>Note that only the macros from the group: \"Event Pad macros\" on \"Lib:EventMacros\" are in the drop downlist <\/html>|-|LABEL|SPAN=TRUE',\n\t'macroName|'\t+macroNameList+'|<html><span title=\"<html><b>Enter here the name of the macro that is used when this EventPad is triggered.<\/html>\">Name of associated macro<\/html><\/span><\/html>|LIST|SELECT='+currentMacro,\n\t'junk|<html><b>Which events trigger this pad (all events are mutual exclusive)<\/b><\/html>|-|LABEL|SPAN=TRUE',\n\t'movedOn|'\t\t+movedOn+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves onto this pad<\/b>.<\/html>\">Token moves onto pad<\/html><\/span><\/html>|CHECK',\n\t'movedOff|'\t\t+movedOff+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>leaves this pad.<\/html>\">Token moves off pad<\/html><\/span><\/html>|CHECK',\n\t'movedOver|'\t+movedOver+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves over this pad.<\/html>\">Token moves over pad<\/html><\/span><\/html>|CHECK',\n\t'movedNot|'\t\t+movedNot+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>on this pad is moved<br>from and back to the same postion on this pad<br>without using waypoints.<\/b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.<\/html>\">Token does zero move on pad<\/html><\/span><\/html>|CHECK',\n\t'movedReturn|'\t+movedReturn+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves off this pad<br>and back onto it, using waypoints.<\/html>\">Token leaves and returns onto pad<\/html><\/span><\/html>|CHECK',\n\t'movedRemain|'\t+movedRemain+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>is moved but remains<br>on the pad the entire move.<\/html>\">Token moves but remains on pad<\/html><\/span><\/html>|CHECK'\n))]\n\n[h:macroName = listGet(macroNameList, macroName)]\n<!-- set choices for all selected tokens -->\n[h,foreach(me, selectedTokens), CODE:{\n\t[switchToken(me)]\n\t[setProperty(\"w42.bot.macroName\", macroName)]\n\t[eventTypeList = \"\"]\n\t[foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t[setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n}]\n\n[r, gm:\"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+selectedTokens+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "465bcdd1-08af-43ec-933e-ec46b7a23d26",
          "commandChecksum": "f91c8365f9c862682777ab4591aafd6d",
          "propsChecksum": "55a15cf1d5bd92018d16159b7e8454c5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "2",
        "index": 293,
        "label": "cos",
        "fontSize": "0.95em",
        "minWidth": "21",
        "playerEditable": false,
        "command": "<!-- developed by Aliasmask -->\n[H: radians = arg(0)]\n[H: cosine = 1]\n[H: product = 1]\n[H, for(i,2,21,2), code: {\n   [H: product = product * -1 * i * (i-1)]\n   [H: cosine = cosine + power(radians,i) / product]\n}]\n[H: macro.return = cosine ]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d9623b22-b40f-44a7-b0e8-5cbb3e554fd0",
          "commandChecksum": "85deff6d16d2b708c828cca655daa7a5",
          "propsChecksum": "ce59e0ae5307ae934e3b90cabf22049c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "11",
        "index": 294,
        "label": "facingToCoord",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- 0:x1, 1:y1, 2:range, 3:angle -->\n[h:macro.return = strformat(\n\t'{\"x\":%s,\"y\":%s}', \n\targ(0) + round(arg(2)*bot_cos(bot_toRadians(arg(3)+90)),0),\n\targ(1) - round(arg(2)*bot_sin(bot_toRadians(arg(3)+90)),0)\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c01eac32-9180-4bc2-86d7-bd65a214d2da",
          "commandChecksum": "1a4d4f3bc5bcd34f944f6a5f6e04f64c",
          "propsChecksum": "0f603bdf26ee21268f3a595fa1c1ad94"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "12",
        "index": 295,
        "label": "facingToCoordX",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- 0:x1, 1:range, 2:angle -->\n[h:macro.return = arg(0) + round(arg(1)*bot_cos(bot_toRadians(arg(2)+90)),0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ae1166fd-3b0b-4fa7-a35d-c2c3634daf5e",
          "commandChecksum": "0f083de3db5bdb5d7379ada27814445b",
          "propsChecksum": "2f4c92daf4798c5e87d0005174ef7770"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "13",
        "index": 296,
        "label": "facingToCoordY",
        "fontSize": "0.95em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- 0:y1, 1:range, 2:angle -->\n[h:macro.return = arg(0) - round(arg(1)*bot_sin(bot_toRadians(arg(2)+90)),0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d8adafbe-e303-4f60-85e8-df3fed9c052f",
          "commandChecksum": "e5d1147c91b3fed3f3b4eeb6ec1919c5",
          "propsChecksum": "b752d2702b64c5f38fbff09cc2332767"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "22",
        "index": 297,
        "label": "getTokenFacing",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ---------------------------------------- getTokenFacing----------------------------------- \ntype 0 or default only changes the range from -180 - 180 to 0 - 360.Type 1 ALSO inverts the angle so CW is positive AND make sure that no facing == 270 (pointing down) instead of -90. \nso:\n\n0 (CCW)(usefull for tokens with the arrow, where unrotated points down=270):\n > = 0 ; ^ = 90 ; < = 180 ; V = 270(no facing) \n1 (CW)(useful for top down tokens (without the arrow. Unrotated then means: 0, 90 CW results in 90, etc.):\n > = 270 ; ^ = 180 ; < = 90 ; V = 0(no facing) \n2 (CW):\n > = 0 ; ^ = 270 ; < = 180 ; V = 90(no facing) \n\n-->']\n\n[h,if(argCount()>0):\tangle\t= getTokenFacing(arg(0)) ; angle\t= getTokenFacing(currentToken())]\n[h,if(argCount()>1):\ttype\t= arg(1) ; type\t= 0]\n\n[h,if(angle == \"\"):\t\tangle\t= -90]\n[h,if(type == 1): \t\tangle\t= angle + 90]\n[h:angle\t= if(angle <0, angle + 360, angle)]\n[r,if(type && angle):\tmacro.return = 360-angle ; macro.return = angle]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1da33867-b931-4bbc-b21a-af011409b49f",
          "commandChecksum": "628199b97cd0a47a36544724113917fa",
          "propsChecksum": "648cd7bc9f22d573e2a3cef3735c590d"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "6",
        "index": 298,
        "label": "mod",
        "fontSize": "1.00em",
        "minWidth": "39",
        "playerEditable": false,
        "command": "[H: macro.return = arg(0) - arg(1) * floor(arg(0) / arg(1))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9a50af0e-c450-448f-aa4a-576fbbd0745e",
          "commandChecksum": "05a7ff2851f7af58be99bc6ff79a4ee2",
          "propsChecksum": "5289e3a4012fc157513b4d7bc7e2b8d8"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "7",
        "index": 299,
        "label": "odd",
        "fontSize": "1.00em",
        "minWidth": "39",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- ODD ------------------------------------------------>']\n[r:if(band(arg(0),1) == 0, 0, 1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6a4f6270-e2af-460e-96d0-d802e19c489e",
          "commandChecksum": "78bf12da8ae60a5907cbf9f80de6bdc0",
          "propsChecksum": "b40af5bfc62a9df59178b9b7cdfa9d70"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "1",
        "index": 300,
        "label": "pi",
        "fontSize": "0.95em",
        "minWidth": "21",
        "playerEditable": false,
        "command": "[H: macro.return = 3.14159265358979323846 ]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "504e64e3-740d-4186-925a-aef012868205",
          "commandChecksum": "3c80e35fcbd3709c8307039e46c30624",
          "propsChecksum": "08b0fd444358436e2d1748585407e3e4"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "21",
        "index": 301,
        "label": "setTokenFacing",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ---------------------------------------- setTokenFacing----------------------------------- -->']\n\n[h:angle\t= arg(0)]\n[h,if(argCount()>1):\tme\t\t= arg(1) ; me\t\t= currentToken()]\n[h,if(argCount()>2):\ttype\t= arg(2) ; type\t\t= 0]\n\n[h:macro.return = setTokenFacing(if(type, 360-angle-90, angle), me)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cbb50c23-a7d8-420d-a6f3-a2dc8f917312",
          "commandChecksum": "d06d3337e3330aa9f0c3b9a2fdc13a57",
          "propsChecksum": "39dbee9c8d93019e7eb803b76f526a37"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "3",
        "index": 302,
        "label": "sin",
        "fontSize": "0.95em",
        "minWidth": "21",
        "playerEditable": false,
        "command": "<!-- developed by Aliasmask -->\n[H: radians = arg(0)]\n[H: sine = radians]\n[H: product = 1]\n[H, for(i,3,24,2), code: {\n   [H: product = product * -1 * i * (i-1)]\n   [H: sine = sine + power(radians,i) / product]\n}]\n[H: macro.return = sine]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "efe00d6a-647e-4b67-858e-246b0b643197",
          "commandChecksum": "42ed38c6a5b5ae59922c5db69bd3710f",
          "propsChecksum": "f6ecba6b1025ee9352ee43cf8978d633"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "4",
        "index": 303,
        "label": "tan",
        "fontSize": "0.95em",
        "minWidth": "21",
        "playerEditable": false,
        "command": "[H: macro.return = bot_sin(arg(0)) / bot_cos(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52d017c5-4b41-44bc-b9c2-f24b92984fad",
          "commandChecksum": "5b6feae0b3aefd5e199e39073c1ef866",
          "propsChecksum": "1f5b43e0531942d919b27a4551243aa5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - math",
        "includeLabel": false,
        "sortBy": "5",
        "index": 304,
        "label": "toRadians",
        "fontSize": "0.95em",
        "minWidth": "57",
        "playerEditable": false,
        "command": "<!-- developed by Aliasmask -->\n[H: macro.return = arg(0) * (bot_pi() / 180)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9bb78a0e-2b84-46b1-902a-5e78c92b83e1",
          "commandChecksum": "dc67fbddb0b01c444e3688116e231c94",
          "propsChecksum": "97b889f22ecfee4f9ffcd5e713256227"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "",
        "index": 305,
        "label": "cpyDelMacros",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ cpyDelMacros ----------------------------------->']\n<!-- \n<html>\nThis macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br>\n<br>\nIn case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br>\nclick <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br>\ntoken.<br>\nIn case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br>\nand if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br>\nprocess.\n<\/html>\n -->\n\n<!-- General method to get macro groups and labels on a token. This version is to delete unwanted or unneeded macros -->\n<!-- but it is possible to use this information for whatever purpose you might think of -->\n<!-- original macro by Rumble, improved by Wolph42 (added copy option and 'all macros' options) -->\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n<!-- Get a list of all macros on a token -->\n[h,if(getMacros() != \"\"): fullMacList\t= getMacros(); assert(0, \"There are no macros on the token <b>\"+token.name+\"<\/b>\", 0)]\n[h:fullMacList\t\t= listSort(fullMacList,\"N+\")]\n[h:fullMacList\t\t= json.fromList(fullMacList))]\n[h:macroList\t\t= json.unique(fullMacList)]\n\n<!-- Loop through the list of macros, and extract the GROUP property from the result of getMacroProps() -->\n[h:groupArray\t\t= \"\"]\n[h,foreach(macro,macroList),CODE:{\n\t[indexes\t\t= getMacroIndexes(macro)]\n\t[foreach(index,indexes): \n\t\tgroupArray\t= if(\n\t\t\tgetStrProp(getMacroProps(index),\"group\")\t== \"\", \n\t\t\tjson.append(groupArray, \"__no group name__\"), \n\t\t\tjson.append(groupArray, getStrProp(getMacroProps(index), \"group\"))\n\t\t)\n\t]\n}]\n\n<!-- Since we need only the names of each unique group, use json.unique() to return a list of the unique entries in groupArray -->\n[h:groupList\t\t= listSort(json.toList(json.unique(groupArray)), \"N+\")]\n\n[h:macrosInGroup\t= \"{}\"]\n[h,foreach(macroGroup, groupList),CODE:{\n\t[tmpObj\t\t= \"\"]\n\t[foreach(macro,macroList),CODE:{\n\t\t[indexes\t= getMacroIndexes(macro)]\n\t\t[foreach(index, indexes): tmpObj\t= \n\t\t\tif(\n\t\t\t\tif(\tgetStrProp(getMacroProps(index),\"group\") == \"\", \n\t\t\t\t\t\"__no group name__\", \n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")\n\t\t\t\t) == macroGroup,\n\t\t\t\tlistAppend(tmpObj, macro), \n\t\t\t\ttmpObj\n\t\t\t)\n\t\t]\n\t}]\n\t[macrosInGroup\t= json.set(macrosInGroup, macroGroup, tmpObj)]\n}]\n\n[h:inputParams\t\t= json.append(\"\", \n\t\t\t\t\t\t\"initial|ALL MACROS||TAB\",\n\t\t\t\t\t\t\"deleteMacros|Copy Macros, Delete Macros|<html><b>Copy or Delete Selected Macros<\/b><\/html>|RADIO|SELECT=0\",\n\t\t\t\t\t\t\".|<html><b>Copy<\/b> will cache the selected macros to a property on lib:EventMacros.<br>After this is done you can select another token and paste the macros onto them.<br><b>Delete<\/b> will delete the selected macros from this token immediately.<br><br><\/html>||LABEL|SPAN=TRUE\",\n\t\t\t\t\t\t\"doUndo|1|<html><b>Allow Undo<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Allow undo<\/b> will store the macro on the property: <i>rumble.bot.deleteMacroUndo<\/i> on<br>the selected token. This will allow you to undo the deletion later on, but will also<br>increase token size<br><br><\/html>||LABEL|SPAN=TRUE\",\n\t\t\t\t\t\t\"deleteAllMacros|0|<html><b>Select ALL macros<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Select ALL macros from the following groups!<\/b><\/html>||LABEL|SPAN=TRUE\"\n)]\n\n[h,foreach(macroGroup, groupList):\n\tinputParams\t\t= json.append(inputParams, \"groupDelete_\"+roll.count+\"|0|\"+macroGroup+\"|CHECK\")\n)]\n\n[h,foreach(macroGroup, groupList),CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[inputParams\t= json.append(inputParams, \"group_\"+roll.count+\"|\"+macroGroup+\"||TAB\")]\n\t[inputParams\t= json.append(inputParams, \".|<html><b>Select individual macros you wish to copy or delete.<\/b><\/html>||LABEL|SPAN=TRUE\")]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[idx\t\t= getMacroIndexes(macroLabel)]\n\t\t[foreach(index, idx): inputParams\t= \n\t\t\tif(\n\t\t\t\tif(\n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")==\"\", \n\t\t\t\t\t\"__no group name__\", \n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")\n\t\t\t\t) == macroGroup, \n\t\t\t\tjson.append(inputParams, \"macro_\"+index+\"|0|<html>\"+macroLabel+\" \"+if(getStrProp(getMacroProps(index),\"tooltip\")==\"\", \"(no tooltip available)\", \"(\"+getStrProp(getMacroProps(index),\"tooltip\")+\")\")+\"<\/html>|CHECK\"), \n\t\t\t\tinputParams\n\t\t\t)\n\t\t]\n\t}]\n}]\n\n<!-- Convert inputParams from a JSON string array to a string list, using ## as the list delimiter (required for this trick) -->\n<!-- pass inputParams to the input() function to generate an input dialog with tabs for each macro group, and the macros listed -->\n[h:abort(input(json.toList(inputParams, \"##\")))]\n\n[h:deleteGroupList\t= \"\"]\n[h,foreach(macroGroup, groupList),CODE:{\t\n\t[if(eval(\"groupDelete_\"+roll.count)): deleteGroupList\t= listAppend(deleteGroupList, macroGroup)]\n}]\n\n<!-- Finally, go through each macro on the token (again!) and, if its box is checked, delete it. -->\n[h:backUpMacros\t\t= \"{}\"]\n[h,foreach(macro,macroList),CODE:{\n\t[macroIndexes\t= getMacroIndexes(macro)]\n\t[foreach(index, macroIndexes),code:{\n\t\t[group\t\t= getStrProp(getMacroProps(index),\"group\")]\n\t\t[group\t\t= if(group == \"\", \"__no group name__\", group)]\n\t\t[checked\t= eval(\"macro_\"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] \n\t\t[if(checked): backUpMacros\t= json.set(backUpMacros, macro, getMacroProps(index, \"json\"))]\n\t\t[if(checked && deleteMacros): removeMacro(index)]\n\t }]\n}]\n\n[r, if(deleteMacros), CODE:{\n\t[r,if(doUndo), CODE:{\n\t\t[h:setProperty(\"rumble.bot.deleteMacroUndo\", backUpMacros)]\n\t\tBackup of macros stored on token. <br>\n\t};{}]\n\tMacro(s) removed.\n};{\n\t[h:setLibProperty(\"cpDel.backUpMacros\", backUpMacros, \"lib:EventMacros\")]\n\t[h:setLibProperty(\"cpDel.groupList\", groupList, \"lib:EventMacros\")]\n\t[h:setLibProperty(\"cpDel.macrosInGroup\", macrosInGroup, \"lib:EventMacros\")]\n\tMacro(s) copied.\n}]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5499299c-44be-4422-8b83-982155ae6290",
          "commandChecksum": "fcb97596bbca4e257080b1b46beeab5a",
          "propsChecksum": "01ea78123c8f7839b0f3f6c7c78943d9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "",
        "index": 306,
        "label": "pasteMacros",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ pasteMacros ----------------------------------->']\n[h:debug = 0]\n\n<!-- \n<html>\nThis button you can use to paste macro on the selected token. Before you do this, you first need to run the <br>\nCopy/Del Macros button on another token.\n<\/html>\n -->\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n[h:backUpMacros\t\t= getLibProperty(\"cpDel.backUpMacros\",\t\"lib:EventMacros\")]\n[h:groupList\t\t= getLibProperty(\"cpDel.groupList\",\t\t\"lib:EventMacros\")]\n[h:macrosInGroup\t= getLibProperty(\"cpDel.macrosInGroup\",\t\"lib:EventMacros\")]\n\n[h:assert(json.type(backUpMacros) == \"OBJECT\", \"No back-up macros were ever stored on this token\", 0)]\n[h:assert(json.length(backUpMacros) > 0, \"No macros left to undelete\", 0)]\n\n[h:macroList\t\t= json.fields(backUpMacros)]\n\n[h:inputParams\t\t= json.append(\"\", \n\t\t\t\t\t\t\"initial|ALL MACROS||TAB\",\n\t\t\t\t\t\t\"deleteAllMacros|0|<html><b>Select ALL macros<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Select ALL macros from the following groups!<\/b><\/html>||LABEL|SPAN=TRUE\"\n)]\n\n[h,foreach(macroGroup, groupList):\n\tinputParams\t\t= json.append(inputParams, \"groupDelete_\"+roll.count+\"|0|\"+macroGroup+\"|CHECK\")\n)]\n\n[h:index\t\t\t= 0]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[inputParams\t= json.append(inputParams, \"group_\"+roll.count+\"|\"+macroGroup+\"||TAB\")]\n\t[inputParams\t= json.append(inputParams, \".|<html><b>Select individual macros you wish to paste.<\/b><\/html>||LABEL|SPAN=TRUE\")]\n\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, index, inputParams\", 0,0,0,0,0)]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[macroData\t= json.get(backUpMacros, macroLabel)]\n\t\t[toolTip\t= json.get(macroData, \"tooltip\")]\n\t\t[if(toolTip == \"\"): toolTip ==\"(no tooltip available)\"]\n\t\t[inputParams = json.append(inputParams, \"macro_\"+index+\"|0|<html>\"+macroLabel+\" \"+toolTip+\"<\/html>|CHECK\")]\n\t\t[index\t= index + 1]\n\t\t<!-- bot_debugInfo(vars [, oneLine, showTok, pause, macroName, macroLocation]) -->\n\t\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, macroData, toolTip, index, macroLabel, inputParams\", 0,0,0,0,0)]\n\t}]\n}]\n\n<!-- Convert inputParams from a JSON string array to a string list, using ## as the list delimiter (required for this trick) -->\n<!-- pass inputParams to the input() function to generate an input dialog with tabs for each macro group, and the macros listed -->\n[h:abort(input(json.toList(inputParams, \"##\")))]\n\n[h:deleteGroupList\t= \"\"]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[if(eval(\"groupDelete_\"+roll.count)): deleteGroupList\t= listAppend(deleteGroupList, macroGroup)]\n}]\n\n[if(debug): pause(\"deleteGroupList\")]\n\n<!-- Finally, go through each macro on the token (again!) and, if its box is checked, delete it. -->\n[h:index\t\t\t= 0]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[macroData\t= json.get(backUpMacros, macroLabel)]\n\t\t[group\t\t= json.get(macroData, \"group\")]\n\t\t[group\t\t= if(group == \"\", \"__no group name__\", group)]\n\t\t[checked\t= eval(\"macro_\"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] \n\t\t[if(checked): pasteProps = json.get(backUpMacros, macroLabel)]\n\t\t[if(checked): createMacro(pasteProps)]\n\t\t[index\t= index + 1]\n\t\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, macroLabel, group, deleteGroupList, checked, macroData\", 0,0,1,0,0)]\n\t}]\n}]\n\nmacros have been copied.",
        "maxWidth": "",
        "tooltip": "<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad4d25f2-1343-4342-b8fd-31be61dd1804",
          "commandChecksum": "003532fd4cfd6a4a23e0622925e87b7a",
          "propsChecksum": "050f52da8b9abc9bb90b19f78ca9ea76"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "",
        "index": 307,
        "label": "undoDelMacros",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------ undoDelMacros ----------------------------------->']\n<!--\n<html>\nIf you deleted macros on the selected token using the Copy/Del Macros function<br>\nAND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br>\nthat process\n<\/html>\n-->\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n[h:copiedMacros\t\t= getLibProperty(\"macroCopies\", \"lib:EventMacros\")]\n[h:assert(json.type(copiedMacros) == \"OBJECT\", \"No back-up macros were ever stored on this token\", 0)]\n[h:assert(json.length(copiedMacros) > 0, \"No macros left to undelete\", 0)]\n\n[h:deletedMacroList\t= json.fields(copiedMacros)]\n[h:abort(input(\"macToRestore|\"+deletedMacroList+\"|Choose Macro to Paste|LIST|SELECT=0 VALUE=STRING\"))]\n[h:restoreProps\t\t= json.get(copiedMacros, macToRestore)]\n[h:copiedMacros\t\t= json.remove(copiedMacros, macToRestore)]\n[h:createMacro(restoreProps)]\n\n<i>[r:macToRestore]<\/i> macro restored.",
        "maxWidth": "",
        "tooltip": "<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "afe2a214-9fd1-441a-a20c-ccd3dc0a8e75",
          "commandChecksum": "64f2447d682dd2d06cc08c1c028676d6",
          "propsChecksum": "0ff55d78702c99a17139f74d02d31c6e"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 308,
        "label": "createSplices",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- createSplices ------------------------------------ -->']\n<!-- new scope no output -->\n<!-- this function splits large (>1000) LISTS OR ARRAYS into splices so they can be handled in loops without bugging out because of the 1000 loop limitation -->\n\n[h: theList = arg(0)]\n<!-- if a list if fed, then turn it into an array -->\n[h, if(json.type(theList) == \"UNKNOWN\"): theList = json.fromList(theList)]\n\n[h: maxCount\t\t\t= json.length(theList)]\n[h: splices\t\t\t\t= \"\"]\n[h: from\t\t\t\t= 0]\n[h: to\t\t\t\t\t= from + 999]\n\n<!-- in case the list has length 0 -->\n[h, if(maxCount < 1):\tto = -1]\n\n[h, while(to >= 0), code: {\n\t[if(to >= maxCount): to = -1]\n\t[thisSplice\t= json.get(theList, from, to)]\n\t[splices\t= json.append(splices, thisSplice)]\n\t[from\t\t= from + 1000]\n\t[if(to != -1):to = from + 999]\n}]\n\n[h:macro.return = splices]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aae7a4b8-e58a-46d2-93ed-002c225a2a02",
          "commandChecksum": "d0eb00b2db936d4240bea1b2be554a47",
          "propsChecksum": "65fa2ad7ec95b847064765ca58159896"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "21",
        "index": 309,
        "label": "debugInfo",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), MacroName, macroLocation)----------------------- -->']\n<!-- NO NEW SCOPE !! -->\n[\t\t\t\t\t w42_debug_vars\t\t= arg(0)]\n[if(argCount() > 1): w42.debug.oneLine\t= arg(1) ; w42.debug.oneLine\t= 1]\n[if(argCount() > 2): w42.debug.showTok\t= arg(2) ; w42.debug.showTok\t= 1]\n[if(argCount() > 3): w42.debug.pause\t= arg(3) ; w42.debug.pause\t\t= 0]\n[if(argCount() > 4): w42.debug.macro\t= arg(4) ; w42.debug.macro\t\t= \"\"]\n[if(argCount() > 5): w42.debug.location\t= arg(5) ; w42.debug.location\t= \"\"]\n\n[if(currentToken() != \"\" && w42.debug.showTok), CODE:{\n\t[w42.debug.currTok\t\t= getName(currentToken())]\n\t[token(w42.debug.currTok): w42.debug.currTok.img = getTokenImage()]\n};{\n\t[if(w42.debug.showTok), CODE:{\n\t\t[w42.debug.currTok\t\t= \"<i><font color='gray'>none<\/font><\/i>\"]\n\t\t[w42.debug.currTok.img\t= \"\"]\n\t};{\n\t\t[w42.debug.currTok\t\t= \"\"]\n\t}]\n}]\n\n[if(hasImpersonated() && w42.debug.showTok), CODE:{\n\t[w42.debug.impTok\t= getImpersonatedName()]\n\t[token(w42.debug.impTok): w42.debug.impTok.img = getTokenImage()]\n};{\n\t[if(w42.debug.showTok), CODE:{\n\t\t[w42.debug.impTok\t\t= \"<i><font color='gray'>none<\/font><\/i>\"]\n\t\t[w42.debug.impTok.img\t= \"\"]\n\t};{\n\t\t[w42.debug.impTok\t\t= \"\"]\n\t}]\n}]\n\n[w42.debug.textOut\t=\"<table border='1'>\" +\n\tif(w42.debug.macro\t\t!= \"\", \"<tr><td><b>Running from:\t\t<\/b><\/td>\t<td colspan='2'>%{w42.debug.macro}@%{w42.debug.location}<\/td><\/tr>\", \"\") + \n\tif(w42.debug.currTok\t!= \"\", \"<tr><td><b>Current Token:\t\t<\/b><\/td>\t<td><img height='15' width='15' src='%{w42.debug.currTok.img}'><\/img><\/td>\t<td>%{w42.debug.currTok}<\/td><\/tr>\", \"\") + \n\tif(w42.debug.impTok\t\t!= \"\", \"<tr><td><b>Impersonated Token:\t<\/b><\/td>\t<td><img height='15' width='15' src='%{w42.debug.impTok.img}'><\/img><\/td>\t<td>%{w42.debug.impTok}<\/td><\/tr>\", \"\") + \n\t\"<\/tr><\/table>\"\n]\n\n[if(w42.debug.oneLine), CODE:{\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<table border='1'><tr>\"]\n\t[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + \"<td><b>\"+w42_debug_var+\":<\/b><\/td><td>%{\"+w42_debug_var+\"}<\/td>\")]\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<\/tr><\/table>\"]\n};{\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<table border='1'>\"]\n\t[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + \"<tr><td><b>\"+w42_debug_var+\":<\/b><\/td><td>%{\"+w42_debug_var+\"}<\/td><\/tr>\")]\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<\/table>\"]\n}]\n\n[broadcast(strformat(w42.debug.textOut))]\n\n[if(w42.debug.pause), CODE:{\n\t[frame(\"Debug Info\", \"width=400; height=600;\"):{\n\t\t[r:strformat(w42.debug.textOut)]\n\t}]\n\t[pause()]\n};{}]\n[h:'<!-- ----------------------------- /DEBUG INFO ----------------------------------------------------- -->']",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8a3da907-aded-4d6c-a65d-61cada97e1c9",
          "commandChecksum": "d68a72bdf9a83c6afbeb44882081a6d2",
          "propsChecksum": "1ba2cb600026058fe211e12e92a71028"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "21",
        "index": 310,
        "label": "execAllPlayers",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------- execAllPlayers (macro name, arguments, players, output to) ----------------------------------------------------- -->']\n<!-- This macro executes the macro on ALL SELECTED clients. Feed it macro@lib:token, args (json array) -->\n<!-- And optional third argument is allowed where you give a list of clients where this macro should be executed -->\n[h,if(argCount() > 2), CODE:{\n\t[userList = arg(2)]\n\t[if(json.type(userList)==\"ARRAY\"):userList = json.toList(userList)]\n};{\n\t[userList = getAllPlayerNames()]\n}]\n[h,if(argCount() > 3), CODE:{\n\t[outputList = arg(3)]\n\t[if(json.type(outputList)==\"ARRAY\"):outputList = json.toList(outputList)]\n};{\n\t[outputList = \"none\"]\n}]\n\n[h: self\t= getPlayerName()]\n[h: others\t= listDelete(userList, listFind(userList, self))]\n\n[h, if(others != \"\"):broadcast(macroLink(\"<color='red'>\", arg(0), outputList, arg(1), \"\"), others)]\n[h,if(listContains(userList, self)), CODE:{\n\t[macro(arg(0)):arg(1)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0696c13e-c32a-40e7-af26-865e7006b02c",
          "commandChecksum": "e018009968ddd1f9ff0a00017f56a8a6",
          "propsChecksum": "c0a620315cb4bb01f9c9c7ae31b5f3dc"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "21",
        "index": 311,
        "label": "findDuplicates",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------- bot_findDuplicates() ------------------------------ -->']\n[h:'<!-- THREE 3 CODE LEVELS -->']\n\n[h:'<!-- get all tokens from all layers on map -->']\n[h:\tallToks\t\t\t= json.sort(getTokenNames(\"json\",json.set(\"{}\", \"layer\", json.append(\"\", \"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\"))),\"N+\")]\n[h:'<!-- check if any duplicates at all -->']\n[h:hasDuplicates\t= if(json.equals(allToks,json.sort(json.unique(allToks))),0,1)]\n[h:duplicates\t= \"\"]\n\n[h, if(hasDuplicates), CODE: {\n\t[lastTok\t= \"\"]\n\t\n\t[allSplices\t= bot_createSplices(allToks)]\n\t\n\t[foreach(tokList,allSplices), CODE: {\n\t\t[foreach(tok,tokList), CODE: {\n\t\t\t[if(lastTok == tok): duplicates = listAppend(duplicates,tok)]\n\t\t\t[lastTok = tok]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t[output = strformat(\"Found duplicates: %{duplicates}\")]\n''\n};{\n\t[output = strformat(\"No duplicate token names\")]\n''\n}]\n\n[h:macro.return = duplicates]\n[h:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "259b8fec-5aef-43cc-923f-599109917d5b",
          "commandChecksum": "e074defc6e4a5328e9e9785177efbadf",
          "propsChecksum": "26bf5e77f7f0379e4543e20f71a0848e"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "16",
        "index": 312,
        "label": "getGridSize",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- getGridSize ------------------------------------------------>']\n[h:macro.return = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "471378bd-5220-42b1-967d-264ccd137007",
          "commandChecksum": "8747e2582d486b9273242a0981f05ba5",
          "propsChecksum": "1a00a282a0a0f04cea2bf4b5472fc2df"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "20b",
        "index": 313,
        "label": "getNewImage",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[token(arg(1)): macro.return = getTokenImage(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d772c191-fcb0-43ea-9956-86be2d2b73a6",
          "commandChecksum": "4a860226f19b5679f27c9d7328bbc979",
          "propsChecksum": "eb7b62ea6ad1a6fa54ae2231c7c957ba"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 314,
        "label": "getPath",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------- GETPATH (pathType (0 dont /1 do /2 do + no step removal /3 remove step only), Distance in pixels (1/0), Token(id)) ----------------------------------------------------- -->']\n[h:'<!-- This function returns ALL points where the direction of a token path changed. For a gridless token these are the way points, for a grid token then also points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction  -->']\n\n[h,if(argCount() > 2): me = arg(2); me\t= getSelected()]\n[h:switchToken(me)]\n\n[h,if(argCount() > 1): units = arg(1); units = 1]\n[h:switchToken(me)]\n\n[h,if(argCount() > 0): pathType = arg(0); pathType\t= 0]\n[h,if(pathType), CODE:{\n\t[pathFeet\t\t= if(isPC(), \"blue feet\", \"red feet\")]\n\t[pathFeet\t\t= if(getOwnerOnlyVisible(), \"purple feet\", pathFeet)]\n\t[directionLst\t= \"0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y\"]\n\t[facingLst\t\t= \"none, -90,90,0,180,45,-135,135,-45\"]\n\t[doLastStep\t\t= 0]\n\t[baseMapName\t= getLibProperty('baseMapName','lib:EventMacros')]\n\t[feetSize\t\t= getSize()]\n};{\n\t[doLastStep\t\t= 1]\n}]\n\n[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]\n\n[h, if(pathType == 3): path = \"[]\"]\n[h:assert(!json.isEmpty(path) || pathType==3, \"Token has not last path\",0)]\n\n[h,if(units): gs = bot_getGridSize() ; gs = 1]\n\n[h,if(json.length(path)), CODE:{\n\t['<!-- first step -->']\n\t[firstStep\t= json.get(path, 0)]\n\t[path\t\t= json.remove(path, 0)]\n\t[x\t\t\t= json.get(firstStep, \"x\")]\n\t[y\t\t\t= json.get(firstStep, \"y\")]\n\t[direction\t= \"\"]\n\t[wp\t\t\t= \"\"]\n\t[point\t\t= \"{}\"]\n};{}]\n\n[h: skipCount\t= 0]\n[h, switch(feetSize):\n\tcase \"Large\":\t\tsizeCount = 1;\n\tcase \"Huge\":\t\tsizeCount = 2;\n\tcase \"Gargantuan\":\tsizeCount = 3;\n\tcase \"Colossal\":\tsizeCount = 4;\n\tdefault:\t\t\tsizeCount = 0\n]\n\n[h,foreach(step, path), CODE:{\n\t[nx\t\t\t= json.get(step, \"x\")]\n\t[ny\t\t\t= json.get(step, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\n\t<!-- need to distinguish between the 8 possible paths +/-(hor, vert, bDiag, fDiag)\n\t\tIf the path is changed THEN the last coord BEFORE the path is changed needs to be saved and the path needs to be reset. \n\t-->\n\t\t\n\t[if(pathType), CODE:{\n\t\t<!-- add facing to the json object -->\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[angle = 0] <!-- initiate value in case ndir is not > 0 -->\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[h: skip = pathType]\n\t[if (sizeCount > skipCount), CODE:{\n\t\t[skip = 0]\n\t\t[skipCount = skipCount + 1]\n\t};{\n\t\t[skipCount = 0]\n\t}]\n\t\n\t[if (direction != ndirection || skip), CODE:{\n\t\t<!-- add point to the step array EITHER always (if pathType) of when the direction changes -->\n\t\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t\t[wp\t\t= json.append(wp, point)]\n\t\t[skipCount = 0]\n\t};{}] \n\n\t[x\t\t\t= nx]\n\t[y\t\t\t= ny]\n\t[direction\t= ndirection]\n}]\n\n[h, if(json.length(path) > 0 && doLastStep), CODE:{\n\t<!-- add last step as waypoint -->\n\t[lastStep\t= json.get(path, -1,-1)]\n\t[nx\t\t\t= json.get(lastStep, \"x\")]\n\t[ny\t\t\t= json.get(lastStep, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\n\t[if(pathType), CODE:{\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t[wp\t\t= json.append(wp, point)]\n};{}]\n\n[h, if(pathType), CODE:{\n\t<!-- remove the old steps and copy a set of feet on each step -->\n\n\t[if(pathType != 2), CODE:{\n\t\t<!-- first remove the old ones -->\n\t\t[currentFeet = getTokens(\",\", json.set(\"{}\", \"layer\", \"OBJECT\", \"setStates\", \"pathFeet\"))]\n\t\t<!-- make sure that you do not delete the originals -->\n\t\t[if(listFind(currentFeet, \"red feet\")!=-1):\t\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"red feet\")]\n\t\t[if(listFind(currentFeet, \"blue feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"blue feet\")]\n\t\t[if(listFind(currentFeet, \"purple feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"purple feet\")]\n\t\t[foreach(feet, currentFeet): removeToken(feet)]\n\t};{}]\n\t\n\t[if(pathType != 3), CODE:{\n\t\t<!-- then copy the new ones-->\n\t\t[foreach(p, wp,\"<br>\"): copyToken(pathFeet, 1, baseMapName, json.set(p, \"useDistance\", units, \"layer\", \"OBJECT\", \"name\", \"w42.bot.feet\", \"size\", feetSize))]\n\t};{}]\n\t[macro.return\t= \"\"]\n};{\n\t<!-- return all the points where the direction changed. -->\n\t[macro.return\t= wp]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "daa06f3c-592b-4eb1-8079-c39f06426979",
          "commandChecksum": "709d7e4256893a40dbd311ccb7b9df6e",
          "propsChecksum": "f3e968843e1f4b729c8401b374845769"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 315,
        "label": "getTokensPath",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------- GETPATH (showPath (0 dont /1 do /2 do + no step removal /3 remove step only), Distance in pixels (1/0), Token(id)) ----------------------------------------------------- -->']\n[h:'<!-- This function returns ALL points where the direction of a token path changed. For a gridless token these are the way points, for a grid token then also points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction  -->']\n\n[h,if(argCount() > 2): me = arg(2); me\t= getSelected()]\n[h:switchToken(me)]\n\n[h,if(argCount() > 1): units = arg(1); units = 1]\n[h:switchToken(me)]\n\n[h,if(argCount() > 0): showPath = arg(0); showPath\t= 0]\n[h,if(showPath), CODE:{\n\t[pathFeet\t\t= if(isPC(), \"blue feet\", \"red feet\")]\n\t[directionLst\t= \"0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y\"]\n\t[facingLst\t\t= \"none, -90,90,0,180,45,-135,135,-45\"]\n\t[doLastStep\t\t= 0]\n\t[baseMapName\t= getLibProperty('baseMapName','lib:EventMacros')]\n\n};{\n\t[doLastStep\t\t= 1]\n}]\n\n[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]\n\n[h, if(showPath == 3): path = \"[]\"]\n[h:assert(!json.isEmpty(path) || showPath==3, \"Token has not last path\",0)]\n\n[h,if(units): gs = bot_getGridSize() ; gs = 1]\n\n[h,if(json.length(path)), CODE:{\n\t['<!-- first step -->']\n\t[firstStep\t= json.get(path, 0)]\n\t[path\t\t\t= json.remove(path, 0)]\n\t[x\t\t\t= json.get(firstStep, \"x\")]\n\t[y\t\t\t= json.get(firstStep, \"y\")]\n\t[direction\t= \"\"]\n\t[wp\t\t\t= \"\"]\n\t[point\t\t= \"{}\"]\n};{}]\n\n[h,foreach(step, path), CODE:{\n\t[nx\t\t\t= json.get(step, \"x\")]\n\t[ny\t\t\t= json.get(step, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\n\t<!-- need to distinguish between the 8 possible paths +/-(hor, vert, bDiag, fDiag)\n\t\tIf the path is changed THEN the last coord BEFORE the path is changed needs to be saved and the path needs to be reset. \n\t-->\n\t\t\n\t[if(showPath), CODE:{\n\t\t<!-- add facing to the json object -->\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[if (direction != ndirection || showPath), CODE:{\n\t\t<!-- add point to the step array EITHER always (if showPath) of when the direction changes -->\n\t\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t\t[wp\t\t= json.append(wp, point)]\n\t};{}] \n\n\t[x\t\t\t= nx]\n\t[y\t\t\t= ny]\n\t[direction\t= ndirection]\n}]\n\n[h, if(json.length(path) > 0 && doLastStep), CODE:{\n\t<!-- add last step as waypoint -->\n\t[lastStep\t= json.get(path, -1,-1)]\n\t[nx\t\t\t= json.get(lastStep, \"x\")]\n\t[ny\t\t\t= json.get(lastStep, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\n\t[if(showPath), CODE:{\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t[wp\t\t= json.append(wp, point)]\n};{}]\n\n[h, if(showPath), CODE:{\n\t<!-- remove the old steps and copy a set of feet on each step -->\n\n\t[if(showPath != 2), CODE:{\n\t\t<!-- first remove the old ones -->\n\t\t[currentFeet = getTokens(\",\", json.set(\"{}\", \"layer\", \"OBJECT\", \"setStates\", \"pathFeet\"))]\n\t\t<!-- make sure that you do not delete the originals -->\n\t\t[if(listFind(currentFeet, \"red feet\")!=-1):\t\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"red feet\")]\n\t\t[if(listFind(currentFeet, \"blue feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"blue feet\")]\n\t\t[foreach(feet, currentFeet): removeToken(feet)]\n\t};{}]\n\t\n\t[if(showPath != 3), CODE:{\n\t\t<!-- then copy the new ones-->\n\t\t[foreach(p, wp,\"<br>\"): copyToken(pathFeet, 1, baseMapName, json.set(p, \"useDistance\", units, \"layer\", \"OBJECT\", \"name\", \"w42.bot.feet\"))]\n\t};{}]\n\t[macro.return\t= \"\"]\n};{\n\t<!-- return all the points where the direction changed. -->\n\t[macro.return\t= wp]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "78c43809-f9a6-4d2a-bdd2-9f91ff1c42f5",
          "commandChecksum": "c4359ae1becedf4f295d507aa45853db",
          "propsChecksum": "b5e76a9b872670fe488577d205bf0558"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "22",
        "index": 316,
        "label": "gotoMap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------- GOTOMAP ------------------------------- -->']\n<!-- This macro changes the map -->\n[h:map\t= arg(0)]\n[h:cPad\t= arg(1)]\n\n[bot_chkSounds(\"self\",1)] <!-- stop all map related sounds -->\n[h:setCurrentMap(map)]\n[bot_chkSounds(listGet(getOwned(),0), getCurrentMapName(), 0)] <!-- start all map related sounds on new map for owned token -->\n\n[h,if(argCount() > 1 && cPad != \"\"):comPad = \"centreOnMePad \" + cPad ; comPad = \"centreOnMePad\"]\n\n[h,if(findToken(comPad) != \"\"): goto(getTokenX(0,comPad),getTokenY(0,comPad))]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f4241f5d-44e2-4eca-9531-d421a6771bf7",
          "commandChecksum": "4aa8b8d8e1e80547543ab78fd17d5405",
          "propsChecksum": "2e75d78dbae06012411669d8bd9eb0c4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "20b",
        "index": 317,
        "label": "gotoToken",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------- gotoToken ---------------------------------------- -->']\n[gotoMap\t= arg(0)]\n[tok\t\t= arg(1)]\n[copyTok\t= arg(2)]\n[X\t\t\t= arg(3)]\n[Y\t\t\t= arg(4)]\n\n[currentMap\t= getCurrentMapName()]\n\n<!-- 1=copy ; 2=move ; 3=select -->\n\n<!-- 2=move from another/same map-->\n[if(copyTok == 0), CODE:{\n\t[abort(input(\n\t\t\"junk|<html>You have selected <b>\"+tok+\"<\/b>. What do you want to do<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"copyTok|<html>Nothing, COPY \"+tok+\" to current location, MOVE \"+tok+\" to current location, \"+if(gotoMap != currentMap, \"go to \"+gotoMap+\" and\",\"\")+\" SELECT \"+tok+\", DELETE \"+tok+\" (confirm), DELETE \"+tok+\" (no confirm)|Pick one|RADIO|\"\n\t))]\n}; {}]\n\n<!-- 1=copy -->\n[if(copyTok == 1):\tcopyToken(tok, 1, gotoMap, json.set(\"{}\", \"useDistance\", 0, \"x\", X, \"y\", Y))]\n\n<!-- 2=move from another/same map-->\n[if(copyTok == 2), CODE:{\n\t[if(gotoMap != currentMap):\tmoveTokenFromMap(tok, gotoMap, X, Y, 100) ; moveToken(X,Y,0,tok)]\n}; {}]\n\n<!-- 3=select -->\n[if(copyTok == 3), CODE:{\n\t[if(gotoMap != currentMap):setCurrentMap(gotoMap)]\n\t[selectTokens(tok)]\n\t[goto(tok)]\n\t[layer\t= getLayer(tok)]\n\t[if(layer != \"TOKEN\"): broadcast(strformat(\"%{tok} is on the %{layer} layer\"))]\n}; {}]\n\n<!-- 4=delete with confirmation -->\n[if(copyTok == 4), CODE:{\n\t[Warning = \"Press OK to delete: <b>\"+tok+\"<\/b>, else press cancel\"]\n\t[pause(\"Warning\")]\n}; {}]\n\n<!-- 5=delete withOUT confirmation -->\n[if(copyTok == 4 || copyTok == 5), CODE:{\n\t[if(gotoMap != currentMap):setCurrentMap(gotoMap)]\n\t[removeToken(tok)]\n\t[if(gotoMap != currentMap):setCurrentMap(currentMap)]\n\t[broadCast(tok+\" has been deleted from map: \"+gotoMap)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9d7f0f3e-c599-487f-9524-504a8eabc32e",
          "commandChecksum": "ca59704139aaeb71d0b27df5aba859aa",
          "propsChecksum": "8138447aaa04fe6b3b5d668f7d5a587b"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 318,
        "label": "ids2Names",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ids2Names -->']\n[h:tokNames = \"\"]\n[h,foreach(tok,arg(0)): tokNames = listAppend(tokNames, getName(tok))]\n[r:tokNames]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "751c38ca-044f-418e-9a96-2b7e340b0579",
          "commandChecksum": "45487f232ab40a82c36b4925b63b7362",
          "propsChecksum": "9d6ad1a9330c1a6b7e4c1396348c72f6"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 319,
        "label": "ids2NamesArray",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ids2NamesArray -->']\n[h:array\t= replace(arg(0), '(\")([^,]+)(\")', '\"[r:getName('\\$2')]\"')]\n[h:macro.return = json.evaluate(replace(array, \"'\", \"'\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c07fe0ab-d118-4ff8-81cb-f83c16363296",
          "commandChecksum": "6b47f196b7cddcf663814de561b00274",
          "propsChecksum": "21c6e94b54dc37752ac6f835c7fb79fa"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "3",
        "index": 320,
        "label": "inStr",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- inStr -->']\n[H: '<!-- 0=Text, 1=string to look for in Text -->']\n[r, if(arg(1)==\"\"):\"\"; getFindCount(strfind(arg(0), arg(1)))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "71731126-db93-4548-a433-93929e695d9f",
          "commandChecksum": "c04d5f7d861d358b9f21c0217cb2a870",
          "propsChecksum": "f4cd1ef1fcadbdee5870bb5c7ef892aa"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "2",
        "index": 321,
        "label": "pause",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-------------------------------------------------------------- PAUSE------------------------------------------------------------------------------->']\n[ toolkit.DebugVariableCount = argCount() ]\n[ toolkit.DebugVariableArray = macro.args ]\n[ toolkit.DebugInputParameter = \".|<html>\" +\n    \"<table cellspacing='2' cellpadding='0' style='background-color:#595751'>\" +\n    \"<tr><td>\" +\n    \"<table width='300px' cellspacing='0' cellpadding='2' style='background-color:#FAF9F5; '>\" +\n    \"%{toolkit.DebugVariableRows}<\/table><\/td><\/tr><\/html>\" +\n    \"|Debugger|LABEL|SPAN=TRUE\"\n]\n[ toolkit.DebugVariableRow = \"<tr %{toolkit.DebugVariableRowStyle}><td>\" +\n    \"<b>%{toolkit.DebugVariableName}<\/b><\/td><td>%{toolkit.DebugVariableContent}\" +\n    \"<\/td><\/tr>\"\n]\n[ toolkit.DebugVariableRows = \"<tr style='background-color:#E0DDD5; font-size:1.1em; '><td><b>Variable<\/b><\/td><td><b>Value<\/b><\/td><\/tr>\" ]\n[ count( toolkit.DebugVariableCount ), code:\n{\n    [ toolkit.DebugVariableRowStyle = \"\" ]\n    [ toolkit.DebugVariableName = json.get( toolkit.DebugVariableArray, roll.count ) ]\n    [ toolkit.DebugVariableContent = eval( toolkit.DebugVariableName ) ]    [H: '<!-- this may not be compatible with a custom eval function (which would overwrite macro.args) -->']\n    [ if( floor( roll.count/2 ) == roll.count/2 ), code:\n    {\n        [ toolkit.DebugVariableRowStyle = \"style='background-color:#EDECE8; '\" ]\n    } ]\n    [ toolkit.DebugVariableRows = toolkit.DebugVariableRows +\n        strformat( toolkit.DebugVariableRow )\n    ]\n} ]\n[ if( toolkit.DebugVariableCount == 0 ), code:\n{\n    [ toolkit.DebugVariableRows = \"<tr><td style='font-size: 1.4em' align='center'><b>Pause<\/b><\/td><\/tr>\" ]\n} ]\n\n[ toolkit.DebugBreak = input( strformat( toolkit.DebugInputParameter ) )]\n[ abort( toolkit.DebugBreak ) ] \n[h:'<!-------------------------------------------------------------- END PAUSE------------------------------------------------------------------------------->']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f9ba5043-3be4-4b93-8883-b177bf932607",
          "commandChecksum": "230221ef56b23b7e707b31e83a058f4f",
          "propsChecksum": "8170c4f3ca1fc574115a6402af735768"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "18",
        "index": 322,
        "label": "ppc2GridCoord",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- bot_ppc2GridCoord(coord [,gs]) ------------------------------------------------>']\n<!-- this function returns a pixel per cell coordinate to a grid cell coordinate  -->\n[if(argCount() > 1): gs = arg(1) ; gs\t= bot_getGridSize()]\n[h:macro.return = round(arg(0)/gs)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a397128d-0edd-4d87-a742-6d41d26be0fb",
          "commandChecksum": "ef627b2ba374ea1cb16c88586abc59e8",
          "propsChecksum": "585d5512954cc4da3ee366d199990b3f"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "18",
        "index": 323,
        "label": "round2Grid",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- round2Grid(coord [,gs]) ------------------------------------------------>']\n<!-- this function returns a coordinate rounded to multiple of grid size  -->\n[if(argCount() > 1): gs = arg(1) ; gs\t= bot_getGridSize()]\n[h:macro.return = gs*round((arg(0)/gs))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "252356cc-75b3-413d-a00c-d763bac52937",
          "commandChecksum": "f08095b0afa3df15bded6ca7c5dfae56",
          "propsChecksum": "58ba62bf8789bca0112f9fe5fac01709"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "20a",
        "index": 324,
        "label": "seekToken",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- seekToken ------------------------------------------------>']\n[h:'<!-- <html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use -->']\n\n[h:'<!-- retrieve the last saved settings from seek token macro findTok, showImage, showName, showLayer, copyTok, libTok, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer -->']\n[h:lastSettings\t= getLibProperty(\"seekTokensLastSettings\", \"Lib:EventMacros\")]\n[h,if(lastSettings == \"\"): lastSettings = \"findTok=0 ; showImage=0 ; showName=1 ; showLayer=0 ; copyTok=0 ; libTok=0 ; doTokenLayer=1 ; doObjectLayer=1 ; doHiddenLayer=1 ; doBackgroundLayer=1 ; \"]\n[h:varsFromStrProp(lastSettings)]\n\n[h:'<!-- option to give parameters, when returnArg is 1 NO input is requested and NO form will pop-up -->']\n\n[h,if(argCount()>0), CODE:{\n\t[\t\t\t\t\t returnArg\t\t= arg(0)]\n\t[h,if(argCount()>1): findTok\t\t= arg(1) ; findTok\t\t= \"\"]\n\t[h,if(argCount()>2): chosenLayers\t= arg(2) ; chosenLayers = '[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]']\n\t[if(string(chosenLayers) == \"\"): chosenLayers = '[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]']\n\t[h,if(argCount()>3): mapList\t\t= arg(3) ; mapList\t\t= getCurrentMapName()]\n\t[h,if(argCount()>4): libTok\t\t\t= arg(4) ; libTok\t\t= 0]\n\t[h,if(argCount()>5): jsonOutput\t\t= arg(5) ; jsonOutput\t= 0] <!-- in case of 1 map a string list is returned by default, json in case of multiple maps. this overrides that result -->\n\n\t[numMaps\t= listCount(mapList)]\n\t[if(numMaps > 1 && !jsonOutput): returnValue= \"{}\" ; returnValue= \"\" ]\n\t[showName\t= 1]\n\t[showImage\t= 0]\n\t[showLayer\t= 0]\n}; {\n\t[mapList\t= \"\"]\n\t[returnArg\t= 0]\n}]\n\n[h, if(mapList == \"\"), CODE:{\n\t[h:mapList\t\t= getAllMapNames()]\n\t<!-- put BASE map first -->\n\t[h:baseMapName\t= getLibProperty(\"baseMapName\",\"lib:EventMacros\")]\n\t[h:mapList\t\t= listAppend(baseMapName, listDelete(mapList, listFind(mapList, baseMapName)))]\n}; {}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:resultTxt\t= \"<hml><table border=1><tr><td><b>MAP<\/b><\/td><td><b>FOUND<\/b><\/td><\/tr><tr>\"]\n[h:me = getSelected()]\n[h, if(listCount(me) == 1), CODE:{\n\t[switchToken(me)]\n\t[h: X = getTokenX(0)]\n\t[h: Y = getTokenY(0)]\n\t[H: PrimePC\t= getName() ]\n}; {\n\t[h: X = 0]\n\t[h: Y = 0]\n\t[H: PrimePC\t= \"\"]\n}]\n\n[h:inputStr\t\t= \"[]\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Find tokens which names have the following search string<\/html>|<html>The token will show up in the results when the<br>search string matches ANY part of the token name|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"findTok|\"+findTok+\"|Enter search string\")]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>In search results<\/html>|<html>The search results will be shown in a frame.<br>When you check all three boxes the result will<br>look like <u>Picture<\/u> <u>Token name<\/u>(<u>token layer<\/u>)|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"showImage|\"+showImage+\"|Show token image|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"showName|\"+showName+\"|Show token name|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"showLayer|\"+showLayer+\"|Show layer|CHECK\")]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>LIB:Tokens (search string is ignored for these)<\/html>|<html>Lib:Tokens can only be found through a special macro<br>and are thus dealt with seperately. An additional <br>feature for lib:Tokens is to find the duplicates only.<br>For the find duplicates note the following: <br>- Only ONE duplicate is shown. This to prevent you <br>from accidentily deleting both. <br>- When you delete one token the results are NOT <br>UPDATED. So on the frame it appears the token is still<br>there even though its not. If you run this macro again<br>you will see the update. <br>|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"libTok|No: only 'normal' tokens, Yes: BOTH normal and lib:Tokens, Yes: ONLY lib:Tokens, Yes: ONLY DUPLICATE lib:Tokens|Find lib:Tokens|RADIO|SELECT=\"+libTok)]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Check layers to look on<\/html>|<html>The result will only show tokens that are on the layers you check here.|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"doTokenLayer|\"+doTokenLayer+\"|Token Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doHiddenLayer|\"+doHiddenLayer+\"|Hidden Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doObjectLayer|\"+doObjectLayer+\"|Object Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doBackgroundLayer|\"+doBackgroundLayer+\"|Background Layer|CHECK\")]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>The results will be presented as macrolinks<\/html>|<html>Macrolinks look like hyperlinks. However when<br>you click on them you do not open a page, but<br>activate a macro. Here you can choose WHICH<br>macro to activate.<br>|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"copyTok|decide when you click, copy token to current location, move token to current location, go to map and select token, DELETE token (with confirmation), DELETE token (WITHOUT confirmation)|Click on link will|RADIO|SELECT=\"+copyTok)]\n\n[h:'<!-- ask for coords -->']\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>If you summon the token(s), do this to: <\/b><\/html>|<html>The Token will be summoned to a CELL coordinate on the<br>current map. Per default this is 0,0. If you look at the<br>bottom right corner you see the coordinates of the cell<br>your cursor was last on the map. You can enter these<br>coordinates into the below boxes. Alternatively you can<br>select a token before you run this and the coords of the<br>position of the selected token will be entered instead.|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, \"X|\"+X+\"|give X coordinates\")]\n[h:inputStr \t= json.append(inputStr, \"Y|\"+Y+\"|give Y coordintates\")]\n\n[h:'<!-- show coords of selected token-->']\n[h, if(PrimePC != \"\"):inputStr\t\t= json.append(inputStr,\"junk|\"+X+\",\"+Y+\"|<html><b>Location of \"+PrimePC+\"<\/b>|LABEL\")]\n\n[h:'<!-- put local variables in input form -->']\n[H: inputStr\t= json.evaluate(inputStr)]\n[h:'<!-- get user input, except when a returnArg is requested -->']\n[H, if(!returnArg): abort(input(json.toList(inputStr,\"##\")))]\n\n[h:'<!-- assertion -->']\n[h:assert(showImage+showName+showLayer, \"Check at least one of the Show Image, Name, Layer boxes\",0)]\n[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, \"Check at least one of the (Token, Hidden, Object, Background) layer boxes\",0)]\n\n<!-- set search string to match everything when empty -->\n[h,if(findTok == \"\"): findTok = \"(?!,).\"]\n[h:regex\t\t= strformat(\"(?i)([^,]*(%{findTok})[^,]*)\")]\n[h,if(!returnArg): result = \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{currentMap}", "%{tok}", "%{copyTok}", "%{X}", "%{Y}"]'>\"+if(showImage, \"<img src=%s><\/img>\", \"<!-- %s -->\")+if(showName, \"%{tok}\", \"\")+if(showLayer, \" (%s)\", \"\")+\"<\/a>\" ; result = \"%{tok}\"]\n\n[h, if(!returnArg), CODE:{\n\t['<!-- {layer:[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]} -->']\n\t[chosenLayers = \"[]\"]\n\t[if(doTokenLayer):\t\tchosenLayers = json.append(chosenLayers, \"TOKEN\")]\n\t[if(doHiddenLayer):\t\tchosenLayers = json.append(chosenLayers, \"HIDDEN\")]\n\t[if(doObjectLayer):\t\tchosenLayers = json.append(chosenLayers, \"OBJECT\")]\n\t[if(doBackgroundLayer):\tchosenLayers = json.append(chosenLayers, \"BACKGROUND\")]\n};{}]\n[h:layers\t\t= json.set(\"{}\", \"layer\", chosenLayers) ]\n\n[h:'<!-- get ALL lib:tokens from ALL maps-->']\n[h, if(libTok):\tlibTokens = listSort(json.fields(json.get(getInfo(\"client\"),\"library tokens\")),\"N+\") ; libTokens = \"\"]\n[h: libFoundList\t\t= \"\"]\n\n[h,foreach(currentMap,mapList,\"\"), CODE: {\n\t[if(currentMap != getCurrentMapName()): setCurrentMap(currentMap)]\n\t[if(libTok < 2): allToks = listSort(getTokenNames(\",\",layers),\"N+\") ; allToks = \"\"]\n\t<!-- remove redundant whitespace around , and double spaces-->\n\t[h: allToks\t=  replace(allToks, \"\\\\s*([\\\\,\\\\s])\\\\s*\",\"\\$1\")]\n\n\t[resultList\t= \"\"]\n\t[id\t\t\t= strfind(allToks, regex)]\n\t[numFound\t= getFindCount(id)]\n\t[if(numFound > 1000), CODE:{\n\t\t[message\t= strformat(\"Found: %{numFound} results on map %{currentMap}. Only showing the first 1000 results\")]\n\t\t[numFound\t= 1000]\n\t\t[pause(\"message\")]\n\t}; {}]\n\t[count(numFound), CODE:{\n\t\t[tok\t\t= getGroup(id, roll.count+1, 0)]\n\t\t[resultList\t= listAppend(resultList, strformat(result, bot_getNewImage(30, tok), getLayer(tok)))]\n\t}]\n\t\n\t[libResultList = \"\"]\n\t[foreach(tok, libTokens), CODE:{\n\t\t[found\t= if(findToken(tok) != \"\", 1, 0)]\n\t\t[if(found && libTok == 3):\t\t\t\t\tduplicate\t\t\t= if(listContains(libFoundList, tok),1,0) ; duplicate = 0]\n\t\t[if(found && libTok == 3):\t\t\t\t\tlibFoundList\t\t= listAppend(libFoundList, tok)]\n\t\t[if(duplicate || (found && libTok < 3)):\tlibResultList\t\t= listAppend(libResultList,\t\tstrformat(result, bot_getNewImage(30,tok), getLayer(tok)))]\n\t\t['if(found):pause(\"found\", \"tok\", \"libTokens\",\"duplicate\",\"libResultList\",\"libTok\")']\n\t}]\n\t\n\t[if(libResultList != \"\"): resultList\t= listAppend(resultList, libResultList)]\n\n\t[if(!returnArg): \n\t\tresultTxt\t= resultTxt + \"<td><b>\" + currentMap + \":<\/b><\/td><td>\" + if(listCount(resultList), resultList, 'none found')+\"<\/td><\/tr>\"\n\t; \n\t\treturnValue\t= if(numMaps > 1 || jsonOutput, json.set(returnValue, currentMap, resultList), resultList)\n\t]\n}]\n[h,if(oldMap != getCurrentMapName()): setCurrentMap(oldMap)]\n\n[h:resultTxt\t= resultTxt + \"<\/table><\/html>\"]\n\n[h,if(copyTok == 0):\texecuteText = strformat(\"a <b>POP-UP<\/b> will appear asking you whether you want to Copy, Move or Select the corresponding token. When moved or copied, it will be to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 1):\texecuteText = strformat(\"the corresponding token will be <b>COPIED<\/b> to this map (%{oldMap}), to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 2):\texecuteText = strformat(\"the corresponding token will <b>MOVED<\/b> from its current location to this map, to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 3):\texecuteText = \"you will switch to the map where the token is at and the token will be selected\"]\n\n[h:output = \"When you click on one of the macrolinks  <u>\"+executeText+\"<\/u><br><br>\"+resultTxt]\n\t\n[r, if(!returnArg && bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Looking for: \"+ findTok,\"width=400; height=400; input=1\"):{[r:output]}]\n};{}]\n\n[r, if(!returnArg && !bot_isFullScreen()), CODE:{\n\t[r,frame(\"Looking for: \"+ findTok,\"width=400; height=400; \"):{[r:output]}]\n};{}]\n\n[h:'<!-- save the settings from seek token macro -->']\n[h:setLibProperty(\"seekTokensLastSettings\", strPropFromVars(\"findTok, showImage, showName, showLayer, copyTok, libTok, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer\",\"UNSUFFIXED\"), \"Lib:EventMacros\")]\n\n[h, if(returnArg):\tmacro.return = returnValue]",
        "maxWidth": "",
        "tooltip": "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4bd2f72e-6e34-4bf7-8440-dfb43e83019e",
          "commandChecksum": "d04fa77347b680410f4f599d4f9e895b",
          "propsChecksum": "3a8ae578a45b5f19b9a061ba7b5f9838"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "",
        "index": 325,
        "label": "showHTML",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:output = arg(0)]\n\n[h: htmlResult = replace(output, \"<\", \"<\")]\n[h: htmlResult = replace(htmlResult, \"<table\", \"<br><table\")]\n[h: htmlResult = replace(htmlResult, \"</table>\", \"<br></table><br>\")]\n\n[h: htmlResult = replace(htmlResult, \"<tr\", \"<br><tr\")]\n[h: htmlResult = replace(htmlResult, \"</tr>\", \"<br></tr><br>\")]\n\n[h: htmlResult = replace(htmlResult, \"<td\", \"<br> <td\")]\n[h: htmlResult = replace(htmlResult, \"</td\", \"<br> </td\")]\n\n[frame(\"displayHTML\"):{\n\t<pre>\n\t\t[r: htmlResult]\n\t<\/pre>\n}]\n\n[frame(\"displayHTMLResult\"):{\n\t[r: output]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aa532c8b-7d31-4caa-81fb-f2466a170be4",
          "commandChecksum": "6881a0d430b542746984a2089eb8509c",
          "propsChecksum": "bf967c6f2e8f720a629331e6c9961db0"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "18",
        "index": 326,
        "label": "snapAngle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- snapAngle ------------------------------------------------>']\n<!-- this function aligns the facing of a token to the closest angle given along a divider and returns the new angle -->\n<!-- e.g a divider of 4 will face a token to either -90 0 90 or 180 depending on where its closest at -->\n<!-- you can also turn off the align and just return the closest angle -->\n[h:switchToken(arg(0))]\n[h,if(getTokenFacing() == \"\"): setTokenFacing(-90)]\n[h,if(argCount()>1): corners\t= arg(1); corners\t= 8]\n[h,if(argCount()>2): align\t\t= arg(2); align\t\t= 1]\n\n[h:cornerDivider = round(360/corners)]\n[h:angle = round( (getTokenFacing()) / cornerDivider ) * cornerDivider]\n\n[h, if(align): setTokenFacing(angle)]\n\n[h:macro.return = angle]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d262971-6972-4874-9b45-8a6ee6f772fd",
          "commandChecksum": "2d9f1262a895167cac92a765f04781b8",
          "propsChecksum": "e7ab5713313b45577647dea63a245adb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "18",
        "index": 327,
        "label": "snapToGrid",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- snap2Grid(tok) ------------------------------------------------>']\n[moveToken(round(getTokenX(1,arg(0))/json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\"),0), round(getTokenY(1,arg(0))/json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\"),0), 0, arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1b0d5f72-118b-46ed-b1f8-803aaa8f338a",
          "commandChecksum": "2237ae7059d79db7cea019cd7e0b10fc",
          "propsChecksum": "09abdadf7a32b31623b2f58ec5999a6b"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "21",
        "index": 328,
        "label": "sortTokByProp",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------- bot_sortTokByProp (propertyName [,sortOrder(asc/desc) ,list or array of tokens. Defaults to selected tokens) -------------- -->']\n[h:sortKey\t= arg(0)]\n[h,if(argCount() > 1): order\t= arg(1) ; order\t= \"ascending\"]\n[h,if(argCount() > 2): tokens\t= arg(2) ; tokens\t= getSelected()]\n\n<!-- build array of token/sortkey objects -->\n[h: array = \"\"]\n[h, foreach(id, tokens): array = json.append(array, json.set(\"\", \"id\", id, \"sortKey\", getProperty(sortKey, id)))]\n\n<!-- sort -->\n[h:array\t= json.sort(array, order, \"sortKey\")]\n\n<!-- retrieve token names/ids -->\n[h:resultArray\t= \"\"]\n[h, foreach(item, array): resultArray = json.append(resultArray, json.get(item, \"id\"))]\n\n<!-- output -->\n[h: macro.return = resultArray]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5f8b8778-fb24-4a39-959f-7e2b92f02058",
          "commandChecksum": "60f79fa416b0dba78a3b9a67a1dcf38e",
          "propsChecksum": "408dfa80a8a8ae0e023d8c4f71324180"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "19",
        "index": 330,
        "label": "travelAngle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- travelAngle ------------------------------------------------>']\n<!-- this function calculates the facing of a token travelling in a certain direction with a acurracy of 45 degrees -->\n<!-- x1 is the current position, x2 is the postion travelling to -->\n<!-- based on CIFs calculateFacing -->\n[h:x1 = arg(0)]\n[h:y1 = arg(1)]\n[h:x2 = arg(2)]\n[h:y2 = arg(3)]\n<!-- option 0 = return angle, 1 = return cardinal directions -->\n[h, if(argCount()>4):option = arg(4) ; option = 0]\n\n[h:dx = x2 - x1]\n[h:dy = y2 - y1]\n\n[h, if(dx), CODE:{\n\t<!-- check if the angle close to one of the 4 diagonals. If not set the smallest dn to 0 -->\n\t<!-- tan(45/2) == 0.414 and 1/0.414 == 2.414 -->\n\t[diagonal = abs(dy/dx)]\n\t[if(diagonal < 0.414214):dy = 0]\n\t[if(diagonal > 2.414214):dx = 0]\n}; {}]\n\n<!-- make sure that the other value is limited between -1 and 1 and positive by adding +1 -->\n[dxl = min(1, max(dx, -1)) + 1]\n[dyl = min(1, max(dy, -1)) + 1]\n\n<!-- this creates two sets dx and dy with the values 0,1 or 2. By multiplying dx by 3 and adding it to dy you get a list of 0 to 8 (without 4 which can only exist if dx and dy are both 0, and that means that the token does NOT travel) which you can turn into a list of corresponding angles -->\n[h:'pause(\"x1\",\"y1\",\"x2\",\"y2\",\"dx\",\"dy\",\"diagonal\",\"dxl\",\"dyl\")']\n[h,if(option):\n\tmacro.return = listGet(\"North West,West,South West,North,NONE,South,North East,East,South East\", 3 * dxl + dyl)\n;\n\tmacro.return = listGet(\"135, 180, -135, 90, 0, -90, 45, 0, -45\", 3 * dxl + dyl)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3a86af99-d761-4913-8f38-a469799e68a9",
          "commandChecksum": "418a66b198c0744e9469ebe69351aaf0",
          "propsChecksum": "84649aebc5c82a13d50ebc4bcb9d0cf8"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "1",
        "index": 331,
        "label": "createTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- TokenParserBoxFrame ------------------------------------------------------- -->']\n<!-- shows a frame in which you can copy paste an excel table. This table will be processed in a table+ table. -->\n[frame(\"List builder\", \"width = 250; height = 400; temporary = 1\"): {\n\t<html>\n\t<head>\n\t\t<title>Create BoT Table<\/title>\n\t\t<meta name = \"input\" content = \"true\">\n <\/head>\n\t<body>\n\t\t<form method = \"json\" name = \"TableInput\" action = \"[r:macroLinkText('text2Table@Lib:onTokenMove')]\">\n\t\t\t<input type = \"hidden\" name = \"show\" value = 0> <\/input>\n\t\t\t<table>\n\t\t\t\t<tr><th align = \"left\"><label for = \"Name\">Paste List here (straight from excel):<\/label><\/th><\/tr>\n\t\t\t\tKeep in mind this does NOT create an MT table but a more extensive BoT table. See manual for more info\n\t\t\t\t<tr><td><textarea rows = \"10\" cols = \"500\" name = 'TextBox' ><\/textarea><\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<table>\n\t\t\t\t<tr><td colspan=\"2\" width=\"5%\"><b>Title of the table:<\/b><\/td><\/tr>\n\t\t\t\t<tr><td colspan=\"2\"><input type = \"text\" name = \"Title\": size = \"50\"> <\/input><\/td><\/tr>\n\t\t\t\t<tr><td width=\"5%\"><input type = \"checkbox\" name = \"show\" value = 1> <\/input> <\/td><td width=\"95%\">Edit table afterwards<\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<br>\n\t\t\t<input type = \"submit\" name = \"Save\" value = \"Save\"> <\/input>\n\t\t<\/form>\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1ca61bde-8e0e-4535-9007-2e2a823c35a5",
          "commandChecksum": "4c4ae9a4a4656c41b0d5fce1d9c3b869",
          "propsChecksum": "aa96f9bd6f7bf874d4e9531a077e2629"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "10",
        "index": 332,
        "label": "deleteTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- deleteTable ------------------------------------------------------- -->']\n<!-- gives a lists of all available tables, from which the one picked will be deleted -->\n\n[h:shortTblNames\t= bot_listBoTTables()]\n\n[h:abort(input(\"shortTblName|\"+shortTblNames+\"|Choose a table|RADIO|SELECT\t= 0 VALUE=STRING\"))]\n\n[h:resetProperty(\"tbl.\"+shortTblName, \"lib:EventMacros\")]\n[h:broadcast(strformat(\"Table <b>%{shortTblName}<\/b> has been deleted\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "324f843c-6ee9-440c-a818-7bf02eb6db22",
          "commandChecksum": "06385de3735753acba15eb690efae19b",
          "propsChecksum": "0ba693b6f14522711c21e7a6a4005691"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "6",
        "index": 333,
        "label": "getColumns",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- getColumns (0.table name) ------------------------------------------------------- -->']\n<!-- returns a list of the columns of a table -->\n[macro.return\t= decode(json.fields(json.get(getLibProperty(\"tbl.\"+arg(0), \"Lib:EventMacros\"), listGet(bot_getRows(arg(0)),1))))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a2fec30a-4fb0-447e-868e-ce45b0a83f45",
          "commandChecksum": "e178d806d365c7cd6864ccaac143d400",
          "propsChecksum": "fb3a0efdf89fefe84573aecb2e81af5a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "5",
        "index": 334,
        "label": "getRows",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- getColumns (0.table name) ------------------------------------------------------- -->']\n<!-- returns a list of the columns of a table -->\n[macro.return\t= decode(json.fields(getLibProperty(\"tbl.\"+arg(0), \"Lib:EventMacros\")))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8ce3562e-1c67-4c7b-b68a-49f847c8b2b1",
          "commandChecksum": "39b2d88ce928dcfae3c47ea67a0bc639",
          "propsChecksum": "3f15802709c29d05c711f1e814eaf4bd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "99",
        "index": 335,
        "label": "json.pappend",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- json.pappend ------------------------------------------------------- -->']\n<!-- json.pappend( 0. json object, 1. path/like/this, 2. value to add)  -->\n<!-- original code by lmarkus001, minor updates by wolph42 -->\n\n[assert(argCount()\t== 3, \"json.pset requires three arguments (JSONVariable, JSONPath, Value)\", 0)]\n[jV\t\t= arg(0)]\n[path\t= trim(arg(1))]\n[val\t= arg(2)]\n\n[path\t= replace(\"path\\\", \"\\\\\\\", \"/\")]\n[path\t= if(substring(path, 0, 1) == \"/\", substring(path, 1), path)]\n\n[if(listCount(path, \"/\") <= 1), CODE: {\n\t[output\t\t= json.append(jV, val)]\n};{\n\t[fld\t\t= listGet(path, 0, \"/\")]\n\t[newPath\t= substring(path, length(fld)+1)]\n\t[assert(fld != \"\", \"Invalid path \" + path, 0)]\n\t[newjV\t\t= json.get(jV, fld)]\n\t<!-- recursive call -->\n\t[output\t\t= json.set(jV, fld, json.pappend( newjV, newPath, val))]\n}]\n\n[macro.return = output]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fe0820b3-2727-48d2-988c-3ee6005751ad",
          "commandChecksum": "3a3f97062bf9736dac63c301bd50a2c5",
          "propsChecksum": "5ed3f24fd287fb2af6b206b9093b6645"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "99",
        "index": 336,
        "label": "json.paths",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- json.paths ------------------------------------------------------- -->']\n<!-- json.paths( 0. json object) -->\n<!-- original code by Craig, further improved by lmarkus001, minor updates by wolph42 -->\n\n[assert(argCount() > 0, \"json.paths requires a single argument ( JSONVariable )\", 0)]\n[val\t= arg(0)]\n[if(argCount() > 1): prefix\t= arg(1) ; prefix\t= \"\"]\n[paths\t= \"[]\"]\n[if(json.type(val) != \"UNKNOWN\"), foreach(p, json.fields(val)), CODE: {\n\t[obj\t= json.get(val, p)]\n\t[if(json.type(obj)\t== \"UNKNOWN\"), CODE : {\n\t\t[paths\t\t= json.append(paths, prefix + \"/\" + p)]\n\t};{\n\t\t[newPrefix\t= prefix + \"/\" + p]\n\t\t[paths\t\t= json.union(paths, json.paths(obj, newPrefix))]\n\t}] \n}]\n\n[macro.return\t= json.sort(paths)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "65e4c7d6-e221-4fe8-9402-fe3861a46537",
          "commandChecksum": "6cdde44249ec4e66b43cc958c8da8335",
          "propsChecksum": "9833de992bad48d0146db8b8944968a9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "99",
        "index": 337,
        "label": "json.pget",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- json.pget ------------------------------------------------------- -->']\n<!-- json.pget( 0. json object, 1. path/like/this)  -->\n<!-- original code by Craig, further improved by lmarkus001, minor updates by wolph42 -->\n\n[assert(argCount()\t== 2, \"json.pget requires two arguments (JSONVariable, JSONPath)\", 0)]\n[val\t= arg(0)]\n[path\t= arg(1)]\n[foreach(fld, path, \"\", \"/\"), CODE:{ \n\t[if(fld != \"\"), CODE: {\n\t\t[if(json.type(val)\t== \"OBJECT\"): assert(json.contains(val, fld), \"Invalid path ( \" + fld + \" )\", 0)]\n\t\t[if(json.type(val)\t== \"ARRAY\"): aT\t= if( fld > (json.length(val) - 1), 0, 1)]\n\t\t[if(json.type(val)\t== \"ARRAY\"): assert( aT, \"Invalid path index ( \" + fld + \" )\", 0)]\n\t\t[val\t= json.get(val, fld)]\n\t};{}]\n}]\n\n[macro.return\t= val]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "25f0fea1-f7a3-4ecd-8db2-3222ab3f9842",
          "commandChecksum": "aa8560a34100b21c7371db88dd4565af",
          "propsChecksum": "269e262dcb6a645ef93ac7d0313af98f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "99",
        "index": 338,
        "label": "json.pset",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- json.pset ------------------------------------------------------- -->']\n<!-- json.pset( 0. json object, 1. path/like/this, 2. value to add)  -->\n<!-- original code by lmarkus001, minor updates by wolph42 -->\n\n[assert(argCount()\t== 3, \"json.pset requires three arguments (JSONVariable, JSONPath, Value)\", 0)]\n[jV\t\t= arg(0)]\n[path\t= arg(1)]\n[val\t= arg(2)]\n[path\t= if(substring(path, 0, 1)\t== \"/\", substring(path, 1), path)]\n[if(listCount(path, \"/\") == 1), CODE: {\n\t[output\t\t= json.set(jV, path, val)]\n};{\n\t[fld\t\t= listGet(path, 0, \"/\")]\n\t[newPath\t= substring(path, length(fld)+1)]\n\t[assert(fld != \"\", \"Invalid path \" + path, 0)]\n\t[newjV\t\t= json.get(jV, fld)]\n\t[output\t\t= json.set(jV, fld, json.pset( newjV, newPath, val))]\n}]\n[macro.return\t= output]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2b8f34d7-1412-4cd2-8dd9-d9a09b764f8c",
          "commandChecksum": "3cd8a5f6f91f51bf11b567ff366ffc3f",
          "propsChecksum": "7ab2c6030ca1c57bb2914596540ccb16"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "8",
        "index": 339,
        "label": "listBoTTables",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- listBoTTables ------------------------------------------------------- -->']\n<!-- returns a list with the SHORT names of the tables -->\n\n[h:fullTblNames \t= listSort(getMatchingLibProperties(\"tbl\\\\..*\", \"Lib:EventMacros\"),\"A+\")]\n[h:shortTblNames\t= \"\"]\n[h, foreach(item, fullTblNames): shortTblNames\t= listAppend(shortTblNames,substring(item,4))]\n[h:assert(shortTblNames != \"\", \"There are currently no tables stored on lib:EventMacros\", 0)]\n[h:macro.return\t\t= shortTblNames]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6f4c715a-36b4-459e-bd3a-3dd76b46cf46",
          "commandChecksum": "6b165cd405f88549560b3eb034712ea7",
          "propsChecksum": "daac8779642b3f491a9b2c1267608954"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "7",
        "index": 340,
        "label": "listMTTables",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- listMTTables ------------------------------------------------------- -->']\n<!-- returns a list of all the available MAPTOOL tables -->\n[h:macro.return\t\t= json.toList(json.sort(json.get(getInfo(\"campaign\"), \"tables\")))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3b6178f8-dbdb-402a-8224-8284581d703f",
          "commandChecksum": "f093a43e1e1ded5eeef2918860dc682b",
          "propsChecksum": "916e713e4397b002f70d41908ab0312c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "4",
        "index": 341,
        "label": "processTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------------- processTable ------------------------------------------------- -->']\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[h:debug\t\t\t= 0]\n\n[h:result\t\t\t= macro.args]\n[h:assert(json.type(result) == \"OBJECT\",\"processTable received an erronous table. Most likely this is because you used double quotes in one of the fields.\",0)]\n[h:origResult\t\t= result]\n[h:result\t\t\t= encode(result)]\n[h:result\t\t\t= replace(result, \"%7B\", \"{\")]\n[h:result\t\t\t= replace(result, \"%7D\", \"}\")]\n[h:result\t\t\t= replace(result, \"%3A\", \":\")]\n[h:result\t\t\t= replace(result, '%22', '\"')]\n[h:result\t\t\t= replace(result, '%2C', ',')]\n[h:result\t\t\t= replace(result, '%40', '@')]\n\n[h:shortTblName\t\t= json.get(origResult, \"shortTblName\")]\n[h:choice\t\t\t= json.get(origResult, \"button\")]\n[h:tableColumnSize\t= json.get(origResult, \"tableColumnSize\")]\n\n<!-- process choice -->\n[h:rebuild\t\t\t= 0]\n[h:addRow\t\t\t= 0]\n[h:addColumn\t\t= 0]\n[h,switch(choice), CODE:\n\tcase \"Save\":{ \n\t\t<!-- do nothing just continue --> \n\t};\n\tcase \"Reset to last save\":{\n\t\t[bot_showTable(shortTblName)]\n\t\t[abort(0)]\n\t};\n\tcase \"Save & Close\":{\n\t\t[closeFrame(\"Table Editor\")]\n\t};\n\tcase \"<- Column ->\":{\n\t\t[tableColumnSize = tableColumnSize + 1]\t\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"-> Column <-\":{\n\t\t[tableColumnSize = tableColumnSize - 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"Add Row\":{\n\t\t[addRow\t\t= 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"Add Column\":{\n\t\t[addColumn\t= 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tdefault:{\n\t\t[abort(0)]\n\t};\n]\n\n[h,if(choice == \"close\" || choice == \"submit change & close\"): closeFrame(\"Table Editor\")]\n[h:assert(choice != \"close\", \"Changes have been discarded\", 0)]\n\n<!-- create new table based on changes -->\n<!-- first check if the column or row names have changed, if so process that in the table -->\n[h:tmpResult\t\t= result]\n[h:columns\t\t\t= \"\"]\n[h:rows\t\t\t\t= \"\"]\n\n[h,foreach(item, result), CODE:{\n\t[if(startsWith(item, \"@\")), CODE:{\n\t\t<!-- these are the column names, check if they have changed! -->\n\t\t<!-- typical entry:  \"@name\": \"name\" (unchanged)  \"@name\": \"Type\" (changed) -->\n\t\t[value\t= json.get(result, item)]\n\t\t[item\t= substring(item,1)]\n\t\t<!-- value has changed so change ALL column entries in the table -->\n\t\t[if(value != item): tmpResult = replace(tmpResult, '@'+item+'\"', '@'+value+'\"')]\n\t\t<!-- create list of column names -->\n\t\t[columns\t= listAppend(columns, value)]\n\t}]\n\n\t[if(endsWith(item, \"@\")), CODE:{\n\t\t<!-- these are the row names, check if they have changed! -->\n\t\t<!-- typical entry:  \"pistol@\": \"pistol\" (unchanged)  \"pistol@\": \"gun\" (changed) -->\n\t\t[value\t= json.get(result, item)]\n\t\t[item\t= substring(item,0,length(item)-1)]\n\t\t<!-- value has changed so change ALL column entries in the table -->\n\t\t[if(value != item): tmpResult = replace(tmpResult, '\"'+item+'@', '\"'+value+'@')]\n\t\t<!-- create list of row names -->\n\t\t[rows\t\t= listAppend(rows, value)]\n\t}]\n}]\n[h:result\t\t\t= tmpResult]\n[h,if(addColumn):\tcolumns\t= listAppend(columns, encode(\"<new column>\"))]\n[h,if(addRow):\t\trows\t= listAppend(rows, encode(\"<new row>\"))]\n\n<!-- finally process the remainder into a new table json structure -->\n[h:table\t= json.set(\"{}\", \"tableColumnSize\", tableColumnSize)]\n[h,foreach(rowName, rows), CODE:{\n\t<!-- these are the table entries -->\n\t<!-- typical entry:  \"pistol@damage\": \"3d6\" -->\n\t[row\t= \"{}\"]\n\t[h,foreach(columnName, columns): row = json.set(row, columnName, json.get(result, rowName+\"@\"+columnName)))]\n\t[table\t= json.set(table, rowName, row)]\n\t['pause(\"rowName\",\"rows\",\"row\",\"result\",\"columns\")']\n}]\n\n[h,if(debug == 1), code:{\n\t<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n\t[bot_debugInfo(\"result,table\",0,1,0, getMacroName(), getMacroLocation())]\n\t[r,frame(\"Debug\", \"width=100; height=100; temporary=1\"): {\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n\t\t[r:json.indent(table)]\n\t}]\n\t[h:where = getMacroName()]\n\t[h:pause(\"shortTblName\", \"where\", \"rows\", \"columns\")]\n};{}]\n\n<!-- and save it -->\n[h:setLibProperty(\"tbl.\"+shortTblName, table, \"Lib:EventMacros\")]\n[h,if(rebuild || debug): bot_showTable(shortTblName)]\n[h:broadcast(\"Table is updated!\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1e369b0a-bd6f-41c6-a6af-d6ced03eedcc",
          "commandChecksum": "948fd5bd1b8284fe7d8c1ee6877d5c7d",
          "propsChecksum": "51ca2a8a9774c19abf9485b29e1349bc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "9",
        "index": 342,
        "label": "searchRow",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- searchRow ------------------------------------------------------- -->']\n[while(!done), CODE:{\n\t[row\t\t= listGet(rows, roll.count)]\n\t[pause(\"row\")]\n\t[if(indexOf(row,\"-\")+1), CODE:{\n\t\t[location\t= indexOf(row,\"-\")]\n\t\t[start\t\t= number(substring(row, 0, location))]\n\t\t[end \t\t= number(substring(row, location + 1, length(row)))]\n\t\t[if(roll >= start && roll <= end): resultRow = row]\n\t''\n\t};{\n\t\t[if(roll == row): resultRow = row]\n\t''\n\t}]\n\t[if(roll.count >= rowCount || resultRow != \"\"): done = 1]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "96ee3c62-f809-4e69-baea-cb8f3023b442",
          "commandChecksum": "0ddd36a7abe519070ae89525c81d44f3",
          "propsChecksum": "017e13c12a13c7c85ca04d7e602b9856"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "9",
        "index": 343,
        "label": "setTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- bot_setTable ------------------------------------------------------- -->']\n<!-- keep in mind that you canNOT use numerical values for the column names!!!! -->\n<!-- arguments: 0 = shortTblName, 1. = column, 2 = row (either index or name), value -->\n<!-- THREE CODE LEVELS -->\n\n[h:assert(argCount() == 4, \"setTable requires EXACTLY 3 paramters: tableName, columnName, rowName, value\",0)]\n[h:shortTblName\t= arg(0)]\n[h:column\t\t= arg(1)]\n[h:row\t\t\t= arg(2)]\n[h:value\t\t= encode(arg(3))]\n\n[h:table\t\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n[h:rows\t\t\t= decode(json.fields(table))]\n[h,if(listContains(rows, \"tableColumnSize\")): rows = listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n[h:assert(listContains(rows,row), strformat(\"Cannot find the row <b>%{row}<\/b> in the table: <b>%{shortTblName}<b>. Available rows are: <b>%{rows}<\/b>\"),0)]\n[h:columns\t\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n[h:assert(listContains(columns,column), strformat(\"Cannot find the column <b>%{column}<\/b> in the table: <b>%{shortTblName}<\/b>. Available column are: <b>%{columns}<\/b>\"),0)]\n\n[h:encColumn\t= encode(column)]\n[h:encRow\t\t= encode(row)]\n\n[h:tmpRow\t\t= json.get(table, encRow)]\n[h:tmpRow\t\t= json.set(tmpRow, encColumn, value)]\n[h:table\t\t= json.set(table, encRow, tmpRow)]\n\n[h:table\t\t= setLibProperty(\"tbl.\"+shortTblName, table, \"Lib:EventMacros\")]\n\n[bot_setTable(\"tiny\", 'name', 6, \"tom\")]\n\n<pre>\n[r:table\t\t= getLibProperty(\"tbl.tiny\", \"Lib:EventMacros\")]\n[r:rows\t\t\t= decode(json.fields(table))]\n[r:columns\t\t= decode(json.fields(json.get(table, listGet(rows,0))))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c2ab1df3-4f39-4a5d-bb7e-12e3fb25b93a",
          "commandChecksum": "1207dafa5ccb7964f8cb7ac3a4013f68",
          "propsChecksum": "984354dd6346ea0f6e288566da69e14e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "3",
        "index": 344,
        "label": "showTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------------- showTable(shortTblName) ------------------------------------------------- -->']\n<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n[h:debug = 0]\n\n[h,if(argCount()): \n\tshortTblName = arg(0) \n; \n\tabort(input(\n\t\t\"shortTblName|\"+bot_listBoTTables()+\"|Show which table|RADIO|VALUE=STRING\"\n\t))\n]\n[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\n<!-- ----------------------------- DEBUG --------------------------- -->\n[h,if(debug == 1), code:{\n\t[r,frame(\"Debug\", \"width=100; height=100; temporary=1\"): {\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n\t\t[r:json.indent(table)]\n\t}]\n\t[h:pause(\"shortTblName\")]\n};{}]\n<!-- ----------------------------- /DEBUG --------------------------- -->\n\n[h,if(json.contains(table, \"tableColumnSize\")), CODE:{\n\t[size\t= json.get(table, \"tableColumnSize\")]\n\t[table\t= json.remove(table, \"tableColumnSize\")]\n};{\n\t[size\t= 10]\n}]\n\n[h:encRows\t\t= json.fields(table)]\n[h:encColumns\t= json.fields(json.get(table, listGet(encRows,0)))]\n\n<!-- create header row -->\n[h:headerRow\t= \"<td align='center'><b>Index<\/b><\/td>\"]\n[h,foreach(encColumn, encColumns), CODE:{\n\t[column\t\t= decode(encColumn)]\n\t[headerRow\t= headerRow + strformat(\"<td><b><input type='text' name='@%{column}' value='%{column}' size='%{size}'><\/b><\/td>\")]\n}]\n\n[h:processorLink\t= macroLinkText('processTable@Lib:onTokenMove', 'none')]\n[h:htmlStr\t\t\t=\tstrformat(\"\n\t<form action='%{processorLink}' method='json' >\n\t<input type='hidden' name='shortTblName' value='%{shortTblName}'>\n\t<input type='hidden' name='tableColumnSize' value='%{size}'>\n\t<input type='submit' name='button' value='Save'>\n\t<input type='submit' name='button' value='Reset to last save'>\n\t<input type='submit' name='button' value='Save & Close'>\n\t<input type='submit' name='button' value='<- Column ->'>\n\t<input type='submit' name='button' value='-> Column <-'>\n\t<input type='submit' name='button' value='Add Row'>\n\t<input type='submit' name='button' value='Add Column'>\n\t<table cellpadding='0' cellspacing='0'><tr>%{headerRow}<\/tr>\n\")]\n\n[h,if(debug == 1), code:{\n\t['bot_debugInfo(\"htmlStr\",1,0,0)']\n};{}]\n\n[h,foreach(encIndex,encRows), CODE:{\n\t[nRow\t\t= roll.count]\n\t[index\t\t= decode(encIndex)]\n\t[encRow\t\t= json.get(table, encIndex)]\n\t[htmlRow\t= strformat(\"<td><input type='text' name='%{index}@' value='%{index}' size='%{size}'><\/td>\")]\n\t[foreach(encColumn, encRow), CODE:{\n\t\t[nColumn\t= roll.count]\n\t\t[column\t\t= decode(encColumn)]\n\t\t[value\t\t= decode(json.get(encRow, encColumn))]\n\t\t[htmlRow\t= strformat(\"%{htmlRow}<td><input type='text' name='%{index}@%{column}' value='%{value}' size='%{size}'><\/td>\")]\n\t}]\n\t[htmlStr\t= strformat(\"%{htmlStr}<tr>%{htmlRow}<\/tr>\")]\n}]\n\n[h:htmlStr\t=\tstrformat(\"%{htmlStr}\n\t<\/table>\n\t<input type='submit' name='button' value='Save'>\n\t<input type='submit' name='button' value='Reset to last save'>\n\t<input type='submit' name='button' value='Save & Close'>\n\t<input type='submit' name='button' value='<- Column ->'>\n\t<input type='submit' name='button' value='-> Column <-'> \n\t<\/form>\n<br>\n<b>Da Rules<\/b>: <br>\nWhen I'm talking about column/row *names* I means the entries in the first column (==Index ==row names) and the top row (== column names). When I'm talking about *values* thats the rest. Every value is referred (found) by its corresponding column and row name.<br>\n- do NOT use the 'single quotes' in the table. Everything should still work, but they will be removed. <br>\n- do NOT use '@' for column or row names. I use this in the code as seperator, so funky stuff will happen if you're using it too. It should be ok to use it inside values, just not in the names. <br>\n- every column and row MUST have a unique name <br>\n- thus the 'add row/column' macro will only work once until you renamed the newly created column/row.<br>\n- everything you enter is encoded and then stored in a json object. This *Should* result in a quite robust table allowing for many characters. I have not tested them all, although I'm fairly certain that it will break on 'non-printable character' (e.g. the apostrophe's in Word).<br>\n\")]\n[h:'bot_showHTML(htmlStr)']\n\n[r,frame(\"Table Editor\", \"width=100; height=100; temporary=1\"): {\n\t[r:htmlStr]\n\t[r,if(debug == 1), code:{\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n[r:json.indent(table)]\n\t};{}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85ec4e4a-a794-4b81-81c7-de50e9f88334",
          "commandChecksum": "8484b92d5e1f397fe17fb51e70a7e81d",
          "propsChecksum": "2278c69d9d132b6db4264732bb93a277"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "9",
        "index": 345,
        "label": "table",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- bot_table ------------------------------------------------------- -->']\n<!-- keep in mind that you canNOT use numerical values for the column names!!!! -->\n<!-- arguments: 0 = shortTblName, optional: 1 = column (either index or name. Defaults to 0), 2 = row (either index or name, Defaults to random pick) -->\n<!-- THREE CODE LEVELS -->\n\n[h, if(argCount() > 0): shortTblName= arg(0);\tshortTblName= \"\"]\n[h, if(argCount() > 1): column\t\t= arg(1);\tcolumn\t\t= 0]\n[h, if(argCount() > 2): roll\t\t= arg(2);\troll\t\t= \"random\"]\n\n[if(shortTblName == \"\"), CODE:{\n\t<!-- show table list and all options to pick a value -->\n\t[shortTblNames\t= bot_listBoTTables()]\n\t[abort(input(\"shortTblName|\"+shortTblNames+\"|Choose a table|RADIO|SELECT=0 VALUE=STRING\"))]\n\n\t[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\t[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n\t[h:rows\t\t= decode(json.fields(table))]\n\t[h, if(listContains(rows, \"tableColumnSize\")):rows\t\t= listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n\t[h:columns\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n\n\t[abort(input(\n\t\t\"column|\"+columns+\"|Choose column|RADIO|SELECT=0 VALUE=STRING\",\n\t\t\"row|\"+rows+\"|Choose row|RADIO|SELECT=0 VALUE=STRING\"\n\t))]\n''\n};{\n\t[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\t[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n\t[h:rows\t\t= decode(json.fields(table))]\n\t[h, if(listContains(rows, \"tableColumnSize\")):rows\t\t= listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n\t[h:columns\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n\t[h,if(isNumber(column)): column\t= listGet(columns, column)]\n\n\t[h,if(isNumber(roll) || roll == \"random\"),CODE:{\n\t\t<!-- retrieve the highest number for the roll -->\n\t\t[rowCount\t= listCount(rows)]\n\t\t[lastRow\t= listGet(rows, rowCount-1)]\n\t\t[if(indexOf(lastRow,\"-\")+1): end\t= substring(lastRow, indexOf(lastRow,\"-\") + 1, length(lastRow)) ; end = lastRow]\n\t\t[if(isNumber(end)), CODE:{\n\t\t\t[end\t\t\t= number(end)]\n\t\t\t[numericRows\t= 1]\n\t\t''\n\t\t};{\n\t\t\t[end\t\t\t= listCount(rows)]\n\t\t\t[numericRows\t= 0]\n\t\t''\n\t\t}]\n\t\t\n\t\t<!-- Make the roll -->\n\t\t[roll\t= if(roll == \"random\",roll(1, end),roll)]\n\t\t\n\t\t[if(numericRows), CODE:{\n\t\t\t[resultRow\t= \"\"]\n\t\t\t[done\t\t= 0]\n\t\t\t<!-- seperate function as the while loop does not do well in these nested if statements. SAME SCOPE -->\n\t\t\t[bot_searchRow()]\n\t\t''\n\t\t};{\n\t\t\t<!-- NOT numeric rows -->\n\t\t\t[row\t= listGet(rows, roll-1)]\n\t\t''\n\t\t}]\n\t''\n\t};{\n\t\t<!-- the argument isnt a number and thus a string, so look for a string -->\n\t\t[row\t= roll]\n\t''\n\t}]\n''\n}]\n[pause(\"column\", \"row\")]\n[macro.return\t= decode(json.pget(table,encode(row)+\"/\"+encode(column)))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1020543e-ee84-417e-8277-8f7788bfb3cd",
          "commandChecksum": "bbbe13e60ab82667f8232e7db61229f4",
          "propsChecksum": "ba2b70fc8e5335377f3e3330302b6493"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "13. Tables",
        "includeLabel": false,
        "sortBy": "2",
        "index": 346,
        "label": "text2Table",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- text2Table ------------------------------------------------------- -->']\n<!-- this function does the actual processing of the copy pasted excel table in the html form. -->\n\n<!-- List Parsing XPTL -->\n[h: args \t= macro.args]\n[h: Title \t= json.get(args, \"Title\")]\n[h: show \t= json.get(args, \"show\")]\n[h: text \t= encode(json.get(args, \"TextBox\"))]\n\n[delim\t \t= \"%09\"]\n[lb \t\t= \"%0A\"]\n\n[jTable\t\t= \"{}\"]\n[row\t\t= \"\"]\n[rowName\t= \"\"]\n\n[rows\t\t= json.fromList( text , lb )]\n[nRows\t\t= json.length( rows )]\n\n<!-- first line only: might be more efficient to pull this out and only do it once \n\t(rather than having to evaluate and skip EVERY OTHER TIME THROUGH THE LOOP) -->\n[line.txt\t= json.get( rows , 0 )]\t\t\t\t\t\t<!-- get the 1st line (omitting line break) -->\n[headerRow\t= json.fromList( line.txt , delim )]\t\t<!-- \"%09\" if encoded, decode( \"%09\" ) otherwise, or specified by argument? -->\n[tableName\t= json.get( headerRow, 0 )]\n[nCols\t\t= json.length( headerRow )]\t\t\t\t\t<!-- this might only really need to be done with the first line -->\n[rows\t\t= json.remove( rows , 0 )]\t\t\t\t\t<!-- drop header row (for convenience) -->\n\n<!-- all subsequent rows -->\n[h, FOREACH( rowText , rows ), CODE: {\n\t[rowText\t= listAppend(rowText, \"tmp\", delim)]\t\t<!-- if the list ends with a couple of empty values they are discarded, so add a tmp value -->\n\t[row\t\t= json.fromList( rowText , delim )]\t\t\t<!-- \"%09\" if encoded, decode( \"%09\" ) otherwise, or specified by argument? -->\n\t[row\t\t= json.remove( row, nCols)]\t\t\t\t\t<!-- remove tmp value -->\n\t[jRow\t\t= \"{}\" ]\n\t[FOR( i , 0 , nCols ), CODE: {\n\t\t[item \t\t= json.get( row , i )]\t\t\t\t\t<!-- get the 'ith' item (omitting delimiter) -->\n\t\t[column\t\t= json.get( headerRow , i )]\t\t\t<!-- get the 'ith' column name -->\n\n\t\t<!-- name of current row / assemble row object -->\n\t\t[if( i == 0 ): rowName = item ; jRow = json.set( jRow , column, item )]\n\t}]\n\t[jTable\t\t= json.set( jTable , rowName , jRow )]\n}]\n\n[h:setLibProperty(\"tbl.\"+Title, jTable, \"Lib:EventMacros\")]\n[h,if(show):bot_showTable(Title)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "24a1a64b-7805-4792-a408-3a1ea4e595fa",
          "commandChecksum": "d8441f20af2a64a0ca9e218630eed568",
          "propsChecksum": "14f769d421c28ea4bd4bb26d9de83e69"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "2",
        "index": 347,
        "label": "deferToggleDoor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t<!-- Assertions and initializing properties -->\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\t<!-- choices are: nothing,crack,open,close -->\n\t[choice\t\t\t= getProperty(\"w42.bot.choice\", me)]\n\n\t<!-- Abort when player is on other map -->\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDistance, xDirection -->\n\t[varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t<!-- initialize timers -->\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n<!-- ROTATION INIT -->\n\t<!-- check if door is open or closed, and if in between reset its position to either open or closed -->\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n<!-- SLIDING INIT -->\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t<!-- does the door slides left right (x) or up down (y) -->\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n<!-- ROTATION -->\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t\t[if(choice==\"crack\"):\tendPos\t= bot_getTokenFacing(me) + direction*crackOpenAngle]\n\t\t[if(choice==\"close\"):\tabort(0)] <!-- door is already closed -->\n\t\t\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[startPos \t\t= bot_getTokenFacing(me)]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t\n\t\t[if(choice==\"crack\"):\tendPos\t\t= startPos + direction*crackOpenAngle]\n\t\t[if(choice==\"open\"):\tendPos\t\t= totalOpenAngle]\n\t\t[if(choice==\"close\"):\tdirection\t= -1*direction]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n<!-- /ROTATION -->\n\n<!-- SLIDING -->\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, getTokenX(1), getTokenY(1))]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t\t[if(choice==\"crack\"):\tendPos\t= startPos + direction*crackOpenDistance]\n\t\t[if(choice==\"close\"):\tabort(0)] <!-- door is already closed -->\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, getTokenX(1), getTokenY(1))]\n\n\t\t[if(choice==\"crack\"):\tendPos\t= startPos + direction*crackOpenDistance]\n\t\t[if(choice==\"open\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t\t[if(choice==\"close\"):\tdirection\t= -1*direction]\n\n\t\t<!-- if the door is not open, make sure that its in the correct open position -->\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n<!-- /SLIDING -->\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n<!-- ------------------------------------------------------>\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t<!-- ROTATING -->\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t<!-- SLIDING -->\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n<!-- ------------------------------------------------------>\n\n<!-- Check if animation is finished -->\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t<!-- if not, rotate door yet another step -->\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t<!-- if youre the only one running (or the initiator) also set the door visible again -->\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8cb48486-f137-43cd-ba6e-c78d78abaf11",
          "commandChecksum": "8c853fbcbdbb181298684e20888b2f98",
          "propsChecksum": "ede0aaf0ae090fd057c4d33a0cc0582a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "7",
        "index": 348,
        "label": "isDoorClosed",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- isDoorClosed --------------------------------------- -->']\n\n[h,if(argCount() > 0):\tmainDoor\t= arg(0) ; mainDoor\t= currentToken()]\n\n[h:switchToken(mainDoor)]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h,if(openMethod < 2):\n\tisClosed \t\t= if(bot_getTokenFacing(mainDoor) == closedAngle, 1, 0)\n; \n\tisClosed \t\t= if(getTokenX(1) == closedDoorX && getTokenY(1) == closedDoorY , 1, 0)\n]\n\n[r:macro.return = isClosed]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5aecdb95-454d-45c6-a580-7cbddf4c33e0",
          "commandChecksum": "c0c46100b16e50929aa598a2a5240521",
          "propsChecksum": "60a6d3282299c9f3f7bd7e29cf8221ad"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "99",
        "index": 349,
        "label": "setDoor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- setDoor Stamp version---------------------------------------------->']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n stepSize=0;\n halfStepSize=0;\n crackStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpendistance=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n')]\n\n<!-- FIRST initialize ALL vars -->\n[h:varsFromStrProp(initList)]\n\n<!-- look for potential double door -->\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n<!-- THEN initialize any values already stored on the door -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n<!-- setup macro event link -->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t<!-- create macro list from the Event Button Macros group -->\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n\n[h: abort(input(\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\t\"crackOpenAngle|\"+crackOpenAngle+\"|How many degrees does the door turn when opening it a bit (to peek)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"crackOpendistance|\"+crackOpendistance+\"|How much does the door slide away a bit (to take a peek, also in distance per cell)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\"\n))]\n\n<!-- idiot checks and setting properties -->\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, openDistance\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n\n<!--------------------------------------------------------------------->\n<!-------------------------the big loop ------------------------------->\n<!--------------------------------------------------------------------->\n\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t<!-- set other properties -->\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t<!-- rotating door -->\n\t\t[stepSize\t\t=  openAngle/(animateTime+1)]\n\t\t[crackStepSize\t= 10/(animateTime+1)]\n\t\t[halfStepSize\t= 45/(animateTime+1)]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t<!-- sliding door -->\n\t\t[stepSize\t\t= openDistance/(animateTime+1)]\n\t\t[crackStepSize\t= (openDistance/10)/(animateTime+1)]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t<!-- 2=left, 3=right, 4=north, 5=south -->\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t<!-- setup double door -->\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\", \"closedDoorX=\"+getTokenX(1,doubleDoorName)+\";closedDoorY=\"+getTokenY(1,doubleDoorName))]\n\n\t<!-- setup token switch -->\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t<!-- lock the door is set to such -->\n\t[h:setState(\"Locked\",isLocked)]\n\n\t<!-- add gm Note -->\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t<!-- setup the macro link -->\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpendistance, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f194e082-1a01-47ca-bf98-ac0e70ec7906",
          "commandChecksum": "2648174f634c9d8e8a060be9c479247d",
          "propsChecksum": "dd9e677aee621b810f335bce0b3230ea"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "1",
        "index": 351,
        "label": "toggleDoor",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t<!-- a trigger button is used next to the door -->\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t<!-- name of the token operating the door -->\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t<!-- door is openened with a macro (likely by the gm) -->\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n<!-- INITIALIZE VALUES -->\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDistance, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n[h:crack\t\t\t\t= getStrProp(getProperty(\"w42.bot.doorData\", mainDoor),\"crackOpenDistance\")]\n[h,if(crack==\"\"): crackOpenDistance=0]\n\n<!-- MAKE ASSERTIONS -->\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n<!-- DOOR EVENT TRIGGER -->\n<!-- if an event is linked to the door being operated -->\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n[if(crackOpenAngle+crackOpenDistance > 1), CODE:{\n\t[choices\t= \"Do nothing, Crack the door open (further), Open the door all the way, close the door\"]\n\t[propList\t= \"nothing,crack,open,close\"]\n\t<!-- some menu is required -->\n\t[abort(input(\n\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\"choice|\"+choices+\"|You...|RADIO|VALUE=STRING\"\n\t))]\n\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t<!-- abort if nothing -->\n\t[assert(choice != \"nothing\",\"you do nothing\",0)]\n}; {\n\t[choice = \"normal\"]\n}]\n\n[h:setProperty(\"w42.bot.choice\", choice, mainDoor)]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a95d7d0f-1014-4843-a74d-c1b7d2ebaa1d",
          "commandChecksum": "8566b9d75c7439b3d7987b28511ca326",
          "propsChecksum": "6dcab5f0b251355fbee789c1a798612e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "2",
        "index": 352,
        "label": "toggleDoors",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'!<!-- -----------------------------------------toggleDoors ------------------------------------------------------>']\n<!-- <html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close -->\n[h:'<!-- create a list of doors on the object layer that have been set for animation-->']\n[h:tokens\t= getTokenNames(\",\",'{\"layer\":\"OBJECT\"}')]\n[h:me\t\t= getSelectedNames()]\n[h:showClosestOnly\t= if(!isGM() || me != \"\", 1, 0)]\n[h, if(showClosestOnly):assert(listCount(me) == 1, \"Make sure (only) one token is selected\",0)]\n[h:Doors\t= \"\"]\n[h, foreach(tok, tokens),CODE:{\n\t[if(startsWith(tok, \"Door \") && getProperty(\"w42.bot.doorData\", tok)!=\"\" && !endsWith(tok, \"a\")): Doors = listAppend(Doors, tok)]\n}]\n\n[h: assert(Doors != \"\",\"There are no doors set on the object layer of this map\",0)]\n\n[h:Doors = listSort(Doors, \"N+\")]\n\n[h:'<!-- Create list of door identifiers -->']\n[h:iDoors\t\t\t\t= \"\"]\n[h:descriptionsDoors\t= \"\"]\n[h:playerDoors\t\t\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t[id\t\t\t\t\t= substring(door, 5)]\n\t[description\t\t= getStrProp(getProperty(\"w42.bot.doorData\",door),\"description\")]\n\t[iDoors\t\t\t\t= listAppend(iDoors, id)]\n\t[varsFromStrProp(getProperty(\"w42.bot.doorData\", door))]\n\t<!-- if player: only add doors within proximity -->\n\t[if(showClosestOnly), CODE:{\n\t\t[proximity\t\t= getStrProp(getProperty(\"w42.bot.doorData\",door),\"proximity\")]\n\t\t[distance\t\t= getDistance(me, 1, door)]\n\t\t[descriptionsDoors\t= listAppend(descriptionsDoors, strformat(\"(%{id}) %{description}\"))]\n\t\t[if((distance <= proximity || proximity == 0) && getVisible(door)): playerDoors\t\t= listAppend(playerDoors, door)]\n\t};{\n\t\t[descriptionsDoors\t= listAppend(descriptionsDoors, strformat(\"(%{id}) %{description}\"))]\n\t}]\n}]\n\n[h,if(showClosestOnly): usableDoors = playerDoors; usableDoors = Doors]\n\n[h:'<!-- turn this list into an input string -->']\n[h:inputStr\t= \"junk|<html><b>Toggle Doors - (name of the door) Description given<\/b><br><\/html>|-|LABEL|SPAN=TRUE\"]\n[h,if(usableDoors == \"\"):inputStr\t= listAppend(inputStr, \"junk|<html><b><font color=red>\"+if(showClosestOnly, \"You are too far from any door to open\", \"There are no doors on this map\")+\"<\/font><\/b><br><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n\n[h,foreach(door, Doors), if(listContains(usableDoors, door)), CODE:{\n\t\t[newStr = \"door\" + roll.count + \"|0|\" + listGet(descriptionsDoors, roll.count) + \"|CHECK\"]\n\t\t[inputStr = listAppend(inputStr, newStr,\"##\")]\n};{\n\t\t[eval(\"door\" + roll.count + \"=0\")]\n}]\n\n[h:'<!-- execute input string -->']\n[h: abort(input(inputStr))]\n\n[h:'<!-- process results, that is animate the chosen doors -->']\n[h,foreach(door, Doors), CODE:{\n\t['if(eval(\"door\" + roll.count)):bot_toggleDoor(listGet(iDoors, roll.count))']\n\t[if(eval(\"door\" + roll.count)):execLink(macroLinkText(\"toggleDoor@lib:onTokenMove\",\"none\",listGet(iDoors, roll.count)),1)]\n}]\n[h:'!<!-- ---------------------------------------end toggleDoors ---------------------------------------------------->']",
        "maxWidth": "",
        "tooltip": "<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6e67d565-88b4-443c-a102-5958e5252f3d",
          "commandChecksum": "195393c506631066126f64ea687e7033",
          "propsChecksum": "bf6ccf32d84b526e9617bfca833d2acf"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4. ShadowPads",
        "includeLabel": false,
        "sortBy": "11",
        "index": 353,
        "label": "doShadowPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- bot_doShadowPad -------------------------------->']\n<!-- \nif both pads are occupied, shadowtokens are placed on the pads in their relative position. All shadowtokens are visible to owner only, so all the clients who participate in the shadow view can see the shadow tokens. The rest not. \nThe following events should be set to trigger this event:\n- movedOn  (activate)\n- movedOff  (deactivate)\n- movedRemain (move shadow)\n- movedReturn (move shadow)\n'p' stands for 'primary' which is where the currentToken has moved on\n's' stands for 'secondary' which is the 'other' pad that is linked to the primary\n-->\n\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n[h:padName\t\t= arg(2)]\n\n<!-- introduce the settings: canSelectShadowTok:  Object Layer(0), Token Layer(1), Token Layer and autoselect Main Token(2) -->\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n[h:switchToken(me)]\n\n<!-- retrieve the name of the linked pad -->\n[h:sName\t\t= if(bot_inStr(padName, \"Ground\"), \"Floor\", \"Ground\")]\n[h:id\t\t\t= getGroup(strfind(padName,\"ShadowPad ([^\\\\s]+)\"),1,1)]\n[h:sPadname\t\t= strformat(\"ShadowPad %{id} %{sName}\")]\n\n<!-- check if the pads were already activated -->\n[h:pActive\t\t= if(isNumber(getProperty(\"w42.bot.Active\", padName)),getProperty(\"w42.bot.Active\", padName),0)]\n[h:sActive\t\t= if(isNumber(getProperty(\"w42.bot.Active\", sPadName)),getProperty(\"w42.bot.Active\", sPadName),0)]\n\n<!-- if the linked pad was already activated, get the tokens on that pad -->\n[h,if(sActive == 1): sTokList\t= getProperty(\"w42.bot.onPad\", sPadName) ; sTokList = \"\"]\n\n<!-- initialize tokList -->\n[h:tokList\t\t= \"\"]\n\n[h,if(event == \"movedOn\"), CODE:{\n\t<!-- retrieve names of toks already on the pad and add the new one. Store this list on the pad -->\n\t[pTokList\t= getProperty(\"w42.bot.onPad\", padName)]\n\t[if(!listContains(pTokList, me)): pTokList\t= listAppend(pTokList, me)]\n\t[setProperty(\"w42.bot.onPad\", pTokList, padName)]\n\t[setProperty(\"w42.bot.Active\", 1, padName)]\n};{}]\t\n\n[h,if(event == \"movedOff\"), CODE:{\n<!-- retrieve the names of toks already on the pad and remove this one from it. Store the new list on the pad -->\n\t[pTokList\t= getProperty(\"w42.bot.onPad\", padName)]\n\t[pTokList\t= listDelete(pTokList, listFind(pTokList, me))]\n\t[setProperty(\"w42.bot.onPad\", pTokList, padName)]\n\t<!-- if no toks on pad left, deactivate it -->\n\t[if(pTokList == \"\"):setProperty(\"w42.bot.Active\", 0, padName)]\n\t\n\t<!-- if shadowmove is active: remove its shadow (as you just moved off) -->\n\t[if(pActive && sActive): bot_removeShadow(me)]\n\t[if(pTokList == \"\" && pActive && sActive), CODE:{\n\t\t<!-- if there are no tokens on this other pad then remove ALL shadow tokens -->\n\t\t[foreach(tok, sTokList): bot_removeShadow(tok)]\n\t};{}]\n\t\n\t[if(pTokList != \"\" && pActive && sActive), CODE:{\n\t\t<!-- if there are tokens left on this other pad then set their ownership to the participating clients (==those who own tokens participating) -->\n\t\t[viewingPlayers\t= \"[]\"]\n\t\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\t[foreach(tok, tokList), if(isOwnedByAll(tok)): \n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getAllPlayerNames(\"json\")) \n\t\t\t;\n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getOwners(\"json\",tok))\n\t\t]\n\t\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\t[foreach(tok, tokList): setOwner(viewingPlayers, tok+\" shadow\")]\n\t};{}]\n};{}]\t\n\n[h, if( event == \"movedOn\" && sActive), CODE:{\n\t<!-- if a new token moved on the shadow pad and on the other pad there is at least one token (iow both pads are activated) -->\n\t<!-- create a list of ALL tokens -->\n\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\n\t[if(pActive), CODE:{\n\t\t<!-- if the shadowpads are already active only the new token needs to be added. All the existing pads need the ownership changed to add the current player -->\n\t\t<!-- so retrieve the owners from one of the other shadow tokens from the other and add the owners(s) of me -->\n\t\t[others\t\t= getOwners(\"json\", listGet(sTokList, 0)+\" shadow\")]\n\t\t[if(isOwnedByAll(me)): \n\t\t\tviewingPlayers = json.union(others, getAllPlayerNames(\"json\")) \n\t\t;  \n\t\t\tviewingPlayers = json.union(others, getOwners(\"json\",me)) \n\t\t]\n\t\t\n\t\t<!-- then set the this new owner list to all the shadow tokens. Keep in mind that me+shadow is not yet created so to prevent an error remove it from the tokenlist -->\n\t\t[tokList\t= listDelete(tokList, listFind(tokList, me))]\n\t\t[foreach(tok, tokList): setOwner(viewingPlayers, tok+\" shadow\")]\n\t\t<!-- copytoken only needs to do me so set the list to me -->\n\t\t[tokList\t= me]\n\t};{\n\t\t<!-- The pads are activated by this move, so create a list of clients who own tokens that are on the other shadow pad, they will see the shadow tokens, the rest not. -->\n\t\t[viewingPlayers\t= \"[]\"]\n\t\t[foreach(tok, tokList), if(isOwnedByAll(tok)): \n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getAllPlayerNames(\"json\"))\n\t\t\t;\n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getOwners(\"json\",tok))\n\t\t]\n\t}]\n\t\n\t<!-- as a new token moved onto the shadowpad a shadowToken needs to be created, in case the this was the first token to move on this pad ALL participating tokens require a shadowToken -->\n\t<!-- you cannot change the properties of a copyToken so you need to change the original before the copy and then change it back. -->\n\t[foreach(tok, tokList), CODE:{\n\t\t<!-- how it is -->\n\t\t[isVisible\t= getOwnerOnlyVisible(tok)]\n\t\t[hasHalo\t= getHalo(tok)]\n\t\t[owners\t\t= getOwners(\"json\", tok)]\n\t\t\n\t\t<!-- in case a shadowToken is already on the map, use that instead -->\n\t\t[altShadow\t= if(findToken(tok+\" shadow\") !=\"\", 1, 0)]\n\n\t\t<!-- how they will be, and use the existing shadowTok is its there -->\n\t\t[newTok\t\t= if(altShadow , tok+\" shadow\", tok)]\n\t\t[setProperty(\"w42.bot.isShadowToken\", 1, newTok)]\n\t\t[setOwnerOnlyVisible(1, newTok)]\n\t\t[setHalo(\"black\", newTok)]\n\t\t[setOwner(viewingPlayers, newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.doNotDelete\", 1, newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.x\", getTokenX(1, newTok), newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.y\", getTokenY(1, newTok), newTok)]\n\t\t\n\t\t<!-- create x and y coord for shadow token -->\n\t\t<!-- if no copy is created, move the alt shadow to the correct coord. Else retrieve x an y coords for copytoken -->\n\t\t<!-- reference tokens can be anything but need to end with ' Ground' and ' Floor'. This must NOT be added to the argument -->\n\t\t[bot_shadowCoords(tok, !altShadow)]\n\t\t\n\t\t<!-- create the new token with the correct properties, one size smaller -->\n\t\t[sizeList = \"Fine,Diminutive,Tiny,Small,Medium,Large,Huge,Gargantuan,Colossal\"]\n\t\t[size = if(getSize(tok) == \"\" || getSize(tok) == \"Fine\", \"Diminutive\", getSize(tok))]\n\t\t[pause(\"size\",\"altShadow\")]\n\t\t[if(!altShadow): copyToken(tok,1, \"\", json.set(\"{}\", \"name\", tok+\" shadow\", \"layer\", if(canSelectShadowTok, \"TOKEN\", \"OBJECT\"), \"x\", x, \"y\", y,\"useDistance\",1, \"size\", listGet(sizeList, listFind(sizeList,size)-1)))]\n\t\t\n\t\t<!-- how it was (restore) -->\n\t\t[setOwnerOnlyVisible(isVisible, tok)]\n\t\t[setHalo(hasHalo, tok)]\n\t\t[setOwner(owners, tok)]\n\t\t[resetProperty(\"w42.bot.isShadowToken\", tok)]\n\t}]\n};{}]\n\n<!-- if token moved but remained on the on the shadow pad then move its shadow accordingly -->\n[h,if( (event == \"movedRemain\" || event == \"movedReturn\") && sActive), CODE:{\n\t[tokList\t= listAppend(getProperty(\"w42.bot.onPad\", padName), getProperty(\"w42.bot.onPad\", sPadName))]\n\t[foreach(tok, tokList):bot_shadowCoords(tok)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2583ba31-b596-4b59-bfe3-96ce1213b673",
          "commandChecksum": "55cdaabbd77eb35428984adfd7ec629c",
          "propsChecksum": "ca66568af40d0398d8e5299d1b28aa3b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4. ShadowPads",
        "includeLabel": false,
        "sortBy": "32",
        "index": 354,
        "label": "removeShadow",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- bot_removeShadow(tok) ------------------------------------------------>']\n<!-- removes the shadow tokens from the shadow pads on exit -->\n\n[tok\t= arg(0)+\" shadow\"]\n[if(getProperty(\"w42.bot.doNotDelete\", tok) == 1), CODE:{\n\t[moveToken(getProperty(\"w42.bot.x\", tok), getProperty(\"w42.bot.y\", tok), 1, tok)]\n};{\n\t[removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f69fe9b8-04a2-42cb-832e-087d3eb7f9fa",
          "commandChecksum": "216265446b359df2d50717fc208710df",
          "propsChecksum": "53a2b6c26d8f2b41117fe0f678511a38"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4. ShadowPads",
        "includeLabel": false,
        "sortBy": "32",
        "index": 355,
        "label": "setReference",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- bot_setReference () ------------------------------------------------>']\n<!-- \n<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions <\/html> \n-->\n\n[h:me = getSelectedNames()]\n<!-- assert correct selected -->\n[h:assert(listCount(me)==1,\"Please select (only) one reference token\",0)]\n[h:assert(bot_inStr(me, \" Floor\")||bot_inStr(me, \" Ground\"),\"This token misses the Ground or Floor suffix\",0)]\n[h:switchToken(me)]\n\n[h:isFloor\t\t= if(bot_inStr(me, \" Floor\"), 1,0)]\n[h:reference\t= substring(me, 0, indexOf(me, if(isFloor, \" Floor\", \" Ground\")))]\n[h:sMe\t\t\t= reference + if(isFloor, \" Ground\", \" Floor\")]\n[h:assert(findToken(sMe) != \"\", sMe+\" token not found. Create that one first\",0)]\n\n[H: '<!-- no new scope!! results in allList -->']\n[h:bot_getValidTokens(1, json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")), 0, \"ShadowPad \")]\n[h:allList\t= replace(allList, \" Floor\", \"\")]\n[h:allList\t= replace(allList, \" Ground\", \"\")]\n[h:allList\t= json.toList(json.unique(json.fromList(allList)))]\n\n[h:abort(input(\"choice|\"+allList+\"|Link to which shadow pads?|LIST|VALUE=STRING\"))]\n\n[h:padNameG = choice + \" Ground\"]\n[h:padNameF = choice + \" Floor\"]\n\n[h:setProperty(\"w42.bot.referenceTok\", reference, padNameG)]\n[h:setProperty(\"w42.bot.referenceTok\", reference, padNameF)]\n\n[H: '<!-- make sure the shadowpads are clean!! -->']\n[h:setProperty(\"w42.bot.onPad\", \"\", padNameG)]\n[h:setProperty(\"w42.bot.onPad\", \"\", padNameF)]\n[h:setProperty(\"w42.bot.Active\", \"\", padNameG)]\n[h:setProperty(\"w42.bot.Active\", \"\", padNameF)]\n\n[h:broadcast(strformat(\"%{reference} has been linked to %{choice}\"))]",
        "maxWidth": "",
        "tooltip": "<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c0fa5e2d-0007-4358-a20d-ec51579c3cf6",
          "commandChecksum": "91995a0b5536d8606f12b9baa0f450f1",
          "propsChecksum": "81be7ca0d4752037df3bf3c6f04591b4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4. ShadowPads",
        "includeLabel": false,
        "sortBy": "32",
        "index": 356,
        "label": "shadowCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------- bot_shadowCoords (tok [,returnCoords]) ------------------------------------------------>']\n<!-- this function is used for the shadow token function and either moves or returns the new coords of the shadow token -->\n<!-- NO NEW SCOPE -->\n\n[switchToken(arg(0))]\n<!-- reference tokens can be anything but need to end with ' Ground' and ' Floor'. This must NOT be added to the argument -->\n[if(argCount() > 1): returnCoords = arg(1); returnCoords = 0]\n\n[referenceToken\t= getProperty(\"w42.bot.referenceTok\", padName)]\n[shadow\t\t\t= token.name + ' shadow']\n\n<!-- the token will belong to the reference that is closest -->\n[whereAmI    \t= if( (abs(getTokenX() - getTokenX(1, referenceToken + ' Ground')) + abs(getTokenY() - getTokenY(1, referenceToken + ' Ground'))) < (abs(getTokenX() - getTokenX(1, referenceToken + ' Floor')) + abs(getTokenY() - getTokenY(1, referenceToken + ' Floor'))) , -1, 1 )]\n\n\n[if(returnCoords), CODE:{\n\t<!-- no new scope so just create the coords -->\n\t[x\t= getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') )]\n\t[y\t= getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') )]\n};{\n\t[moveToken( getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') ), getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') ), 1, shadow)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a26ce20c-c44c-4775-ba2a-7b8299e4e366",
          "commandChecksum": "13e28e4624fbb9c3b45e0d6448630d2e",
          "propsChecksum": "acbc3c0ede10511a0bb995f1aaf38c24"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "16",
        "index": 357,
        "label": "formatTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_formatTime(time in ms, useHTML) ---------------------------------- -->']\n[seconds\t\t= arg(0)/1000]\n[if(argCount()>1): useHTML = arg(1) ; useHTML = 1]\n\n[minutes\t\t= floor(seconds/60)]\n[seconds\t\t= seconds - minutes*60]\n\n[hours\t\t\t= floor(minutes/60)]\n[minutes\t\t= minutes - hours*60]\n\n[macro.return\t= if(hours, hours+if(useHTML,\"<b>h<\/b>\",\" hours \"),\"\") + if(minutes, minutes+if(useHTML,\"<b>m<\/b>\",\" minutes \"),\"\") + seconds+if(useHTML,\"<b>s<\/b>\",\" seconds \")]",
        "maxWidth": "",
        "tooltip": "Total amount of time passed since the timer was started",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1e676d50-3368-4bc8-b5ee-dff4095730cf",
          "commandChecksum": "ddf7f60b3bae074a082e93434c742647",
          "propsChecksum": "3c5fee590c71bf641d7ca0b780d24329"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "12",
        "index": 358,
        "label": "pauseTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_pauseTime() ---------------------------------- -->']\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n[h:setLibProperty(\"w42.bot.pauseTime\", time, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 1, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "266937cb-9c78-4ebb-9718-d79140cee3cb",
          "commandChecksum": "105bcb10076b6e989468602d0825fa61",
          "propsChecksum": "628871c841158edd6ce30d44d8b41e0f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "2",
        "index": 359,
        "label": "resetTimer",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[setLibProperty('w42.bot.lastTime'+arg(0), json.get(getInfo(\"client\"),\"timeInMs\"), 'lib:EventMacros')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a91a2a2b-26e7-43fd-a900-af0d50e838eb",
          "commandChecksum": "156795b403f4f16aba1794a72b39af3c",
          "propsChecksum": "ba6e20dca8c2cd1647e2de8700977828"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "13",
        "index": 360,
        "label": "resumeTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_resumeTime([makeup]) ---------------------------------- -->']\n[h:pausedTime\t= getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")]\n[h:time\t\t\t= json.get(getInfo(\"client\"), \"timeInMs\") - pausedTime]\n[h:pauseTime\t= getLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\")]\n[h:stoppedTime\t= max(0,time - pauseTime)]\n[h:pausedTime\t= pausedTime + stoppedTime]\n[h:setLibProperty(\"w42.bot.pausedTime\", pausedTime, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 0, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "57f18bbb-48be-4012-a8d8-ef441f1c2bad",
          "commandChecksum": "c1f119412cb3f20672d8f0a4ffe7bc90",
          "propsChecksum": "d862c86c88ceeb8851d19f412deb228c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "11",
        "index": 361,
        "label": "startTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_startTime ---------------------------------- -->']\n[h:time\t= json.get(getInfo(\"client\"), \"timeInMs\")]\n[h:setLibProperty(\"w42.bot.startTime\", time, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.subTime\", time, \"lib:EventMacros\")]\n<!-- reset pauseTimer -->\n[h:setLibProperty(\"w42.bot.pausedTime\", 0, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.pauseTime\", 0, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 0, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>start the timer<br>to reset just run startTime again",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b34b4aec-5a57-4fc3-ba83-e920517cb8db",
          "commandChecksum": "a1024e696257705e321eccbe5cf6ae3d",
          "propsChecksum": "9d20e3a5a5741494e6319266fb16f4e6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "14",
        "index": 362,
        "label": "subTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_subTime([makeup]) ---------------------------------- -->']\n[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n\n[h:subTime\t\t= getLibProperty(\"w42.bot.subTime\", \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.subTime\", time, \"lib:EventMacros\")]\n[h:resultTime\t= time - subTime]\n[h,if(makeUp): resultTime = bot_formatTime(resultTime)]\n[h:macro.return\t= resultTime]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "12eb4ea6-42e8-4220-8579-89f2dc88b3a4",
          "commandChecksum": "c74ab467f6b55e595d36ed47e14bef74",
          "propsChecksum": "6fb9644962325e39938a898e57c4364e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "",
        "index": 363,
        "label": "timeOut",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------- timeOut() --------------------------------- -->']\n<!-- build in delay to make sure this macro is called only once -->\n[h: lastRun\t\t\t= getLibProperty('w42.bot.lastTime'+arg(0),'lib:EventMacros')]\n[h,if(lastRun == \"\"):lastRun = 0]\n[h: currentTime \t= json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: timeLockDelay\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n<!-- both the upper and lower time range need to be set, cause of the possibility of different timezones and client pcs that have their clock set differently -->\n[h: macro.return\t= if(currentTime < lastRun - timeLockDelay || currentTime > lastRun + timeLockDelay, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "29ed267c-fa7a-4395-aae0-bf3186da7bf2",
          "commandChecksum": "a20f49c6e578c38e2a237a2b88bc3ce8",
          "propsChecksum": "d0cc39cf3b3f2790b65be23cfd809b40"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "15",
        "index": 364,
        "label": "totalTime",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------- bot_totalTime([makeup]) ---------------------------------- -->']\n[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n[h:startTime\t= getLibProperty(\"w42.bot.startTime\", \"lib:EventMacros\")]\n\n[h:resultTime\t= time - startTime]\n[h,if(makeUp): resultTime = bot_formatTime(resultTime)]\n[h:macro.return\t= resultTime]",
        "maxWidth": "",
        "tooltip": "<html>Total amount of time passed since the timer was started<br>pass 1 as parameter to get formatted time<br>note that totaltime does NOT reset the timer",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7b97585a-b3b5-466e-92ab-f90c9bc9917a",
          "commandChecksum": "ddca7bad8be6cd3a2669620a98ac5d88",
          "propsChecksum": "c7fe3adf4af7cdedb0ee6c3abb8d980f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "d. Nildiks Frames",
        "includeLabel": false,
        "sortBy": "",
        "index": 365,
        "label": "frameClose",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- frameClose by Nildik ----------------------------------------------------- -->']\n[h: numArgs\t= argCount()]\n[h, if(numArgs>0):\tframeNr\t= arg(0); frameNr\t= 1]\n[h, count(4):\t\tset(  \"frame\"+(roll.count + 5) , tableImage(\"frames\",frameNr * 10 + roll.count + 6)  )]\n\n[h:macro.return\t= \"\n\t\t\t<\/td>\n\t\t\t<td style='background-image: url(\" + frame5 + \"); background-repeat: repeat; font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t\t<tr>\n\t\t\t<td \" + table(\"frames\", frameNr*10+7) + \" background=\" + frame6 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td  background=\" + frame7 + if(frameNr==0,\" style='padding-bottom: 10px; font-size:1px''>\n\t\t\t\t<input type='text' size=30>\n\t\t\t<\/td>\", \" style='font-size:1px'><\/td>\") + \"\n\t\t\t<td background=\" + frame8 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/table>\n\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b4b3f8fc-01fc-4885-9c9a-9ab89054cc3e",
          "commandChecksum": "f7b0e9ce778f79b50f83167e6557733f",
          "propsChecksum": "13199a8a7ac14b7dade35372e0376c0b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "d. Nildiks Frames",
        "includeLabel": false,
        "sortBy": "",
        "index": 366,
        "label": "frameOpen",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- frameOpen by Nildik (frameNr, Title, titletitleColor) ----------------------------------------------------- -->']\n\n[h:numArgs\t= argCount()]\n[h,if(numArgs > 0):\tframeNr\t\t= arg(0) ; frameNr\t\t= 1] \n[h,if(numArgs > 1):\ttitle\t\t= arg(1) ; title\t\t= \"\"] \n[h,if(numArgs > 2):\ttitleColor\t= arg(2) ; titleColor\t= \"black\"]\n[h,count(5):\t\tset(  \"frame\"+roll.count , tableImage(\"frames\",frameNr * 10 + roll.count + 1)  )]\n\n<!-- frames for which title do NOT work: 0,2,3,4,5,6,7,8,14,15,16 -->\n[h:noTitleList\t= \"0,2,3,4,5,6,7,8,14,15,16\"]\n[h:noTitle\t\t= listContains(noTitleList, frameNr)]\n[h:htmlTitle\t= \"<h3 align=center><font titleColor=\" + titleColor + \">\" + title + \"<\/font><\/H3>\"]\n\n[h:macro.return\t= \"\n\t<table border='0'  cellspacing='0' cellpadding='0'  width='100%'  align='center'>\n\t\t<tr>\n\t\t\t<td \" + table(\"frames\", frameNr*10+1) + \" background=\" + frame0 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td  background = \"+frame1+\" style='font-size:1px'>\n\t\t\t\"+ if(title == \"\" || noTitle, \"\", htmlTitle) +\"<\/td>\n\t\t\t<td  \"+table(\"frames\", frameNr*10+3)+\" background=\" + frame2 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t\t<tr>\n\t\t\t<td background=\" + frame3 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td background=\" + frame4 + \">\" +\n\t\t\tif(title != \"\" && noTitle, htmlTitle,\"\")\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "403e297b-8505-4eec-887b-63670ec3b074",
          "commandChecksum": "014d6fcd9cf25693e75c82bd9d0ac83c",
          "propsChecksum": "e516957ae172664b1aa337089c845fe6"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "d. Nildiks Frames",
        "includeLabel": false,
        "sortBy": "0",
        "index": 367,
        "label": "frameOverview",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[frame(\"Nildiks Frames\", \"width=600; height=800\"): {\n\t<html><head><title>Whisper<\/title><\/head><body>\n\n\n\t[h:nFrame = 0]\n\t\n\t[r,count(14), code:{\n\t\t[R: bot_frameOpen(nFrame)]\n\t\t<table cellpadding='10' width='100%' border='0'>\n\t\t\t<tr><td>\n\t\t\t<font color=\"white\">this is frame number: [r:nFrame]<\/font.\n\t\t\t\n\t\t\n\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t\t[R:bot_frameClose(nFrame)]\n\t\t[h:nFrame = nFrame+1]\n\t}]\n\t<\/body><\/html>\n}]\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8c63ca4b-897e-47b1-935c-4b3e00905645",
          "commandChecksum": "d5b395b69949bfc2b34bd8a1a3485d1f",
          "propsChecksum": "538542689d7dfa1e8cb70169eff77b18"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "purple",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "10",
        "index": 368,
        "label": "getCircleCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------- bot_getCircleCoords(me, range, drawToken) -------------------------------------- -->']\n<!--\t- from the range of 10 and larger, only the outside of the circle is drawn (faster)\n\t\t- drawToken==\"\": returns coordinates of the circle and does NOT draw it when\n\t\t- drawToken!=\"\":  returns the ids of the copied tokens and DOES draw it. \n\t\t- drawToken MUST be present on the BASE map\n-->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[drawToken\t= arg(2)]\n\n<!-- initiate variables -->\n[h:libCoords\t= \"lib:EventMacros\"]\n[h:updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n[H:tX\t\t\t= getTokenX(0, me)]\n[H:tY\t\t\t= getTokenY(0, me)]\n[draw\t\t\t= if(drawToken == \"\", 0, 1)]\n\n<!-- upto and including th range of 10 will be filled with blast tokens. Beyond that, only the border is shown (unless draw is false) -->\n[h:fullFillRange= if(draw, 1000, 10)]\n\n[h:XCoords\t\t= getLibProperty(\"circleXrange\"+range, libCoords)]\n\n[h,if(  json.type(XCoords) != \"ARRAY\" ), CODE:{\n\t[XCoords\t= \"[]\"]\n\t[YCoords\t= \"[]\"]\n\t<!-- calculate the x and y coords IF not already store on the lib -->\n\n\t[h,for(i,-range, range+1, 1), CODE:{\n\t\t[x\t= abs(i)]\n\t\t[for(j,-range, range+1, 1), CODE:{\n\t\t\t[y\t\t= abs(j)]\n\t\t\t[step\t= (x+y) - ceil( min(x,y) /2)]\n\t\t\t[if(step <= range && range <= fullFillRange), CODE:{\n\t\t\t\t[XCoords\t= json.append(XCoords, i)]\n\t\t\t\t[YCoords\t= json.append(YCoords, j)]\n\t\t\t\t''\n\t\t\t};{\n\t\t\t\t[if(step == range && range > fullFillRange), CODE:{\n\t\t\t\t\t[XCoords\t= json.append(XCoords, i)]\n\t\t\t\t\t[YCoords\t= json.append(YCoords, j)]\n\t\t\t\t''\n\t\t\t\t};{}]\n\t\t\t''\n\t\t\t}]\n\t\t''\n\t\t}]\n\t''\n\t}] \n\t<!-- store the x and y coordinates seperately -->\n\t[setLibProperty(\"circleXrange\"+range, XCoords, libCoords)]\n\t[setLibProperty(\"circleYrange\"+range, YCoords, libCoords)]\n''\n};{\n\t[YCoords\t= getLibProperty(\"circleYrange\"+range, libCoords)]\n''\n}]\n\n<!-- special case range = 0 -->\n[h,if(!range), CODE:{\n\t[XCoords\t= \"[0]\"]\n\t[YCoords\t= \"[0]\"]\n};{}]\n\n[h:i\t\t= 0]\n[h, if(draw), CODE:{\n\t<!-- copy the blast tokens onto the map, return the ids of the copies -->\n\t[copies\t= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, \"x\", \"[r:tX + json.get(XCoords,i)]\", \"y\", \"[r:tY + json.get(YCoords,i)][h:i=i+1]\")))]\n\t[macro.return\t= copies]\n};{\n\t<!-- return the coords -->\n\t[coords\t\t= \"[]\"]\n\t[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set(\"{}\",\"x\",tX+json.get(XCoords, i) ,\"y\",tY+json.get(YCoords, i) )  )]\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4dcc1472-8754-4c6a-afa5-f09cf46e0738",
          "commandChecksum": "bb1237afc3710de709851b0ee56f6022",
          "propsChecksum": "689f72858d6331ecb0a28f2ddd7d835b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "20",
        "index": 369,
        "label": "getConeCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_getConeCoords (me, x1,y1, x2,y2) -->\n<!-- returns an array with all coords of the cone-->\n\n[me\t\t\t= arg(0)]\n[x1\t\t\t= arg(1)]\n[y1\t\t\t= arg(2)]\n[x2\t\t\t= arg(3)]\n[y2\t\t\t= arg(4)]\n\n[xc\t\t\t= getTokenX(0,me)]\n[yc\t\t\t= getTokenY(0,me)]\n\n<!-- check if p2 is clockwise from p1, if not then swap them -->\n[if(!bot_isClockWise (xc,yc,x1,y1,x2,y2)), CODE:{\n\t[xt\t= x1]\n\t[yt\t= y1]\n\t[x1\t= x2]\n\t[y1\t= y2]\n\t[x2\t= xt]\n\t[y2\t= yt]\n}]\n\n[centre\t\t\t= json.set(\"{}\",\"x\",xc,\"y\",yc)]\n[checked\t\t= json.append(\"[]\",centre)]\n[coneCoords\t\t= checked]\n[oldConeCoords\t= coneCoords]\n[toCheck\t\t= bot_getNeighbourXY(centre)]\n[stop\t\t\t= 0]\n\n<!-- create array of line points -->\n[lineCoords\t\t= bot_getLineCoords (xc, yc, x1, y1)]\n[lineCoords\t\t= json.union(lineCoords, bot_getLineCoords (xc, yc, x2, y2))]\n\n[bot_startTime()]\n\n[while(!stop), CODE:{\n\t<!-- check all neighbouring coords whether they are on or outside the cone -->\n\t<!-- dont use bot_pointOnCone as it includes a lengthy line check, do the linecheck here -->\n\t[foreach(coord, toCheck), CODE:{\n\t\t[onCone\t= json.contains(lineCoords, coord) + bot_pointInCone(json.get(coord, \"x\"), json.get(coord, \"y\"), me, x1,y1,  x2,y2)]\n\t\t[if(onCone): coneCoords = json.append(coneCoords, coord)]\n\t}]\n\t[checked\t\t= json.union(checked, toCheck)]\n\n\t<!-- build a new toCheckArray of all neighbouring coords around the coords that are part of the cone -->\n\t<!-- optimize by removing already checked coords from coneCoords -->\n\t[newCoords\t\t= json.difference(coneCoords, oldConeCoords)]\n\t[toCheck\t\t= \"[]\"]\n\t[foreach(coord, coneCoords), CODE:{\n\t\t[newCoords\t= bot_getNeighbourXY(coord)]\n\t\t[toCheck\t= json.union(toCheck, newCoords)]\n\t}]\n\t\n\t<!-- remove all coords already checked -->\n\t[toCheck\t\t= json.difference(json.unique(toCheck), checked)]\n\t[oldConeCoords\t= coneCoords]\n\t[if(json.isEmpty(toCheck)): stop=1]\n}]\n[broadcast(\"Process took: \"+bot_totalTime(1))]\n[h:macro.return\t= coneCoords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "831240c7-d398-4fea-9574-7ab3ac0e93cb",
          "commandChecksum": "961e93392a1902904e1410297936aa56",
          "propsChecksum": "dc0599b810b75c8a2fa0425be1fae8ce"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "40",
        "index": 370,
        "label": "getLineCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_getLineCoords (x0, y01, x1, y1 ,relative)-->\n[x0\t\t= arg(0)]\n[y0\t\t= arg(1)]\n[x1\t\t= arg(2)]\n[y1\t\t= arg(3)]\n<!-- return coordinates relative to first coordinate -->\n[if(argCount() > 4):\trel\t= arg(4) ; rel = 0]\n\n[dx\t\t= abs(x1-x0)]\n[dy\t\t= abs(y1-y0)]\n[sx\t\t= if(x0 < x1, 1, -1)]\n[sy\t\t= if(y0 < y1, 1, -1)]\n[err\t= dx - dy]\n[relX\t= rel*x0]\n[relY\t= rel*y0]\n\n[stop\t= 0]\n[coords\t= \"[]\"]\n\n[while (!stop), CODE:{\n\t[coord\t= json.set(\"{}\",\"x\",x0-relX,\"y\",y0-relY))]\n\t[coords\t= json.append(coords,coord)]\n\n\t[if(x0 == x1 && y0 == y1): stop = 1]\n\t[e2\t= 2 * err]\n\n\t[if(e2 > -dy), CODE:{\n\t\t[err\t= err - dy]\n\t\t[x0\t\t= x0 + sx]\n\t};{}]\n\n\t[if(e2 < dx), CODE:{\n\t\t[err\t= err + dx]\n\t\t[y0\t\t= y0 + sy ]\n\t};{}]\n}]\n\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "069e5ca6-261b-42b3-9426-d808714a4504",
          "commandChecksum": "8bb20ba50ac4749c9c1c002571ec0f27",
          "propsChecksum": "fad0f0aba4e31b12b276ef4d7929c770"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "30",
        "index": 371,
        "label": "getSquareCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_getSquareCoords (x1, y1, x2, y2)-->\n[x1\t\t= arg(0)]\n[y1\t\t= arg(1)]\n[x2\t\t= arg(2)+1]\n[y2\t\t= arg(3)+1]\n\n[coords\t= \"[]\"]\n\n[for(x,x1,x2),CODE:{\n\t[for(y,y1,y2): coords\t= json.append(coords, json.set(\"{}\",\"x\",x,\"y\",y)  )]\n}]\n\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "08acac55-98e1-4486-ac7d-25c2c92e5a2d",
          "commandChecksum": "0b06f3271b911d378a1ac406d76daaf9",
          "propsChecksum": "69079c2ca4364c66dd2670ec573d2e48"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "50",
        "index": 372,
        "label": "getTriangleCoords",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_getTriangleCoords (x1,y1, x2,y2, x3,y3,relative) -->\n[x1\t= arg(0)]\n[y1\t= arg(1)]\n[x2\t= arg(2)]\n[y2\t= arg(3)]\n[x3\t= arg(4)]\n[y3\t= arg(5)]\n[rel\t= arg(6)]\n\n[xMin\t= min(x1,x2,x3)]\n[yMin\t= min(y1,y2,y3)]\n[xMax\t= max(x1,x2,x3)]\n[yMax\t= max(y1,y2,y3)]\n\n[coords\t= \"[]\"]\n\n[for(x,xMin,xMax), CODE:{\n\t[for(y,yMin,yMax), CODE:{\n\t\t[if(bot_pointInTriangle(x,y,x1,y1,x2,y2,x3,y3,0)): coords\t= json.append(coords,json.set(\"{}\",\"x\",x,\"y\",y))]\n\t}]\n}]\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b50beb35-3c1c-4f1d-93f5-506fee74f142",
          "commandChecksum": "f0b551138d207a4e708f154b15fab75b",
          "propsChecksum": "23bcdaf78f6260f09a54d891d7162879"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "20",
        "index": 373,
        "label": "pointInCone",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_pointInCone (xp,yp, me, x1,y1, x2,y2) -->\n<!-- checks if a point (p) is between three points (centre, 1 and 2) on a SPHERE, does NOT include boundary -->\n<!-- always make sure that p2 is clockwise from p1 !! -->\n\n<!-- isClockWise (xcentr,ycentr,x1,y1,x2,y2) -->\n[h:macro.return\t= if(\n\tbot_isClockWise\t\t(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(3),arg(4),  arg(0),arg(1)) && \n\t!bot_isClockWise\t(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(5),arg(6),  arg(0),arg(1)) && \n\tif(getDistanceToXY(arg(0),arg(1),0,arg(2)) <= getDistanceToXY(arg(3),arg(4),0,arg(2)),1,0), \n\t1, 0\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6a9c0fef-483a-413c-abac-e98e54139510",
          "commandChecksum": "ed5f095659e9c0f3a415c43941ea01b2",
          "propsChecksum": "e679d7c2191c1cbdfa73473a0da830d9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "50",
        "index": 374,
        "label": "pointInTriangle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_pointInTriangle (xp,yp, x1,y1, x2,y2, x3,y3):boolean -->\n<!-- checks if a point is between three points, does not include boundary, a line check is needed for that -->\n[h:b2\t= if( (arg(0) - arg(6)) * (arg(5) - arg(7)) -  (arg(4) - arg(6)) * (arg(1) - arg(7)) < 0, 1,0)]\n[macro.return = if(if( (arg(0) - arg(4)) * (arg(3) - arg(5)) -  (arg(2) - arg(4)) * (arg(1) - arg(5)) < 0, 1,0) == b2 && b2 == if( (arg(0) - arg(2)) * (arg(7) - arg(3)) -  (arg(6) - arg(2)) * (arg(1) - arg(3)) < 0, 1,0),1,0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "541ac6d7-2160-4d10-a2de-ef4c9b9389e3",
          "commandChecksum": "b968d3fcf75120e576da118c437bd4ea",
          "propsChecksum": "550b13a2154bec8059681b3a12441b27"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "10",
        "index": 375,
        "label": "pointOnCircle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tbot_pointOnCircle (xp,yp, me, range) \n\t\tOR\n\t\tbot_pointOnCircle (tok, me, range) -->\n<!-- checks if a point (p) or token (tok) is on a circle centered on me with range r, DOES include boundary -->\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnCircle, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[point\t\t= json.set(\"{}\",\"x\",xp,\"y\",yp)]\n<!-- bot_getCircleCoords(me, range, draw)  -->\n[circle\t\t= bot_getCircleCoords (me, range, \"\")]\n[h:macro.return\t= json.contains(circle, point)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "96408125-af37-4e39-bb0f-29f1bcbf847a",
          "commandChecksum": "f4cba48ff3f17a004cb07a818c9b81a2",
          "propsChecksum": "99b60b2babe2e1cd73d5ced06d77db81"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "20",
        "index": 376,
        "label": "pointOnCone",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tbot_pointOnCone (xp,yp, me, range, arc=angle) \n\t\tOR\n\t\tbot_pointOnCone (tok, me, range, arc=angle) \n-->\n<!-- checks if a point is on a cone, DOES include boundary -->\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[arc\t= arg(3)/2]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t<!-- retrieve the gridcoords where the triangle corners end -->\n\t\t<!-- get both angles in radians -->\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 5:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[arc\t= arg(4)/2]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t<!-- retrieve the gridcoords where the triangle corners end -->\n\t\t<!-- get both angles in radians -->\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnCone, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:p1\t\t= bot_pointOnLine\t(xp,yp,  x1,y1,  x2,y2)]\n[h:p2\t\t= bot_pointOnLine\t(xp,yp,  x1,y1,  x3,y3)]\n[h:p3\t\t= bot_pointInCone\t(xp,yp,  me,  x2,y2,  x3,y3)]\n\n[h:macro.return\t= if(p1 || p2 || p3, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aa06f281-75af-40ae-92ba-127fa7d78027",
          "commandChecksum": "8717ec0d3554433b816de5bcac0f949a",
          "propsChecksum": "76750cf1a8591ccad9de180038bc00ef"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "40",
        "index": 377,
        "label": "pointOnLine",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tbot_pointOnLine (xp,yp, x1,y1, x2,y2) \n\t\tOR\n\t\tbot_pointOnLine (xp,yp, me, range) \n\t\tOR\n\t\tpointOnLine (tok, me, range) (use facing) -->\n<!-- checks if a point (p) or token (tok) is on a line between 2 points (1 and 2) or on a line casted from me, DOES include boundary -->\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 6:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[x1\t\t= arg(2)]\n\t\t[y1\t\t= arg(3)]\n\t\t[x2\t\t= arg(4)]\n\t\t[y2\t\t= arg(5)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnLine, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[point\t\t= json.set(\"{}\",\"x\",xp,\"y\",yp)]\n<!-- bot_getLineCoords (x0, y01, x1, y1)-->\n[line\t\t= bot_getLineCoords (x1, y1, x2, y2)]\n\n[h:macro.return\t= json.contains(line, point)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f76a4677-70e4-4f96-bb77-8e938fa17833",
          "commandChecksum": "4c437989096e06a613e8a0914d69216c",
          "propsChecksum": "bbf57102ef12026915d0b17583a0a04a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "30",
        "index": 378,
        "label": "pointOnSquare",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tbot_pointOnSquare (xp,yp, me, range) \n\t\tOR\n\t\tbot_pointOnSquare (tok, me, range) \n-->\n<!-- checks if a point (p) is within range of me, assuming a square area with range (me, edge square) -->\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnSquare, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[xc\t\t= getTokenX(0, me)]\n[yc\t\t= getTokenY(0, me)]\n[x1\t\t= xc - range]\n[y1\t\t= yc - range]\n[x2\t\t= xc + range]\n[y2\t\t= yc + range]\n\n[h:macro.return\t= if(\n\txp >= x1 &&\n\typ >= y1 &&\n\txp <= x2 &&\n\typ <= y2, \n\t1, 0\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "737557dc-60bf-4cbd-a7bd-96fcf5101e87",
          "commandChecksum": "3bc0d40eced034f25477f27fc8879be1",
          "propsChecksum": "98630ddf274626b2b72e5db3d629ba7d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "50",
        "index": 379,
        "label": "pointOnTriangle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tbot_pointOnTriangle (xp,yp, x1,y1, x2,y2, x3,y3) \n\t\tOR\n\t\tbot_pointOnTriangle (xp,yp, me, range, arc=angle) \n\t\tOR\n\t\tbot_pointOnTriangle (tok, me, range, arc=angle) \n-->\n<!-- checks if a point is between three points, DOES include boundary -->\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[arc\t= arg(3)/2]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t<!-- retrieve the gridcoords where the triangle corners end -->\n\t\t<!-- get both angles in radians -->\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 5:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[arc\t= arg(4)/2]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t<!-- retrieve the gridcoords where the triangle corners end -->\n\t\t<!-- get both angles in radians -->\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 8:{\n\t\t[xp\t\t\t= arg(0)]\n\t\t[yp\t\t\t= arg(1)]\n\t\t[x1\t\t\t= arg(2)]\n\t\t[y1\t\t\t= arg(3)]\n\t\t[x2\t\t\t= arg(4)]\n\t\t[y2\t\t\t= arg(5)]\n\t\t[x3\t\t\t= arg(6)]\n\t\t[y3\t\t\t= arg(7)]\t\n\t};\n\tdefault:{\n\t\t[assert(0,\"Error in bot_pointOnTriangle, wrong amount of arguments: \"+argCount(),0)]\n\t}\n]\n\n[h:p1\t\t= bot_pointOnLine\t\t(xp,yp,  x1,y1,  x2,y2)]\n[h:p2\t\t= bot_pointOnLine\t\t(xp,yp,  x1,y1,  x3,y3)]\n[h:p3\t\t= bot_pointOnLine\t\t(xp,yp,  x3,y3,  x2,y2)]\n[h:p4\t\t= bot_pointInTriangle\t(xp,yp,  x1,y1,  x2,y2,  x3,y3)]\n\n[h:macro.return\t= if(p1 || p2 || p3 || p4, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "29f7ab7c-587d-42c5-8d93-55299691c807",
          "commandChecksum": "b2fd502379b39a80451b515218a4c5a7",
          "propsChecksum": "5f7e525067d3ac2f3bcc23a317940a9a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "10",
        "index": 380,
        "label": "selectOnCircle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnCircle (me, range) -->\n<!-- selects all tokens inside of the shape -->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[toks\t\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "876e7b3c-b330-499c-acb3-0bf95a74a802",
          "commandChecksum": "90bc3e753bedd101112830f6f33994f0",
          "propsChecksum": "58e7dc31dfc67cbe03d463419ab96016"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "20",
        "index": 381,
        "label": "selectOnCone",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnCone (me, range, arc=angle) -->\n<!-- selects all tokens inside of the shape -->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)]\n[toks\t\t= \"\"]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n<!-- bot_pointOnCone (tok, me, range, arc=angle) -->\n[foreach(tok, allToks), if(bot_pointOnCone(tok, me, range, arc)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5a385711-27d0-438d-8193-35d9bf5c686b",
          "commandChecksum": "079d605c3c4e76a41f7b7a6442d54aa4",
          "propsChecksum": "597f0963a9ca7f3fc3ac3f52f84bf1c8"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "40",
        "index": 382,
        "label": "selectOnLine",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnLine (me, range, sort)(use tokenfacing) -->\n<!-- OR selectOnLine (me, x2,y2, sort) -->\n<!-- selects all tokens inside of the shape -->\n\n[h:assert(argCount() > 2, \"ERROR in selectOnline: wrong number of arguments. Either pass: me,range,sort(=1/0) or me, x2,y2,sort\", 0)]\n\n[if(argCount() == 3), CODE:{\n\t[me\t\t\t= arg(0)]\n\t[range\t\t= arg(1)]\n\t[sort\t\t= arg(2)]\n\t\n\t[x1\t\t\t= getTokenX(0, me)]\n\t[y1\t\t\t= getTokenY(0, me)]\n\t[angle\t\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t[x2\t\t\t= x1 + round(range*bot_cos(angle),0)]\n\t[y2\t\t\t= y1 + round(range*bot_sin(angle),0)]\n};{\n\t[me\t\t\t= arg(0)]\n\t[x1\t\t\t= getTokenX(0, me)]\n\t[y1\t\t\t= getTokenY(0, me)]\n\t[x2\t\t\t= arg(1)]\n\t[y2\t\t\t= arg(2)]\n\t[sort\t\t= arg(3)]\n}]\n\n[area\t\t= bot_getLineCoords (x1, y1, x2, y2, 1)]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"area\", json.set(\"{}\", \"token\", me, \"offsets\", area)  )  )]\n\n[if(sort), CODE:{\n\t[tmpArray\t= \"[]\"]\n\t[foreach(tok, allToks): tmpArray\t= json.append(tmpArray,json.set(\"{}\", \"tok\", tok, \"distance\", getDistance(me,0,tok)))]\n\t[tmpArray\t= json.sort(tmpArray,'a','distance')]\n\t[allToks\t= \"\"]\n\t[foreach(obj, tmpArray): allToks\t= listAppend(allToks, json.get(obj, \"tok\"))]\n};{}]\n\n[selectTokens(allToks, 0, \",\")]\n[macro.return\t= allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5a4653aa-aa86-4a2c-b726-3fb1d6204120",
          "commandChecksum": "9c3363e52c04c76e67a9033d329efc05",
          "propsChecksum": "6f69fcc88cf234e072569a3523705625"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "30",
        "index": 383,
        "label": "selectOnSquare",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnSquare (me, range) -->\n<!-- selects all tokens inside of the shape -->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[toks\t\t= \"\"]\n\n<!-- the formula for range makes sure that the corners of the square are taken into account as well. -->\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", ceil(sqrt(2*range*range)+range/10) ))  )]\n<!-- bot_pointOnCone (tok, me, range, arc=angle) -->\n[foreach(tok, allToks), if(bot_pointOnSquare(tok, me, range)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "55e42a68-86f1-4a62-87ed-98845140b927",
          "commandChecksum": "c80da99206e2ed8b1a505810b1e1b291",
          "propsChecksum": "eed60d17e8f2e1eda292450810486ffa"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "50",
        "index": 384,
        "label": "selectOnTriangle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnTriangle (me, range) -->\n<!-- selects all tokens inside of the shape -->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)]\n[toks\t\t= \"\"]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n<!-- bot_pointOnTriangle (tok, me, range, arc=angle) -->\n[foreach(tok, allToks), if(bot_pointOnTriangle(tok, me, range, arc)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ecf0c9fd-e1d5-438c-82b2-95893f5523d3",
          "commandChecksum": "15c319a19fa47893f0880ea853a83d50",
          "propsChecksum": "c5a44c3e4d34fa658a2de441cff96adf"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "99",
        "index": 385,
        "label": "selectOnTriangle NEW (but not correct",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- selectOnTriangle (me, range,arc) -->\n<!-- selects all tokens inside of the shape -->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)/2]\n\n[angle\t= bot_getTokenFacing(me,2)]\n\n<!-- retrieve the gridcoords where the triangle corners end -->\n<!-- get both angles in radians -->\n[arc1\t\t= (angle - arc)*bot_pi()/180]\n[arc2\t\t= (angle + arc)*bot_pi()/180]\n<!-- get grid coords -->\n[x2\t\t\t= round(range*bot_cos(arc1),0)]\n[y2\t\t\t= round(range*bot_sin(arc1),0)]\n[x3\t\t\t= round(range*bot_cos(arc2),0)]\n[y3\t\t\t= round(range*bot_sin(arc2),0)]\n[area\t\t= bot_getTriangleCoords (0,0,x2,y2,x3,y3)]\n[pause(\"x2\",\"y2\",\"x3\",\"y3\",\"arc1\",\"arc2\",\"area\")]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"area\", json.set(\"{}\", \"token\", me, \"offsets\", area)  )  )]\n[selectTokens(allToks, 0, \",\")]\n[macro.return\t= allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9133d712-fe56-414c-845a-e1460c4d3ccb",
          "commandChecksum": "feb5d490f5345ca66e2ffd4f1ba65760",
          "propsChecksum": "26ca0cee6e6ee0f53cebbe7f6250173d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "10",
        "index": 386,
        "label": "showCircle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tshowCircle (me, range, arc=angle, drawToken) -->\n\n<!-- this is a completely redundant functions as everything is done by bot_getCircleCoords, but for function name consistancy this is added. -->\n<!-- returns coordinates of the circle and does NOT draw it when drawToken==\"\" ;  returns the ids of the copied tokens and DOES draw it, when drawToken !=\"\" -->\n\n[macro.return = bot_getCircleCoords(arg(0), arg(1), arg(2))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "20ce4264-c18d-4182-95db-3a631cd53f1b",
          "commandChecksum": "5107015db19f1b01e0b79e0c2ed5db82",
          "propsChecksum": "0133aba10ba0f7a57a72b9f09feb96b3"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "20",
        "index": 387,
        "label": "showCone",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- showCone (tok, range, arc=angle, drawToken) -->\n<!-- returns an array with all coords of the cone-->\n<!-- draws the cone on grid if option set true-->\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)/2]\n[drawToken\t= arg(3)]\n\n[x1\t\t\t= getTokenX(0, me)]\n[y1\t\t\t= getTokenY(0, me)]\n[angle\t\t= bot_getTokenFacing(me,2)]\n[libCoords\t= \"lib:EventMacros\"]\n\n<!-- retrieve the gridcoords where the cone corners end. -->\n<!-- get both angles in radians -->\n[arc1\t\t= (angle - arc)*bot_pi()/180]\n[arc2\t\t= (angle + arc)*bot_pi()/180]\n<!-- get grid coords -->\n[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\n[XCoords\t= getLibProperty(\"coneXrange_\"+range+\"_\"+angle+\"_\"+arc, libCoords)]\n\n[if(  json.type(XCoords) != \"ARRAY\" ), CODE:{\n\t<!-- that cone does not yet exist, so create it -->\n\t[coords\t\t\t= bot_getConeCoords(me,  x2,y2,  x3,y3)]\n\t[XCoords\t\t= \"[]\"]\n\t[YCoords\t\t= \"[]\"]\n\t\n\t[foreach(coord, coords), CODE:{\n\t\t<!-- create a set of x and y at the origin point for future use -->\n\t\t[XCoords\t= json.append(XCoords, json.get(coord, \"x\") - x1)]\n\t\t[YCoords\t= json.append(YCoords, json.get(coord, \"y\") - y1)]\n\t}]\n\t\n\t[setLibProperty(\"coneXrange_\"+range+\"_\"+angle+\"_\"+arc, XCoords, libCoords)]\n\t[setLibProperty(\"coneYrange_\"+range+\"_\"+angle+\"_\"+arc, YCoords, libCoords)]\n};{\n\t<!-- that cone does exist, so get Y as well -->\n\t[YCoords\t\t= getLibProperty(\"coneYrange_\"+range+\"_\"+angle+\"_\"+arc, libCoords)]\n}]\n\n[h, if(drawToken != \"\"), CODE:{\n\t<!-- copy the blast tokens onto the map, return the ids of the copies -->\n\t[copies\t\t\t= \"[]\"]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[copies\t\t\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, \"x\", \"[r:x1 + json.get(XCoords,i)]\", \"y\", \"[r:y1 + json.get(YCoords,i)][h:i=i+1]\")))]\n\t[broadcast(copies)]\n\t[macro.return\t= copies]\n};{\n\t<!-- return the coords -->\n\t[coords\t\t\t= \"[]\"]\n\t[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set(\"{}\",\"x\",x1+json.get(XCoords, i) ,\"y\", y1+json.get(YCoords, i) )  )]\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fc307cf2-3f74-4926-91c5-d6387a2a2640",
          "commandChecksum": "f3caac004d0fdb178a8c21c714140cbe",
          "propsChecksum": "74a258f85ad8756938f34bb1b3d9ed95"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "40",
        "index": 388,
        "label": "showLine",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tshowLine (x1,y1, x2,y2, drawToken) \n\t\tshowLine (me, range, drawToken) \n-->\n<!-- returns an array with all coords of the line-->\n<!-- draws the line on grid (if option set true)-->\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[me\t\t\t= arg(0)]\n\t\t[range\t\t= arg(1)]\n\t\t[drawToken\t= arg(2)]\n\n\t\t[x1\t\t\t= getTokenX(0, me)]\n\t\t[y1\t\t\t= getTokenY(0, me)]\n\n\t\t[angle\t\t= bot_getTokenFacing(me,2)]\n\t\t<!-- retrieve the gridcoords where the cone corners end. -->\n\t\t<!-- get angle in radians -->\n\t\t[arc\t\t= angle*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc),0)]\n\t};\n\tcase 5:{\n\t\t[x1\t\t\t= arg(0)]\n\t\t[y1\t\t\t= arg(1)]\n\t\t[x2\t\t\t= arg(2)]\n\t\t[y2\t\t\t= arg(3)]\n\t\t[drawToken\t= arg(4)]\n\t};\n\tdefault:{[assert(0,\"Error in showLine, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= bot_getLineCoords(x1,y1,  x2,y2)]\n\n[h, if(drawToken != \"\"), CODE:{\n\t<!-- copy the blast tokens onto the map, return the ids of the copies -->\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t<!-- return the coords -->\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "80ab0a70-de9f-4d5f-8acc-a08a725cd2e3",
          "commandChecksum": "93f3e20105aed101941ba88f49ecb164",
          "propsChecksum": "1cf35a3566abf996a6c043a55d6d9f69"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "30",
        "index": 389,
        "label": "showSquare",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tshowSquare (me, range, drawToken) \n\t\tOR\n\t\tshowSquare (x1,y1, x2,y2, drawToken) \n\t-->\n<!-- returns an array with all coords of the square-->\n<!-- draws the square on grid (if option set true)-->\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[me\t\t= arg(0)]\n\t\t[range\t= arg(1)]\n\t\t[drawToken\t= arg(2)]\n\n\t\t[xc\t\t= getTokenX(0, me)]\n\t\t[yc\t\t= getTokenY(0, me)]\n\n\t\t[x1\t\t= xc - range]\n\t\t[y1\t\t= yc - range]\n\t\t[x2\t\t= xc + range]\n\t\t[y2\t\t= yc + range]\n\t};\n\tcase 5:{\n\t\t[x1\t\t= arg(0)]\n\t\t[y1\t\t= arg(1)]\n\t\t[x2\t\t= arg(2)]\n\t\t[y2\t\t= arg(3)]\n\t\t[drawToken\t= arg(4)]\n\t};\n\tdefault:{[assert(0,\"Error in showSquare, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= bot_getSquareCoords(x1,y1,  x2,y2)]\n\n[h, if(drawToken != \"\"), CODE:{\n\t<!-- copy the blast tokens onto the map, return the ids of the copies -->\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t<!-- return the coords -->\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e1150c5a-45f7-4bdb-8cec-8b13c08ea1b9",
          "commandChecksum": "c783917afad837cbc909c902ee183dcb",
          "propsChecksum": "47435bc0c6c06e708d1b6cea69b840d1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "12. GeoFunctions",
        "includeLabel": false,
        "sortBy": "50",
        "index": 390,
        "label": "showTriangle",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\tshowTriangle (x1,y1, x2,y2, x3,y3, drawToken) \n\t\tOR\n\t\tshowTriangle (me, range, arc=angle, drawToken) \n-->\n<!-- returns coordinates of the triangle and draws it on grid if options set true -->\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[me\t\t= arg(0)]\n\t\t[range\t= arg(1)]\n\t\t[arc\t= arg(2)/2]\n\t\t[drawToken\t= arg(3)]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t\t= bot_getTokenFacing(me,2)]\n\n\t\t<!-- retrieve the gridcoords where the cone corners end. -->\n\t\t<!-- get both angles in radians -->\n\t\t[arc1\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t= (angle + arc)*bot_pi()/180]\n\t\t<!-- get grid coords -->\n\t\t[x2\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(arc1),0)]\n\n\t\t[x3\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 7:{\n\t\t[x1\t\t\t= arg(0)]\n\t\t[y1\t\t\t= arg(1)]\n\t\t[x2\t\t\t= arg(2)]\n\t\t[y2\t\t\t= arg(3)]\n\t\t[x3\t\t\t= arg(4)]\n\t\t[y3\t\t\t= arg(5)]\t\n\t\t[drawToken\t\t= arg(5)]\n\t\t};\n\tdefault:{[assert(0,\"Error in bot_showTriangle, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= json.union(\n\tbot_getTriangleCoords( x1,y1,  x2,y2,  x3,y3 ),\n\tbot_getLineCoords(x1,y1,  x2,y2) ), \n\tbot_getLineCoords(x1,y1,  x3,y3) ),\n\tbot_getLineCoords(x3,y3,  x2,y2) )\n]\n\n[h, if(drawToken != \"\"), CODE:{\n\t<!-- copy the blast tokens onto the map, return the ids of the copies -->\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t<!-- return the coords -->\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "97427797-5bd2-4b1c-93ad-7ce0770417db",
          "commandChecksum": "fc3f51d33278c4d4764a8817bf6ffffb",
          "propsChecksum": "6b463f4b53fbd3f275cca2d61ca2c8fc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12a. Geofunctions - support",
        "includeLabel": false,
        "sortBy": "",
        "index": 391,
        "label": "getNeighbourXY",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- getNeighbourXY (coord) -->\n<!-- returns an array with all neighbouring coords -->\n\n[x\t\t= json.get(arg(0), \"x\")]\n[y\t\t= json.get(arg(0), \"y\")]\n\n[h:macro.return\t= '[\n\t{\"x\":'+(x-1)+',\"y\":'+(y-1)+'},\n\t{\"x\":'+(x  )+',\"y\":'+(y-1)+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y-1)+'},\n\t\n\t{\"x\":'+(x-1)+',\"y\":'+(y  )+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y  )+'},\n\t\n\t{\"x\":'+(x-1)+',\"y\":'+(y+1)+'},\n\t{\"x\":'+(x  )+',\"y\":'+(y+1)+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y+1)+'}\n]']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f1603fb0-038b-4c4a-869a-c06b4a3abd29",
          "commandChecksum": "8e0122a9adb84a63f0cca4860b09a835",
          "propsChecksum": "5a8cc717685f515b23cb4199da41e573"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "15. Summon",
        "includeLabel": false,
        "sortBy": "26",
        "index": 395,
        "label": "getValidTokens",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- -------------------------------- getValidTokens(useCurrentMap) ------------------------------------ -->']\n[H: '<!-- based on Orpheus WoD campaign macro -->']\n\n[h,if(argCount() > 0): useCurrentMap\t= arg(0); useCurrentMap\t= 0]\n[h,if(argCount() > 1): conditions\t\t= arg(1); conditions\t= \"{}\"]\n[h,if(argCount() > 2): use_None\t\t\t= arg(2); use_None\t\t= 1]\n[h,if(argCount() > 3): startsWithTxt\t= lower(arg(3)); startsWithTxt\t= \"\"]\n\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:assert(listContains(getAllMapNames(),baseMapName), \"Uknown map: '\"+baseMapName+\"' Set the correct BASE map value in the settings macro of the Bag of Tricks macro panel\",0)]\n[h,if(use_None): noneImageId = getImage('image:none')]\n[h, if(!useCurrentMap):setCurrentMap(baseMapName)]\n\n[h:pcPropType\t\t= getLibProperty(\"summonPcPropType\",\"lib:EventMacros\")]\n[h:npcPropType\t\t= getLibProperty(\"summonNpcPropType\",\"lib:EventMacros\")]\n[h:propTypesList\t= getLibProperty(\"summonPropTypesList\",\"lib:EventMacros\")]\n[h:specialList\t\t= getLibProperty(\"summonSpecialList\",\"lib:EventMacros\")]\n[h:tokenList \t\t= listSort(getTokenNames(\",\",conditions),\"N\")]\n\n[h,if(startsWithTxt != \"\"), CODE:{\n\t<!-- if startswith string is used, narrow the list to those only -->\n\t[newTokenList\t= \"\"]\n\t[foreach(tok, tokenList): newTokenList = if(startsWith(lower(tok), startsWithTxt), listAppend(newTokenList, tok), newTokenList)]\n\t[tokenList\t\t= newTokenList]\n}; {}]\n\n[h:'<!-- remove non existing tokens from specialList -->']\n[h:tmpList = \"\"]\n[h, foreach(item, specialList), CODE:{\n\t[if(findToken(item) != \"\"), CODE:{\n\t\t[if(getLayer(item) == 'TOKEN'): tmpList = listAppend(tmpList, item)]\n\t}; {}]\n}]\n[h: specialList \t= tmpList]\n\n[h:pcList\t\t\t= \"\"]\n[h:npcList\t\t\t= \"\"]\n[h:charList\t\t\t= \"\"]\n[h:allList\t\t\t= \"\"]\n[h,foreach(propType, propTypesList): set(propType+\"List\",\"\")]\n\n[h:fancyPcList\t\t= \"\"]\n[h:fancyNpcList\t\t= \"\"]\n[h:fancyCharList\t= \"\"]\n[h:fancyAllList\t\t= \"\"]\n[h,foreach(propType, propTypesList): set(\"fancy\"+propType+\"List\",\"\")]\n[h:fancySpecialList\t= \"\"]\n[h:specialNumber\t=0]\n\n[H,FOREACH(tok, tokenList), CODE:{\n\t[pc \t\t\t= if(getPropertyType(tok) == pcPropType && isPC(tok),1 ,0)]\n\t[npc \t\t\t= if(getPropertyType(tok) == npcPropType && isNPC(tok),1 ,0)]\n\t\n\t[isPC = isPC(tok)]\n\t[isNPC = isNPC(tok)]\n\t\n\t[foreach(propType, propTypesList):set(propType, if(getPropertyType(tok) == propType, 1, 0))]\n\t[special\t\t= listContains(specialList,  tok)]\n\n\t[if(pc), CODE:{\n\t\t[pcList\t\t= listAppend(pcList, tok)]\n\t\t[token(tok): fancyPcList = listAppend(fancyPcList, tok + getTokenImage(60))]\n\t\t[charList\t= listAppend(charList, tok)]\n\t\t[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]\n\t}; {}]\n\t[if(npc), CODE:{\n\t\t[npcList\t= listAppend(npcList, tok)]\n\t\t[token(tok): fancyNpcList = listAppend(fancyNpcList, tok + getTokenImage(60))]\n\t\t[charList\t= listAppend(charList, tok)]\n\t\t[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]\n\t}; {}]\n\t[foreach(propType, propTypesList), CODE:{\n\t\t[tmpEval\t= eval(propType)]\t\t\n\t\t[if(tmpEval): set(propType+\"List\", listAppend(eval(propType+\"List\"), tok))]\n\t\t[if(tmpEval), token(tok): set(\"fancy\"+propType+\"List\", listAppend(eval(\"fancy\"+propType+\"List\"), tok + getTokenImage(60)))]\n\t}]\n\t[if(special), CODE:{\n\t\t[token(tok): fancySpecialList = listAppend(fancySpecialList, tok + getTokenImage(60))]\n\t}; {}]\n\t\n\t[allList\t\t= listAppend(allList, tok)]\n\t[token(tok): fancyAllList = listAppend(fancyAllList, tok + getTokenImage(60))]\n\n}]\n\n[h,if(use_None), CODE:{\n\t[pcList\t\t= if(pcList \t!= \"\", listAppend(\"none\", pcList), \"none\")]\n\t[npcList\t= if(npcList\t!= \"\", listAppend(\"none\", npcList), \"none\")]\n\t[charList\t= if(charList\t!= \"\", listAppend(\"none\", charList), \"none\")]\n\t[allList\t= if(allList \t!= \"\", listAppend(\"none\", allList), \"none\")]\n\n\t[if(fancyPcList == \"\"):\t\tfancyPcList\t\t= \"none\" + noneImageId ; fancyPcList\t= listAppend(\"none\" + noneImageId, fancyPcList)]\n\t[if(fancyNpcList == \"\"):\tfancyNpcList\t= \"none\" + noneImageId ; fancyNpcList\t= listAppend(\"none\" + noneImageId, fancyNpcList)]\n\t[if(fancyCharList == \"\"):\tfancyCharList\t= \"none\" + noneImageId ; fancyCharList\t= listAppend(\"none\" + noneImageId, fancyCharList)]\n\t[if(fancyAllList == \"\"):\tfancyAllList\t= \"none\" + noneImageId ; fancyAllList\t= listAppend(\"none\" + noneImageId, fancyAllList)]\n\n\t[foreach(propType, propTypesList), CODE:{\n\t\t[set(propType+\"List\", listAppend(\"none\", eval(propType+\"List\")))]\n\t\t[set(\"fancy\"+propType+\"List\", if(eval(\"fancy\"+propType+\"List\") == \"\", \"none\" + noneImageId , listAppend(\"none\" + noneImageId, eval(\"fancy\"+propType+\"List\"))))]\n\t}]\n\n\t[specialList\t= listAppend(\"none\", specialList)]\n\t[if(fancySpecialList == \"\"): fancySpecialList\t= \"none\" + noneImageId ; fancySpecialList\t= listAppend(\"none\" + noneImageId, fancySpecialList)]\n}; {\n\t[h,foreach(propType, propTypesList), CODE:{\n\t\t[set(propType+\"List\", eval(propType+\"List\"))]\n\t\t[set(\"fancy\"+propType+\"List\", eval(\"fancy\"+propType+\"List\")]\n\t}]\n}]\n\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "beb5002f-ad59-43d7-b7a7-8b490030c548",
          "commandChecksum": "dabe3d6b94b61b26c8d51852796c493b",
          "propsChecksum": "56ab80192f3661f116cc081c90c2ca10"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "teal",
        "group": "15. Summon",
        "includeLabel": false,
        "sortBy": "23",
        "index": 396,
        "label": "embarkation",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------- embarkation ---------------------------->']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'<!----------------- INITIALIZE VALUES ---------------------------->']\n[h:ok\t\t\t= 0]\n<!-- maximum amount of passengers in vehicle -->\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"w42.Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'<!-- create the input for the DDB, select visible tokens upto 10 squares -->']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'<!-- no new scope, so charList and fancyCharlist are defined variables! -->']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'<!-- add any token currently embarked to the (fancy)charList -->']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'<!----------------- USER INPUT ---------------------------->']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'<!-- build the entire input string -->']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'<!-- which should end up something like]\n\t[input(]\n\t\t[Bla bla,]\n\t\t[optional message in case of failed idiot check,]\n\t\t[passenger0|DDB|passenger,]\n\t\t[passenger1) -->']\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h:'<!----------------- END INPUT SECTION  ---------------------------->']\n\n[h:'<!----------------- NUMBERS TO NAMES ---------------------------->']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:'<!-- Move the Tokens, either Embark or De-Embark --> ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[H:nX = \"-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1,\t\t-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1\"]\n[h:ny = \"-1,\t-1,\t-1,\t\t0,\t0,\t\t1,\t1,\t1,\t\t-2,\t-2,\t-2,\t\t0,\t0,\t\t2,\t2,\t2\"]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t['<!-- disEmbark Move to Vehicle --> ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX+listGet(nX, roll.count), meY+listGet(nY, roll.count),0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t['<!-- Embark: Move to VPCU--> ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1+listGet(nX, roll.count),vpcuY+1+listGet(nY, roll.count),0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"w42.Passengers\", newEmbarkedList, me)]\n[h:setProperty(\"w42.embarkToggle\",if(listCount(newEmbarkedList)>0, 1, \"\"), me)]\n\n<!-- 0:message, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:tmpManualRolls, 6:target, 7:broadcast,\t8:altMessage,\t9:altUserList, 10:gmOnly -->\n[h: bot_message(\"Embarkation done\", \"Embarkation done\", \"#063404\", bot_ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "173494e2-41a5-4c38-829a-cffdd70476e0",
          "commandChecksum": "3e34a5f074d3b4bfa11122fd27382689",
          "propsChecksum": "9d6aa1ef17b1013024e9a459f1e29baf"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5. Teleport & Roof",
        "includeLabel": false,
        "sortBy": "2",
        "index": 397,
        "label": "mapTeleport",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- mapTeleport ------------------------------------------------- -->']\n\n\t<!-- define the following vars: tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap -->\n\t<!-- doSwitchInterMap:\n\t\t0: swap to other map\n\t\t1: do not swap to other map\n\t\t2: do not swap to other map AND retrieve xy coords from current pad\n\t -->\n[h:varsFromStrProp(arg(0))]\n[bot_playPadSound(padName, tok)]\t<!-- play sound linked to the pad (if any) -->\n\n[newMap \t\t\t= getProperty(\"w42.bot.pairedMap\", padName)]\n[oldMap \t\t\t= getCurrentMapName()]\n[startCentreX \t\t= getTokenX(0, padName)]\n[startCentreY \t\t= getTokenY(0, padName)]\n[if(doSwitchInterMap ==2), CODE:{\n\t<!-- no map swapping and the coords of the OTHER pad are stored on this pad. So no map change required -->\n\t<!-- note that gridsizes can differ over maps so you need to keep that in mind!! -->\n\t[endCentreX \t= getProperty(\"w42.bot.otherPadX\", padName)]\n\t[endCentreY \t= getProperty(\"w42.bot.otherPadY\", padName)]\n\t[endGridSize\t= getProperty(\"w42.bot.otherPadG\", padName)]\n\t[w2\t\t\t\t= getProperty(\"w42.bot.otherPadW\", padName)]\n\t[h2\t\t\t\t= getProperty(\"w42.bot.otherPadH\", padName)]\n};{\n\t[setCurrentMap(newMap)]\n\t<!-- in case a jump/drop interpad is used, the padName does not exist on the new map!! hence it must be renamed -->\n\t[tmpPadName\t\t= if(startsWith(padName, \"InterJump\"), replace(padName, \"Jump\", \"Drop\"), padName)]\n\t[endCentreX \t= getTokenX(0, tmpPadName)]\n\t[endCentreY \t= getTokenY(0, tmpPadName)]\n\t[w2\t\t\t\t= bot_ppc2GridCoord(getTokenWidth(tmpPadName))]\n\t[h2\t\t\t\t= bot_ppc2GridCoord(getTokenHeight(tmpPadName))]\n\t[setCurrentMap(oldMap)]\n}]\n\n[CurrentX\t= getTokenX(0, tok)]\n[CurrentY\t= getTokenY(0, tok)]\n[CurrentGS\t= bot_getGridSize()]\n\n[h,if(doScaleTeleport), CODE:{\n\t<!-- round2grid returns a coordinate rounded to multiple of grid size  -->\n\t[w1\t\t= bot_ppc2GridCoord(getTokenWidth(padName))]\n\t[h1\t\t= bot_ppc2GridCoord(getTokenHeight(padName))]\n\n\t[wc\t\t= w2/w1]\n\t[hc\t\t= h2/h1]\n\t[if(CurrentX == startCentreX + w1 - CurrentGS): \n\t\tNewX\t= endCentreX + w2 - endGridSize \n\t; \n\t\tNewX\t= round(wc*(CurrentX - startCentreX) + endCentreX)\n\t]\n\t[if(CurrentY == startCentreY + h1 - CurrentGS): \n\t\tNewY\t= endCentreY + h2 - endGridSize \n\t; \n\t\tNewY\t= round(hc*(CurrentY - startCentreY) + endCentreY)\n\t]\n};{\n\t[NewX\t= CurrentX - startCentreX + endCentreX]\n\t[NewY\t= CurrentY - startCentreY + endCentreY]\n}]\n\n<!-- moveTokenToMap only works with gridcell coords NOT with distance per cell, so convert x/y to grid -->\n['NewX\t= round(NewX/endGridSize)']\n['NewY\t= round(NewY/endGridSize)']\n['pause(\"w1\",\"h1\",\"w2\",\"h2\",\"wc\",\"hc\",\"NewX\",\"NewY\",\"CurrentX\",\"startCentreX\",\"endCentreX\",\"CurrentY\",\"startCentreY\",\"endCentreY\")']\n\n[Token(tok): w42.bot.init = getInitiative()]\n\n<!-- check if token is standing on a roof, if so, deactivate it. -- ROOFSWAP (inHouse, me, roofName, showHalo) -->\n[h, if(hasProperty(\"w42.bot.onRoof\", tok)): bot_roofSwap(0, tok, getProperty(\"w42.bot.onRoof\", tok), if(bot_inStr(getProperty(\"w42.bot.onRoof\", tok), \"roof\"),1,0))]\n\n<!-- execute a linked event from the settings BEFORE teleport-->\n[h, if(eventMacroPreInterTeleport != \"<none>\"), CODE:{\n\t[macro(eventMacroPreInterTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap\", \"UNSUFFIXED\"))]\n}; {}]\n\n[bot_chkSounds(tok, oldMap, 1, pathPadList)] <!-- stop all map related sounds -->\n[moveTokenToMap(tok, newMap, NewX, NewY, 100)]\n\n[if(doSwitchInterMap != 2), CODE:{\n\t[setCurrentMap(newMap)]\n\t[if(isNumber(w42.bot.init)), CODE:{\n\t\t[Token(tok): addToInitiative()]\n\t\t[Token(tok): setInitiative(w42.bot.init)]\n\t}; {}]\n\t[goto(currentToken())]\n\t[selectTokens(tok)]\n\t[exposeFOW()]\n};{}]\n\n<!-- execute a linked event from the settings AFTER teleport-->\n[h, if(eventMacroPostInterTeleport != \"<none>\"), CODE:{\n\t[macro(eventMacroPostInterTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap\", \"UNSUFFIXED\"))]\n}; {}]\n\n[if(doSwitchInterMap == 0), CODE:{\n\t[bot_chkSounds(tok, newMap, 0)] <!-- start all map related sounds on new map -->\n\t[abort(doAbort)]\n}]\n\n[if(doSwitchInterMap != 2):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f5feb80b-a575-4517-8c82-d0a42d0ffedb",
          "commandChecksum": "a891b3601556c98884f1d9b5b83397ec",
          "propsChecksum": "05dc5c315d1302bf7b285188c2d1e4a9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5. Teleport & Roof",
        "includeLabel": false,
        "sortBy": "4",
        "index": 398,
        "label": "roofSwap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------- ROOFSWAP (inHouse, me, roofName, showHalo, roofHaloColor) ------------------------------------ -->']\n\n[h:inHouse\t\t= arg(0)]\n[h:me\t\t\t= arg(1)]\n[h:roofName\t\t= arg(2)]\n[h:showHalo\t\t= arg(3)]\n[h,if(argCount()>4): roofHaloColor\t= arg(4)]\n\n[h:switchToken(roofName)]\n[h:useAltImage\t= getLibProperty(\"useAltImage\",\"lib:EventMacros\")]\n\n[H, if(inHouse), code: {\n\t[assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\t[nameList\t= getProperty(\"w42.bot.tokens.onHouse\")]\n\t[if(useAltImage && getTokenHandout() != \"\"): noRoofImg\t= getTokenHandout(); noRoofImg\t= tblImage(\"tbl_Image\",1)]\n\t[roofImg\t= getTokenImage()]\n\n\t[if(nameList == \"\"), CODE:{\n\t\t[xtmp = getTokenWidth()]\n\t\t[ytmp = getTokenHeight()]\n\t\t[setTokenImage(noRoofImg)]\n\t\t[setTokenWidth(xtmp)]\n\t\t[setTokenHeight(ytmp)]\n\t\t[if(showHalo):setHalo(roofHaloColor)]\n\t\t[setProperty(\"w42.bot.layer.original\", getLayer())]\n\t\t[setProperty(\"w42.bot.x.original\", xtmp)]\n\t\t[setProperty(\"w42.bot.y.original\", ytmp)]\n\t\t[setLayer(\"BACKGROUND\")]\n\t}]\n\t\n\t[if(roofImg != noRoofImg):setProperty(\"w42.bot.image.original\", roofImg)]\n\t[if(!listContains(nameList, me)): nameList\t= listAppend(nameList, me)]\n\t[setProperty(\"w42.bot.tokens.onHouse\",nameList)]\n\t<!-- also store the name of the roof on the token, so in case of teleport it can be deactivated -->\n\t[setProperty(\"w42.bot.onRoof\",roofName, me)]\n}; {\n\t[nameList\t= getProperty(\"w42.bot.tokens.onHouse\")]\n\t[if(listContains(nameList, me)): nameList\t= listDelete(nameList, listFind(nameList,me))]\n\t[setProperty(\"w42.bot.tokens.onHouse\",nameList)]\n\t<!-- remove property from token -->\n\t[resetProperty(\"w42.bot.onRoof\", me)]\n\n\t[if(nameList == \"\"), CODE:{\n\t\t[xtmp = getProperty(\"w42.bot.x.original\")]\n\t\t[ytmp = getProperty(\"w42.bot.y.original\")]\n\t\t[setTokenImage(getProperty(\"w42.bot.image.original\"))]\n\t\t[setTokenWidth(xtmp)]\n\t\t[setTokenHeight(ytmp)]\n\t\t\n\t\t[if(showHalo):setHalo(\"None\")]\n\t\t[setLayer(getProperty(\"w42.bot.layer.original\"))]\n\t};{}]\n}]\n\n[if(getProperty(\"w42.bot.vblBgScale\") != \"\"): bot_setVBLRoof(roofName, inHouse)]\n\n[h:'pause(\"nameList\", \"me\", \"roofName\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6d020f97-9914-4e84-9e6b-61f2bdd58b1a",
          "commandChecksum": "de74228d5da8d6be2e9b11cb610ff2e5",
          "propsChecksum": "c17f6d65460ac251ce0a916d922c91c1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "5. Teleport & Roof",
        "includeLabel": false,
        "sortBy": "3",
        "index": 399,
        "label": "setRoof",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ---------------------------------------------- setRoof -------------------------------------------- --> ']\n\n[h:roof\t\t\t\t= getName(getSelected())]\n[h:assert(listCount(roof)==1,\"Make sure (only) one token is selected\",0)]\n[h:assert(startsWith(roof, \"Roof \"),\"Make sure the 'roof' is called 'Roof <number>'\",0)]\n[h:switchToken(roof)]\n[h:tmpDoors\t\t\t= getProperty(\"w42.bot.Doors\", roof)]\n\n<!-- check if roof has been previously set with VBL -->\n[h: oldAddVBL = if(hasProperty(\"w42.bot.vblSetup\"), 1, 0)]\n\n<!-- mt version VBL support check -->\n[h:vblSupport\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n\n<!-- create a list of doors on the object layer that have been set for animation-->\n[h:tokens\t\t\t= getTokenNames(\",\",'{\"layer\":\"OBJECT\"}')]\n[h:Doors\t\t\t= \"\"]\n[h, foreach(tok, tokens),CODE:{\n\t[if(startsWith(tok, \"Door \") && getProperty(\"w42.bot.doorData\", tok)): Doors\t= listAppend(Doors, tok)]\n}]\n[h:Doors\t\t\t= listSort(Doors, \"N+\")]\n\n<!-- Create list of door identifiers -->\n[h:iDoors\t\t\t= \"\"]\n[h:desciptionsDoors\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t\t[id\t\t\t\t\t= substring(door, 5)]\n\t\t[iDoors\t\t\t\t= listAppend(iDoors, id)]\n\t\t[h,if(hasProperty(\"description\", door)): description\t= getProperty(\"description\", door); description\t= \"\"]\n\t\t[desciptionsDoors\t= listAppend(desciptionsDoors, strformat(\"(%{id}) %{description}\"))]\n}]\n\n<!-- turn this list into an input string -->\n[H: \t\t\t\tinputStr \t= \"[]\"]\n[h,if(vblSupport):\tinputStr\t= json.append(inputStr, \"junk|<html><b>Apply VBL<\/b> - this will store the current VBL of the building<br>and replace it by a Cross VBL. As soon as a token moves onto the roof<br>The cross VBL will be swapped by the stored building VBL. <\/html>|-|LABEL|SPAN=TRUE\")]\n[h,if(vblSupport):\tinputStr\t= json.append(inputStr, \"addVBL|\"+oldAddVBL+\"|Apply VBL Cross|CHECK\") ; addVBL = 0]\n[h, if(Doors != \"\"):inputStr\t= json.append(inputStr, \"junk|<html><b>Link doors<\/b> - set the entry/exit doors for this roof. This will<br>prevent a token from moving onto the roof by NOT using the door.<br>A token can only enter the building by first moving over one of the<br>selected door tokens.<\/html>|-|LABEL|SPAN=TRUE\")]\n[h,foreach(door, Doors), CODE:{\n\t\t[\t\t\tnewStr\t\t= \"door\" + roll.count + \"|\"+listContains(tmpDoors,door)+\"|\" + listGet(desciptionsDoors, roll.count) + \"|CHECK\"]\n\t\t[\t\t\tinputStr\t= json.append(inputStr, newStr)]\n}]\n\n<!-- put local variables in input form -->\n[H: inputStr = json.evaluate(inputStr)]\n \n<!-- get user input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- process results, that add the chosen doors -->\n[h:tmpDoors\t\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t[if(eval(\"door\" + roll.count)):tmpDoors\t= listAppend(tmpDoors, door)]\n}]\n[h:setProperty(\"w42.bot.Doors\", tmpDoors, roof)]\n\n<!-- add X VBL to roof and also store any BG VBL -->\n[h, if(addVBL && oldAddVBL != addVBL), CODE:{\n\t[vblSetup\t= strformat(\n\t\t\"applyVBL=1; VBLType=0; scaleX=100; scaleY=100; offsetX=0; offsetY=0; thickness=1; fill=0; scale=1; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;\"\n\t)]\n\n\t<!-- get the new VBL settings and apply the new VBL cross to its current position -->\n\t[setProperty(\"w42.bot.vblSetup\", vblSetup, roof)]\n\t[bot_createVBL(roof)]\n\t<!-- createVBL will restore the bgVBL and apply the fgVBL in this case we want the fgVBL only -->\n\t[bot_setVBLRoof(roof, 0)]\n}]\n\n<!-- REMOVE X VBL from  roof and also restore any BG VBL -->\n[h, if(!addVBL && oldAddVBL != addVBL), CODE:{\n\t<!-- remove the cross and set the old VBL -->\n\t[bot_setVBLRoof(roof, 1)]\n\t<!-- remove all VBL data  from the roof -->\n\t[bot_removeVBL(roof)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "da9049a1-fb5e-496c-bb1c-39b7d44047c7",
          "commandChecksum": "9d16f9c7060670b88de34daffffda086",
          "propsChecksum": "64d2b59302ea2a75cfc0cd11ed9e43d7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5. Teleport & Roof",
        "includeLabel": false,
        "sortBy": "99",
        "index": 400,
        "label": "setVBLRoof",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------------------- setVBLRoof (id, on/off) -------------------------------------------- -->']\n[debug = 0]\n\n[me\t\t\t\t= arg(0)]\n[tokenOnRoof\t= arg(1)]\n\n[if(tokenOnRoof), CODE:{\n\t<!-- a token moves onto the roof. So remove the cross and restore the building VBL -->\n\t<!-- erase all vbl on roof and restore the VBL of the building beneath (erase is done int he drawbgvbl function) -->\n\t[bot_drawBgVBL(me)]\t\n};{\n\t<!-- a token moves OFF the roof. So remove the bg VBL and restore the cross -->\n\t<!-- erase all vbl on roof and restore the VBL of the building beneath -->\n\t[rectVBL\t= getProperty(\"w42.bot.rectVBL\")]\n\t[eraseVBL(rectVBL)]\n\n\t<!-- DEBUG INFO(list of variable, one line 1/0, show tokens (1/0), pause(1/0), getMacroName(), getMacroLocation()) -->\n\t[h,if(debug == 1), CODE:{\n\t\t[bot_debugInfo(\"me, tokenOnRoof, rectVBL\",0,1,0, getMacroName(), getMacroLocation())]\n\t};{}]\n\n\t<!-- 0 parameter prevents restoring bgVBL -->\n\t[bot_drawFgVBL(me, 0)]\n}]\n\n[selectTokens(getTokens(\",\", '{ pc:1 }'),1,\",\")]\n[exposeFOW()]\n[deselectTokens()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6531f593-552f-4a3e-9c62-12ab9ceae3e2",
          "commandChecksum": "c0ec70b18fc9adb935e2f651c328858b",
          "propsChecksum": "ceec16821e5bcb4b9a728adfab0f1143"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5. Teleport & Roof",
        "includeLabel": false,
        "sortBy": "1",
        "index": 401,
        "label": "teleport",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!--teleport(token,startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport)-->']\n\n<!-- define the following vars: tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport -->\n[h:varsFromStrProp(arg(0))]\n[bot_playPadSound(padName, tok)]\t<!-- play sound linked to the pad (if any) -->\n\n[h, Token(tok):CurrentX \t= getTokenX(1)]\n[h, Token(tok):CurrentY \t= getTokenY(1)]\n\n[h,if(doScaleTeleport), CODE:{\n\t[gs\t\t= bot_getGridSize()]\n\t[w1\t\t= bot_round2Grid(getTokenWidth(padName),gs)]\n\t[h1\t\t= bot_round2Grid(getTokenHeight(padName),gs)]\n\t[w2\t\t= bot_round2Grid(getTokenWidth(teleportEndName),gs)]\n\t[h2\t\t= bot_round2Grid(getTokenHeight(teleportEndName),gs)]\n\n\t[wc\t\t= w2/w1]\n\t[hc\t\t= h2/h1]\n\t[if(bot_round2Grid(CurrentX,gs) == bot_round2Grid(startCentreX,gs) + w1 - gs): NewX\t= endCentreX + w2 - gs ; NewX = round(wc*(CurrentX - startCentreX) + endCentreX)]\n\t[if(bot_round2Grid(CurrentY,gs) == bot_round2Grid(startCentreY,gs) + h1 - gs): NewY\t= endCentreY + h2 - gs ; NewY = round(hc*(CurrentY - startCentreY) + endCentreY)]\n};{\n\t[NewX\t= CurrentX + endCentreX - startCentreX]\n\t[NewY\t= CurrentY + endCentreY - startCentreY]\n}]\n\n[h,if(!isSnapToGrid(tok)),CODE:{\n\t<!-- if pads are not snapped and the token is, you get strange offsets after the teleport, this fixes that -->\n<!-- needs propper testing at gridsize 28 and other circumstances @@@@ -->\n\t[gs\t\t= bot_getGridSize()]\n\t[NewX\t= round(NewX/gs)*gs]\n\t[NewY\t= round(NewY/gs)*gs]\n};{}]\n\n\t['pause(\"w1\",\"h1\",\"w2\",\"h2\",\"wc\",\"hc\",\"NewX\",\"NewY\",\"CurrentX\",\"startCentreX\",\"endCentreX\",\"CurrentY\",\"startCentreY\",\"endCentreY\")']\n\n<!-- execute a linked event from the settings BEFORE teleport-->\n[h, if(eventPreMacroTeleport != \"<none>\"), CODE:{\n\t[macro(eventPreMacroTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY\", \"UNSUFFIXED\"))]\n}; {}]\n\n<!-- check if token is standing on a roof, if so, deactivate it. -- ROOFSWAP (inHouse, me, roofName, showHalo) -->\n[h, if(hasProperty(\"w42.bot.onRoof\", tok)): \n\tbot_roofSwap(0, tok, getProperty(\"w42.bot.onRoof\", tok), if(bot_inStr(getProperty(\"w42.bot.onRoof\", tok), \"roof\"),1,0))\n]\n\n[h, Token(tok):moveToken(NewX, Newy , 1 )]\n[h:selectTokens(tok)]\n[h:exposeFOW()]\n[h:bot_chkSounds(tok, getCurrentMapName(), 0)] <!-- start all map related sounds on new map -->\n\n<!-- execute a linked event from the settings AFTER teleport-->\n[h, if(eventPostMacroTeleport != \"<none>\"), CODE:{\n\t[macro(eventPostMacroTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "82d95358-42c5-4fd1-b2b8-cdd2a2a11151",
          "commandChecksum": "fdf6d0b3b0a96077fb4032117d44c58f",
          "propsChecksum": "d4383e205ce1ae6f174bfd886dfcdcdd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "1",
        "index": 405,
        "label": "showDescription",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------------------------- showDescription -------------------------------------------------------------- -->']\n\n[h:assert(listCount(getSelected())==1,\"Make sure (only) one 'Adventure Scenario' token is selected\",0)]\n[h:switchToken(getSelected())]\n\n[h: textBox\t\t= getGMNotes()]\n[h: textBox\t\t= encode(textBox)]\n[h: handout\t\t= getTokenHandout()]\n[h: portrait\t= getTokenPortrait()]\n<!-- default height of images -->\n[h: height\t\t= 500]\n\n[h, if(isGM()), code:{\n\t[textBox\t= replace(textBox,\"%C3%B1\",\"%26ntilde%26semi%3B\")]\t<!-- n~ -->\n\t[textBox\t= replace(textBox,\"%C3%91\",\"%26Ntilde%26semi%3B\")]\t<!-- N~ -->\n\t[textBox\t= replace(textBox,\"%C3%A1\",\"a\")]\t\t\t\t\t<!-- a/ -->\n\t[textBox\t= replace(textBox,\"%C3%A9\",\"e\")]\t\t\t\t\t<!-- e/ -->\n\t[textBox\t= replace(textBox,\"%C3%AD\",\"i\")]\t\t\t\t\t<!-- i/ -->\n\t[textBox\t= replace(textBox,\"%C3%B3\",\"o\")]\t\t\t\t\t<!-- o/ -->\n\t[textBox\t= replace(textBox,\"%C3%BA\",\"u\")]\t\t\t\t\t<!-- u/ -->\n\n\t[textBox\t= replace(textBox,\"%E2%80%99\",\"@apostrophe@\")]\t\t<!-- closing curved quotation -->\n\n\t[textBox\t= replace(textBox,\"%C3%81\",\"A\")]\t\t\t\t\t<!-- A/ -->\n\t[textBox\t= replace(textBox,\"%C3%89\",\"E\")]\t\t\t\t\t<!-- E/ -->\n\t[textBox\t= replace(textBox,\"%C3%8D\",\"I\")]\t\t\t\t\t<!-- I/ -->\n\t[textBox\t= replace(textBox,\"%C3%93\",\"O\")]\t\t\t\t\t<!-- O/ -->\n\t[textBox\t= replace(textBox,\"%C3%9A\",\"U\")]\t\t\t\t\t<!-- U/ -->\n\t\n\t[textBox\t= replace(textBox,\"%0A\" ,\"%3Cp+align%3Djustify+style%3D%22text-indent%3A20%22%3E\")]<!-- line break -->\n\t[textBox\t= decode(textBox)]\n\t\n\t[textBox\t= replace(textBox,\"<title>\", \"[h:title='\")]\n\t[textBox\t= replace(textBox,\"<\/title>\", \" '] \")]\n\n\t[textBox\t= replace(textBox,\"<infolink>\", \"[h:infolink='\")]\n\t[textBox\t= replace(textBox,\"<\/infolink>\", \"'][r: macrolink(if(title=='' , 'Info link' , title), 'showInfoLink@lib:OnTokenMove' , 'all',json.append('',title, infolink))](Click to show)    [h: title='']\")]\n\n\t[textBox\t= replace(textBox,\"<share>\", \"[h:share='\")]\n\t[textBox\t= replace(textBox,\"<\/share>\", \"']<table border=1 width=100% bgcolor=silver><tr><td border=0>[r: share]<br>[h: linkText = if(title == '', 'Share text', 'Share text: '+title)][r: macrolink(linkText, 'sendMacroChat@lib:OnTokenMove' , 'all',json.append('',title, share))]<\/table>[h: title='']\")]\n\t\n\t[textBox\t= replace(textBox,\"<image>\", \"[h: image=\")]\n\t[textBox\t= replace(textBox,\"<\/image>\", \"]<img src=[r:image]-100><\/img><br>[h: linkText = if(title == '', 'Share image', 'Share image: '+title)][r: macrolink(linkText, 'sendMacroChat@lib:OnTokenMove' , 'all' , json.append('',title,image,\"+height+\"))][h: title='']\")] \n\t\n\t[if(handout\t!= \"\" || portrait\t!= \"\")\t: suffix\t= \"<table align=center border=1><tr>\" ; suffix\t= \"\"]\n\t[if(handout\t!= \"\")\t\t\t\t\t\t: suffix\t= suffix + \"<td align=center>Handout:<br>\" + macrolink(\"<img src=\" + handout\t+ \"-100><\/img>\", 'sendMacroChat@lib:OnTokenMove', 'all', json.append('',\"Share Handout\",handout,height)\t)]\n\t[if(portrait != \"\")\t\t\t\t\t\t: suffix\t= suffix + \"<td align=center>Portrait:<br>\" + macrolink(\"<img src=\" + portrait\t+ \"-100><\/img>\", 'sendMacroChat@lib:OnTokenMove', 'all', json.append('',\"Share Portrait\",portrait,height))]\n\t[if(handout\t!= \"\" || portrait\t!= \"\")\t: textBox\t= suffix + \"<\/tr><\/table>\" + textBox]\n\n\t<!-- debug -->\n\t['broadcast(replace(textBox, \"<\",\"<br><\"))']\n\n\t[textBox\t= '[frame (\"Location Information\"):{' + bot_frameOpen(4) +  replace(textBox,\"@apostrophe@\",\"´\") + bot_frameClose(4) + '}]']\n\t[execMacro(\"[h: title='']\" + textBox)]\n};{\n\t[assert(handout\t!= \"\", \"The token \"+token.name+\" has no (handout) image to show\",0)]\n\t[macro(\"shareIMG@lib:OnTokenMove\"):json.append('',title,handout,height)]\n}]",
        "maxWidth": "",
        "tooltip": "Copy to campaign panel",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "830d6d35-8212-424c-a708-8235a0fa74c0",
          "commandChecksum": "201e7194168d6f22b99fccad98c69ee3",
          "propsChecksum": "a6dcefbdc3653364e3b4c0c4e16b5dc8"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 406,
        "label": "defineArea",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- defineArea ------------------------------------ -->']\n<!-- ignore output, new scope -->\n<!-- <html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area. -->\n\n[h:stateList = getTokenStates()]\n[h,if(listContains(stateList, \"Special Area\")): selectedState = listFind(stateList, \"Special Area\") ; selectedState = 0]\n[h:abort(input(\n\t'junk|<html><b>DEFINE EVENT AREA<\/b><\/html>|-|LABEL|SPAN=TRUE',\n\t'areaName|<enter name of area>|<html><span title=\"<html>Here you can enter the name of the area to which the<br>coords will be linked. Use alphanumeric characters only<\/html>\">Name of Area<\/html><\/span><\/html>',\n\t'junk|<html><b>Choose one of the below two methods:<br>____________________________________________________<br>Method 1: Use coords of tokens on map<\/b><br><\/html>|-|LABEL|SPAN=TRUE',\n\t'areaState|'+stateList+'|<html><span title=\"<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any state you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.<\/html>\">Name of Token State<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+selectedState,\n\t'areaLayer|TOKEN, OBJECT, HIDDEN, BACKGROUND|<html><span title=\"<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any layer you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.<\/html>\">Name of layer<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT=0',\n\t'deleteTokens|0|<html><span title=\"<html>Note that if you choose NOT to delete them, then the<br>only way to remove them is to manually delete them.<br>Or run this macro again and then check this box.<\/html>\">Delete tokens when done<\/html><\/span><\/html>|CHECK',\n\t'junk|<html>____________________________________________________<br><b>Method 2: Use coords of lastpath of a token<\/b><br><i>Checking the checkbox will result in method 2<\/i><br><\/html>|-|LABEL|SPAN=TRUE',\n\t'useLastPath|0|<html><span title=\"<html>The other method is using the last path of a token.<br>For this you can drag a token over the area you wish<br>to mark. You can use the space bar to set waypoints.<br>Note that if you go twice over one cell that the coord<br>will only be stored once. Also note that you can later<br>edit this area by using the <i>Show Area<\/i> macro,<br>move, add, remove the areaTokens and then redefine the<br>area using the other method.<br><br><b>When you check this checkbox it will ignore the other method!<\/b><\/html>\">Use the last path of a token<\/html><\/span><\/html>|CHECK',\n\t'lastPathName|<Token Name>|<html><span title=\"<html>Enter the name of the token of which the last<br>path you wish to use<\/html>\">If checked give name of token<\/html><\/span><\/html>'\n))]\n\n[h,if(useLastPath), CODE:{\n\t[assert(findToken(lastPathName)!=\"\", \"Can't find: \"+lastPathName,0)]\n\t[token(lastPathName):area = getLastPath(0)]\n}; {\n\t[conditions\t\t= json.set(\"{}\",\"layer\",areaLayer,\"setStates\",areaState)]\n\t[tokList\t\t= getTokens(\",\",conditions)]\n\t[assert(listCount(tokList)>0, \"No tokens have been found that match your criteria. Check whether the LAYER and the NAME are correct\", 0)]\n\t[if(deleteTokens): bot_removeTokens(tokList)]\n\t<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->\n\t[splices\t\t= bot_createSplices(tokList)]\n\t\n\t<!-- loop through the splices and create an array of the coords of all the tokens -->\n\t[area\t\t\t= \"[]\"]\n\t[h, foreach(splice, splices, \"\"), code: {\n\t\t[foreach(tok, splice, \"\"):  area = json.append(area, \"{'x':\"+getTokenX(1,tok)+\",'y':\"+getTokenY(1,tok)+\"}\")]\n\t}]\n}]\n\n<!-- clean up any double entries -->\n[h:area\t\t\t\t\t= json.unique(area)]\n\n[h:mapName\t\t\t\t= getCurrentMapName()]\n[h:storedAreas\t\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n\n<!-- first time use -->\n[h, if(json.type(storedAreas) == \"UNKNOWN\"): storedAreas = \"{}\"]\n\n[h,if(json.contains(storedAreas, mapName)): thisMapAreas = json.get(storedAreas, mapName) ; thisMapAreas = \"{}\"]\n[h:thisMapAreas\t\t\t= json.set(thisMapAreas, areaName, area)]\n[h:storedAreas\t\t\t= json.set(storedAreas, mapName, thisMapAreas)]\n[h:setLibProperty(\"storedAreas\", storedAreas, \"Lib:EventMacros\")]\n\n<!-- show all coords in the chat-->\n[h:broadcast(\"The Area: \"+areaName+\" has been defined.<br> The coordinates are:<br>\"+json.indent(area,2))]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f44fa857-084a-4350-ab71-34d128b05e48",
          "commandChecksum": "aa9162e02e0c80af89811362e1e26f41",
          "propsChecksum": "557236d654721a1d8547a48969dbd284"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 407,
        "label": "fillArea",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- fillArea ------------------------------------ -->']\n[h:'<!-- \n<html>This macro fills a predefined area with tokens<\/html>\n-->']\n\n<!-- create list of overlay tokens, this function also defines the baseMapName variable -->\n[h:bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n<!-- Make sure Area Marker is the first in the list -->\n[h: index = listFind(allList, \"Area Marker\")]\n[h, if(index != -1), CODE:{\n\t[allList\t\t= listDelete(allList,index)]\n\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n}; {}]\n\n<!-- IF a token is selected use that token to define the x and y coord and set it as default choice. -->\n[h:selToks = getSelectedNames()]\n[h:assert(listCount(selToks)<=2, \"Make sure you have maximum two tokens selected\",0)]\n[h,if(selToks != \"\"), CODE:{\n\t[me\t= listGet(selToks,0)]\n\t[x1 = getTokenX(0,me)]\n\t[y1 = getTokenY(0,me)]\n\t[if(listCount(selToks) == 2), CODE:{\n\t\t[me2\t= listGet(selToks,1)]\n\t\t[x2\t\t= getTokenX(0,me2)]\n\t\t[y2\t\t= getTokenY(0,me2)]\n\t\t[xC\t\t= min(x1,x2)]\n\t\t[yC\t\t= min(y1,y2)]\n\t\t[xL \t= max(x1,x2) - xC+1]\n\t\t[yL \t= max(y1,y2) - yC+1]\n\t};{\n\t\t[xC\t\t= x1]\n\t\t[yC\t\t= y1]\n\t\t[xL \t= 10]\n\t\t[yL \t= 10]\n\t}]\n\t[allList\t\t= listAppend(me, allList)]\n\t[token(me): fancyAllList = listAppend(me + getTokenImage(60), fancyAllList)]\n}; {\n\t[xC\t= 0]\n\t[yC\t= 0]\n\t[xL = 10]\n\t[yL = 10]\n}] \n\n[h:inputStr\t\t= \"[]\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>FILL AREA<\/b><br>This macro fills a predefined area with tokens<br>This functions works differently depending on the selected tokens:<br><b>No tokens selected<\/b>: a list of area tokens will appear from which you can pick.<br><b>One token selected<\/b>: the selected token will be added to the top of the list AND<br>its coordinates are used for the upper left corner.<br><b>Two tokens selected: <\/b> same as one token but now the width and length of the area<br>is also pre set, derived from the coordinates of the lower right selected token<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Token|LIST|ICON=TRUE ICONSIZE=30\")]\n[h:inputStr\t\t= json.append(inputStr, \"layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING\")]\n[h:inputStr\t\t= json.append(inputStr, \"xC|\"+xC+\"|X coord of upper left corner\")]\n[h:inputStr\t\t= json.append(inputStr, \"yC|\"+yC+\"|Y coord of upper left corner\")]\n[h:inputStr\t\t= json.append(inputStr, \"xL|\"+xL+\"|How many cells right\")]\n[h:inputStr\t\t= json.append(inputStr, \"yL|\"+yL+\"|How many cells down\")]\n\n<!-- ask for input -->\n<!-- put local variables in input form -->\n[H: inputStr = json.evaluate(inputStr)]\n<!-- get user input -->\n[H:abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- process choices -->\n<!-- get the AreaToken of the BASE map -->\n[h:areaToken\t= listGet(allList, areaTok)]\n[h,if(me != \"\" && areaTok == 0): baseMapName\t= getCurrentMapName()]\n[h:areaToks\t\t= \"\"]\n[h,for(x, xC, xC+xL), CODE: {\n\t[h,for(y, yC, yC+yL):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set(\"{}\",\"useDistance\", 0, \"layer\", layer, \"x\", x, \"y\", y)))]\n}]\n[h:broadcast(\"<br><b>Overlay tokens have been placed<\/b>\")]\n[h,if(me != \"\"): selectTokens(json.fromList(selToks),0,\"json\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills a predefined area with tokens<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b9a8f285-49b7-43af-b7c4-3f8e5a2f6b3a",
          "commandChecksum": "f2c6a647cba5023ca3ca93f8afdd812d",
          "propsChecksum": "d7013268687cfcdfc762510ea1141f6b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 408,
        "label": "showArea",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- showArea ------------------------------------ -->']\n[h:'<!-- THREE CODE LEVELS METHOD USED -->']\n\n<!-- ignore output, new scope -->\n<!-- <html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro. -->\n\n[h:mapName\t\t\t= getCurrentMapName()]\n[h:storedAreas\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n[h:showAreaTokens\t= getLibProperty(\"showAreaTokens\", \"Lib:EventMacros\")]\n[h,if(json.type(showAreaTokens) == \"UNKNOWN\"): showAreaTokens = \"{}\"]\n[h, if(!json.contains(showAreaTokens, mapName)):thisMapAreaTokens = \"{}\"; thisMapAreaTokens = json.get(showAreaTokens, mapName)]\n\n[h:assert(json.contains(storedAreas, mapName), \"This map contains no predefined areas\",0)]\n[h:thisMapAreas\t\t= json.get(storedAreas, mapName)]\n[h:thisMapAreaNames\t= listSort(json.fields(thisMapAreas),\"N+\")]\n\n<!-- create list of Areas on map -->\n[h:inputStr\t\t\t= \"[]\"]\n[h:shownAreas\t\t= json.fields(thisMapAreaTokens)]\n<!-- create list of overlay tokens -->\n[h:bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n<!-- Make sure Area Marker is the first in the list -->\n[h: index = listFind(allList, \"Area Marker\")]\n[h, if(index != -1), CODE:{\n\t[allList\t\t= listDelete(allList,index)]\n\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n}; {}]\n\n[h,if(listCount(thisMapAreaNames)), CODE:{\n\t[inputStr\t\t= json.append(inputStr, \"junk|<html><b>(Un)Check areas to (Un)Show them on the map<\/b><\/html>|<html>Here you can show or remove special areas with the use of overlay tokens OR you can delete areas.<br>If you check one or more areas then those area will be filled with overlay tokens which you can<br>choose from the drop down box. These overlay tokens will be copied on layer you can select from<br>the other drop down box. Areas that are already checked (and thus shown on the map) remain <br>unchanged. So only CHANGES in the checkboxes will be processed. The exception for this is the <br>deletion checkbox. If you check that one, then ALL THE CHECKED AREAS will be deleted.<br><br>Note that the overlay list is created from ALL token on the BASE map which name starts with <i>'Area '<\/i><br>(note the space). So you can add your own by simply dropping overlay tokens on the BASE map and<br>renaming them such that they start with <i>'Area '<\/i><br><br><b>IMPORTANT NOTE:<\/b><br>When you UNCHECK an area (thus effectively REMOVE the overlay tokens), make sure that the<br><u><i>Impersonated<\/i><\/u> panel IS CLOSED. Due to a bug in MT it will take EXTREMELY long (minutes)<br>to remove these tokens when that panel is open.|LABEL|SPAN=TRUE\")]\n\t[foreach(area, thisMapAreaNames): inputStr = json.append(inputStr, \"area\"+roll.count+\"|\"+if(listContains(shownAreas, area),1,0)+\"|\"+area+\"|CHECK\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|______________________________________________|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING\")]\n\t[inputStr \t\t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Overlay|LIST|ICON=TRUE ICONSIZE=30\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|______________________________________________|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|<html><b>OR Delete checked areas<\/b><br>When you check the delete box then the all the areas<br>you have selected (checked) as well will be deleted.<\/html>|<html>When you check this checkbox, ALL THE CHECKED AREAS will be removed|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"deleteArea|0|Delete|CHECK\")]\n}; {\n\t[broadcast(\"<html><b>No special areas found on map<\/b><\/html>\")]\n\t[abort(0)]\n}]\n\n<!-- ask for input -->\n<!-- put local variables in input form -->\n[H: inputStr\t= json.evaluate(inputStr)]\n<!-- get user input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- process choices -->\n<!-- create list of selected area -->\n[h:chosenAreas\t= \"\"]\n[h,foreach(areaName, thisMapAreaNames), if(eval(\"area\"+roll.count)): chosenAreas = listAppend(chosenAreas, areaName)]\n<!-- get the AreaToken of the BASE map -->\n[h:areaToken\t= listGet(allList, areaTok)]\n\n[h,if(deleteArea), CODE:{\n\t[foreach(areaName, chosenAreas),CODE:{\n\t\t[thisMapAreas\t= json.remove(thisMapAreas, areaName)]\n\t\t[storedAreas\t= json.set(storedAreas, mapName, thisMapAreas)]\n\t\t[setLibProperty(\"storedAreas\", storedAreas, \"Lib:EventMacros\")]\n\n\t\t<!-- remove any event links to this area as well -->\n\t\t[linkedAreas\t= getLibProperty(\"linkedAreas\", \"Lib:EventMacros\")]\n\t\t[thisMapLinks\t= json.get(linkedAreas, mapName)]\n\t\t[if(json.type(thisMapLinks) == \"OBJECT\"):\tthisMapLinks\t= json.remove(thisMapLinks, areaName)]\n\n\t\t[thisMapLimits\t= json.get(linkedAreas, mapName+\".W42.Limit\")]<br>\n\t\t[if(json.type(thisMapLimits) == \"OBJECT\"):\tthisMapLimits\t= json.remove(thisMapLimits, areaName)]\n\n\t\t[linkedAreas\t= json.set(linkedAreas, mapName, thisMapLinks, mapName+\".W42.Limit\", thisMapLimits)]\n\t\t[setLibProperty(\"linkedAreas\", linkedAreas, \"Lib:EventMacros\")]\n\n\t\t<!-- finally check if there are still showAreaTokens ids store in the json and if so, remove these as well. -->\n\t\t[areaToks\t\t\t= json.get(thisMapAreaTokens, areaName)]\n\t\t<!-- clear the list on the Lib:EventMacros -->\n\t\t[thisMapAreaTokens\t= json.remove(thisMapAreaTokens, areaName)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t\n\t\t[broadcast(\"The store area: \"+areaName+\" has been removed.\")]\n\t}]\n}; {}]\n\n[h,foreach(areaName, thisMapAreaNames), if(!deleteArea), CODE:{\n\t<!-- if checkbox of area is changed to UNCHECKED then remove area overlay tokens -->\n\t[if(listContains(shownAreas, areaName) && !listContains(chosenAreas, areaName)), CODE:{\n\t\t[areaToks\t\t\t= json.get(thisMapAreaTokens, areaName)]\n\t\t<!-- check whether the first token is actually on the map (as a safety check) -->\n\t\t[areaIsShown = findToken(listGet(areaToks,0))]\n\t\t[if(areaIsShown != \"\"):\tbot_removeTokens(areaToks)]\n\t\t\n\t\t<!-- clear the list on the Lib:EventMacros -->\n\t\t[thisMapAreaTokens\t= json.remove(thisMapAreaTokens, areaName)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t[broadcast(\"<br><b>Overlay tokens of area: \"+areaName+\" have been removed<\/b>\")]\n\t''\n\t}]\n\n\t\n\t<!-- if checkbox of area is changed to CHECKED copy area overlay tokens in area -->\n\t[if(!listContains(shownAreas, areaName) && listContains(chosenAreas, areaName)), CODE:{\n\t\t[area = json.get(thisMapAreas, areaName)]\n\t\t[assert(!json.isEmpty(area), \"that area contains no coordinates\",0)]\n\t\t<!-- show all coords in the chat-->\n\t\t[broadcast(\"Area coordinates are: \"+json.indent(area,2))]\n\n\t\t<!-- put an AreaToken on each coord for visualisation-->\n\t\t<!-- create json splices to prevent the 1000 loop limit (-1 is the last entry in an array)-->\n\t\t[splices\t\t\t= bot_createSplices(area)]\n\n\t\t<!-- loop through the splices and copy a token on each coord -->\n\t\t[areaToks\t= \"\"]\n\t\t\n\t\t[foreach(splice, splices, \"\"), CODE: {\n\t\t\t[foreach(coord, splice, \"\"):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set(coord,\"useDistance\", 1, \"layer\", layer)))]\n\t\t''\n\t\t}]\n\n\t\t[thisMapAreaTokens\t= json.set(thisMapAreaTokens, areaName, areaToks)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t[broadcast(\"<br><b>Overlay tokens for area \"+areaName+\" have been placed<\/b>\")]\n\t''\n\t}]\n''\t\n}]",
        "maxWidth": "",
        "tooltip": "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "00028bff-aca8-456f-ab24-557999d7c8d3",
          "commandChecksum": "f69153724b5abd824a18c6580d6b8314",
          "propsChecksum": "b060f41688d92f831646b81ecd33f8dc"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 409,
        "label": "toggleAreaDraw",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------- toggleAreaDraw ------------------------------------ -->']\n\n[h:toggles\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:drawArea\t= getStrProp(toggles, \"drawArea\")]\n\n[h,if(drawArea), CODE:{\n\t<!-- active, so turn it off -->\n\n\t[drawArea\t\t= 0]\n\t[toggles\t\t= setStrProp(toggles, \"drawArea\", drawArea)]\n\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n\t[setLibProperty(\"drawTokenMap\", \"\", \"lib:EventMacros\")]\n\t[broadcast(\"<font color=red>TOKEN DRAWING IS TURNED OFF\")]\n};{\n\t<!-- inactive, so turn it on -->\n\n\t<!-- FRIST SELECT DRAW TOKEN -->\n\t<!-- create list of overlay tokens -->\n\t[bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n\t[me = getSelected()]\n\t<!-- Make sure Area Marker is the first in the list -->\n\t[index = listFind(allList, \"Area Marker\")]\n\t[if(index != -1), CODE:{\n\t\t[allList\t\t= listDelete(allList,index)]\n\t\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n\t}; {}]\n\t<!-- Make sure Area Marker is the first in the list -->\n\t<!-- if any token is currently Selected add that as first entry -->\n\t[selTok = listGet(getSelectedNames(),0)]\n\t[if(selTok != \"\"), CODE:{\n\t\t[allList\t\t= listAppend(selTok, allList)]\n\t\t[token(selTok): fancyAllList = listAppend(selTok + getTokenImage(60), fancyAllList)]\n\t};{}]\n\t\n\t[inputStr\t\t= json.append(\"[]\", \"junk|<html><b>Pick token which will be used to draw<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[inputStr \t\t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Overlay|LIST|ICON=TRUE ICONSIZE=30\")]\n\n\t<!-- ask for input -->\n\t<!-- put local variables in input form -->\n\t[inputStr = json.evaluate(inputStr)]\n\t<!-- get user input -->\n\t[abort(input(json.toList(inputStr,\"##\")))]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[drawTokenName\t= listGet(allList, areaTok)]\n\t[if(me!=\"\"), CODE:{\n\t\t[x\t= getTokenX(0,listGet(me,0))]\n\t\t[y\t= getTokenY(0,listGet(me,0))]\n\t};{\n\t\t[x\t= 0]\n\t\t[y\t= 0]\n\t}]\n\t[if(findToken(drawTokenName)==\"\"):copyToken(drawTokenName,1,baseMap,strformat('{\"x\":%{x},\"y\":%{y}}'))]\n\t<!-- the selected token is on the current map, the overlay tokena are on the BASE map -->\n\t[drawTokenMap\t= if(areaTok || selTok == \"\", baseMap, getCurrentMapName())]\n\n\t[drawArea\t= 1]\n\t[toggles\t= setStrProp(toggles, \"drawArea\", drawArea)]\n\t[setLibProperty(\"drawTokenName\", drawTokenName, \"lib:EventMacros\")]\n\t[setLibProperty(\"drawTokenMap\", drawTokenMap, \"lib:EventMacros\")]\n\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n\t[broadcast(\"<font color=red>TOKEN DRAWING IS TURNED ON, CLICK THE TOGGLE MACRO AGAIN TO TURN IT OFF<\/font><br>This means that ANY token you drag over the map will leave a trail of 'drawing tokens' in its trail\")]\n}]\n\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro will turn on 'token drawing'. You can select a token to be drawn. When you ove ANY token on the map then the chosen token will be copied in its path",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a6d38105-9fd8-4c25-9009-053fdbe1c786",
          "commandChecksum": "3732bd8feab902f6e5768982a8a3b574",
          "propsChecksum": "e067d850e82f20ab7af90310851de4da"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12a. Geofunctions - support",
        "includeLabel": false,
        "sortBy": "99",
        "index": 410,
        "label": "isClockWise BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- isClockWise (xcentr,ycentr,x1,y1,x2,y2) -->\n<!-- checks if p2 is clockwise from p1 -->\n[x1\t= arg(2) - arg(0)]\n[y1\t= arg(3) - arg(1)]\n[x2\t= arg(4) - arg(0)]\n[y2\t= arg(5) - arg(1)]\n\n[macro.return\t= if(-x1*y2 + y1*x2 > 0,0,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9f949d6a-5752-43a0-bf50-6e4601b28865",
          "commandChecksum": "56f154dc2acb7e239160be917a7ba487",
          "propsChecksum": "214b80b4e3750691a67163c78bea3ae8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12a. Geofunctions - support",
        "includeLabel": false,
        "sortBy": "99",
        "index": 411,
        "label": "pointInCone BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- pointInCone (me, x1,y1, x2,y2, xp,yp) -->\n<!-- checks if a point (p) is between three points (centre, 1 and 2) on a SPHERE, does NOT include boundary -->\n\n[me\t\t\t= arg(0)]\n[x1\t\t\t= arg(1)]\n[y1\t\t\t= arg(2)]\n[x2\t\t\t= arg(3)]\n[y2\t\t\t= arg(4)]\n[xp\t\t\t= arg(5)]\n[yp\t\t\t= arg(6)]\n\n[xc\t\t\t= getTokenX(0,me)]\n[yc\t\t\t= getTokenY(0,me)]\n[distance\t= getDistanceToXY(xp,yp,0,me)]\n[r\t\t\t= getDistanceToXY(x1,y1,0,me)]\n\n[CW\t\t\t= bot_isClockWise\t(xc,yc,  x1,y1,  xp,yp)]\n[CCW\t\t= !bot_isClockWise\t(xc,yc,  x2,y2,  xp,yp)]\n[IR\t\t\t= if(distance <= r,1,0)]\n\n<!-- always make sure that p2 is clockwise from p1 !! -->\n[h:macro.return\t= if(CW && CCW && IR, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "76c822e7-56d1-4286-8d94-f1f10cbd3d90",
          "commandChecksum": "4ae0e2de1593ca9a6b5f9f3ea04e175d",
          "propsChecksum": "88eac245a95f5c6690577dbf20665222"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "20",
        "index": 412,
        "label": "manualText",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:hasTbl\t= json.contains(json.get(getInfo(\"campaign\"),\"tables\"), \"tbl_Image\")]\n[h, if(hasTbl):pointerImg\t= tableImage('tbl_Image',30) ; pointerImg\t= \"\"]\n[h:hasTbl\t= json.contains(json.get(getInfo(\"campaign\"),\"tables\"), \"tbl_Image\")]\n[h, if(hasTbl):bookImg\t\t= tableImage('tbl_Image',26) ; bookImg\t\t= \"\"]\n\n[h:output = \"\n<font color=red><b><u>ON TOKEN MOVE MANUAL<\/u><\/b><br><\/font>\n<br>\nA first and foremost rule that applies to ALL SPECIAL PADS: DO NOT ROTATE THE TOKENS!! Of course if they're square or round it does not matter, but if they're rectangles you cannot rotate them as the 'footprint' will remain unrotated. So you CAN RESIZE but you CANNOT ROTATE<br>\n<br>\n<b><u>Big change between version 9 and 10: Pits and Traps have been replaces by EventPads.<\/u><\/b><br>\nI've written a conversion tool (Convert Trap/Pits - ONLY on the lib:OnTokenMove, NOT in the BoT-macro panel) to convert campaign files created in version 9 or earlier, which make use of the Pits and Traps. \nYou will only need to run this macro once for the whole campaign file. \nIn addition you will need to rewrite the code for the Pit macros a bit, as the passed on arguments differ and the 'Trapped' state is no longer required. \nFinally you need to move ALL macros you created for pits and traps to the new lib:MacroEvents token. <br><br>\n\n<font color=red><b><u>UPGRADING TO A NEW VERSION<\/u><\/b><br><\/font>\nWith the addition of the lib:EventMacros you no longer need to redo all your settings nor need to move or copy paste any personal event macros that you created on that lib. All *your* settings are stored on lib:Eventmacros. So when you upgrade a version you ONLY need to do 2 things:<br>\n1. replace the lib:OntokenMove for the new one (delete first, then drag the new one on your map)<br>\n2. run settings once!<br>\nNote that when you run the settings that its possible that you get some *errors* in the form of input request for strange variables. These are the new settings that have been added but obviously not yet set on *your* lib:eventMacros. You only need to click 'ok' (depending on the update this can be many clicks) and then the settings menu will eventually pop-up. Always check the settings (they should not have changed) and then finally click ok. If you *did* get the input requests then very likely you will notice that there are more settings available. If you only only clicked 'ok' during the input requests, then they all should be turned off by default.<br>\nTHAT'S IT!<br>\n<b>If you upgrade from version 13x or lower<\/b> then you will also need to update the table (see implementation section). It is also prudent to update the lib:EventMacros (for the latter its enough to update the macros, but if you have none of you own I would advise to simply update the entire lib).<br>\n<br>\n<font color=red><b><u>IMPLEMENTATION<\/u><\/b><br><\/font>\nBelow you can find a general and rough guide for implementing the BoT. A more detailed and up to date version can be found <a href = 'https://forums.rptools.net/viewtopic.php?p=274498#p274498'>here<\/a>.<br>\nThe necessary bare actions needed to get this thing on the road, I've put in <b>(parenthesis)<\/b> for which feature this step is required:<br>\n- If you just dropped the .rptok file onto a map, run onCampaignLoad first (though if you're reading this you likely did<br>\n- <b>(Summon Tokens) (=macro):<\/b> Drag the image_none.png to the base map.<br>\n- <b>(Roof & Foliage):<\/b> Load .mttable file from the special tokens into the tables panel<br>\n- <b>(Canopy):<\/b> Make sure there is a map called 'BASE' (either rename the map or change this in the Settings)<br>\n- <b>(Alt. Init. Token):<\/b> Drag the lib:Coords.rptok token onto (BASE) map<br>\n- <b>(EventPads):<\/b> Requires a lib:EventMacros token with at least one macro on it. <br>\n- <b>(Token Door Switches):<\/b> Create 'isButton' state:<br>\n    * Click on an existing state first (you can only add a state if you select one first ?!?)<br>\n    * Change name to 'isButton'<br>\n    * Change type to Image, you can load the 'State.isButton.png' as state image.<br>\n    * Click add and close<br>\n    * Also Create 'Locked' state. Show To: GM Only, Type: Image, you can load the 'State.Locked.png' as state image.<br>\n    * Drag the Lever.rptok file onto the 'BASE' map. MAKE SURE YOU HAVE CREATED THE ISBUTTON STATE <B>BEFORE<\/B> YOU DRAG THIS TOKEN ONTO THE MAP<br>\n- <b>(Path Tracking):<\/b> Create 'pathFeet' state (image State.pathFeet.png)<br>\n- <b>(Event Areas):<\/b> Create 'Special Area' state (image State.Special Area.png)<br>\n- Select the lib:onTokenMove and Drag the '(drag to) Campaign Macros' which you want to use to the Campaign panel (though its enough to only drag the 'Bag of Tricks Macro' macro).<br>\n- Run the 'Settings' macro, here you can exclude maps from the initialization (checked) check if these are set right.<br>\nOff you go.<br>\n<br>\n<font color=red><b><u>REPORTED MISHAPS<\/u><\/b><br><\/font>\n<b>GENERAL REMARK:<\/b> note that YOU CAN ONLY HAVE ONE <font color=#FF0000><b>'ONTOKENMOVE' MACRO<\/b><\/font> IN YOUR CAMPAIGN. So if you e.g. create a backup of the old lib token, you will have 2!! One on the backup lib and one on the new one. Stuff will go haywire!! (actually you *can* have two ontokenmove macros within a campaign, but they will both be activated on the event, which very likely will have unpredictable results. In short: its bad practice)<br>\n<b>THE PADS DON'T WORK:<\/b> There can be several reasons: <br>\n1. the onTokenMove event is turned off. This can be checked by checking te name in group 2. on the lib:OntokenMove: if it says #onTokenMove its turned off. Hit the 'Turn On Token Move Event On/Off' macro. <br>\n2. you just dragged the libs onto your map and you forgot to run onCampaignLoad (or save and reload the campaign file)<br>\n3. you forgot to run the settings. <br>\n4. 'visible to players' is turned off. Double click on token --> config --> check the checkbox on the right 'visible to players' <br>\n <b>ERROR:<\/b> if you get an error '<b><font color=#FF0000>Error executing movedOverToken: the token name or id {1} is unknown.<\/font><\/b>' this means that the code is looking for a token that is not on the map. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>\n <b>ERROR:<\/b> if you use a interteleport and on destination you're asked for coordX and coordY then you the two paired interteleports do NOT have the same name/number. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>\n<b>ISSUE:<\/b> when snap to grid is turned of and you try to teleport more than 2 tokens that overlap, the teleport MIGHT not work.<br>\n<b>ERROR: Can't find map '1' (or any other number).<\/b> If you name your maps 01, 02 or 001, 002, etc. then in the code MT script will transform these 'numbers' into real numbers: 1,2,etc and those maps do not exist. So make sure that the map name cannot be recognized as a number OR be making it an actual number. So 1,2,3 would work and 01m, 02m, etc. also.<br>\n5. there is a lib:Coords token on the map (white token with blue cross hairs). This appears when using alt.init.map. When you change the map you'll need to run both this macro on that map AND Initialize Pads. If you no longer wish to make use of the alternative method, you'll need to delete the lib:Coords from that map. Note that there is also a lib:Coords on the BASE map. This one is not used. Only the ones where the map name is after the 'lib:coords ' are in use. <br>\n<br>\n<font color=red><b><u>INITIALIZE MAPS AND ALT.INIT.MAPS<\/u><\/b><br><\/font>\nWhen you start using the special pads (described here below). You'll need to initialize the campaign file so the BoT 'knows' that they're there. To do this you need to run Initialize Maps. <b><u>Everytime you add, delete or rename a special pad, you will need to run this again<\/u><\/b>. You can however move the tokens (on the same map) anywhere you like. The only thing that initialize maps does is seek and log all the special pads so the on token move event can quickly access them.<br>\nThere is an alternative to this: alt.init.map. This macro works fundamentally different. It actually maps the coordinates of all the special pads on the map. Then when moving over the map the on token move event can check whether you intersected with an area where a special pad is situated. This means that you'll need to run this macro everytime you create, delete, rename AND move a special pad!! \nThe advantage of this method is the fact that when you have a LOT (> 100) special pads e.g. a forest with 'Canopy' tokens then its faster then the traditional method. However it IS slow to initialize (can take 10's of minutes) and it IS generally slower then the initialize maps method.<br>\nWhen using this method you'll notice that a 'lib:Coords <mapname>' is created on the map. On this lib all the spec. pads coords for that map are stored. AS LONG AS THAT TOKEN IS ON THAT MAP IT TAKES PRECEDENCE OVER THE GENERAL INITALIZE MAPS METHOD. As soon as you delete it, then the 'normal' method will be used again. <br>\nNotes:<br>\n- When using interPads (teleport between maps) on a lib:coords map you need to run both initalize maps and alt.init.maps. As alt.init.maps only works for that map and does not check to which other interPad the interPad is linked. <br>\n- In the settings there is a tab to turn off 'initialize maps' for certain maps (again e.g. a forest) this will speed up the initailize method method when you exclude maps which make use of alt.init.maps. Do however keep in mind that when you turn it off, interPads to and from that map won't work!<br>\n<br>\n<font color=red><b><u>SPECIAL TOKENS<\/u><\/b><br><\/font>\nThis drop-in runs different macros whenever a token moves over a 'special' pad. The following special pads are supported:<br>\n- InterPad n<br>\n- PadStart n<br>\n- PadEnd n<br>\n<br>\n- InterPadBorder n<br>\n- PadStartBorder n<br>\n- PadEndBorder n<br>\n<br>\n- InterJump n<br>\n- InterDrop n<br>\n- PadJump n<br>\n- PadDrop n<br>\n<br>\n- InterJumpBorder n<br>\n- InterDropBorder n<br>\n- PadJumpBorder n<br>\n- PadDropBorder n<br>\n<br>\n- AssignPad [group] [index]<br>\n- EventPad n<br>\n- Canopy n<br>\n- Foliage n<br>\n- Roof n<br>\n- Linked n1 [Special Pad] n2<br>\n- Linked n1 Bridge n2 (i.c.w. Roof, Foliage or Canopy)<br>\n- MappedPad n<br>\n- ShadowPad n Ground & ShadowPad n Floor<br>\n- Ward n<br>\n<br>\nWhere 'n' is a identifier (1,2,3, etc. but with version 26 anything is allowed, so 'Sea', 'Yet another level', 'are you sure' etc. is also possible). This means that these token names are reserved. Should you use such a token nonetheless than this likely will show up in the error report from the 'initialize pads' macro. <br>\n[group] and [index] will be explained later with Assignpads<br>\nAs mentioned, ANY identifier is allowed as long as its unique for that token. Originally this was restricted to numbers only. If you want this back then there is a setting: 'settings > general > Numeric Id for special pads only' that you can check. This way only special pads with a numeric identifier are initialized. Do note however that 'Linked' pads (see below) will not work!! <br>\n<br>\n<b><u>The rules:<\/b><\/u><br>\n<b>In general<\/b>: If you want to use special pads just name a token e.g. 'Ward 1' (without the ''). Name the next 'Ward 2' etc (the numbers do not need to be contiguous). The Initialize map macro will check for duplicates and these will show up in the error report.<br>\n<br>\n<b>PadStart and Padend<\/b>: these are used to teleport a token from one to another a token on 'PadStart 1' will be teleported to 'PadEnd 1' and vice versa. So to pair two teleports (start and end) they need to have the same number.<br>\n<br>\n<b>PadJump and PadDrop<\/b>: these work exactly the same as PadStart and PadEnd, save the fact that it only works one way: PadJump --> PadDrop, not the other way round. These you can typically use for doors where the interior map of e.g. a house is situated somewhere else, this way a token can step through a door and appear on the interior map, similar the other way round, to exit a building you are teleported back to the 'outside' map<br>\n<br>\n<b>InterPad<\/b>: Note that for earlier users that the name has changed, it now starts with a capital letter!<br> These work the same as PadStart and PadEnd only they have the same name and are on different maps. So InterPad 1 on 'Grasslands' and Interpad 1 on 'Plains' are connected to eachother.<br>\n<br>\n<b>InterJump and InterDrop<\/b>: these work exactly the same as PadJump and PadDrop only these you use to teleport between maps, just like the interPad<br>\n<br>\n<b>PadStartBorder, PadEndBorder, InterPadBorder<\/b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to make certain that players are teleported to another section when they move over/into a certain section. Note that these work two way, so if tokens keep moving on them they get send to and back. The Jump/Drop versions below can be used to prevent that.<br>\n<br>\n<b>PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder<\/b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to divide larger maps into pieces and divide them over several maps then when a token walk over the 'border' its automatically transferred to the next map. By splitting these up into one way tokens you won't have the issue that when a token walk ONTO the border (and is thus transported) and then moves OVER the border its transported back again. The token actually will need to take a step 'back' (onto another one way telport back, if you put it there) before its transported.\n<br><br>\n\n<b>AssignPad<\/b>: AssignPad: These are teleport tokens to which you can assign ONE token. This token will be teleported as soon as the assign pad event is executed. Hence there are two supporting macros:<br>\n-  'Assign Tokens to Pads' and <br>\n- 'Execute AssignPads'. <br>\n<br>\nTo set these up you need tokens called 'AssignedPad Group Index'. Where 'Group' and 'Index' can by anything alphanumeric (so 1,2,3, etc and a,b,c,d, etc. and NOT ',<>?! etc. ) Some examples AssignedPad Red 1, AssignedPad Red 2, AssignedPad Alpha Jim, AssignedPad Alpha Tom. You can also leave out the group: AssignedPad 1, AssignedPad 2. <br>\n<br>\nThe advantage of groups is that the assign and execute macro menus will have a tab per group so you can more easily assign tokens and you can choose more easily to execute certain groups instead of all the pads.<br>\nIf you want to execute the teleportation without any interface, e.g. as part of an event then you can use the following line of code to do this:<br>\n[h:bot_execAssignPads(1)]<br>\nIts also possible to execute only one group (e.g. 'Red') as follows:<br>\n[h:bot_execAssignPads(1, 'Red')]<br>\n<br>\n<i><u>Notes:<\/u><\/i><br>\n- You do NOT need to run 'initialize pads' for these tokens to work<br>\n- You DO need to run 'assign tokens to pads' before these tokens work<br>\n- Make sure that there are no double or trailing spaces in the name e.g. 'AsssignPad..Attack.5.' (replaced ' ' with '.' for illustration) will generate an error.<br>\n- When you execute, you can turn off entire groups in the first tab, you do NOT need to turn of the checks for those pads individually in there corresponding tab.<br>\n- ALL the tokens need to be on the same map. Interteleport is NOT possible.<br>\n<br>\n\n<b>EventPad<\/b>: These tokens are triggered on certain events, which you can set prior to using them. To set an EventPad simply select one (or more) and click on the 'Set Event Pad'. This will pop up an input screen where you can link any macro that is placed on the lib:EventsMacros token and in addition you can set the token to trigger this macro for one or more of the following events:<br>\n- When a token is moved onto the EventPad<br>\n- When a token is moved off the EventPad<br>\n- When a token is moved over the EventPad<br>\n- When a token on the EventPad is moved but then placed back at its original spot (zero move). Note that Zero move event is turned off per default in the settings, so to make use of this event you will first need to turn it on globally in the settings. <br>\n- When a token on the EventPad is moved, waypoints are used, but the move ends back on the EventPad<br>\n- When a token on the EventPad is moved but remains on the EventPad (e.g. one step left on a big pad)<br>\nI have left the original Pit and Trap pad on the map (but converted) so you can still check out how these macros work. The 'reset Pit' (to reset the picture for the opened pit) macro still works.<br>\n<br>\n\n<b>Roof<\/b>: Any token called Roof n,will disappear and leave a red outline (halo) when a token moves over it and reappear when moved away from it.<br>\nYou can also choose to 'set' a roof with the corresponding button. When you do this you will get a list of doors (if any) which you can check. When you do this the token can only move in or out of the building (roof) through an OPEN door. It is thus vital that its actually an entry (so a door that is on the edge of the roof) and it will only work for doors that have been 'set'. This because you need to open the door before you can enter and an 'open' door can only be detected when its actually 'set'.<br>\n<b>Note that the 'warded roofs' only ward players, not gm's!!<\/b><br>\n<br>\nAn additional feature available from b90+ is 'apply VBL'. When this is checked the current VBL of the building beneath the roof is stored (on the roof token) and the VBL is replaced with a VBL Cross. This VBL Cross will be swapped with the building VBL as soon as a token moves onto the roof. \n<br>Note that this only works AFTER the maps has been 'initialized'<br>\n<br>\n\n<b>Foliage<\/b>: Same function as roof, only without the red outline (halo).<br>\n<br>\n<b>Canopy<\/b>: Same function as Foliage, only a tree trunk will appear in its place (see below for more info).<br>\n<br>\n<b>Linked<\/b>: Linked pads work for Foliage, Canopy and Roofs (you can mix them). When they are linked all are activated if one is activated (see below for more info). Additionally they can be used for bridges.<br>\n<br>\n<b>Linked Bridge<\/b>: Linked Bridge pads are linked pads but the when a token first moves over the bridge token and then over the e.g. linked Roof, the roof is NOT activated (<a href = 'http://bit.ly/1f5wn6X'>see video tutorial<\/a>).<br>\n<br>\n<b>ShadowPad<\/b>: Typically used for two floor maps on one MT map where the upper floor can look out to the ground floor, e.g. loft in a barn. When token on seperate levels step onto these pads a 'shadow token' is created on the other floor.<br>See below for more info.<br>\n<br>\n<b>MappedPad<\/b>: These are teleport tokens which you can map. When creating these pads, after initializing you'll get a pop-up where you can map the start destinations<br>\n<br>\n<b>Ward<\/b>: Any token called Ward n will prevent a token to be moved on. It will simply return the token to the original spot<br>\n\n<br>\n<b><u>THE TELEPORT TOKENS NAME SYNTAX EXPLAINED<\/u><\/b><br>\nHere a short description of where to think of for which names:<br>\n- 'start'/'end' means TWO WAY teleport<br>\n- 'jump'/'drop' means ONE WAY teleport, where 'jump' teleports and 'drop' not<br>\n- 'inter' means between maps, these tokens are linked by having the SAME name, while e.g. 'start'/'end' (always on the same map) are linked by DIFFERENT names.<br>\n- 'border' means that the teleport is activated not only when you step ONTO but also when you MOVE OVER the pad. Withouth the 'Border' they are ONLY activated when THE MOVE ENDS ON THE PAD.<br>\nAll the pads are linked by their number!! so a 'PadStart 3' will be linked with 'Padend 3' and an 'InterJump 2' on one map will be linked to a 'InterJump 2' on another map. <br>\n<br>\n<b><u>ADVANCED STUFF ROOF AND FOLIAGE<\/u><\/b><br>\nFirst let me explain how the roof and foliage work: in the tables there is an image stored that is completely transparent. When a token moves over either a roof or foliage token the 'roof' or 'foliage' image is removed and stored somewhere else on the token and the transparent image is placed instead of it. This way it looks like the foliage or roof dissapears. The advantage of the table is that that image can be retrieved always, no matter on which map you are. You can however also choose to do this differently by retrieving the image not from the table but from the handout section of the token itself. This has two advantages:<br>\n1. You don't need to load the tabel <br>\n2. You can use ANY picture. <br>\nTo show this I've prepped the two trees.<br>\nThe left tree (Foliage 1) has a seperate token beneath it of a trunk, when you move over it, the foliage will dissapear and you'll see the trunk token. <br>\nThe right tree (Foliage 2) is a single token (so no trunk beneath it), so when you move over that tree you'll see nothing. However if you look at the token properties you'll notice an image with a trunk in the token handout section.<br>\n<br>\nNow in the settings you can choose the setting 'Use alternative transparent iamge for foliage', checking this option, will first check the token handout of a token and if it finds an image it will swap it for the foliage image. If not, then it will take the picture from the table. <br>\nWhat you'll see happening now is that the left tree still dissapears, but the right tree will grow semi transparent and a trunk will appear. <br> This method will allow you to create 'special' tokens if you like. <br>\n<br>\n<b><u>CANOPY<\/u><\/b><br>\n<b>Requirements<\/b><br>\n- A Map in the campaign file called 'BASE' (you can change this required map name in the settings.)<br>\n- Images of tree trunks on that map on the OBJECT layer, which start their name with 'Trunk...'<br>\n- Note that the images replace the whole image of the canopy, this means that just an image of a tree trunk will be stretched over the full area of the Canopy image. Therefore you need to edit the trunk image so that a lot of transparent space surrounds it. Have a look in the example campaign to see what I mean. Typically the canopy is 20x the size (diameter) of the trunk, so if e.g. the trunk is 10px wide then the total span of the image must be 200x200 px. (with at the centre a 10x10px trunk image).,\n<b>Usage:<\/b><br>\nThe tree trunk images need to 'set' first. To do this run the 'choose trunks' macro, this macro will check the 'BASE' (or another map if you changed the settings) map for tokens on the object layer that start their name with 'Trunk...' and will provide a check list from which you can choose which trunks should be used and whic not<br>\nCanopy works in the same way as 'Foliage' with one important difference. When you initialize Canopy, the Canopy token handout is checked and when its empty an image of a tree trunk is put there. When you a pc or npc token moves over the canopy token, the canopy image is swapped for a tree trunk image.The tree trunk is randomly selected from the 'set' trunks from the 'choose trunk' macro.<br>\n<br>\n<b>Draw VBL<\/b><br>\nThis operation will only work when you have the 'Support VBL' setting turned on in the general settings. When you click on it, it wil automatically draw a Vision Blocking Layer cross over all trunks of the Canopy pads. The cross will have the size of 1 square. <br>\n<br>\n<b>Useful Stuff to Know about Canopy, Trunks and Trees<\/b><br>\n- Trunks are usually between 10 and 70 cm (that is 4 inch upto 2ft 4 inch)<br>\n- Canopy is typically 20x the size of the trunk so a 10cm trunk has a canopy of 2m (=+/- 2yards) and one of 70cm is 14m. <br>\n- The height of the tree = the width of the canopy (roughly)<br>\n- Typical spreading of trees in a forest is 5m (so on average 5 meters/yards between trees). The variance is actually very small but if you take into account thin or thick forest this can range between 3 and 7m<br>\n<br>\n\n<b><u>LINKED SPECIAL PADS (Roof, Canopy, Foliage & Bridge)<\/u><\/b><br>\n<b>Requirements<\/b><br>\nThe following setting: 'settings > general > Numeric Id for special pads only' must be UNCHECKED!.<br>\n<br>\nThe special pads Roof, Canopy and Foliage can be linked. When linked, they are ALL triggered when a token moves onto one of them. They will remain 'triggered' until no token is positioned on any of them.<br>\nTo link 2 or more tokens is very simple. Just add 'Linked n' to the front of the token name. 'n' here is the indentifier for the linked tokens. E.g. 'Linked 1' or 'Linked Forest' can be used as identifier. Just make sure that the entire identifier is ONE word (so no spaces), e.g. 'Linked A Forest' will generate an error.<br>\n<br>\nA special type in de linked tokens are 'bridges'. When a bridge is linked in the set of roofs then the roofs are NOT activated when the token ALSO moves over the bridge token.  <a href = 'http://bit.ly/1f5wn6X'>There is a video tutorial that better shows this.<\/a>\n<br>\n<b>Example:<\/b> lets take a map with the following tokens<br>\n- 'Linked 1 Canopy 1' <br>\n- 'Linked 1 Canopy 2'<br>\n- 'Linked Houses Roof 1'<br>\n- 'Linked Houses Foliage 3'<br>\n- 'Linked Houses Canopy NextToHouse'<br>\n- 'Linked 2 Roof 1' <br>\n- 'Linked 2 Bridge 1'<br>\n\nAfter initialization you will have three linked groups. The 'Linked 1' and 'Linked Houses' group. Now when a token moves over 'Linked 1 Canopy 1' (L1C1) then that image of that pad will be swapped for a tree trunk. At the same time the same will be done for 'Linked 1 Canopy 2' (L1C2). Should you now also move a token on L1C2 and then remove the first token from L1C1, then both pads remain 'activated'. Only after all tokens have moved off both L1C1 and L1C2 will they be de-activated.<br>\nAs you can see from the second linked group 'Linked Houses', you can use ANY identifier you like as long as it does not contain any spaces (' '). <br>\nFinally the Linked 2 group. If you drag a token over Bridge 1 and drop it onto roof 1, then the roof does NOT disappear!. If however you drag a token onto roof 1 WITHOUT moving it first over Bridge 1, then the roof DOES disappear!<br>\n<br>\n\n<b><u>SHADOWPADS <\/u><\/b><br>\n<b>Requirements<\/b><br>\n- Two ShadowPads with the same identifier and one with the ' Ground' suffix and the other with the ' Floor' suffix.<br>\n- Two Reference tokens with equal names and the the suffixes ' Ground and ' Floor'.<br>\nShadow pads link two floors of a building to eachother. When a token moves over a ShadowPad on one floor it will 'cast a shadow' on the ShadowPad on the other floor.<br>\nThe reference tokens are use to align the position of the real and shadow token. The ShadowPads are used to create or remove the shadow tokens. ShadowPads will be activated as soon as one or more tokens are standing on BOTH pads.<br>\nTypically you will put the ShadowPads on the background layer and set the size to freesize then size and place them as you wish. You check off 'visible' so the players won't see the pad.<br>\n<br>\nFor the reference tokens you need to do the following:<br>\n1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br>\ne.g. 'Stairs to Ground' and 'Stairs to Floor' or 'Reference Ground' and 'Reference Floor' etc. Only use alphanumerical characters and do NOT use the words 'Floor' or 'Ground' inside the name of the token. So do NOT do e.g.: 'The "Grounds" Ground' 'The "Grounds" Floor'<br>\n2. Make sure that the reference tokens are snapped to grid and medium sized.<br>\n3. Place one of the tokens on the ground floor and one on the first floor. Make sure that their position is aligned e.g. place both in the upper left corner of the room or in the exact centre etc. Just keep in mind that if you e.g. place the real token just below the reference token, that the shadow token will also be just below the (other) reference token.<br>\nYou can place them on any layer (so also the hidden) and you can set them to Visible to players or not.<br>\n4. Then select one of the reference tokens and hit the 'Set Reference' macro. Select the shadow pads to which it should be linked and hit ok.<br>\n<br>\nThe tricky part here is that the shadow pads will check to which reference token the real token is closest to<br>\nand assume it belongs to THAT reference token. So make sure that the real token is always closest to one<br>\nreference token on one of the maps. The safest method is by placing the reference tokens in the centre of both<br>\nmaps.<br>\n<br>\nTo clarify: envision two floors created in maptool adjacent to eachother. So on the left you have the ground <br>\nfloor and on the right you have the first floor. Now place both reference tokens in the upper LEFT corner of<br>\nboth floors. Then place the Player token in the upper RIGHT corner of the GROUND floor (left map). In that case <br>\nthe player token will be closer to the reference token on the FIRST floor (right map). In this case the shadow<br>\npads will thus assume that the player token is on the FIRST floor (e.g. apparently floating outside).<br>\n<br>\n<font color=red><b><u>EVENT BUTTONS<\/u><\/b><br><\/font>\nEvent buttons are tokens that, when selected by a user, activate a macro. Here you can think of simply posting a message in the chat, to moving all user to another map. <br>\n<br>\n<b><u>CREATING EVENT BUTTONS<\/u><\/b><br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the code that is activated when the button, e.g. 'Switch To Map' (This is something you will need to do yourself, but I have added two example macro on the lib.)<br>\n2. Select the button (any token on the token layer will do) to which that macro should apply e.g. 'Move to Fair Haven'<br>\n3. Run the macro 'Set Event Button'<br>\n4. Select 'Switch Map' from the list<br>\n5. In the 'Give Arguments' box enter the arguments as a stringproperty, e.g.'toMap=Fair Haven'<br>\n<br>\nHere it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>\ncontain ONLY alphanumeric  characters!<br>\nNote that you can give multiple arguments! Just seperate them with a ;.<br>\nE.g. toMap=Fair Haven;message=Going to Fair Haven;<br>\n<br>\n6. Click OK. Now everything is set up<br>\n<br>\nTo use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>\nbut it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>\nmake this pop-up small, but you cannot close it (else the buttons will not work).<br>\n<br>\nIf you now click on the button 'Switch to Fair Haven' the macro 'Switch Map' is activated.<br>\n<br>\n<font color=red><b><u>EVENT PADS<\/u><\/b><br><\/font>\nEvent pads are tokens that, when a user moves a token on/off/over it, it will activate a macro. Typical use for this is a trap.<br>\nThese pads are quite similar to Event Buttons, with the difference that here you need to make a move action to activate the pad instead of simply selecting the button.<br>\n<br>\n<b><u>CREATING EVENT PADS<\/u><\/b><br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group: 'Event Pad Macros', containing the code that is activated when Event is triggered. For example 'Spear Trap<br>\n2. Select an 'Event token'. This is a token which name starts with 'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'. This token can be placed on any layer<br>\n3. Run the macro 'Set Event Pad'<br>\n4. Pick an Event macro from the list, e.g. 'Standard Pit'.<br>\n5. Then select the events on which this macro is triggered. (they have tooltips)<br>\n7. Click OK. <br>\n8. Run 'Initialize Maps'<br>\nNow everything is set up<br>\n<br>\nTo activate the pad you must move a token e.g. onto the pad. The macro will be activated if one of the selected events is triggered.<br>\n<br>\n<font color=red><b><u>EVENT AREAS<\/u><\/b><br><\/font>\nEvent areas work roughly the same as Event Tokens. Depending on the movement of the token in respect to the area they trigger a macro. This macro can be a trap a pit or difficult terrain. The difference with the event-tokens is:<br>\n- Event tokens can be moved around (on the same map) without the need to reinitialize<br>\n- Event tokens are images and as images can be influenced more easily, e.g the crack that turns into a pit when you walk over it.<br>\n- Event Areas can be ANY size you like (with a resolution of the grid cells), they can also have holes in them, be seperated all over the map, but they still remain ONE area. <br>\n- Event Areas are significantly faster when going for multiple event areas vs event tokens.<br> \n<a href = 'http://bit.ly/YEhS4a'>also see this video tutorial<\/a><br>\n<br>\n<b><u>CREATING EVENT AREAS<\/u><\/b><br>\n<br>\nTo create an event area you need to do the following:<br>\n1. Define the area (the coordinates it covers)<br>\n2. Assign the area (to an event macro like the pit)<br>\n<br>\n<b>Step 1: Define Area<\/b><br>\nWhat needs to be done is to get cell coordinates inside a json array. To do this there are 2 methods: lastPath and getTokens.<br>\n<i>LastPath method<\/i>: Grab any token with an unique name and (literally) drag it over the map to create a path. You can use the space bar to create waypoint. You can have overlapping paths as the coordinate will only be saved once, BUT you need to do it in ONE go. Once you have the path complete you drop the token:<br>\n- start 'Define Token'<br>\n- select the 'last path' method<br>\n- fill in the name of the token and give a name to the area and click ok. <br>\nNow the area is created. This is a pretty simple and easy way to create an area, but you cannot create two seperate parts.<br>\n<br>\n<i>GetTokens method<\/i>: Again grab any token, but this time with a unique state. (It has to be the ONLY token on THAT map with THAT state). Copy paste this token over the areas you wish to define. If you have e.g. 5 pits that all 5 use the same event macro then you can create these 5 pit areas in one go (effectively they are thus ONE Defined area, covering 5 parts of the map). Once done:<br>\n- start 'Define Token'<br>\n- select the 'Use coords...' method<br>\n- fill in the name of the STATE <br>\n- select the LAYER you put those tokens on <br>\n- give a name to the area and click ok. <br>\nNow the area is created. This is a bit more work, but note that you can first copy paste 5 tokens, then select all 5 and start copy-pasting with that group, rinse and repeat and you can build pretty large areas in no time using this method. <br>\n<br>\nNote that there is a 'Reset Show Area Tokens' option at the bottom, I'll get to this later with the 'Show Area' macro.<br>\n<br>\n<b>Step 2: Assign Area<\/b><br>\nRun the Assign Area macro. Per Area that you created there will be an input section, sorted per map. One input section contains a dropdown box with ALL the macro on the lib:EventMacros, so you will also find e.g. onCampaignLoad, which is not very useful to link. Pick the macro from the list that you created for that area and then select the triggers that actually trigger the macro to be run. Note that all 6 triggers are mutually exclusive (you can NEVER trigger 2 of them in one move). Click ok and you're golden. <br>\n<b>Important Note<\/b> that in order to 'redefine' an area its very useful if the AreaToken has a unique State set to it on the BASE map! For the example campaign I've given it the state 'Special Area'.<br> \n<br>\n<b>Step 3: Show Area (optional)<\/b><br>\nThis will fill the defined area with the overlay tokens which should be located on the BASE map. This servers two purposes.<br>\n1. You can quickly show an overlay using one of the overlay tokens. You can choose e.g. the hidden layer to show it to GM(s) only, or background layer to show to all<br>\n2. If you pick the <i>Area Marker<\/i> token as overlay (if it exists it will be the default choice) then you can rearrange the area (delete, add, move overlay tokens) and then redefine the area.(define and use the same name, this will overwrite the old one). <br>\nAdditionaly this macro can be used to delete areas from the map. Simply check the areas you wish to have removed, check the 'delete' checkbox and click ok.<br>\nMore info about this macro you can find in the tooltips when you run this macro. <br>\n<br>\n<b><u>SPECIAL EVENT AREA: <i>Limit Movement<\/i><\/u><\/b><br>\nWhen assigning and Area to an even macro, there is one macro 'Limit Movement' that differs from the rest. If you Assign the area to THAT macro then it will be run BEFORE ALL THE OTHER CHECKS. The reason is that IF you work with limited movement e.g. 10 steps AND someone walks over difficult terrain (double move cost), but does not realise it and moves her token with 10 steps (actually 20) straight onto a teleport or a trap. Then you would FIRST like to check whether the token could have reached that and THEN trigger that pad. You could probly use it for other ends as well, but this is what its intended for. \nBecause every system is unique, the current macro show you how it works when you move around, you need to adjust the macro to fit your needs. \nNote that the 'Limit Movement' is turned OFF per default in the settings. By setting the value to any numeric value other then 0 you will turn it on. <br>\n<br>\n<font color=red><b><u>ANIMATED DOORS, DOOR SWITCHES AND VBL AUTOMATION<\/u><\/b><br><\/font>\n<b>Parameters<\/b><br>\nTo make use of this functionality you need to create special 'door' tokens, with the following parameters.<br>\n- For rotating doors the length of these tokens needs to be twice the length of the door (for sliding doors this is not necessary). The width is irrelevant. Select a couple of doors in the campaign file to get an idea. <br>\n- The name of the token needs to start with 'Door ' followed by an identifier, usually a number, but can also be a string. <br>\n- In case of a double door, there needs to be a mirrored copy of the 'main' door with the same name ending with 'a'. E.g. if the main door is 'Door 5' then the mirrored copy must be called 'Door 5a'. You only need to setup the main copy.<br>\n- When using the animation feature (that is you've set a timer) make sure that 'snap to grid' is turned off for the door token. <br>\n<br>\nNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>\n<br>\n<b>Setup<\/b><br>\nTo create a single animated door you simply need to select the door and click 'Set Door' and enter the parameters for that door:<br>\n<u>angle closed door<\/u>: When you set the door for the first time, the current angle of the door is automatically picked. Its thus best to put the door in the closed position and then run the setup. If you copy paste a door that has already been set, the set value will be taken. To reset it, make sure this field is empty, click save and run setup again. You will now get the current angle of the door.<br>\n<u>degrees open door<\/u>: The is the amount of degrees the door turns when you open it. Half open would be 45, open would be 90 and wide open is 160 (default)<br>\n<u>open clockwise<\/u>: The way the door turns<br>\n<u>double door<\/u>: If there is another door with the same name as the door you set, but with 'a' at the end (e.g. 'Door 5a') then you can check this. When you open the door, then 'Door 5a' will also open in a mirrored direction<br>\n<u>Description<\/u>: This text will appear in the 'toggle doors' macro<br>\n<u>time (ms)<\/u>: The amount of time it takes for the door to open. 1000 = 1 second. The default is 2000 (2 seconds). If you set the time to 0 then a seperate routine is run instead which simply changes the angle of the door WITHOUT any animation<br>\n<u>Switch<\/u>: When you check this then a Switch Token will appear close to the door, when you click on this token the door will automatically open/close. You can change the image if you like, resize it, move it and even copy paste it if you want multiple switches that correspond with that door (e.g. one on each side). Do keep the switch on the TOKEN layer though (else you can't select it)<br>\n<u>Locked<\/u>: (works only icw Switches) This will set a 'Locked' State on the door. When a player clicks on the switch a message will be send to the chat explaining that the door is locked. To unlock the door simply remove the state (or run 'set door' once again and decheck 'locked')<br>\n<u>Proximity<\/u>: This will check the proximity of player owned tokens close to the switch. The proximity is counted in number of cells. If no player owned tokens are close enough, the door won't open. You can set this to '0' to turn this off. GM's won't be checked, so they can always open the door.<br>\n<br>\n<b>Setup VBL Options (Vision Blocking Layer)<\/b><br>\nThis TAB is only available if you check 'VBL support' in the general settings. And you should only check that if you have a MT version that supports VBL macro's<br>\n<u>Use VBL for door<\/u>: this is the overall setting if you turn this on then toggling the door will also change the VBL of the door. Uncheck will NOT do ANY VBL operations<br>\n<u>Peek ... and Open...<\/u>: when you check none of these options but you have checked the use VBL on doors then toggling the door will default to open the door fully AND do the VBL operation. If you check one of the boxes then it will ALWAYS default to that operation, if you check more then one, you will get a pop-up request when you toggle the door, asking you which of the options you wish to execute. <br>\n<br>\n<b>Note<\/b>: When you have set the door, the name of the door will appear in the GM Notes. So when the door is on the object layer and you click on it while on the token layer, the name of the door will appear!<br>\n<br>\n<b>Rules for Door Image when using VBL !!<\/b><br>\nWhen using VBL the image of the door has to comply to 3 rules!<br>\n1. The ORIGINAL image (so when viewing it in e.g. an image editor and NOT in maptools) has to have the HINGES LEFT and the DOOR KNOB RIGHT<br>\n2. The LENGTH of the entire image has to be TWICE the size of the picture of the door. So when the door covers 1 square, the entire image covers 2 squares. The empty space has to be on the hinges side. So: |      o---^-| (where 'o' is the hinge, '^' is the door knob and '|' are the image boundaries.) Check out the VBL map in the BoT campaign file to see what I mean. <br>\n3. If you don't use VBL your door can cover any amount of squares. However the current VBL ONLY works for 1 square door images (thus 2 square image when taking rule 2 into account)<br>\n<br>\n<b>Operating doors<\/b><br>\nThere are several ways to operate a door:<br>\n1. Select the door and run the 'Toggle Door' macro from the campaign panel.<br>\n2. Impersonate the door and enter '[ r:toggleDoor()]' in the chat<br>\n3. Enter '[ r:toggleDoor(5)]' in the chat to operate 'Door 5'<br>\n4. Create a macro on the campaign panel with: '[ r:toggleDoor(5)]' to specifically operate 'Door 5' with a one click button<br>\n5. Run 'Toggle Door<b>s<\/b>' macro from the campaign panel, this will give you a list of doors that have been set up AND are on the OBJECT layer. The ones you select will be animated.<br>\n6. Use a Switch (see above on how to add one). To operate a switch, you must make certain that you have the 'Switch Frame' active! Click on 'Activate Switches' on the campaign panel or the BoT macro panel.<br>\n<br>\n\n<font color=red><b><u>UTILITY MACROS<\/u><\/b><br><\/font>\n<br>\n<b><u>ANIMATE MOVEMENT<\/u><\/b><br>\nWith this function you can choose to use the input panel by selecting a token and clicking 'Animate Move' in the 'Animation' window. However this is a bit cumbersome for e.g. casting a fireball. The 'better' way is by calling the macro directly:<br>\n<br>\n<b>bot_animateToken<\/b><i>(tokenID [,x,y,relative,onImpact(-1:bounce; 0=continue; 1=stop),layer(json.object),vbl(1; 0),delay(ms)])<br><\/i>\n<br>\nIf you give at least the token Id and the x and y coordinates then this function will run automatically with the following 'default' settings: relative=0, onImpact=0, layer='[]', vbl=0, delay=0.<br>\n<br>\n<u>What do these settings mean:<\/u><br>\n<b>- X (#cells)<\/b>: The destination X coord of the token, either absolute or relative to its current position<br>\n<b>- Y (#cells)<\/b>: Dito X, but then Y<br>\n<b>- Delay (ms)<\/b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br>\n<b>- Relative (1/0)<\/b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br>\n<b>- onImpact - Bounce (-1)<\/b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An 'obstacle' is defined by the below settings. <br>\n<b>- onImpact - Continue (0)<\/b>: the token is moved to its destination no matter what<br>\n<b>- onImpact - Stop (1)<\/b>: the animation stop as soon as it meets an obstacle<br>\n<b>- Token (and the other) layer(s)<\/b>: 'The 'checked' layers will be searched for obstacles' where the token can run into while its moving<br>\n<b>- Vision Blocking Layer<\/b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc. <br>\n<br>\nNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>\n<br>\n<b><u>ANIMATED TEXT<\/u><\/b><br>\nThese are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the 'Bag of Tricks macro panel'. When the text animation is activated a frame will pop-up on every attached client pc printing the text. <br>\n<b>- text<\/b>: The text you enter here will be animated in a frame<br>\n<b>- title<\/b>: The title of the frame<br>\n<b>- position<\/b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won't be animated<br>\n<b>- html-header<\/b>: Here you can set some basic make up for the frame itself. If you enter 'Default' it will show a black-green frame with courier font<br>\n<b>- width & height<\/b>: The dimensions of the Frame<br>\n<b>- delay<\/b>: Amount of delay per character printed in ms.<br>\n<b>- upper<\/b>: Print the animated text in UPPER CASE<br>\n<br>\n<b><u>BENCHMARK<\/u><\/b><br>\nThis tool is specifically developed for Maptool macro developers and can be used to test the execution time of several different macro to see which method is the fastests<br>\nSimply create one or more macro in the group 'Benchmark Macros' on lib:EventMacros (there has to be one empty macro called 'Default' in that group as well.). Then hit the Benchmark button on the menu. A form pops-up asking you the amount of iterations including an indication of how long each iteration set roughly takes. <br>\nE.g. 100 (~2 seconds) means that each macro will run 100 times and then the total time is divided by 100 and the time it takes to run Default is deducted from that result. The resulting time is thus the execution time it takes to run that macro one time. <br>\nWhen more then 1 macro is tested, then a comparison result is given with a normalization overview with the fastest as base. This means that if e.g. macro1 takes 2 seconds and macro2 takes 4 seconds that the normalization will show that macro2 takes 2x as much time as to run macro1.<br>\nNote that macro in the 'Benchmark Macros' group which name starts with '@' will be skipped by the benchmark test. This way you can swiftly turn off certain macros for non-testing.<br>\n<br>\n\n<b><u>EMBARKATION (VEHICLES)<\/u><\/b><br>\nThere are two embarkation macros in the menu. Embarkation (in Setup) and Toggle Embark (in Utility). To use these macros a token named VPCU is required on the map where you use these macros.<br>\nThe workings are simple: select a Token (any token) that act as <i>container<\/i> (typically a vehicle like a car). Then click on <i>Embarkation<\/i> a menu will pop-up where you can pick tokens, surrounding the container token. The tokens you select will embark on the container (vehicle).<br>\nThis effectively means that they are moved onto the VPCU token.<br>\nNow you can move the container/vehicle around over the map and at any time you wish to disembark, you can click on <i>Toggle Embark<\/i> in the Utility Menu. This will swiftly place the tokens around the container. Clicking the toggle again, will move the tokens back to the VPCU.<br>\nThus Embarking/Disembarking is done with the toggle button. Changing tokens that are linked to the container is done with the Embarkation macro. Note that thus the Embarkation macro can also be used to embark/disembark tokens (but is a bit of a hassle). <br>\n<br>\n\n<b><u>FORCE SELECTION<\/u><\/b><br>\n(This is an alternative to the full screen toggle but much more demanding. Force selection and Toggle Full Screen mode are NOT related)\nThis is a very specific add-on that most of you likely won't be using, but it can be quite useful. You can run two instances of MT on your pc, connected and both set to gm. When you combine this with 'Always on Top' (a free aplplication with which you can force windows application to remain always 'on top' even if another window is active. This way you can have e.g. your campaign macros and chat window visible while using the full screen modus. The issue however is is that if you use macro's that are set for 'apply to selected token', that the token you happen to have selected on you 'full screen' client (Master), is not necessary selected on your 'show chat and campaign button' client (Slave). Specifically for this reason I've created an extra option into the Bag of Tricks. IF you login to the Master with a slave that has the gm-name <b>forceButtons<\/b> (the Slave must also be GM !!) then when you select a token on the Master it will also be automatically selected on the Slave. This way you ensure that the macros always work as intended. To activate the 'syncing' you will need to first run the <b>Activate Switches<\/b> macro. To summarize:<br>\n- Start GM server (Master)<br>\n- Start another instance of MT and login to the GM Server with username: forceButtons (Slave)<br>\n- on the Master run 'activate switches', a frame should appear, this is used for the onTokenSelectionEvent<br>\n- Start 'Always on Top' (google it and download it)<br>\n- Undock the panels from the slave that you wish to use, including the 'toolbar' <br>\n- Make the Slave map window very small (don't minimize)<br>\n- Lock the Slave's toolbar so its always on top<br>\n- Switch to the Master and set it to full screen. <br>\n- IF you did everything alright then the toolbar should remain on top, when you select that then the undocked windows like campaign and chat will pop up over the full screen map. <br>\n- When you select a token on the Master, it should now also be selected on the Slave. <br>\n<br>\n<b><u>GROUP MOVE & GROUP SELECT<\/u><\/b><br>\nThese are two distinct functions that have nothing to do with eachother. 'Group Move' will move the entire group when one token of that group is moved. 'Group Select' will select all the other tokens of the group when one token is selected. 'Group Move' is useful for e.g. battles with grouped units. 'Group Move' has for this reason also several formation and rotation buttons. These will NOT work for 'Group Select' groups. 'Group Select' is useful when creating maps and you want to group several tokens into one selectable object. <br>\nBoth grouping methods work as follows: select a group of tokens and click on the 'Group (...)' macro. In addition for the 'Group Move' you are asked to enter a name for the group. Don't use any funky characters for the group name like: ,; . 'space' etc. It might break. Another additional option for 'Group Move' will become available if you turn on 'Show group panel on select' in the bot-settings: when you have the 'activate switch' panel turned on (see 'token buttons') then every time you select a token of a 'move group' the 'group macro panel' will pop up, giving you the extra options like rotate clockwise, counterclockwise (both in steps of Free, 45 or 90, see below), spread and contract. To clear a group, simply select one or all the tokens and click 'clear group'.<br>\n<br>\n\n<b><u>INVISIBILITY<\/u><\/b><br>\nThese functions can be turned off or on the in the settings-->toggle tab. It uses <i>visible to owner only (VTOO) function<\/i>. When a token is set to invisible the VTOO is (automatically) turned on. Any token that has <i>See invisibility<\/i> turned on will be added as owner to the invisible token when the invisible token is in range. Any token that has <i>Purge invisibility<\/i> turned on will turn off the VTOO setting as long as its in range. Any token that has <i>Annul invisibility<\/i> turned on will terminate the invisibility permanently (until turned on again) for any token in range. Here the full workings of the required functions and what needs to be done:<br>\nSETTINGS:<br>\nIn the settings under the toggle tab you can find:<br>\n<b>Invisibility<\/b>: check this to make use of this functionality<br>\n<b>Invisibility State<\/b>: you can create any state you like for tokens that are invisible, HOW you name the state e.g. <i>invisible<\/i> is what you need to enter here.<br>\n<b>Purge State<\/b>: you can create any state you like for tokens that can purge invisibility, HOW you name the state e.g. <i>purge_invisible<\/i> is what you need to enter here.<br>\n<b>Annul State<\/b>: you can create any state you like for tokens that can annul invisibility, HOW you name the state e.g. <i>annul_invisible<\/i> is what you need to enter here.<br>\nTo make use of these function you can either run the bot macros directly or implement their corresponding functions in your own macro. They all DO need to be called for their appropriate function\n<table border=1><tr>\n<td><b>Campaign Panel Macro<\/b><\/td><td><b>function<\/b><\/td><td><b>Description<\/b><\/td><\/tr><tr>\n<td>Start Invisibility<\/td><td>\t\t[h:bot_startInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> invisibility.\t\tEffect: tokens get a state and VTOO is turned on.<\/td><\/tr><tr>\n<td>End Invisibility<\/td><td>\t\t[h:bot_endInvisibility([tokenList])]<\/td><td>\t\tturn <b>off<\/b> invisibility.\t\tEffect: state is removed and VTOO is turned off.<\/td><\/tr><tr>\n<td>See Invisibility<\/td><td>\t\t[h:bot_seeInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> see invisibility. \tEffect: tokens get a state. Ownership will be added to all invisible_state tokens in range.\tRequired property: w42.seeInvisRange. \t<\/td><\/tr><tr>\n<td>Saw Invisibility<\/td><td>\t\t[h:bot_sawInvisibility([tokenList])]<\/td><td>\t\tturn <b>off<\/b> see invisibility .\tEffect: state and ownerships are removed.<\/td><\/tr><tr>\n<td>Purge Invisibility<\/td><td>\t\t[h:bot_purgeInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> purge invisibility .\tEffect: tokens get a state and VTOO is turned off for all invisible_state tokens in range.\tRequired property: w42.purgeInvisRange.\t<\/td><\/tr><tr>\n<td>Purged Invisibility<\/td><td>\t[h:bot_purgedInvisibility([tokenList])]<\/td><td>\tturn <b>off<\/b> purge invisibility. Effect: states are removed, VTOO is turned back on for all invisible_state tokens in range (IF they are not purged by another token!).<\/td><\/tr><tr>\n<td>Anul Invisibility<\/td><td>\t\t[h:bot_anulInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> anul invisibility. \tEffect: tokens get a state. Visibility is ended for all tokens in range.\t\t\t\t\tRequired property: w42.annulInvisRange.\t<\/td><\/tr><tr>\n<td>Annuled Invisibility<\/td><td>\t[h:bot_annuledInvisibility([tokenList])]<\/td><td>\tturn <b>off<\/b> anul invisibility.\tEffect: states are removed. <\/td><\/tr><tr>\n<td colspan=3>These functions you call to turn the specific functionality on or off. By default it applies to the selected token(s), optionally you can give a list of token as argument. When you run the macro from the campaign panel it will run for all selected tokens. All detection macros (see/purge/annul) require a <i>Range<\/i> property. If the property is not set (or not numerical) the the <i>turn on<\/i> macros will show an input pop-up asking for these values. The values entered need to be numerical (e.g. 30).<\/td><\/tr>\n<\/table>\nOther properties that will be created on the tokens when these functions are used are:\nw42.originalOwners: this will store the current owners before any (purge invisibility) owners are added. When invisibility is ended, the original owners will be restored.<br>\nw42.purgeDistance: here the purge invisibility range will be stored.<br>\nw42.inPurgeRange: here all tokens will be stored that are invisible AND within the tokens purge invisibility range.<br>\nw42.purgedBy: here all tokens will be stored that have purge invisibility AND are in range of your token.<br>\n<br>\n<b><u>NILDIKS' ROOM DESCRIPTION MACRO<\/b><\/u>:  <img src='\"+bookImg+\"' alt='Nildiks Room Description'><br>\nThis macro (that has the image of a book) can be used with Nildiks' Room Description Tokens. A 'Description Token' can litterally be ANY token. Although for the sake of recognition its best to use a recognizable image, e.g.: <img src='\"+pointerImg+\"-20' alt='Room Description Token'><br>\nIts purpose is simple: it gives a description of the room, area or encounter.<br>\nTo set up such a 'room description token' do the following:<br>\n1. write everything important of your room, area or encounter in a <u>GM notes<\/u> of a token.<br>\n2. you can enclose text between <share>...</share>. Later, you will be able to share this text to your players<br>\n3. you can enclose a image url or a asset image between <image>...</image>. Later, you will be able to share this image to your players.<br>\n3. you can allways share the images of portrait and handout of this token (these will show up at the top of the location information panel)<br>\n4. you can use html tags to format your text. For example <b>...</b> to use bold or <h1>...</h1> to write titles<br>\n<br>\nWhen the 'Room description token' has all the information, select it, and press the macro button with the picture of an open book. A new frame will be open with all this information nicely presented, formatted and with images and macrolink to share images and text with your players whenever needed.<br>\nIf you share an image to your players, they will be able to zoom in and out on the image.<br>\nYou can create an info token for every room, area or encounter that you have in your map.<br>\n<br>\nOn the 'Example Map of Special Pads' you can find this token: <img src='\"+pointerImg+\"-20' alt='Room Description Token'>.This token is an example of an info token of a dungeon room. You can double click on it to see its notes. You can select it and run the macro to see the description<br>\n<br>\n<b><u>RENUMBER TOKENS<\/u><\/b><br>\nSlightly obsolete macro, this renumbers all the tokens with the same name so there are NO double names and NO gaps in the counting. <br>\n<br>\n<b>ROTATING GROUPS (Group Move only):<\/b>\nGroups can be rotated by selecting one token of the group and then click CW (Clockwise) or CCW (Counter clockwise) after which the group will be rotated. <br>\nThe rotation process knows three different methods:<br>\n- snapped to grid: group will be rotated in increments of 90 degrees<br>\n- unsnapped to grid: group will be rotated in increments of 45 degrees<br>\n- use facing of token (unsnapped only!): when the selected token has a facing set the rest of the tokens will be rotated around that token along the facing angle. This effectively will allow free rotation of the group. <br>\n<br>\nSome notes:<br>\n- This macro makes use of the label field of the token and any current value will get overwritten!!. Changing this value after a group has been set will de-activate group- movement when you move THAT token. The token will still be part of the group and will be moved if another token of the group is moved<br>\n- When you set a group with tokens that already belong to another group, then that ENTIRE other group will be cleared!!. <br>\n- The onTokenMove pads like teleports, events, canopy, etc. will ONLY work for the token that you actually move. <br>\n- Group move will ONLY work when you move ONE token. <br>\n- You can temporarily turn off group movement by togglinh the 'Turn On Token Move Event Macor On/Off'<br>\n- When using the tokenfacing rotation method; the resolution isn't infinite which will result in the tokens formation to become slighly irregular when a lot of this type of rotation is used. Also the CW and CCW buttons will have the same result as the tokens are rotated according to the set facing and not anymore CW or CCW<br>\n- <b>The formation macros (rotate, square, wedge etc.) will also work if you select more then one token which do not belong to a group.<\/b><br>\n<br>\n<b><u>SET VBL STAMP<\/u><\/b><br>\nWith this function you can apply a Vision Blocking Layer (VBL) stamp upon a token. With this stamp you can move, rotate and copy the token and the applied VBL will 'move' with the token. Note that one of the options is 'Current VBL' that means that ALL VBL that is ON the token (so not outside of it) will be stored on the token and set as the VBL 'stamp'. There however a few tricky things which Ill explain here:<br>\n<u>Core thing to know:<\/u> The stamp function fully relies on the onTokenMove event! And that event is ONLY triggered on the TOKEN layer. Also the save VBL function is NOT 100% perfect. A mathematical model will be made of the VBL which most likely will be slightly different then what you applied. <br>\n<br>\nSo what does this mean...:<br>\n1. This 'stamp' function ONLY WORKS ON THE TOKEN LAYER. If you thus want to use if for buildings, do all that what you want to do on the token layer and then when finished, send the token to the background layer.<br>\n2. The first time you store custom VBL on a token, move the token outside the VBL area. Then switch to VBL modus and you'll notice that the 'former' vbl is still there. You can leave or remove that VBL. When I created the code I chose to not remove the former VBL automatically for complex reasons I'm not gonna explain here. After this the VBL will move with your token AND it will remove the VBL where it was. <br>\n3. If you rotate a VBL stamped token, the VBL will rotate AFTER you have moved it a bit. Wiggling the token a bit is enough (to trigger onTokenMove event). <br>\n4a. If you move the VBL stamped token on top of an existing VBL layer: the VBL stamp will be applied on top of the existing VBL.<br>\n4b. If you then move that token outside of the VBL area, the former VBL will be restored!!<br>\nHOWEVER: same rule as above applies: it won't be 100% perfect!<br>\n5. Copy pasting will make the function cry a bit as it gets confused by formerly stored VBL, so things will go a bit weird when you do this. Here a breakdown:<br>\n5a. Make sure that you operate in a VBL free environment (so that you don't accidentily use of overwrite background VBL)<br>\n5b. Create and apply VBL stamp to token as explained<br>\n5c. Copy the token and paste it somewhere away from the original<br>\n5d. Move the copy, again make sure that you move it OUTSIDE the original position. You will notice 2 things: 1. the VBL will be applied to the copy; 2. the VBL will be removed from the original. <br>\n5e. Move the original to restore the VBL. <br>\nRinse and repeat. <br>\n6. When using lots of stamps and you move these around in a complex VBL environment its possible that pieces of VBL are left behind. Theres not much I can do about this as its a limitation of the 'not a 100% perfect copy of the original VBL'. Just keep an eye out for it!\n<br><br>\n<b><u>SCATTER<\/u><\/b><br>\nThis macro was originally created by Craig (one of the MT ancients) and is further developed by me. <br>\nWith this macro you can scatter a couple of tokens within a predefined area. E.g. a token of a tree, scattered 100x in an area of 100x100 cells. <br>\nTo use the scatter macro, just select a couple of tokens you wish to scatter, run the macro, set the parameters and hit the ok button. After a couple of seconds youll find the token scattered over the pre-defined area<br>\n<br><b>Parameters<\/b><br>\n<b>- 'Select a token or object': <\/b>On the map on any layer you can select a number of token  <br>\n<b>- Number of Copies:\t<\/b> The total number of copies of the selected token copied into the designated area<br>\n<b>- Distance (N,W,S,E): <\/b>The distance in cells counting from the selected token (if you have mult. tokens selected, the cells are counted from that each seperate token. So if you have e.g. a Tree and a Bush token selected and north: 100. Then trees are copied upto 100 cells north from the original Tree token and bush tokens are copied upto 100 cells north from the Bush token<br>\n<b>- Spreading:\t\t\t<\/b> The minimal distance between two tokens within the designated area within the designated layer. 0 = No spreading. How does it work exactly: When you set this value to 1 or higher, all the Id's of the tokens that are copied are stored into a list. Then randomly one is picked from that list (lets call it token X. From token X ANY token on the DESIGNATED LAYER withing 'SPREAD' RANGE WILL BE DELETED. The deleted tokens and token X is then removed from the list and another token is randomly selected from the list until the list is empty. Thus: if there are already tokens within the designated area and you don't want them deleted, make sure that the DESIGNATED LAYER is an empty layer (e.g. Hidden). When done you can select all the tokens on the Hidden layer (from the explorer panel) and move them with one click to the layer where you want them.<br>\n<b>- Rotation:\t\t\t<\/b>Here you can choose different rotation settings, depending   <br>\n<b>- Range of Size:\t\t<\/b>If the original tokens are of Medium size then a size range of e.g. 2 will randomly copy new tokens from 2 sizes smaller upto 2 sizes bigger. If you want to work with free size, then select e.g. 5 similar tokens of different sizes and set the 'Range of size' to 'keep original size'<br>\n<b>- Layer:\t\t\t\t<\/b>The designated layer where upon the tokens are copied.<br>\n<b>NOTE:<\/b> When SPREAD is used, the 'weeding' of trees closer in distance then the spread value is done by a defered macro call. This means that you can interact with the map while the process runs. In this case wait for the 'Spread Calculations Done' message. DO NOT CHANGE MAPS (or your pc might explode) also refrain from adding or removing any token from that map until then.<br>\n<i>When multiple tokens are selected:<\/i><br>\n<b>- Number of Tokens (of each / Randomly selected: <\/b>If you select e.g. 2 tokens e.g. a Tree and a Bush and number of copies is set to 10: then 'each' = 10 copies of the Tree and 10 copies of Bush. 'Randomly Selected' = A total of 10 copies randomly selected from the tree and bush, e.g. 3 Trees and 7 Bushes. <br> \n<br>\n<b><u>SEEK TOKEN<\/u><\/b><br>\nSimply enter the first part of the name of a token that you seek and ALL maps will be checked and if the string matches then the token name will be listed for that map. It will also list all the lib:tokens!!<br>\n<br>\n<b><u>SET TOKEN SIZE<\/u><\/b><br>\nThis macro you will need if you want to use alt.init token (so you have > 100 special pads on one map) AND some of these pads are free size. For alt init map to work it needs to know the size of a token, and this is indeterminable when using free size tokens. With this macro you can select all tokens of the same size and set their size in one go.<br>\n<br>\n<b><u>SUMMON TOKEN(S)<\/u><\/b><br>\nThis macro summons a token onto a selected token. For this macro to work you will need to select a token first.<br>\nWhen you start using this macro, make sure you have set it up correctly in the settings. It wil show 5 types of Drop down boxes (DDB): NPC, PC, (N)PC, Property Type and Special. <br>\n- <b>(N)PC<\/b> These three will show (N)PCs, however you need to set the Property types for PCs and NPCs first in the settings<br>\n- <b>Property Type<\/b> For every property type that you list in the settings one DDB will be shown.<br>\n- <b>Special<\/b> Here you can simply give a list of token names that will show up in the last DDB<br><br>\n\n<b><u>SWITCH MAP & centreOnMePad<\/u><\/b><br>\nThis macro shows a list of ALL maps (including hidden). The map you choose will force ALL clients to that map and centre the view on the 'centreOnMePad' if its there. <br>\nAdditionally if you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i> then these will show up as locations<br>\nin this macro (after a 'rescan').<br>\nIn order to rescan: check the checkbox after 're-scan this map' and click ok.<br>\n\n<br>\n<b><u>TABLES<\/u><\/b><br>\nThese utilities consits out of several macros:<br>\n<br>\n<u>In the macro menu:<\/u><br>\n- <b>Create Table<\/b>: this macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns.<br>\n- <b>Show Table<\/b>: this macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values. When you create a table using the above function, you can about feed it anything you like. However when you starte editing it you can no longer use quotes neither single (will be removed) nor double (render an error)<br>\n- <b>Delete Table<\/b>: this macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros<br>\n<br>\n<u>Script/Code functions (these only work for the 'Bag of Tricks' Tables, stored on lib:EventMacros, i.o.w. created by using the above macros):<\/u><br>\n- <b>bot_table()<\/b>: with this function you can retrieve a value from the stored BoT Tables.<br>Usage: bot_table('name of table', optional: 'column', 'row'). Here 'row' can either be an index number or the actual name of the row. Column must always refer to the column name. Leaving them empty will result in a random choice for row and the 1st column for column.<br>\n- <b>bot_listBoTtables()<\/b>: returns a list with the stored BoT Tables.<br>\n- <b>bot_listMTtables()<\/b>: returns a list with the stored Maptool Tables.<br>\n- <b>bot_getRows('table name')<\/b>: returns the row names of the given BoT table<br>\n- <b>bot_getColumns('table name')<\/b>: returns the column names of the given BoT table<br>\n<br>\n<u>In addition the following functions have been added, originally created by Craig, updated by LMarkus001 and slightly tinkered by me.<\/u><br>\n- <b>json.path()<\/b>: returns the nested keys from a json object<br>\n- <b>json.pget()<\/b>: returns the requested value. Usage: json.pget(jsonObject, 'key1/key2/etc')<br>\n- <b>json.pset()<\/b>: sets a value for the given key. Usage: json.pset(jsonObject, 'key1/key2/etc', value)<br>\n<br>\n<b><u>TOGGLE FULL SCREEN MODE<\/u><\/b><br>\nCurrently this mode needs to be toggled (Shortcut key is F2) as there is no way to check whether you are in Full Screen or not (in the next MT build this should be solved). How it works is simple: if you are in full screen (ctrl+alt+enter) you can press F2 to toggle to full screen mode. The BoT menu will also pop in screen. All the relevant screens will show up in dialog, even the last chat message IF you make use of the message function implemented in this FW. To do that you will need to check the 'redefine broadcast' setting in the settings. This results in the broadcast function not only porting to chat but also to a chat dialog. In that case you will always see the last broadcasted message in full screen.<br>\nOne remark: when you click somewhere on the MT map then the dialogs will 'dissapear' (as they are moved to the background). To get them back use alt+tab. <br>\n<br>\n\n<font color=red><b><u>SETTINGS<\/u><\/b><br><\/font>\n<br>\n<b><u>TOGGLES<\/u><\/b><br>\nIn the toggles you can turn certain ontokenmove related features on or off. Turning them on will generally result in (slightly) reduced response time when moving a token.<br>\nAll these settings contain tooltips explaining you what to do<br>\n<br>\n<b><u>VISION BLOCKING TOKEN STAMPS (VBL Stamps)<\/u><\/b><br>\nIn the general settings, after you turn on VBL support you will find in the 'Toggles' tab a 'VBL Stamps' setting. If you check this then ANY token with the LABEL: <i>VBLStamp<\/i> will get a VBL cross drawn over it when you move the token. This VBL cross will move along with the token. <br>\n<br>\n<b><u>GENERAL EVENTS<\/u><\/b><br>\nIn the settings you will find a new tab with a list of events to which you can link your own events. E.g. if you wish to post a message to the screen every time someone teleports saying from where and to where they are teleported: this is the place to do this. <br>\nTo make this work you first need to create an event macro on lib:EventMacro in the group 'Event List Macros'. This can be as simple as a chat message saying: 'You are being teleported'. <br>\nOnce you have created this event you will find it back in the dropdownlists you see in the tab 'General Events'. Simply pick the one at the event and you're done!<br>\n<br>\n<b>Event List Macros<\/b><br>\nWhen creating an event list macro please limit the characters you use in the name of the macro to alphanumeric characters ONLY!!! <br>\n<br>\nFor the onTokenMove and onMultipleTokensMove (both before and after) there is one arguments available, which you can call with: [h:arg(0)]. Depending on which event this will return the following:<br>\n- For onTokenMove both before and after: The token name<br>\n- For onMultipleTokensMove BEFORE: list of moved token ID's. This linked macro will run ONCE<br>\n- For onMultipleTokensMove AFTER: NAME of current token. This linked macro will run FOR EVERY TOKEN INDIVIDUALLY!<br>\n<br>\nFor the teleports there are also a bunch of useful variables locally available. To acces these you need to start your macro with: [h:varsFromStrProp(arg(0))]<br>\nDepending on the even type the following variables will be defined locally:<br>\n<b>teleport<\/b>: tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY<br>\n<b>inter map teleport<\/b>: tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap<br>\n<b>where:<\/b><br>\n<u>tok<\/u>: The name of the token<br>\n<u>padName<\/u>: Then name of the pad you are teleported from (in case of inter map transport that is also the name of the Pad you are transporte to)<br>\n<u>teleportEndName<\/u>: The name of the pad you are transported to (local map only)<br>\n<u>CurrentX/Y<\/u>: X/Y coord of where the token is transported from<br>\n<u>NewX/Y<\/u>: X/Y coord of where the token is transported to<br>\n<u>oldMap<\/u>: Name of map of where the token is transported from<br>\n<u>newMap<\/u>: Name of map of where the token is transported to<br>\n<br>\n<b>Example Event List Macro:<\/b><br>\n[h:varsFromStrProp(arg(0))]<br>\n[h:bot_animateText(tok+' is being teleported from '+oldMap+' to '+newMap,'Inter map teleport', 0,'default','300','50')]\n\n\"]\n\n<!-- run the function documentation frame as well -->\n[h:bot_manFunctionsTxt()]\n<!-- run the vieo tutorials splash as well -->\n[h:bot_videoTutorials()]\n\n<!-- start manual frame (in this order the manual frame ends on top -->\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Manual\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Manual\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "16dab219-c68a-4f8c-99cd-aab884bfb0a4",
          "commandChecksum": "52a62294b936a28c7c728f54ebda49fa",
          "propsChecksum": "1e52ec46d57872fcb61e20911676aa4b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "UNDER CONSTRUCTION",
        "includeLabel": false,
        "sortBy": "",
        "index": 418,
        "label": "codeChecker",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:name\t\t= \"initializePads\"]\n[h:index\t= getMacroIndexes(name, \",\", \"lib:ontokenmove\")]\n[h:macro\t= getMacroProps(index, \"json\", \"lib:ontokenmove\")]\n[h:taText\t= am.test.reformatMacroOutput(macro,\"lib:ontokenmove\")]\n\n[H:am.test.openFrame(\"lib:ontokenmove\",\"Original code\",taText)]\n\n[H:taText\t= replace(taText,\"&\",\"&\")]\n[H:taText\t= replace(taText,\"\\\\\\\\\",\"\\")]\n[H:taText\t= replace(taText,\"/\",\"/\")]\n[H:taText\t= replace(taText,\"[\\$]\",\"$\")]\n[H:taText\t= replace(taText,'\"','@42@')]\n\n[H:taText\t= replace(taText,'\"','@42@')]\n[H:taText\t= replace(taText,\"\t\",\"@43@\")]\n[H:taText\t= replace(taText,\"<!--\",\"@44@\")]\n[H:taText\t= replace(taText,\"-->\",\"@45@\")]\n[H:taText\t= replace(taText,\"<\",\"<\")]\n\n      \n[h:regex\t= \"([(){}\\\\[\\\\];<>:,'\\\\n]|@42@|@43@|@44@|@45@|<|if)+\"]\n[h:result\t= strfind(taText, regex)]\n\n[h:gutStr\t= \"\"]\n[h,count(getFindCount(result),\"\"), CODE:{ \n\t[tmp\t= getGroup(result, roll.count+1, 0)]\n\t[gutStr\t= gutStr + tmp]\n\n}]\n\n[H:gutStr\t= replace(gutStr,'@42@', '\"')]\n[H:gutStr\t= replace(gutStr,'@43@', '\t')]\n[H:gutStr\t= replace(gutStr,'@44@', '<!-- ')]\n[H:gutStr\t= replace(gutStr,'@45@', ' -->')]\n[H:gutStr\t= replace(gutStr,'<', '<')]\n\n[H:am.test.openFrame(\"lib:ontokenmove\",\"gut code\", gutStr)]\n\nok",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "92e33aac-dc4e-46b1-950e-115a931822ad",
          "commandChecksum": "1206e1ab052464dd05b52bd471e3c46f",
          "propsChecksum": "95c7a2fc5e6ffa1f7733b55f92a86824"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "3",
        "index": 419,
        "label": "Build Option Vars",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:setLibProperty(\"bot.fg.Transportation\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.EventTokenArea\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.UtilityMove\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.UtilityGeneral\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Tables\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Animations\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.MapCreation\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.VBL\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Other\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Functions\",\"\",\"lib:OnTokenMove\")]\n\n<!-- copy paste json construct here below -->\n\n[h:setLibProperty(\"bot.fg.GroupList\",\"bot.fg.Transportation,bot.fg.EventTokenArea,bot.fg.UtilityMove,bot.fg.UtilityGeneral,bot.fg.Tables,bot.fg.Animations,bot.fg.MapCreation,bot.fg.VBL,bot.fg.Other,bot.fg.Functions\",\"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"On Map Teleport pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadStart, PadEnd) every teleport consists out of a starting pad and ending pad (paired pads), if you drop a token on one it will end on the other. You can resize or place them anyway you want, as long as its on the same map.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Between Map Teleport pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Interpad) Any Interpad is automatically paired with the Interpad with the SAME identifier (e.g. '1') on a DIFFERENT map. Again, size and place are completely free, as long as its on two different maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"One way teleports\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadJump, PadDrop, InterJump and InterDrop) Moving onto a 'Jump' token will transport you its paired 'drop' token. And NOT the other way round. The 'Inter' version can be used for transport between maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"One Way Teleport Border pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder) As with the one way teleports The big difference with the 'normal one way teleports' is that the 'border teleport' tokens will teleport a token that moves onto OR OVER the special pad. I've added 8 new tokens to the zip file (4 horizontal and 4 vertical as you must NOT rotate the tokens, because the footprint of the token does NOT rotate). <br>The inter versions can ideally be used for e.g. large maps where you can build seperate sections on seperate MT maps. This will keep the memory use per map low and will give an easy transfer between to sections. <br>The map versions can be used for creating e.g. a closed loop map where the edges of the map are connected. Moving over the edge will automatically transport you to the opposite edge.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Two Way Teleport Border pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(InterPadBorder, PadStartBorder, PadEndBorder) Same as the above one way, but now also two ways teleports.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Mapped Teleports\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(MappedPad) These pads work similar to the teleport pads, although of these there is only one type of pad and not two like the start and end pad with the 'normal' teleports. When initializing them you'll get a pop-up per map where they exist and here you can set the destination pad. The 'destination' must be a number, so you can if you like also put in forumulas or dice rolls, as long as the result is a number (and as long as a destination pad with that number actually exist).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Transparent Roofs\", \"Type\",\"Token\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Roof) When a token moves onto a building (with a roof) the roof automatically turns transparent (with a red halo) and return opague again when the token moves away from it. For this to work you will need to install the tabel into your framework inside the attached zip file.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Roof VBL Swap\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"in addition to existing Roof swap function, an option is added where you can store the VBL currently on a building and swap it with a VBL cross shape. Hence from the outside players can see the partially and as soon as they enter the building the VBL of the roof is swapped with the VBL of the building.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Warded Roofs\", \"Type\",\"Token/Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Roof) Roofs have now a corresponding 'set roof' macro with which you can assign doors to the roof. If doors are assigned, the Roof automatically becomes a 'warded' area, which you can ONLY enter through the OPEN door. Thus if the door is closed, there is no way a player can move her token onto the roof. If the door is open, a player can ONLY move in the building when it moves her token OVER the door token first.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Foliage\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Foliage) Tokens with these names work exactly as roofs, except there will be NO red halo outline for the transparent version AND you can choose to use a different picture to swap with when you move over it. (on default when you move over them their image is swapped with an transparent image from the tables).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Canopy\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Canopy) Tokens with these names are automatically given an treetrunk as alternative image when a token moves over them.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Warded Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros\", \"Description\",\"(Ward) Tokens that move onto this area are moved back to their original position. They cannot enter the area.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Event Pads\", \"Type\",\"Token/Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Event Macros\", \"Description\",\"(EventPad) These tokens are triggered on certain event e.g. when a token move onto the pad. These events can be set through a 'set event pad' macro. These pads replace the former Pit and Trap pads and allow for a much more versatile use. When the pad is triggered then a macro that you linked to it will run. Extra example is added: trip wire in combination with a net trap (thnx Pinkrose)\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Canopy, Foliage, Roof) Linked tokens are special pads that are activated simultaneously. If you have two or more tokens that are linked by the same link identifier, e.g. 'Linked 1 Roof 5' and 'Linked 1 Canopy 3' (here the link identifier is '1'), then when one of the tokens is activated (by moving a token on top of it) the other is activated as well.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Bridge Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(i.c.w. Canopy, Foliage, Roof) Bridges are pads that you link with Canopy, Foliage or Roof pads. When you move over a Bridge and then onto a Roof (in one move) then the roof does NOT dissapear (See vid. tutorial for more info).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Tunnel Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(i.c.w. Canopy, Foliage, Roof) Tunnels work exactly the same as Bridges albeith the opposite effect. So when moving over a tunnel token the roofs disappear, while moving directly onto a roof they won't.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Shadow Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; ShadowPads\", \"Description\",\"(ShadowPads ) This allows to watch token movement on map A from map B. Typical use is a 2 story building where you can watch the ground floor from the first floor through a gap in the floor (and vice versa). See vid tutorial for more details.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Event Areas\", \"Type\",\"Area\", \"Dependencies\",\"State: Special Area; Token: Area Marker\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof; Event Area Macros\", \"Description\",\"These are Areas you can define (and these can take ANY form, with a resolution of the grid) and depending whether a token moves onto, over, off, etc. it will trigger an event (macro). The best use for these are to define difficult terrain areas which impede the movement of a token. For which the 'Limit Movement' macro in the lib:EventMacros lib is now adapted.<br>Finally one other good thing of these areas: they're FAST! A lot faster then the token method currently in use.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group (Select)\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"Create groups of tokens. When you select one token of the group, all the tokens are automatically selected.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Group Move; Group Select\", \"Description\",\"You can combine tokens into one group. When you move ONE token of that group then the whole group moves accordingly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Rotation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"When the group is defined you can use the CW or CCW rotation buttons to rotate the group. For snapped tokens the increment is 90, for unsnapped its 45 and its also possible to select a token from the group and set its facing and then click either CW or CCW, after which the group will be rotated to that direction (unsnapped only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Formations\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"For defined groups (or a group of selected tokens) you can set different formation like, square, wedge, line, echelon, spread and compact.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Centre on token\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"A toggle in the settings where you can turn on continuous centre on token. This will force a centre on map for every token moved. (only works for single token move).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Restore FoW (Fog of War)\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"When a player moves a token all the FoW will be restored and only the PC visible areas will be cleared. This function has the extra advantage that the VBL lag bug (game gets very laggy after a while when there is a lot of VBL on the map) is ommitted.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"VBL (Vision Blocking Layer) move check\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This function is created by Aliasmask. It can also be found on his lib:Players. However to make both libs compatible I've added it to the BoT so it can be turned off on lib:Players. This function checks EVERY step of the just-moved-token and checks whether it can see into gridcell its moving into. If not then the movement is halted. This function too has the extra advantage that the VBL lag bug is ommitted.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Path Tracking\", \"Type\",\"Setting\", \"Dependencies\",\"State: pathFeet; Token: red feet, blue feet\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"Added toggle to the settings where you can turn on path tracking. This will show small feet in the grid cells where the last token moved. Red for NPCs and blue for PCs.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Lock Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This is a toggle on the macro panel that will lock down the movement of ALL tokens. Only the gm can move the tokens now. To use simply hit the macro button and hit it again to allow movement again.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Lock Token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"Similar to lock movement, only this works on the individual token. It prevents the token from being moved. Both by player and gm! To use: select one or more token. Click the 'lock token' macro. There is a general toggle in the settings to turn this feature on and off.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Invisibility Purge\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This functions can be turned of or on the in the settings-->toggle tab. It uses <i>visible to owner only function<\/i>. When a token is invisible this setting is (automatically) turned on. Any token that has <i>Purge invisibility<\/i> turned on will be added as owner to the invisible when the invisible token is in range. See manual for full instructions.<\/i>\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Set Light\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro whith which you can easily set lights sources on tokens\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Rumbles Dice Box\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Rumbles Dice Box\", \"Description\",\"A frame where you can set a pool of dice that you can roll in one click. I have used Rumbles code and layout as a basis and rewrote most of it. Noteably I've added 'options' so you can fully customize the frame.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Show Token Handout\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that forces a pop-up on ALL clients showing a token handout (gm only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Switch Map\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A macro that forces ALL clients and selected tokens to the chosen map AND forces all views to the centreOnMePad (if its on the map)(gm only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Seek token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A utility that scans ALL maps and ALL tokens returning a list of all tokens that match the search string. Updated with a wide variety of options, biggest change is showing the results as macro links which allows you to either Copy, Move or Select the token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"bot_debugInfo()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A macro that shows all kinds of debug info (primarily for tracking variable values), with several optional settings.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Aliasmasks Disguise macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: Polymorph\", \"Macro_Group\",\"Aliasmak Usedisguise\", \"Description\",\"A macro that allows you to add extra token images to a token, so you can e.g. 'polymorph' during gameplay into something else.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"LMarkus Whisper Frame\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"LMarkus Whispers\", \"Description\",\"A frame where you can whisper (with some text formats) to one or more players without needing to use the /w option. It also includes an impersonation feature so you can speak as another token, without needing to actually impersonate it.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Rumbles Delete Macros utility\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Rumbles Delete Macros utility\", \"Description\",\"A macro that allows you to copy/paste/delete macros from/on a selected token onto another token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Plothos Message Manager uttility\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Plothos Message Manager\", \"Description\",\"A macro that allows you to create and store messages for players.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Event Buttons\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Event Macros\", \"Description\",\"A macro that links an lib:EventMacro macro to a token. When the token is selected, the macro is activated. Usefull for e.g. switching maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Benchmark\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro specially developed for macro developers. It can be used to discern the execution time for a certain macro.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Map Diagnosis\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that checks ALL maps and ALL (lib)tokens for potential issues. It checks whether token names contain non-alphanumerical characters and checks the libs for the same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead you to the token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Token Name Cleaner\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that detects and cleans up characters in token names that are incompatible with the macro system in maptool.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Bubblobills Input String Builder\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Bubblobills Input String Builder\", \"Description\",\"A macro with which you can easily create the code for a complex input string.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Nildiks Fancy Frames\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: frames\", \"Macro_Group\",\"Nildiks Frames\", \"Description\",\"Two macro functions that allow you to show fancy frames around the 'frames' you usually show to the players.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Nildiks Room Description Token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: encounters, tbl_Image\", \"Macro_Group\",\"Nildiks Room Description\", \"Description\",\"The Room Description token allows you to easily access a description of the area where the players are AND to easily share texts (e.g. pieces or parchments, treasure etc) and images (of e.g. encounters) with them in one overview\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Create Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Show Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Delete Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_table()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"With this function you can retrieve a value from the stored BoT Tables. Usage: bot_table('name of table', optional: 'column', 'row', ). Both 'column' and 'row' can either be an index number or the name of the row/column. Leaving them empty will result in a random choice.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_listBoTtables()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns a list with the stored BoT Tables.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_listMTtables()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns a list with the stored Maptool Tables.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_getRows('table name')\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns the row names of the given BoT table\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_getColumns('table name')\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns the column names of the given BoT table\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated Doors\", \"Type\",\"Menu Macro\", \"Dependencies\",\"State: Locked; Token: DoorLeverToken\", \"Macro_Group\",\"Door Animation\", \"Description\",\"Full functionality to setup animated doors, both single and double, both rotating and sliding. Including support to activate them in at least 5 different ways. \")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"VBL on Doors\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Door Animation\", \"Description\",\"Toggling (open or close) an animated door will give the following options: look through key-hole, look through window, crack door open, open door half way, open door fully. The VBL will be adjusted accordingly\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Token door switches (with proximity check)\", \"Type\",\"Menu Macro\", \"Dependencies\",\"State: isButton\", \"Macro_Group\",\"Door Button\", \"Description\",\"Set up a door with a switch token that corresponds with that door when you click on the switch. Option for the gm to 'Lock' the door, so players can't open it. You can also set a proximity check, that checks whether a token of the player is close enough to open the door.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animate Token Movement Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"A macro and macro button with which you can animate the movement of one or more tokens. See video\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animate Token Movement Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"Same as the macro only in the form of a macro function that you can call inside your own macros.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated text Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"A macro that generates an input screen where you can setup the animated text. This will pop up a frame on every client pc showing a frame where a delayed text is printed in\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated text Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"Same as the macro only in the form of a macro function that you can call inside your own macros.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Set View Animation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\t\"Use lastpath of selected token to run a screen animation\")]\t\t\t[h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Link View Animations\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\"Link the view animation of selected tokens and store it on one token\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Run View Animation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\t\"Run view animation created for selected token\")]\t\t\t\t\t\t[h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Scatter\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"Select one or more tokens, set an area and a number and copies of the tokens will be randomly scattered accross the preset area. Ideal for e.g. rocks, trees, or a chaos warband.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Building A Forest\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"A macro to build a big forest FAST and have it ready for the Canopy 'Trick'. This is a specialized macro based on the 'Scatter' macro\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Summon tokens\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Summon\", \"Description\",\"A macro with which you can summon tokens from the 'BASE' map onto the current.map . The location you can set by hand or you can summon it onto a selected token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Fill Area\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"A macro that with which you can quickly fill an area with tokens (also useful for creating special areas).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Draw Order Edit Panel\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Order\", \"Description\",\"With this panel you can edit the draw order of the selected tokens, rotate them individually, random or as a group. It also contains layer and shape dropdown list.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Crowd Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"An new set of macros that allows you to fill a e.g. Town square with tokens (forming a crowd), which can then 'flee in panic' when the fight goes down.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Map Editor\", \"Type\",\"Menu Macro/Area\", \"Dependencies\",\"State: editFieldMarker; Token: GridCoordMarker\", \"Macro_Group\",\"Scatter\", \"Description\",\"Two new macro to create a field on the map where its VERY easy to place token, used for map creation. Try it out for more info.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"VBL Stamps on tokens\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"With this macro you can add a VBL layer upon a token that 'moves' with the token. (Its not really ON the token, but erased and redrawn as you move the token). Possible VBL are Square, Rectangle, Line, Regular Polygon. With a bunch of extra options (like offset, scale, fill, etc.).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Drawable Polygon Stamps\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"In addition to the 'normal' stamps, you can now also save ANY VBL currently over the token as a stamp. So you can draw VBL over a token as you normally draw VBL and the store that VBL as a stamp onto the token. This is particularly usefull for dungeon tiles where you can store the VBL data onto the tile and then copy paste the tile over the map.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Mass VBL\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function will draw VBL on ALL tokens that match a (partial) search string. Its mainly intended for roofs and canopy but options (selection, all, layers) have been added to use it for other purposes. This macro also contains 2 different scaling techniques to apply the VBL onto the token. Finally you can also store the ENTIRE VBL structure and you can use Toggle VBL to turn that on or off\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Toggle VBL\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function corresponds with Mass VBL. In Mass VBL you can store all the added VBL and with this function you can turn it on or off instantly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"VBL Grenade\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function will erase ALL VBL in a given radius (in grid cells) around one or more selected tokens.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"Force Selection\", \"Type\",\"Other\", \"Dependencies\",\"None\", \"Macro_Group\",\"Door Button\", \"Description\",\"To use with 'Always on Top' application. With this feature you can force a client slave to have the same button selected as you have on the master. Read the manual for more info. Usefull for those that like to use Full Screen Mode but still have a chat window and macros available. (and working)\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"Load Map and Coordinates on Start Up\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"This feature can be found in the settings, where you can set the map to load on start-up and the coordinates (or token name) on that map to go to.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"AssignedPads Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Assigned Pads\", \"Description\",\"Teleport pads that are linked to a specific token, can be used for a mass invasion!\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"AssignedPads Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Assigned Pads\", \"Description\",\"Same as the macro menu but now on the fly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Functions\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Function Macros\", \"Function\",\"Function Macros\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Geofunctions Support; Geofunctions; Util - Math; Message; Util - General; Util - Documented\", \"Description\",\"<a href='macro://manFunctionsTxt@Lib:OnTokenMove/none/Impersonated?'>Bot Function Manual (for overview)<\/a>\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c9843b28-005d-40f7-8861-7040d87b532b",
          "commandChecksum": "1a4e655ca4a7c59804eb124527895356",
          "propsChecksum": "60eb1a287166a27e08aba77a07631f2d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "3",
        "index": 420,
        "label": "optionTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- optionTable (id, vars) ------------------------------------------------>']\n<!-- bot_optionTable(\"bot.fg.Transportation\",\"Function, Description\") -->\n<!-- this macro generates a dialog with an overview of options belonging to the given groupID and only showing the given columns -->\n\n[h:'<!-- option.array = \n[{\n\"Group_Name\":\"Function Macros\",\n\"Function\":\"Function Macros\",\n\"Type\":\"Function Macro\",\n\"Dependencies\":\"None\",\n\"Macro_Group\":\"Geofunctions Support; Geofunctions; Util - Math; Message; Util - General; Util - Documented\",\n\"Description\":\"Bot Function Manual\"\n},{etc.}]\n-->']\n\n[h:assert(argCount()==2, getMacroName() + \" Requires 2 arguments, you only gave it: \"+ argCount(),0)]\n\n[h:option.var\t= arg(0)]\n[h:vars\t\t\t= arg(1)] <!-- Function, Description, Dependencies -->\n[h:option.array\t= getLibProperty(option.var, \"lib:OnTokenMove\")]\n[h:option.first\t= json.get(option.array, 0)]\n[h:allVars\t\t= json.fields(option.first)]\n[h:option.group\t= json.get(option.first, \"Group_Name\")]\n\n<!-- check if vars exist -->\n[h,foreach(var, vars), CODE:{\n\t[assert(listCount(allVars, var),var + \" does not exist\",0)]\n}]\n\n<!-- create HTML string -->\n[R: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 1pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 1px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n[h:output = styleHTML + \"<html><body>\n\t<font color=red size=5><b>\"+option.group+\" Functions<\/b><\/font><br><br>\n\t <a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Back<\/b><\/a><br>\n\t<br>\n\t<table width='100%'  class='btnformat' valign=top><tr cellpadding='0px'><td class='btnformat'><b>\n\"]\n\n<!-- header -->\n[h:header\t= \"\"]\n[h,foreach(var, vars), CODE:{\n\t[header\t= listAppend(header, var, \"<\/b><\/td><td class='btnformat'><b>\")]\n}]\n[h:output = output + header + \"<\/b><\/td><\/tr><tr cellpadding='0px'><td class='btnformat'>\"]\n\n<!-- content table -->\n[h:content\t= \"\"]\n[h,foreach(item, option.array), CODE:{\n\t[tmpContent\t= \"\"]\n\t[varsFromStrProp(json.toStrProp(item))]\n\t[foreach(var, vars), CODE:{\n\t\t[tmpContent\t= listAppend(tmpContent, eval(var), \"<\/td><td class='btnformat'>\")]\n\t}]\n\t[content\t= listAppend(content, tmpContent, \"<\/td><\/tr><tr cellpadding='0px'><td  class='btnformat'>\")]\n}]\n\n[h:output =  output + content + \"\n\t<\/td><\/tr><\/table>\n\t<br>\n\t<b>Dependencies:<\/b><br>\n\tDependencies are additional things you need to install before you can make use of that particular feature. Note that you can still install the entire feature group even without the dependency installed. You would just not be able to use that specific feature, but you can use all others.\tPossible dependencies are:\n\t<table border=0 valign='top'>\n\t\t<tr><td><i>Tokens<\/i>:<\/td><td>simply drag and drop these onto the same map as where lib:OnTokenMove is.<\/td><\/tr>\n\t\t<tr><td><i>Tables<\/i>:<\/td><td>menu --> window --> tables --> import --> select table --> open.<\/td><\/tr>\n\t\t<tr><td><i>States<\/i>:<\/td><td>menu --> edit --> campaign properties --> states (tab) --> enter name --> browse --> select image --> open --> add --> ok.<\/td><\/tr>\n\t<\/table>\n\tAll files required for the dependencies can be found in the <a href='https://forums.rptools.net/viewtopic.php?p=274503#p274503'><b>the special pads zip file<\/b><\/a> a more extensive explanation on how to install the dependencies can be found <a href='https://forums.rptools.net/viewtopic.php?p=274498#p274498'><b>here<\/b><\/a><br>\n\t<br>\n\t <a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Back<\/b><\/a>\n\t<\/body><\/html>\n\"]\n<!-- // create HTML string -->\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "211b62d1-9910-4f26-811c-9a85e4cf2349",
          "commandChecksum": "5235678a4d42a139eb95fe0bebcdc0e4",
          "propsChecksum": "66330d2ad1f5e07af4070c121ef415bd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "2",
        "index": 422,
        "label": "featureTable",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- featureTable () ------------------------------------------------>']\n\n<!-- get feature list -->\n[h:feature.array\t= getLibProperty(\"bot.fg.GroupList\", \"lib:OnTokenMove\")]\n<!-- get settings -->\n[h:feature.Settings\t= getLibProperty(\"w42.bot.fg.GroupSettings\", \"lib:EventMacros\")]\n[h,if(feature.Settings == \"\"), CODE:{\n\t<!-- on first time use EventMacros is not yet initialized -->\n\t[setLibProperty(\"w42.bot.fg.GroupSettings\",\"bot.fg.Transportation=0 ; bot.fg.EventTokenArea=0 ; bot.fg.UtilityMove=0 ; bot.fg.UtilityGeneral=0 ; bot.fg.Tables=0 ; bot.fg.Animations=0 ; bot.fg.MapCreation=0 ; bot.fg.VBL=0 ; bot.fg.Other=0 ; bot.fg.Functions=0\",\"lib:EventMacros\")]\n\t[feature.Settings\t= getLibProperty(\"w42.bot.fg.GroupSettings\", \"lib:EventMacros\")]\n};{}]\n\n<!-- initialize settings -->\n[h:varsFromStrProp(feature.Settings,\"SUFFIXED\")]\n\n<!-- create HTML string -->\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n<!-- create html -->\n[h: processorLink = macroLinkText(\"processFeatureForm@Lib:OnTokenMove\", \"none\")]\n[h:output =  strformat(\"%{styleHTML}<html><body><form action=%{processorLink} method='json'>\n<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><b><< Back to the welcome screen<\/b><\/a><br>\n<a href='macro://videoTutorials@Lib:OnTokenMove/none/Impersonated?'><b>< Back to video tutorials<\/b><\/a><br>\n<br>\n<font color=red size=5><b>BOT features<\/b><br><br><\/font>\nBelow you see an overview of 'Feature Groups' which you can turn on (checked) or off (unchecked) at any time. Each group represents a list of features which will become available when you turn those on. 'Show overview' will show you the specific features that belong to that group. Show overview will also give you an overview of what you need to install additionally to make use of those features (dependencies). You can change your choices later by clicking on the the 'BoT Features' button. <br>\n<br>\n<table class='btnformat'><tr><td class='btnformat'>\")]\n\n<!-- header -->\n<!-- <tr><td>function<\/td><td>type<\/td><td>group<\/td><td>etc. <\/td><\/tr> -->\n[h:'foreach(var, vars), CODE:{\n\t[VAR = \"function\"]\n\t[output\t= listAppend(output, var, \"<\/td><td>\"]\n}']\n\n<!-- content table -->\n[h:tmpOutput=\"\"]\n[h,foreach(item, feature.array), CODE:{\n\t[option.group\t= json.get(json.get(getLibProperty(item, \"lib:OnTokenMove\"), 0), \"Group_Name\")]\n\t[checked\t= if(eval(item+\"_\"), \"CHECKED\", \"UNCHECKED\")]\n\t[tmpOutput = listAppend(\n\t\ttmpOutput, \n\t\tstrformat(\"\n\t\t\t<input type='hidden' name='%{item}' value=0>\n\t\t\t<input type='checkbox' name='%{item}' value=1 '%{checked}'/>\n\t\t\t<\/td><td class='btnformat'>%{option.group}\n\t\t\t<\/td><td class='btnformat'><input type='submit' name='btn%{item}' value='Show Overview' />\n\t\t\"),\n\t\t\"<\/td><\/tr><tr><td class='btnformat'>\"\n\t)]\n\t['pause(\"item\", item+\"_\", \"checked\", \"option.group\")']\n}]\n\n[h:output =  strformat(\"%{output}%{tmpOutput}<\/td class='btnformat'><\/tr><\/table><br>\nWhen you hit 'save' the settings window will pop-up. Make sure you hit OK and NOT Cancel. Obviously: if you like you can go through the settings first and change what you want before hitting ok.<br>\n<br>\n<input type='submit' name='btnSaveSettings' value='Save'/><\/form><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "23c4ebef-aae8-405f-aebb-ed4aaa2e2a53",
          "commandChecksum": "fe9b9f4cb268de6feebeb81c8888a8ed",
          "propsChecksum": "7aefb59d517c8498c619ae4e6b271976"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "4",
        "index": 423,
        "label": "processFeatureForm",
        "fontSize": "1.00em",
        "minWidth": "192",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------ processFeatureForm ----------------------------------- -->']\n[h:'broadcast(macro.args)']\n\n[h:args\t\t\t= macro.args]\n[h:strPropVars\t= json.toStrProp(args)]\n[h:argList\t\t= json.fields(args)]\n[h:setLibProperty(\"w42.bot.fg.GroupSettings\", strPropVars, \"lib:EventMacros\")]\n\n[h,if(json.contains(args, \"btnSaveSettings\")), CODE:{\n\t<!-- close frame after save -->\n\t[bot_updateVirtualMenu()]\n\t[closeFrame(\"Set BoT features\")]\n\t[bot_settings()]\n};{\n\t<!-- show requeste feature list in same frame after save -->\n\t<!-- bot.fg.Transportation=1 ; bot.fg.EventTokenArea=0 ; bot.fg.UtilityMove=0 ; bot.fg.UtilityGeneral=0 ; bot.fg.Tables=0 ; bot.fg.Animations=0 ; bot.fg.MapCreation=0 ; bot.fg.VBL=1 ; bot.fg.Other=0 ; bot.fg.Functions=0 -->\n\t[foreach(arg, argList), CODE:{\n\t\t[if(startsWith(arg, \"btn\")): bot_optionTable(substring(arg,3),\"Function, Description, Dependencies\")]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "688c291e-cdf9-4495-99f9-a42216cfd964",
          "commandChecksum": "84db1c1441b2541082b7fdb6304ffbe3",
          "propsChecksum": "d7bf45527138cad86729611f092e2783"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "10",
        "index": 425,
        "label": "settings",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!------------------------------------SETTINGS-------------------------------------------------------->']\n[h:assert(isGM(), \"Only a GM can modify the settings\",0)]\n\n<!-- Settings -->\n[h:useAltImage\t\t\t= getLibProperty('useAltImage','lib:EventMacros')]\n[h:checkMapsOCL\t\t\t= getLibProperty('checkMapsOCL','lib:EventMacros')]\n[h:showGroupPanelOnSelect= getLibProperty('showGroupPanelOnSelect','lib:EventMacros')]\n[h:fullScreenBroadcast\t= getLibProperty('fullScreenBroadcast','lib:EventMacros')]\n[h:oldFSB\t\t\t\t= fullScreenBroadcast]\n[h:numericIdOnly\t\t= getLibProperty('numericIdOnly', 'lib:EventMacros')]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n[h:baseMapName\t\t\t= getLibProperty('baseMapName','lib:EventMacros')]\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes','lib:EventMacros')]\n[h:haloColors\t\t\t= 'red,dark gray, yellow, blue, black, white,light gray,teal,none']\n[h:onLineClients\t\t= listInsert(json.toList(bot_nself()),0,\"\")]\n\n<!-- animations -->\n[h:animationPerClient\t= getLibProperty('animationPerClient','lib:EventMacros')]\n[h:timeLockDelay\t\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n<!-- summon token macro -->\n[h:summonPcPropType\t\t= getLibProperty('summonPcPropType','lib:EventMacros')]\n[h:summonNpcPropType\t= getLibProperty('summonNpcPropType','lib:EventMacros')]\n[h:summonPropTypesList\t= getLibProperty('summonPropTypesList','lib:EventMacros')]\n[h:summonSpecialList\t= getLibProperty('summonSpecialList','lib:EventMacros')]\n\n<!-- invisibility purge -->\n[h:invisState\t\t\t= getLibProperty('invisState','lib:EventMacros')]\n[h:seeInvisState\t\t= getLibProperty('seeInvisState','lib:EventMacros')]\n[h:purgeInvisState\t\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n[h:annulInvisState\t\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n<!-- map exclusions -->\n[h:allMaps\t\t\t\t= listSort(getAllMapNames(),\"N+\")]\n\n<!-- set vars for Toggles -->\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n<!-- halo colors is stored as string, so convert to number -->\n[h:roofHaloColor\t\t= max(0,listFind(haloColors, roofHaloColor))]\n[h:forceSelectClient\t= max(0,listFind(onLineClients, forceSelectClient))]\n\n<!-- OCL -->\n[h:useStartUpMap\t\t= getLibProperty('useStartUpMap','lib:EventMacros')]\n[h:startUpMap\t\t\t= getLibProperty('startUpMap','lib:EventMacros')]\n[h:startUpCoords\t\t= getLibProperty('startUpCoords','lib:EventMacros')]\n[h:useCentreOnMePad\t\t= getLibProperty('useCentreOnMePad','lib:EventMacros')]\n[h:runSwitchForm\t\t= getLibProperty('runSwitchForm','lib:EventMacros')]\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n\n<!-- SYSTEM -->\n[h:libCoordSize\t\t\t= getLibProperty('libCoordSize', 'lib:EventMacros')]\n[h:maxPadsPerRun\t\t= getLibProperty('maxPadsPerRun','lib:EventMacros')]\n[h:maxGroupSelect\t\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:maxOrderSelect\t\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:padNameList \t\t\t= getLibProperty('padNameList', 'lib:EventMacros')]\n\n<!-- start up map -->\n[h:startUpMapList\t\t= getAllMapNames()]\n[h:startUpMapNum\t\t= listFind(startUpMapList,startUpMap)]\n[h:baseMapNum\t\t\t= listFind(startUpMapList,baseMapName)]\n\n<!-- create list of event macros from the group \"Event List Macros\" used for \"General Events\" tab -->\n[h:oldMap\t\t\t\t= getCurrentMapName()]\n<!-- check if the map where lib:Eventmacros is situated, still exists -->\n[h,if(baseMapNum == -1), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|The map with lib:EventMacros does not exist. Pls select the correct one|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n}]\n[h:setCurrentMap(baseMapName)]\n<!-- check if lib:Eventmacros is on the map -->\n[h,if(findToken(\"lib:EventMacros\") == \"\"), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|<html>Lib:EventMacros is NOT on map: <b>'+baseMapName+'<\/b>. Please select the map where Lib:EventMacros is on|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n\t[setCurrentMap(baseMapName)]\n}]\n[h:assert(findToken(\"lib:EventMacros\") != \"\", \"<font color=red>No Lib:EventMacro found on map <b>\"+baseMapName+\"<\/b> please correct this.\",0)]\n[h:macroIDList\t\t= getMacroGroup(\"Event list macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n<!-- convert the macro names into macro index for the list -->\n[h:triggerEventList = \"eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport\"]\n[h,foreach(trigger, triggerEventList): set(trigger, listFind(macroNameList, eval(trigger)))]\n\n[h,if(getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')==\"\"):setLibProperty('w42.bot.fg.GroupSettings', \"bot.fg.Transportation=1;btnbot.fg.Transportation=Show?Overview;bot.fg.EventTokenArea=1;bot.fg.UtilityMove=1;bot.fg.UtilityGeneral=1;bot.fg.Tables=1;bot.fg.Animations=1;bot.fg.MapCreation=1;bot.fg.VBL=1;bot.fg.Other=1;bot.fg.Functions=1\", 'lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros'),'suffixed')]\n<!--\n bot.fg.Transportation\n bot.fg.EventTokenArea\n bot.fg.UtilityMove\n bot.fg.UtilityGeneral\n bot.fg.Tables\n bot.fg.Animations\n bot.fg.MapCreation\n bot.fg.VBL\n bot.fg.Other\n bot.fg.Functions\n-->\n[h:inputStr\t= \"[]\"]\n[h,if(bot.fg.EventTokenArea_ || bot.fg.Transportation_ || bot.fg.UtilityMove_ || bot.fg.Other_ || bot.fg.UtilityGeneral_ || bot.fg.Animations_ || bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- GENERAL -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- Settings -->\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>General<\/html>||TAB\")]\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Settings<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useAltImage|'+useAltImage+'|<html><span title=\"<html>When checked, the system will first check whether there is a token handout image on the foliage token. <br>If so it will swap the original image for that one, if not it will grab the table image. <br>Unchecked, the system will automatically grab the tbl image<\/html>\">Use alternative transparent image for foliage<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'checkMapsOCL|'+checkMapsOCL+'|<html><span title=\"<html><b>When checked:<\/b> the system will check all the maps when you load the campaign,<br>to see if they appear in the pad database. This is not a full initialization but it will<br>prevent bug reports after you load the campaign and if any inconsistancies are<br>found it will initialize the campaign file. What you will notice is that MT will<br>quickly flick through all the maps when you load the campaign.<br><b>When unchecked:<\/b> no checks are made so nothing will happend when you load the<br>campaign file.<\/html>\">Check all maps on start up<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doSwitchInterMap|Change to other map, do not change to other map, do not change AND store coords|<html><span title=\"<html><b>Change to other map<\/b>: When using inter map teleport, switch to the map after teleportation<br><b>do not change to other map<\/b>: do NOT switch to destination map after teleportation<br><b>do not change AND store coords<\/b>: when using the do NOT switch map option, the system needs to<br>check the destination pad for the correct coords before sending the token there and then return to<br>the current map. This causes maptool to reload the current map. To prevent this you can use this third<br>option, which will store the coords of both pads on eachother during the <i>initialize pads<\/i> process.<br><b>BUT<\/b> that means that you CANNOT move the interPads without running <i>initialize maps<\/i> again.<\/html>\">Automatically swap to map for interpads<\/html><\/span><\/html>|RADIO|SELECT='+doSwitchInterMap)]\n\t[h,if(bot.fg.Transportation_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doScaleTeleport|'+doScaleTeleport+'|<html><span title=\"<html><b>When checked:<\/b> teleportation will keep track of different size teleports<br>This means that if you move to the lower right corner of a small pad you and up<br>on the lower right corner of a larger pad. <br><b>When unchecked:<\/b>teleportation will be relative to the upper left corner<br>of the teleport. So if you move from the lower right corner of a 4x4 to a 2x2<br>pad, then you will end up 2 squares down and 2 squares right OUTSIDE the 2x2 pad.<br>Mb<NOTE:<\/b> turning this on is tricky! E.g. if you make one of 2 vertical border pads<br>twice as thick as the other, and you move 6 squares over the pad, then you will<br>end up 12 (or 3 depending on the direction) beyond the other teleport!<br><\/html>\">Scale Teleportation<\/html><\/span><\/html>|CHECK')]\n\n\t[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'showGroupPanelOnSelect|'+showGroupPanelOnSelect+'|<html><span title=\"<html>When you select a <i>group<\/i> AND the <i>activate switch panel<\/i> is active<br>automatically show the group macro panel<\/html>\">Show group panel on select<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Other_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'fullScreenBroadcast|'+fullScreenBroadcast+'|<html><span title=\"<html>When you check this then the broadcast function will be redefined. Next to its<br>usual function it will ALSO broadcast to a dialog window called <i>Last Chat<\/i><br>but ONLY when the full screen mode is toggled (see campaign macros or F2). This<br>will result in a dialog popping up in full screen mode showing the last message<br>send to chat, using the broadcast function.<br><b>Important note:<\/b> currently its not possible to check whether a client is in<br>full screen or not, this means that this toggle is set for ALL clients.<\/html>\">Redefine <i>Broadcast<\/i> for full screen mode<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'numericIdOnly|'+numericIdOnly+'|<html><span title=\"<html>When you check this then ONLY special pads like Roof, Ward, PadStart, etc.<br>followed by a number (e.g. 1,2,3) will be identified as a special pad. E.g. <u>Roof 1<\/u><br>is recognized as a special pad and <u>Roof Red Barn<\/u> not. If you UNCHECK this<br>then <u>Roof Barn Red<\/u> WILL be identified as a special pad. As usual <i>linked<\/i> pads<br>require the SAME identifier. So <u>PadStart Sea Level<\/u> will be connected to<br><u>PadEnd Sea Level<\/u> (IF the box is unchecked!)<br><b>Note that Linked Pads will NOT work when this is checked<\/b><\/html>\">Numeric Id for special pads only (disable Links!)<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'forceRoomShare|Send macro link to chat, Force share on screen, do both|<html><span title=\"<html><b>Send macro link to chat<\/b>: When using Nildiks room description token, <br>when you click on a <i>share<\/i> link, a macro link is sent to the chat that<br>players can click on to open the frame with the shared information.<br><b>Force share on screen<\/b>: Instead of sending a macro link, the<br>information is immediately opened on the screen of the players.<br><b>Both<\/b>: The information is immediately shown on the players screen<br>AND a click-able macro link is sent to the chat.<\/html>\">When sharing a Room Description<\/html><\/span><\/html>|RADIO|SELECT='+forceRoomShare)]\n\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'baseMapName|'+startUpMapList+'|<html><span title=\"<html>The use of the Canopty option requires a BASE map where the treetrunks are situated. per default this Map is called BASE, here you can give it a different name.<\/html>\">Name of BASE Map<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+baseMapNum)]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'excludeLightTypes|'+excludeLightTypes+'|<html><span title=\"<html>Here you can enter one or more light <u>types<\/u> seperated by a comma (,) (e.g.: Generic, D20) that you dont want to show up as a tab in the Set Light Source macro<\/html>\">Exclude Light Types<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'roofHaloColor|'+haloColors+'|<html><span title=\"<html>Here you can set the color of the halo for the Roof special pad<\/html>\">Set Roof halo color<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+roofHaloColor)]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'forceSelectClient|'+onLineClients+'|<html><span title=\"<html>If you select a client (player pc) from this list then when a gm selects a token<br>on a map that same token will also be selected on the chosen clients side. This <br>is particularly usefull in a laptop beamer setup where you have one single GM <br>client and one single players client to show the map. <br><br>Note that if a previously set (player) client does not exist when this campaign<br>is loaded then this value will be reset to empty and you need to run settings <br>again to select the client.<\/html>\">Force Token Selection on Client<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+forceSelectClient)]\n\n\t[h,if(bot.fg.Animations_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr,\"junk|<html><b>Animations<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'animationPerClient|'+animationPerClient+'|<html><span title=\"<html>Animations like for the doors and the token movement will have an instance running<br>on eacht seperate client. This because the network connection of the server is<br>usually not fast enough to send updates of the animated object to the clients. This<br>requires a copy of the animated token on each client which is visible to the owner only.<br>This copy is removed from the client as soon as the animation is over.<br><i>Visible to owner only<\/i> will only work if <i>strict token ownership<\/i> is checked<br>for the running server. If its not set, then all the copies of all the clients are<br>visible on all the other clients as well. This will look messy. Hence this option to<br>run the animation on the server only.<br><b>When checked:<\/b> Animations will be played on each client<br><b>When unchecked:<\/b> Animations will be played on the server only<br><\/html>\">Run animations per client<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'timeLockDelay|'+timeLockDelay+'|<html><span title=\"<html>When using the token buttons to open or close doors then the onTokenSelectionEvent is<br>triggered. Unfortunately its triggered more than once. With the effect that the door<br>opens, closes, opens etc. To prevent this Ive created a time-out in which the event is<br>ignored. If this time is too short you will notice the door open-close event triggering<br>multiple times. If you set if to slow then you have to wait that time before you can<br>use the button again. The time is in ms meaning that 1000\t= 1 second. If you encounter<br>the problem of the door animation triggering multiple times when you click the door<br>button then you should set this timer higher, e.g. to 1000. <\/html>\">Time lock delay for token buttons (ms)<\/html><\/span><\/html>')]\n\t}]\n\n\t[h,if(bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr,\"junk|<html><b>Summon Token Macro<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonPcPropType|'+summonPcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of PCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of PCs<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonNpcPropType|'+summonNpcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of NPCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of NPCs<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonPropTypesList|'+summonPropTypesList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will also generate a dropdownbox for any tokenproperty<b><u>type<\/b><\/u> that <br>is listed here<\/html>\">List of Summon Token Property Types<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonSpecialList|'+summonSpecialList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will generate a dropdownbox for listed tokenproperties. In addition <br>here you can set Token Names which you want to let appear in a seperate Dropdownbox. <br>Here its used for the special pad names, but it can be used for other purposes<\/html>\">List of Summon Token Special<\/html><\/span><\/html>')]\n\t}]\n}]\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- ONCAMPAIGNLOAD -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- stuff that happens when the campaign is loaded -->\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>On Campaign Load<\/html>||TAB\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Stuff that happens when you load the campaign<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useStartUpMap|'+useStartUpMap+'|<html><span title=\"<html><b>When checked:<\/b> the below two settings (load map on start up and go to coordinates) will be used.<\/html>\">Use Start Up map and coordinates<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'startUpMap|'+startUpMapList+'|<html><span title=\"<html>Pick here the name that should be loaded on campaign load or when players log in.<\/html>\">Set map to open at start up<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+startUpMapNum)]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'startUpCoords|'+startUpCoords+'|<html><span title=\"<html>Set here the coordinates which the map will be centred on campaign load<br>or when players log in. You can see the coordinates of your cursor on the<br>map in the lower right corner of Maptool. Example (X,Y): <b>5,4<\/b>.<br><br>Alternatively you can also enter a <b>token name<\/b>, however when you do that<br>make sure that the name does not contain any comma(s): <i>,<\/i><\/html>\">Set coordinates to centre map on start up.<\/html><\/span><\/html>')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useCentreOnMePad|'+useCentreOnMePad+'|<html><span title=\"<html>This setting will override the coordinates unless the CentreOnMePad<br>is not found on the map. When you check this setting then on start up<br>the map will be centred onto this token for all clients.<\/html>\">Centre on CentreOnMePad on start up.<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Animations_ || bot.fg.EventTokenArea_ || bot.fg.Other_ || bot.fg.UtilityMove_)\t:inputStr\t= json.append(inputStr, 'runSwitchForm|'+runSwitchForm+'|<html><span title=\"<html><b>When checked: <\/b>the form that you need to start so door switches work, <br>will start automatically on campaign load .<\/html>\">Start door switches form<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'disableOCLCheck|'+disableOCLCheck+'|<html><span title=\"<html><b>When checked: <\/b>The boT check result* shown in the chat<br>after you have loaded the campaign, will be turned OFF.<br><br>*Thats the red-yellow colored bar called:<br><i>Bag of Tricks - OnCampaignLoad checks<\/i><\/html>\">Disable OCL Checks<\/html><\/span><\/html>|CHECK')]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- EXCLUSIONS -->\n\t\t\t\t\t\t\t\t\t\t\t\t<!-- map exclusion -->\n\t\t\t\t\t\t\t\t\t\t\t\t[h\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>Exclusions<\/html>||TAB\")]\n\t\t\t\t\t\t\t\t\t\t\t\t[h\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Which maps should be excluded from the Initialization<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\n\t\t\t\t\t\t\t\t\t\t\t\t[H:excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n\t\t\t\t\t\t\t\t\t\t\t\t[H, if(json.isEmpty(excludedMaps)): excludedMaps\t= \"[]\"]\n\t\t\t\t\t\t\t\t\t\t\t\t[h,foreach(map, allMaps), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[H: isExcluded\t= json.contains(excludedMaps,map)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[H\t:inputStr\t= json.append(inputStr,strformat(\"map%{roll.count}|%{isExcluded}|%{map}|CHECK\"))]\n\t\t\t\t\t\t\t\t\t\t\t\t}]\n}]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- Property type exclusion -->\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Which propertyTYPES should NOT trigger the onTokenMoveEvent<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'excludePropertyTypes|'+excludePropertyTypes+'|<html><span title=\"<html>Here you can enter one or more property types that will NOT trigger the onTokenMoveEvent.<br>Token property types can be set in menu-->edit-->campaign properties-->Token Properties.<br>There you find a list of the token properties for your campaign. Per default you will find the<br> Basic property type there. A property type for a token you can set by double clicking on<br>a token-->config tab-->Properties. That field contains a dropdown menu where you can choose <br>the property type for that token. All the Property Types you list in this field will NOT trigger<br>the event when moved. E.g. if you list SpecialPads here and your drag a token with the SpecialPad<br>property type onto a teleport token, then that token will NOT be teleported.<\/html>\">Exclude Property Types<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- TOGGLES -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- toggle things on or off -->\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>Toggles<\/html>||TAB\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can turn off certain checks to speed thing up<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doGroups|'+doGroups+\t\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off group movement<\/html>\">Group movement<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doSnap2Grid|'+doSnap2Grid+\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off Snap To Grid. This is mainly<br>interesting for token move animation where you <br>want the tokens to move smoothly, but also have<br>them snapped to grid. When checked this option<br>will snap the last moved token to grid. This only<br>works when Maptools its Snap To Grid is turn off.<\/html>\">Snap To Grid<\/html><\/span><\/html>|CHECK')]\n[h, if(vblSupport == 1 && bot.fg.VBL_)\t\t\t\t\t:inputStr \t= json.append(inputStr, 'doVBLStamp|'+doVBLStamp+\t'|<html><span title=\"<html>Uncheck to turn off VBL stamps.<br>VBL Stamps are Vision Blocking Layer stamps that work on tokens<br>that have a label set to <i>VBLStamp<\/i>. When a tokens has this<br> word in its label a VBL cross will be drawn over it when it is moved.<br> And that VBL cross will move with the token.<\/html>\">VBL Stamps<\/html><\/span><\/html>|CHECK') ; doVBLStamp\t= 0]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doResetFoW|'+doResetFoW+\t\t\t\t\t'|<html><span title=\"<html>Check to restore ALL Fog of War on every move<\/html>\">Restore FoW<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.VBL_)\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doVBLCheck|'+doVBLCheck+\t\t\t\t\t'|<html><span title=\"<html><i>This feature is developed by Aliasmask.<\/i><br>It does two things:<br><b>1.<\/b> If a token <i>cuts a corner<\/i> of a vision blocking area,<br>then a warning is given and the token is moved to the spot<br>BEFORE the corner was cut.<br> <b>2.<\/b> Because of the path that the token was dragged along<br>would be cleared of the fog of war (FoW) its movement is<br>reset and the macro clears the FoW.<br> The latter has the HUGE advantage that it also is a work<br>around for the (b87) FoW lag issue! If you have individual<br>FoW turned on for tokens then after a while dragging tokens<br>around can become very laggy. This option solves that issue.<br> The disadvantage is that if you move tokens over a large path<br>then it takes considerably longer (in addition to the normal<br>delay this Bag of Tricks introduces). The delay is not<br>noticeable for short distances but becomes e.g. 1 second<br>when you drag a token over 300 squares.<br>  <\/html>\">VBL move check<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doCentreOnTok|'+doCentreOnTok+\t\t\t\t'|<html><span title=\"<html>Check to continuously centre the map on the moving token.<br>Does not work for multiple moving tokens<\/html>\">Centre on token<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'doTriggerOnZeroMove|'+doTriggerOnZeroMove+\t'|<html><span title=\"<html>If you move a token and put it back onto its original spot then,<br>this will trigger the onTokenMoveEvent. If you <b>check<\/b> this box then if<br>a token is standing on a special pad, that pad will be activated.<br><b>Uncheck<\/b> to ignore this zero move.<br><b>Note<\/b> that if you set Waypoints and then return to the original<br>spot, that the token has actually moved and the special pad<br>WILL be activated!<\/html>\">Trigger Pads on zero move<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'doSpecialPads|'+doSpecialPads+\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off the special pads entirely (Check Start and Check Path included).<\/html>\">Check special pads<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doLockMovement|'+doLockMovement+\t\t\t'|<html><span title=\"<html>Check to prevent the movement of locked tokens.<br>You can select a token and toggle the <i>lock movement<\/i><br>macro. When a token is locked this way AND when this setting<br>is turned on, the movement of that tokens will always be <br>reverted. Not even the gm can move the token.<br><\/html>\">Lock movement for locked tokens<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doFullScreenMode|'+doFullScreenMode+\t\t'|<html><span title=\"<html>b89+: Check to turn on a isFullScreen check.<br>This will automatically switch the BoT macro panel to<br>full screen mode (showing the panel while in full screen)<br>and back to a dockable frame when not in full screen.<\/html>\">Full Screen Mode<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.UtilityMove_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, \"junk|<html><b>___________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'doInvisibility|'+doInvisibility+\t\t\t'|<html><span title=\"<html>This will turn on the invisibility checks on token move<br>It will only trigger for tokens that either have:<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t1. Invisibility State<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. See, Purge and/or Annul Invisibility State<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. The <i>seeing, purging or annulling<\/i> token has a a corresponding range set as property.<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>NOTE:<\/b> you can only see the invisibility effects (on a player client) when running a server with <i>STRICT TOKEN OWNERSHIP<\/i> turned on.<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe range set will be the maximum distance at which the invisible token is seen/purged/annuled. If the property does not exist you will be asked<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\tto enter a value when you run the macro for a token. The corresponding properties are: w42.seeInvisRange, w42.purgeInvisRange, w42.annulInvisRange.<\/html>\">Invisibility<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'invisState|'+invisState+\t\t\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state used for Invisibility<\/html>\">Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'seeInvisState|'+seeInvisState+\t\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the name of the state used for seeing invisibility<\/html>\">See Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'purgeInvisState|'+purgeInvisState+\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state name of the used for purging invisibility<\/html>\">Purge Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'annulInvisState|'+annulInvisState+\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state name of the used for annulling invisibility<\/html>\">Annul Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, \"junk|<html><b>___________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n}]\n[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doShowPath|Do not Track Path, Track Path, Track Path and delete feet manually|<html><span title=\"<html>When Track Path is turned on, small feet will be placed in the cells over which a token is moved. <br>Red feet for NPCs and Blue feet for PCs.<br><br><b>Do not Track Path:<\/b> its turned off <br><b>Track Path:<\/b> its turned on, only the LAST move is shown<br><b>Track Path and delete feet manually:<\/b> for every move feet will be placed in the path. <br>To remove them from the map use the following command: [bot_getPath(3)]<br><br><b><u>Note that 3 conditions MUST BE MET before you toggle this setting:<\/u><\/b><br>1. the blue and red feet must on the BASE map and NOT on the OBJECT layer<br>2. a state <i>pathFeet<\/i> must be created (the feet must have that state)<br>3. BOTH the <i>impersonation and selection panel<\/i> must be closed (or the removal will be <br>extremely slow)<\/html>\">Show the last moved path<\/html><\/span><\/html>|RADIO|SELECT='+doShowPath)]\n[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'canSelectShadowTok|Object Layer, Token Layer, Token Layer and autoselect Main Token|<html><span title=\"<html>When using shadow pads, you can choose the layer where the shadow tokens are placed:<br>- Object layer: shadow token can not be selected (targeted) by players<br>- Token layer: shadow token *can* be selected (targeted) by players<br>- Token layer (autoselect main): when the shadow token is selected the actual token is selected instead.<br>The latter requires the <i>activate switches<\/i> macro to be running.<\/html>\">Where to place Shadow Tokens<\/html><\/span><\/html>|RADIO|SELECT='+canSelectShadowTok)]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{}]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>The following toggles work for altInitMap only!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'doFirstPointPath|'+doFirstPointPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token starts its movement on a special pad<br>e.g.(under) canopy, then the token activates the relevant code.<br>E.g. in case of Canopy if the token moves away far enough then it will restore<br>the Canopy picture. Turning this off will result in this check NOT taking place.<br>So Canopy will dissapear but no longer reappear. Turning this off is usefull when<br>you are not using Canopy, Foliage or Roof pads.<\/html>\">Check Start (Canopy, Foliage or Roof)<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'doInnerPointsPath|'+doInnerPointsPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token moves over a Ward or EventPad,<br>then the code is activated for that pad encountered. E.g. in case of Ward,<br>the Token is placed on the edge of the ward and the rest of the movement is negated.<br>Turning this off is usefull when you are not using Ward or EventPad pads.<\/html>\">Check Path (Ward, Event)<\/html><\/span><\/html>|CHECK')]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Movement Limiter!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'limitMovement|'+limitMovement+\t\t\t'|<html><span title=\"<html>Here you can set a number or a token property to which token movement is limited during<br>initiative. Entering e.g. <i>4<\/i> means that the max allowed move is 4 cells. Entering<br><i>movement<\/i> will limit the movement of the token to its <i>movement<\/i> property. You<br>can enter any token property you like as long as that token property contains a number.<br>Should a player in this case move her token 5 or more cells, then they will receive a<br>message and the movement will be reset (so the tokens will be returned to its original<br>position). <br><br><b>Note that this feature will NOT work:<\/b><br>- when the user moving the token is a GM<br>- when the number set here is 0<br>- when the token is NOT in the initiative panel<br><br>Also note that this does not prevent someone from moving her token twice!<br><br><b>The macro that handles this is placed on the lib:EventMacros.<\/b> You can edit<br>this macro to better suit your framework. More explanations you can find there.<\/html>\">Limit movement to: (0\t= ignore)<\/html><\/span><\/html>')]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- GENERAL EVENTS -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- macros linked in ontokenmove -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>General Events<\/html>||TAB\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can link an event macro to other events<\/b><br>Note that only the macros from the group:<br>'Event list macros' are in the drop downlists<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME when you move ONE token<\/html>\">Before the Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreMultipleTokenMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME when you move MULTIPLE tokens<\/html>\">Before Multiple Tokens are Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreMultipleTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroOnTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro executes ONLY after a LEGAL move of ONE token.<br>But BEFORE the event macros are executed.<br>This macro will run before any of the OnTokenMove code is executed<\/html>\">When Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroOnMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro executes ONLY after a LEGAL move of MULTIPLE tokens.<br>But  before any events of the special pads are executed<\/html>\">When Multiple Tokens are Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnMultipleTokensMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html>For the coders. The events herabove will be called in the onTokenMove scope.<br>Below will be called in a deferred macro (of onTokenMove) and will thus NOT<br>be in scope of the onTokenMove! The token ID, getLastPath(0) and getLastPath (1)<br>will be passed on as variables.<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro that executes EVERYTIME after a LEGAL move of ONE token.<br>This macro will run after any events of the special pads take place<\/html>\">After Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro that executes EVERYTIME after a LEGAL move of MULTIPLE tokens.<br>This macro will run after any events of the special pads take place<\/html>\">After Multiple Tokens are  Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostMultipleTokensMove)]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html>In the events below a strprop is passed on with contextual variables<br>These can be created using varsFromStrProp(arg(0)) and are as follows:<br>tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventPreMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport on the same map occurs.<\/html>\">Before Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPreMacroTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventPostMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport on the same map occurs.<\/html>\">After Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPostMacroTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport to another map occurs.<\/html>\">Before Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreInterTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport to another map occurs.<\/html>\">After Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostInterTeleport)]\n}]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- SYSTEM -->\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- Dev only stuff -->\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>System<\/html>||TAB\")]\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can set the technical stuff<\/b><br>As a general rule: do not touch unless you <br>know what you are doing<\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'libCoordSize|'+libCoordSize+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>Just do not change this value. Its used for the x/y area size of the lib coords<\/html>\">Lib coords size<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'maxPadsPerRun|'+maxPadsPerRun+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>If you have a map with a LOT of special pads on it (> 500) it is likely that<br>Maptool will crash when initializing them all at once. For this reason Ive<br>implemented this setting to break up large numbers of special pads to scan into<br>smaller bits which requires you to run the alternative initializing macro more than once.<br>The maximum supported amount of special tokens on one map is 1000 so the default<br>setting (500) will require you to run the init macro at most twice. <br><br><b>Change this when:<\/b> This number of pads to scan in one run might be too<br>much for older pcs and Maptool might crash. If this is the case lower the setting.<br><\/html>\">Maximum of pads to scan per run<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'maxGroupSelect|'+maxGroupSelect+'|<html><span title=\"<html>This setting is used for the group selection feature, specifically the panel. If a too large selection is made (>1000) MT crashes.<br>In addition the tool will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default<br>is 500 but you can lower (to speed things up) or up (to allow bigger selections) then number to a max of 1000 (at your own risk)<\/html>\">Maximum allowed group selection<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.MapCreation_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'maxOrderSelect|'+maxOrderSelect+'|<html><span title=\"<html>This setting is used for the order selection panel. If a too large selection is made (roughly over 500) MT crashes. In addition the tool<br>will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default is 200 but you<br>can lower (to speed things up) or up (to allow bigger selections) then number to a max of 500 (at your own risk)<\/html>\">Maximum allowed order selection<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'padNameList|'+padNameList+'|<html><span title=\"<html>This is the entire list of special pads. If you remove any of this list then these will not be initialized.<br>If you somehow have messed this up, clear the entire box click OK and then run OCL. <\/html>\">Special Pads List<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n}]\n\n<!-- run the input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- process results of input -->\n[H: excludedMaps = \"[]\"]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t[foreach(map, allMaps), code: {\n\t\t[if(eval(\"map\"+roll.count)): excludedMaps = json.append(excludedMaps,map)]\n\t}]\n}]\n\n<!-- if startup coords are not set -->\n[h,if(startUpCoords == 0): startUpCoords = \"0,0\"]\n\n[h,if(!summonPropTypesList): summonPropTypesList = \"\"]\n[h,if(!summonSpecialList): summonSpecialList = \"\"]\n\n<!-- convert the macro index into the actual macro name -->\n[h,foreach(trigger, triggerEventList):set(trigger, listGet(macroNameList, eval(trigger)))]\n\n<!-- check redefine broadcast and initiate accordingly -->\n[h,if(oldFSB != fullScreenBroadcast):broadcast(\"You have changed the broadcast setting. For this to take effect you will need to RELOAD the campaign. Note that its a bad idea to run oncampaignload in this case, you really need to reload the campaign!\")]\n\n[H:setLibProperty(\"useStartUpMap\",useStartUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpMap\",startUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpCoords\",startUpCoords,\"lib:EventMacros\")]\n[H:setLibProperty(\"useCentreOnMePad\",useCentreOnMePad,\"lib:EventMacros\")]\n[H:setLibProperty(\"runSwitchForm\",runSwitchForm,\"lib:EventMacros\")]\n[H:setLibProperty(\"disableOCLCheck\",disableOCLCheck,\"lib:EventMacros\")]\n\n[H:setLibProperty(\"excludedMaps\",excludedMaps,\"lib:EventMacros\")]\n[h:setLibProperty(\"useAltImage\", useAltImage,\"lib:EventMacros\")]\n[h:setLibProperty(\"checkMapsOCL\", checkMapsOCL,\"lib:EventMacros\")]\n[h:setLibProperty(\"showGroupPanelOnSelect\", showGroupPanelOnSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"fullScreenBroadcast\", fullScreenBroadcast,\"lib:EventMacros\")]\n[h:setLibProperty(\"numericIdOnly\", numericIdOnly, \"lib:EventMacros\")]\n[h:setLibProperty(\"forceRoomShare\", forceRoomShare, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"baseMapName\", baseMapName,\"lib:EventMacros\")]\n[h:setLibProperty(\"excludeLightTypes\",excludeLightTypes, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"animationPerClient\", animationPerClient,\"lib:EventMacros\")]\n[h:setLibProperty(\"timeLockDelay\", timeLockDelay, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"invisState\",invisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"seeInvisState\",seeInvisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"purgeInvisState\",purgeInvisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"annulInvisState\",annulInvisState,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"summonPcPropType\", summonPcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonNpcPropType\", summonNpcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonPropTypesList\", summonPropTypesList,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonSpecialList\", summonSpecialList,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"libCoordSize\", libCoordSize, \"lib:EventMacros\")]\n[h:setLibProperty(\"maxPadsPerRun\", maxPadsPerRun,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxGroupSelect\", maxGroupSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxOrderSelect\", maxOrderSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"padNameList\", padNameList, \"lib:EventMacros\")]\n\n[h:doVBLStamp = if(doVBLStamp && vblSupport, 1, 0)]\n\n<!-- Initialize drawArea -->\n[h, if(getStrProp(\"toggles\", \"drawArea\") == \"\"), CODE:{\n\t[drawArea\t= 0]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n}]\n\n[h:toggles = strPropFromVars(\"forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doInvisibility, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\nSettings done.",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "db64a9ed-9a48-4d4d-a2f3-e4f4c7722af5",
          "commandChecksum": "cf5d2d21c642f453758c9ac2d185842b",
          "propsChecksum": "f72134fd578015a943a1efff813302bd"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "1",
        "index": 427,
        "label": "createMacroButtonsOTMSetup",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------------- createMacroButtonsOTMSetup --------------------------------------------------- -->']\n[h:'<!-- bot_HTMLMacroButton(cellWidth, cellColor, textColor, text, macroName, shadow, toolTip, arguments, macro location, output to) -->']\n\n[h:'<!-- get the menu buttons html -->']\n[h:menuButtons\t= getLibProperty(\"bot.fg.MenuButtons\", \"lib:OnTokenMove\")]\n[h:varsFromStrProp(menuButtons)]\n\n[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='#e5e5cc'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine\t= \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd\t= \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor=\"#e5e5cc\" style=\"font-size:8.5px; text-align:center\">\n<table width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tr><td>\n\t<table width=\"100%\"><tr><td bgColor = \"#e5e5cc\" align=\"center\">\n\t\t<span color=\"black\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Setup<\/b>\" ,\"MacroButtonsOTMSetup@this\",\"none\")]<\/span>\n\t\t<\/td><td bgColor = \"#c5c5ac\" align=\"center\">\n\t\t<span color=\"gray\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Utils<\/b>\" ,\"MacroButtonsOTMUtils@this\",\"none\")]<\/span>\n\t<\/td><\/tr><\/table>\n\t<\/td><\/tr><tr><td>\n\n<!-- The menu buttons html is created by the createButtonsDB macro. Then the result is stored (encoded) in a libEventTokens property as a strprop. Above the button names e.g. 'door' are created as variables. The below lists are macro per menu item e.g. 'utilList' contains a set of macros that is shown under the 'utils' grouptitle. Hence the entire menu structure is build up dynamically. Every two buttons a newLine html is added so the buttons are paired by two. You could change the odd() part to check for every three so you would have three buttons next to eachother. \nSince the list items are strings they need to be eval() and also decode() as theyre stored encoded in the strProp. -->\n\n<!-- create the lists corresponding with the macro menu groups based on the installation settings -->\n[h:varsFromStrProp(getLibProperty('bot.fg.menuMacroList',  'lib:OnTokenMove'))]\n\n[r, if(listCount(basicsList)), CODE:{\n\t[h:groupTitle\t= \"Basics\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, basicsList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(basicsList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(animationList)), CODE:{\n\t[h:groupTitle\t= \"Animation\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, animationList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(animationList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(soundList)), CODE:{\n\t[h:groupTitle\t= \"Sound\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, soundList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(soundList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(scatterList)), CODE:{\n\t[h:groupTitle\t= \"Scatter & Canopy\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, scatterList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(scatterList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(eventList)), CODE:{\n\t[h:groupTitle\t= \"Event Pads/<font color=#FFFF00>Areas<\/font> (Traps & Pits)\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, eventList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(eventList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(assignList)), CODE:{\n\t[h:groupTitle\t= \"Assign Pads\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, assignList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(assignList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(tablesList)), CODE:{\n\t[h:groupTitle\t= \"Tables\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, tablesList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(tablesList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(mapList)), CODE:{\n\t[h:groupTitle\t= \"Map Editor\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, mapList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(mapList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilsList)), CODE:{\n\t[h:groupTitle\t= \"Utils\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilsList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilsList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "81dbb9dd-f92c-4f24-8979-db230c031f3b",
          "commandChecksum": "5c6079f3aef8c04e1feeaef2947fd4ec",
          "propsChecksum": "c9a9f3faa871a9cc94e1b89db613d03c"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "orange",
        "group": "1. Macro Frame",
        "includeLabel": false,
        "sortBy": "2",
        "index": 435,
        "label": "updateVirtualMenu",
        "fontSize": "11pt",
        "minWidth": "193",
        "playerEditable": false,
        "command": "<!-- to update the virtual menu: \nfirst add the new button to createbuttonDB\nthen add it below to the corresponding menu at the order spot you want it and with the if(feature dependent) in front of it. \n\nshould you wish to create a new menu topic\"\ncreate it below as the others\nand add the name to: menuMacros variable way below\nfinally update the createMacroButtonsOTMxxx with the new group\n -->\n\n<!--\n bot.fg.Transportation\n bot.fg.EventTokenArea\n bot.fg.UtilityMove\n bot.fg.UtilityGeneral\n bot.fg.Tables\n bot.fg.Animations\n bot.fg.MapCreation\n bot.fg.VBL\n bot.fg.Other\n bot.fg.Functions\n-->\n\n[h:groupSettings   = getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')]\n[h:varsFromStrProp(groupSettings,'suffixed')]\n\n<!-- --------------------------------------------------------------------- -->\n<!-- ----------------------------- UTIL MENU ----------------------------- -->\n<!-- --------------------------------------------------------------------- -->\n\n[h:utilAnimationList = '']\n\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Door')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Doors')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Lock')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'ClearSound')]\n[h, if(bot.fg.MapCreation_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveCrowd')]\n[h, if(bot.fg.MapCreation_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveCrowdP')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveToken')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'AnimateText')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'runAnimateView')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'ResetPit')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'UnShowAreaUtil')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'ExecuteEvent')]\n[h, if(bot.fg.Other_):utilAnimationList = listAppend(utilAnimationList,'ExecAssignpad')]\n\n[h:utilUtilList = '']\n\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'DiceBox')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SwitchMap')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SeekToken')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SetLightSource')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'UseDisguise')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ToggleSpecial')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ShowHandout')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'WhisperFrame')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'MessageMngr')]\n[h, if(bot.fg.MapCreation_):utilUtilList = listAppend(utilUtilList,'SetDrawOrder')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'GroupMove')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'UngroupMove')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'Formations')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'ActivateGroup')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'GroupSelect')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'UngroupSelect')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'toggleEmbark')]\n[h, if(bot.fg.MapCreation_):utilUtilList = listAppend(utilUtilList,'SummonTokens')]\n[h, if(bot.fg.VBL_):utilUtilList = listAppend(utilUtilList,'ToggleVBL')]\n[h, if(bot.fg.VBL_):utilUtilList = listAppend(utilUtilList,'VBLGrenade')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'LockMovement')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'LockToken')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):utilUtilList = listAppend(utilUtilList,'moveEventToggle')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ShowDescription')]\n\n[h:utilInvisList = '']\n\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'StartInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'EndInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'SeeInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'SawInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'PurgeInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'PurgedInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'AnulInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'AnulledInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'resetRanges')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'changeElevation')]\n\n<!-- --------------------------------------------------------------------- -->\n<!-- ----------------------------- SETUP MENU ----------------------------- -->\n<!-- --------------------------------------------------------------------- -->\n\n[h:basicsList = '']\n\n[h, if(1):basicsList = listAppend(basicsList,'Settings')]\n[h, if(1):basicsList = listAppend(basicsList,'BoTFeatures')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):basicsList = listAppend(basicsList,'InitializePads')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):basicsList = listAppend(basicsList,'AltInitPads')]\n[h, if(1):basicsList = listAppend(basicsList,'Manual')]\n\n[h:animationList = '']\n\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'SetDoor')]\n[h, if(bot.fg.EventTokenArea_):animationList = listAppend(animationList,'SetRoof')]\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'setAnimateView')]\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'linkViewAnim')]\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.Other_ || bot.fg.Animations_):animationList = listAppend(animationList,'ActivateSwitches')]\n\n[h:soundList = '']\n\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'ClearSound')]\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'ReplaceSoundURL')]\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'SetSound')]\n\n[h:scatterList = '']\n\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'BuildForest')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ChooseTrunks')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'CreateCrowd')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ChooseCrowd')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ScatterTokens')]\n[h, if(bot.fg.VBL_):scatterList = listAppend(scatterList,'MassVBL')]\n\n[h:eventList = '']\n\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'DrawArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'SetEventPad')]\n[h, if(bot.fg.EventTokenArea_ || bot.fg.MapCreation_):eventList = listAppend(eventList,'FillArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'ResetPit')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'DefineArea')]\n[h, if(bot.fg.UtilityGeneral_):eventList = listAppend(eventList,'SetEventButton')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'AssignArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'UnShowArea')]\n\n[h:assignList = '']\n\n[h, if(bot.fg.Other_):assignList = listAppend(assignList,'AssignTokens')]\n[h, if(bot.fg.Other_):assignList = listAppend(assignList,'Execute')]\n\n[h:tablesList = '']\n\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'CreateTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'ShowTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'DeleteTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'CreateMTTable')]\n\n[h:mapList = '']\n\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MapEditor')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'QuitMapEditor')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MovetoHidden')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MovetoToken')]\n\n[h:utilsList = '']\n\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SeekToken')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetLightSource')]\n[h, if(bot.fg.EventTokenArea_):utilsList = listAppend(utilsList,'SetReference')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Remove20')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetDrawOrder')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'RenumberTokens')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'ToggleSpecial')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetTokenSize')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'CopyDelMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'PasteMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'UndoDelMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'FindDuplicates')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'embarkation')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'PadExplorer')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'AutoDisguiseBttn')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'SetVBLStamp')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'MassVBL')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'ToggleVBL')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Deleteprops')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Benchmark')]\n[h, if(1):utilsList = listAppend(utilsList,'DiagnoseMaps')]\n[h, if(1):utilsList = listAppend(utilsList,'CleanTokNames')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'roomDescrHelp')]\n\n[h:menuMacros = strPropFromVars('utilAnimationList,utilUtilList,utilInvisList,basicsList,animationList,soundList,scatterList,eventList,assignList,tablesList,mapList,utilsList','unsuffixed')]\n[h:setLibProperty('bot.fg.menuMacroList', menuMacros, 'lib:OnTokenMove')]",
        "maxWidth": "",
        "tooltip": "this builds the macro menu corresponding to the installation settings",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d8ca42d0-02a2-4444-b762-c90206e73ea5",
          "commandChecksum": "097819ec944005e271d0a7e67f865fc5",
          "propsChecksum": "05de2b92e2f32acd3c0801b06c064ee7"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "1a",
        "index": 436,
        "label": "diagnoseFeatures",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!--\n bot.fg.Transportation\n bot.fg.EventTokenArea\n bot.fg.UtilityMove\n bot.fg.UtilityGeneral\n bot.fg.Tables\n bot.fg.Animations\n bot.fg.MapCreation\n bot.fg.VBL\n bot.fg.Other\n bot.fg.Functions\n-->\n\n[h:groupSettings   = getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')]\n[h:varsFromStrProp(groupSettings,'suffixed')]\n\n<!-- make sure that the number and order of the arrays corresponds with the lists !!  -->\n\n<!-- actual thing -->\n[h:diagStateArray = '[]']\n[h, if(bot.fg.Animations_):diagStateArray = json.append(diagStateArray,'isButton')]\n[h, if(bot.fg.Animations_):diagStateArray = json.append(diagStateArray,'Locked')]\n[h, if(bot.fg.UtilityMove_):diagStateArray = json.append(diagStateArray,'pathFeet')]\n[h, if(bot.fg.EventTokenArea_):diagStateArray = json.append(diagStateArray,'Special Area')]\n[h, if(bot.fg.MapCreation_):diagStateArray = json.append(diagStateArray,'Prone')]\n[h, if(bot.fg.MapCreation_):diagStateArray = json.append(diagStateArray,'editFieldMarker')]\n\n[h:diagTokenArray = '[]']\n[h, if(bot.fg.Animations_):diagTokenArray = json.append(diagTokenArray,'DoorLeverToken')]\n[h, if(bot.fg.UtilityMove_):diagTokenArray = json.append(diagTokenArray,'blue feet')]\n[h, if(bot.fg.UtilityMove_):diagTokenArray = json.append(diagTokenArray,'red feet')]\n[h, if(bot.fg.EventTokenArea_):diagTokenArray = json.append(diagTokenArray,'Area Marker')]\n[h, if(bot.fg.MapCreation_):diagTokenArray = json.append(diagTokenArray,'GridCoordMarker')]\n[h, if(bot.fg.UtilityGeneral_):diagTokenArray = json.append(diagTokenArray,'VPCU')]\n\n[h:diagTableArray = '[]']\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'tbl_Image')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'Polymorph')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'encounters')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'frames')]\n\n<!-- corresponding descriptions with the actual things -->\n[h:diagStateList = '']\n[h, if(bot.fg.Animations_):diagStateList = listAppend(diagStateList,'the switch buttons to operate doors')]\n[h, if(bot.fg.Animations_):diagStateList = listAppend(diagStateList,'doors so the gm can lock them (doors will NOT work without this state)')]\n[h, if(bot.fg.UtilityMove_):diagStateList = listAppend(diagStateList,'path tracking (blue and red feet)')]\n[h, if(bot.fg.EventTokenArea_):diagStateList = listAppend(diagStateList,'creating special areas (like movement limitation)')]\n[h, if(bot.fg.MapCreation_):diagStateList = listAppend(diagStateList,'used for the Crowd utility')]\n[h, if(bot.fg.MapCreation_):diagStateList = listAppend(diagStateList,'used for Map Editor Utility')]\n\n[h:diagTokenList = '']\n[h, if(bot.fg.Animations_):diagTokenList = listAppend(diagTokenList,'the switch buttons to operate doors')]\n[h, if(bot.fg.UtilityMove_):diagTokenList = listAppend(diagTokenList,'path tracking (the PC track)')]\n[h, if(bot.fg.UtilityMove_):diagTokenList = listAppend(diagTokenList,'path tracking (the NPC track)')]\n[h, if(bot.fg.EventTokenArea_):diagTokenList = listAppend(diagTokenList,'creating special areas (like movement limitation)')]\n[h, if(bot.fg.MapCreation_):diagTokenList = listAppend(diagTokenList,'the transparent field tokens required for the Map Editor')]\n[h, if(bot.fg.UtilityGeneral_):diagTokenList = listAppend(diagTokenList,'a token required as placeholder when using the Embarkation macros (vehicles)')]\n\n[h:diagTableList = '']\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Roofs - Formations - Dicebox - Room Descriptions')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Aliasmask Polymorph (table is only necessary if you want to access images from that table)')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Nildiks Room Description  (table is only necessary if you want to access images from that table)')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Nildiks Fancy Frames and Room Description')]\n\n[h:diagArrays = strPropFromVars('diagStateArray,diagTokenArray,diagTableArray','unsuffixed')]\n[h:diagLists = strPropFromVars('diagStateList ,diagTokenList ,diagTableList','unsuffixed')]\n[h:setLibProperty('bot.fg.diagArrays', diagArrays, 'lib:OnTokenMove')]\n[h:setLibProperty('bot.fg.diagLists', diagLists, 'lib:OnTokenMove')]\n\nDiagnose settings have been updated",
        "maxWidth": "",
        "tooltip": "create DB for dependency check for features",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dda76b40-9b2b-40c1-b104-68628ad7dfc5",
          "commandChecksum": "9696027330441fb671ede1d00cc9ba36",
          "propsChecksum": "97d022c08d25206123ebc09b067ac326"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "10",
        "index": 437,
        "label": "settings BCK",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!------------------------------------SETTINGS-------------------------------------------------------->']\n[h:assert(isGM(), \"Only a GM can modify the settings\",0)]\n\n<!-- Settings -->\n[h:useAltImage\t\t\t= getLibProperty('useAltImage','lib:EventMacros')]\n[h:checkMapsOCL\t\t\t= getLibProperty('checkMapsOCL','lib:EventMacros')]\n[h:showGroupPanelOnSelect= getLibProperty('showGroupPanelOnSelect','lib:EventMacros')]\n[h:fullScreenBroadcast\t= getLibProperty('fullScreenBroadcast','lib:EventMacros')]\n[h:oldFSB\t\t\t\t= fullScreenBroadcast]\n[h:numericIdOnly\t\t= getLibProperty('numericIdOnly', 'lib:EventMacros')]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n[h:baseMapName\t\t\t= getLibProperty('baseMapName','lib:EventMacros')]\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes','lib:EventMacros')]\n[h:haloColors\t\t\t= 'red,dark gray, yellow, blue, black, white,light gray,teal,none']\n[h:onLineClients\t\t= listInsert(json.toList(bot_nself()),0,\"\")]\n\n<!-- animations -->\n[h:animationPerClient\t= getLibProperty('animationPerClient','lib:EventMacros')]\n[h:timeLockDelay\t\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n<!-- summon token macro -->\n[h:summonPcPropType\t\t= getLibProperty('summonPcPropType','lib:EventMacros')]\n[h:summonNpcPropType\t= getLibProperty('summonNpcPropType','lib:EventMacros')]\n[h:summonPropTypesList\t= getLibProperty('summonPropTypesList','lib:EventMacros')]\n[h:summonSpecialList\t= getLibProperty('summonSpecialList','lib:EventMacros')]\n\n<!-- set vars for Toggles -->\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n<!-- halo colors is stored as string, so convert to number -->\n[h:roofHaloColor\t\t= max(0,listFind(haloColors, roofHaloColor))]\n[h:forceSelectClient\t= max(0,listFind(onLineClients, forceSelectClient))]\n\n<!-- OCL -->\n[h:useStartUpMap\t\t= getLibProperty('useStartUpMap','lib:EventMacros')]\n[h:startUpMap\t\t\t= getLibProperty('startUpMap','lib:EventMacros')]\n[h:startUpCoords\t\t= getLibProperty('startUpCoords','lib:EventMacros')]\n[h:useCentreOnMePad\t\t= getLibProperty('useCentreOnMePad','lib:EventMacros')]\n[h:runSwitchForm\t\t= getLibProperty('runSwitchForm','lib:EventMacros')]\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n\n<!-- SYSTEM -->\n[h:libCoordSize\t\t\t= getLibProperty('libCoordSize', 'lib:EventMacros')]\n[h:maxPadsPerRun\t\t= getLibProperty('maxPadsPerRun','lib:EventMacros')]\n[h:maxGroupSelect\t\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:maxOrderSelect\t\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:padNameList \t\t\t= getLibProperty('padNameList', 'lib:EventMacros')]\n\n<!-- start up map -->\n[h:startUpMapList\t\t= getAllMapNames()]\n[h:startUpMapNum\t\t= listFind(startUpMapList,startUpMap)]\n[h:baseMapNum\t\t\t= listFind(startUpMapList,baseMapName)]\n\n<!-- create list of event macros from the group \"Event List Macros\" used for \"General Events\" tab -->\n[h:oldMap\t\t\t\t= getCurrentMapName()]\n<!-- check if the map where lib:Eventmacros is situated, still exists -->\n[h,if(baseMapNum == -1), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|The map with lib:EventMacros does not exist. Pls select the correct one|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n}]\n[h:setCurrentMap(baseMapName)]\n<!-- check if lib:Eventmacros is on the map -->\n[h,if(findToken(\"lib:EventMacros\") == \"\"), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|<html>Lib:EventMacros is NOT on map: <b>'+baseMapName+'<\/b>. Please select the map where Lib:EventMacros is on|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n\t[setCurrentMap(baseMapName)]\n}]\n[h:assert(findToken(\"lib:EventMacros\") != \"\", \"<font color=red>No Lib:EventMacro found on map <b>\"+baseMapName+\"<\/b> please correct this.\",0)]\n[h:macroIDList\t\t= getMacroGroup(\"Event list macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n<!-- convert the macro names into macro index for the list -->\n[h:triggerEventList = \"eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport\"]\n[h,foreach(trigger, triggerEventList): set(trigger, listFind(macroNameList, eval(trigger)))]\n\n[h:inputStr\t= json.append(\"\", \"tab1|<html><b>General<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Settings<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'useAltImage|'+useAltImage+'|<html><span title=\"<html>When checked, the system will first check whether there is a token handout image on the foliage token. <br>If so it will swap the original image for that one, if not it will grab the table image. <br>Unchecked, the system will automatically grab the tbl image<\/html>\">Use alternative transparent image for foliage<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'checkMapsOCL|'+checkMapsOCL+'|<html><span title=\"<html><b>When checked:<\/b> the system will check all the maps when you load the campaign,<br>to see if they appear in the pad database. This is not a full initialization but it will<br>prevent bug reports after you load the campaign and if any inconsistancies are<br>found it will initialize the campaign file. What you will notice is that MT will<br>quickly flick through all the maps when you load the campaign.<br><b>When unchecked:<\/b> no checks are made so nothing will happend when you load the<br>campaign file.<\/html>\">Check all maps on start up<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSwitchInterMap|Change to other map, do not change to other map, do not change AND store coords|<html><span title=\"<html><b>Change to other map<\/b>: When using inter map teleport, switch to the map after teleportation<br><b>do not change to other map<\/b>: do NOT switch to destination map after teleportation<br><b>do not change AND store coords<\/b>: when using the do NOT switch map option, the system needs to<br>check the destination pad for the correct coords before sending the token there and then return to<br>the current map. This causes maptool to reload the current map. To prevent this you can use this third<br>option, which will store the coords of both pads on eachother during the <i>initialize pads<\/i> process.<br><b>BUT<\/b> that means that you CANNOT move the interPads without running <i>initialize maps<\/i> again.<\/html>\">Automatically swap to map for interpads<\/html><\/span><\/html>|RADIO|SELECT='+doSwitchInterMap)]\n[h:inputStr\t= json.append(inputStr, 'doScaleTeleport|'+doScaleTeleport+'|<html><span title=\"<html><b>When checked:<\/b> teleportation will keep track of different size teleports<br>This means that if you move to the lower right corner of a small pad you and up<br>on the lower right corner of a larger pad. <br><b>When unchecked:<\/b>teleportation will be relative to the upper left corner<br>of the teleport. So if you move from the lower right corner of a 4x4 to a 2x2<br>pad, then you will end up 2 squares down and 2 squares right OUTSIDE the 2x2 pad.<br>Mb<NOTE:<\/b> turning this on is tricky! E.g. if you make one of 2 vertical border pads<br>twice as thick as the other, and you move 6 squares over the pad, then you will<br>end up 12 (or 3 depending on the direction) beyond the other teleport!<br><\/html>\">Scale Teleportation<\/html><\/span><\/html>|CHECK')]\n\n[h:inputStr = json.append(inputStr, 'showGroupPanelOnSelect|'+showGroupPanelOnSelect+'|<html><span title=\"<html>When you select a <i>group<\/i> AND the <i>activate switch panel<\/i> is active<br>automatically show the group macro panel<\/html>\">Show group panel on select<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'fullScreenBroadcast|'+fullScreenBroadcast+'|<html><span title=\"<html>When you check this then the broadcast function will be redefined. Next to its<br>usual function it will ALSO broadcast to a dialog window called <i>Last Chat<\/i><br>but ONLY when the full screen mode is toggled (see campaign macros or F2). This<br>will result in a dialog popping up in full screen mode showing the last message<br>send to chat, using the broadcast function.<br><b>Important note:<\/b> currently its not possible to check whether a client is in<br>full screen or not, this means that this toggle is set for ALL clients.<\/html>\">Redefine <i>Broadcast<\/i> for full screen mode<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'numericIdOnly|'+numericIdOnly+'|<html><span title=\"<html>When you check this then ONLY special pads like Roof, Ward, PadStart, etc.<br>followed by a number (e.g. 1,2,3) will be identified as a special pad. E.g. <u>Roof 1<\/u><br>is recognized as a special pad and <u>Roof Red Barn<\/u> not. If you UNCHECK this<br>then <u>Roof Barn Red<\/u> WILL be identified as a special pad. As usual <i>linked<\/i> pads<br>require the SAME identifier. So <u>PadStart Sea Level<\/u> will be connected to<br><u>PadEnd Sea Level<\/u> (IF the box is unchecked!)<br><b>Note that Linked Pads will NOT work when this is checked<\/b><\/html>\">Numeric Id for special pads only (disable Links!)<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'forceRoomShare|Send macro link to chat, Force share on screen, do both|<html><span title=\"<html><b>Send macro link to chat<\/b>: When using Nildiks room description token, <br>when you click on a <i>share<\/i> link, a macro link is sent to the chat that<br>players can click on to open the frame with the shared information.<br><b>Force share on screen<\/b>: Instead of sending a macro link, the<br>information is immediately opened on the screen of the players.<br><b>Both<\/b>: The information is immediately shown on the players screen<br>AND a click-able macro link is sent to the chat.<\/html>\">When sharing a Room Description<\/html><\/span><\/html>|RADIO|SELECT='+forceRoomShare)]\n\n[h:inputStr = json.append(inputStr, 'baseMapName|'+startUpMapList+'|<html><span title=\"<html>The use of the Canopty option requires a BASE map where the treetrunks are situated. per default this Map is called BASE, here you can give it a different name.<\/html>\">Name of BASE Map<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+baseMapNum)]\n[h:inputStr = json.append(inputStr, 'excludeLightTypes|'+excludeLightTypes+'|<html><span title=\"<html>Here you can enter one or more light <u>types<\/u> seperated by a comma (,) (e.g.: Generic, D20) that you dont want to show up as a tab in the Set Light Source macro<\/html>\">Exclude Light Types<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'roofHaloColor|'+haloColors+'|<html><span title=\"<html>Here you can set the color of the halo for the Roof special pad<\/html>\">Set Roof halo color<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+roofHaloColor)]\n[h:inputStr = json.append(inputStr, 'forceSelectClient|'+onLineClients+'|<html><span title=\"<html>If you select a client (player pc) from this list then when a gm selects a token<br>on a map that same token will also be selected on the chosen clients side. This <br>is particularly usefull in a laptop beamer setup where you have one single GM <br>client and one single players client to show the map. <br><br>Note that if a previously set (player) client does not exist when this campaign<br>is loaded then this value will be reset to empty and you need to run settings <br>again to select the client.<\/html>\">Force Token Selection on Client<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+forceSelectClient)]\n\n[h:inputStr\t= json.append(inputStr,\"junk|<html><b>Animations<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'animationPerClient|'+animationPerClient+'|<html><span title=\"<html>Animations like for the doors and the token movement will have an instance running<br>on eacht seperate client. This because the network connection of the server is<br>usually not fast enough to send updates of the animated object to the clients. This<br>requires a copy of the animated token on each client which is visible to the owner only.<br>This copy is removed from the client as soon as the animation is over.<br><i>Visible to owner only<\/i> will only work if <i>strict token ownership<\/i> is checked<br>for the running server. If its not set, then all the copies of all the clients are<br>visible on all the other clients as well. This will look messy. Hence this option to<br>run the animation on the server only.<br><b>When checked:<\/b> Animations will be played on each client<br><b>When unchecked:<\/b> Animations will be played on the server only<br><\/html>\">Run animations per client<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'timeLockDelay|'+timeLockDelay+'|<html><span title=\"<html>When using the token buttons to open or close doors then the onTokenSelectionEvent is<br>triggered. Unfortunately its triggered more than once. With the effect that the door<br>opens, closes, opens etc. To prevent this Ive created a time-out in which the event is<br>ignored. If this time is too short you will notice the door open-close event triggering<br>multiple times. If you set if to slow then you have to wait that time before you can<br>use the button again. The time is in ms meaning that 1000 = 1 second. If you encounter<br>the problem of the door animation triggering multiple times when you click the door<br>button then you should set this timer higher, e.g. to 1000. <\/html>\">Time lock delay for token buttons (ms)<\/html><\/span><\/html>')]\n\n[h:inputStr\t= json.append(inputStr,\"junk|<html><b>Summon Token Macro<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'summonPcPropType|'+summonPcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of PCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of PCs<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonNpcPropType|'+summonNpcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of NPCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of NPCs<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonPropTypesList|'+summonPropTypesList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will also generate a dropdownbox for any tokenproperty<b><u>type<\/b><\/u> that <br>is listed here<\/html>\">List of Summon Token Property Types<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonSpecialList|'+summonSpecialList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will generate a dropdownbox for listed tokenproperties. In addition <br>here you can set Token Names which you want to let appear in a seperate Dropdownbox. <br>Here its used for the special pad names, but it can be used for other purposes<\/html>\">List of Summon Token Special<\/html><\/span><\/html>')]\n\n<!-- ONCAMPAIGNLOAD -->\n<!-- stuff that happens when the campaign is loaded -->\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>On Campaign Load<\/html>||TAB\")]\n[h:inputStr\t= json.append(inputStr, \"junk|<html><b>Stuff that happens when you load the campaign<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'useStartUpMap|'+useStartUpMap+'|<html><span title=\"<html><b>When checked:<\/b> the below two settings (load map on start up and go to coordinates) will be used.<\/html>\">Use Start Up map and coordinates<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'startUpMap|'+startUpMapList+'|<html><span title=\"<html>Pick here the name that should be loaded on campaign load or when players log in.<\/html>\">Set map to open at start up<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+startUpMapNum)]\n[h:inputStr = json.append(inputStr, 'startUpCoords|'+startUpCoords+'|<html><span title=\"<html>Set here the coordinates which the map will be centred on campaign load<br>or when players log in. You can see the coordinates of your cursor on the<br>map in the lower right corner of Maptool. Example (X,Y): <b>5,4<\/b>.<br><br>Alternatively you can also enter a <b>token name<\/b>, however when you do that<br>make sure that the name does not contain any comma(s): <i>,<\/i><\/html>\">Set coordinates to centre map on start up.<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'useCentreOnMePad|'+useCentreOnMePad+'|<html><span title=\"<html>This setting will override the coordinates unless the CentreOnMePad<br>is not found on the map. When you check this setting then on start up<br>the map will be centred onto this token for all clients.<\/html>\">Centre on CentreOnMePad on start up.<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'runSwitchForm|'+runSwitchForm+'|<html><span title=\"<html><b>When checked: <\/b>the form that you need to start so door switches work, <br>will start automatically on campaign load .<\/html>\">Start door switches form<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'disableOCLCheck|'+disableOCLCheck+'|<html><span title=\"<html><b>When checked: <\/b>The boT check result* shown in the chat<br>after you have loaded the campaign, will be turned OFF.<br><br>*Thats the red-yellow colored bar called:<br><i>Bag of Tricks - OnCampaignLoad checks<\/i><\/html>\">Disable OCL Checks<\/html><\/span><\/html>|CHECK')]\n\n<!-- EXCLUSIONS -->\n<!-- map exclusion -->\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>Exclusions<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Which maps should be excluded from the Initialization<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:allMaps\t= listSort(getAllMapNames(),\"N+\")]\n[H:excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n[H, if(json.isEmpty(excludedMaps)): excludedMaps = \"[]\"]\n[h,foreach(map, allMaps), CODE:{\n\t[H: isExcluded\t= json.contains(excludedMaps,map)]\n\t[H: inputStr\t= json.append(inputStr,strformat(\"map%{roll.count}|%{isExcluded}|%{map}|CHECK\"))]\n}]\n\n<!-- Property type exclusion -->\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Which propertyTYPES should NOT trigger the onTokenMoveEvent<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'excludePropertyTypes|'+excludePropertyTypes+'|<html><span title=\"<html>Here you can enter one or more property types that will NOT trigger the onTokenMoveEvent.<br>Token property types can be set in menu-->edit-->campaign properties-->Token Properties.<br>There you find a list of the token properties for your campaign. Per default you will find the<br> Basic property type there. A property type for a token you can set by double clicking on<br>a token-->config tab-->Properties. That field contains a dropdown menu where you can choose <br>the property type for that token. All the Property Types you list in this field will NOT trigger<br>the event when moved. E.g. if you list SpecialPads here and your drag a token with the SpecialPad<br>property type onto a teleport token, then that token will NOT be teleported.<\/html>\">Exclude Property Types<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n<!-- Toggles -->\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>Toggles<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can turn off certain checks to speed thing up<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'doGroups|'+doGroups+\t\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off group movement<\/html>\">Group movement<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSnap2Grid|'+doSnap2Grid+\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off Snap To Grid. This is mainly<br>interesting for token move animation where you <br>want the tokens to move smoothly, but also have<br>them snapped to grid. When checked this option<br>will snap the last moved token to grid. This only<br>works when Maptools its Snap To Grid is turn off.<\/html>\">Snap To Grid<\/html><\/span><\/html>|CHECK')]\n[h, if(vblSupport == 1):inputStr \t= json.append(inputStr, 'doVBLStamp|'+doVBLStamp+\t'|<html><span title=\"<html>Uncheck to turn off VBL stamps.<br>VBL Stamps are Vision Blocking Layer stamps that work on tokens<br>that have a label set to <i>VBLStamp<\/i>. When a tokens has this<br> word in its label a VBL cross will be drawn over it when it is moved.<br> And that VBL cross will move with the token.<\/html>\">VBL Stamps<\/html><\/span><\/html>|CHECK') ; doVBLStamp = 0]\n[h:inputStr = json.append(inputStr, 'doResetFoW|'+doResetFoW+\t\t\t\t\t'|<html><span title=\"<html>Check to restore ALL Fog of War on every move<\/html>\">Restore FoW<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doVBLCheck|'+doVBLCheck+\t\t\t\t\t'|<html><span title=\"<html><i>This feature is developed by Aliasmask.<\/i><br>It does two things:<br><b>1.<\/b> If a token <i>cuts a corner<\/i> of a vision blocking area,<br>then a warning is given and the token is moved to the spot<br>BEFORE the corner was cut.<br> <b>2.<\/b> Because of the path that the token was dragged along<br>would be cleared of the fog of war (FoW) its movement is<br>reset and the macro clears the FoW.<br> The latter has the HUGE advantage that it also is a work<br>around for the (b87) FoW lag issue! If you have individual<br>FoW turned on for tokens then after a while dragging tokens<br>around can become very laggy. This option solves that issue.<br> The disadvantage is that if you move tokens over a large path<br>then it takes considerably longer (in addition to the normal<br>delay this Bag of Tricks introduces). The delay is not<br>noticeable for short distances but becomes e.g. 1 second<br>when you drag a token over 300 squares.<br>  <\/html>\">VBL move check<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doCentreOnTok|'+doCentreOnTok+\t\t\t\t'|<html><span title=\"<html>Check to continuously centre the map on the moving token.<br>Does not work for multiple moving tokens<\/html>\">Centre on token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doTriggerOnZeroMove|'+doTriggerOnZeroMove+\t'|<html><span title=\"<html>If you move a token and put it back onto its original spot then,<br>this will trigger the onTokenMoveEvent. If you <b>check<\/b> this box then if<br>a token is standing on a special pad, that pad will be activated.<br><b>Uncheck<\/b> to ignore this zero move.<br><b>Note<\/b> that if you set Waypoints and then return to the original<br>spot, that the token has actually moved and the special pad<br>WILL be activated!<\/html>\">Trigger Pads on zero move<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSpecialPads|'+doSpecialPads+\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off the special pads entirely (Check Start and Check Path included).<\/html>\">Check special pads<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doLockMovement|'+doLockMovement+\t\t\t'|<html><span title=\"<html>Check to prevent the movement of locked tokens.<br>You can select a token and toggle the <i>lock movement<\/i><br>macro. When a token is locked this way AND when this setting<br>is turned on, the movement of that tokens will always be <br>reverted. Not even the gm can move the token.<br><\/html>\">Lock movement for locked tokens<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doFullScreenMode|'+doFullScreenMode+\t\t'|<html><span title=\"<html>b89+: Check to turn on a isFullScreen check.<br>This will automatically switch the BoT macro panel to<br>full screen mode (showing the panel while in full screen)<br>and back to a dockable frame when not in full screen.<\/html>\">Full Screen Mode<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doShowPath|Do not Track Path, Track Path, Track Path and delete feet manually|<html><span title=\"<html>When Track Path is turned on, small feet will be placed in the cells over which a token is moved. <br>Red feet for NPCs and Blue feet for PCs.<br><br><b>Do not Track Path:<\/b> its turned off <br><b>Track Path:<\/b> its turned on, only the LAST move is shown<br><b>Track Path and delete feet manually:<\/b> for every move feet will be placed in the path. <br>To remove them from the map use the following command: [bot_getPath(3)]<br><br><b><u>Note that 3 conditions MUST BE MET before you toggle this setting:<\/u><\/b><br>1. the blue and red feet must on the BASE map and NOT on the OBJECT layer<br>2. a state <i>pathFeet<\/i> must be created (the feet must have that state)<br>3. BOTH the <i>impersonation and selection panel<\/i> must be closed (or the removal will be <br>extremely slow)<\/html>\">Show the last moved path<\/html><\/span><\/html>|RADIO|SELECT='+doShowPath)]\n[h:inputStr = json.append(inputStr, 'canSelectShadowTok|Object Layer, Token Layer, Token Layer and autoselect Main Token|<html><span title=\"<html>When using shadow pads, you can choose the layer where the shadow tokens are placed:<br>- Object layer: shadow token can not be selected (targeted) by players<br>- Token layer: shadow token *can* be selected (targeted) by players<br>- Token layer (autoselect main): when the shadow token is selected the actual token is selected instead.<br>The latter requires the <i>activate switches<\/i> macro to be running.<\/html>\">Where to place Shadow Tokens<\/html><\/span><\/html>|RADIO|SELECT='+canSelectShadowTok)]\n\n[h:inputStr = json.append(inputStr, \"junk|<html><b>The following toggles work for altInitMap only!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'doFirstPointPath|'+doFirstPointPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token starts its movement on a special pad<br>e.g.(under) canopy, then the token activates the relevant code.<br>E.g. in case of Canopy if the token moves away far enough then it will restore<br>the Canopy picture. Turning this off will result in this check NOT taking place.<br>So Canopy will dissapear but no longer reappear. Turning this off is usefull when<br>you are not using Canopy, Foliage or Roof pads.<\/html>\">Check Start (Canopy, Foliage or Roof)<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doInnerPointsPath|'+doInnerPointsPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token moves over a Ward or EventPad,<br>then the code is activated for that pad encountered. E.g. in case of Ward,<br>the Token is placed on the edge of the ward and the rest of the movement is negated.<br>Turning this off is usefull when you are not using Ward or EventPad pads.<\/html>\">Check Path (Ward, Event)<\/html><\/span><\/html>|CHECK')]\n\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Movement Limiter!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'limitMovement|'+limitMovement+\t\t\t'|<html><span title=\"<html>Here you can set a number or a token property to which token movement is limited during<br>initiative. Entering e.g. <i>4<\/i> means that the max allowed move is 4 cells. Entering<br><i>movement<\/i> will limit the movement of the token to its <i>movement<\/i> property. You<br>can enter any token property you like as long as that token property contains a number.<br>Should a player in this case move her token 5 or more cells, then they will receive a<br>message and the movement will be reset (so the tokens will be returned to its original<br>position). <br><br><b>Note that this feature will NOT work:<\/b><br>- when the user moving the token is a GM<br>- when the number set here is 0<br>- when the token is NOT in the initiative panel<br><br>Also note that this does not prevent someone from moving her token twice!<br><br><b>The macro that handles this is placed on the lib:EventMacros.<\/b> You can edit<br>this macro to better suit your framework. More explanations you can find there.<\/html>\">Limit movement to: (0 = ignore)<\/html><\/span><\/html>')]\n\n<!-- General Events -->\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>General Events<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can link an event macro to other events<\/b><br>Note that only the macros from the group:<br>'Event list macros' are in the drop downlists<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'eventMacroPreTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnTokenMove event macro is executed.<br>This macro will run before any of the OnTokenMove code is executed<\/html>\">Pre On Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPreMultipleTokenMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnMultipleTokenMove event macro is executed.<br>This macro will run before any of the OnMultipleTokenMove code is executed<\/html>\">Pre On Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreMultipleTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroOnTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run before any events of the special pads take place<\/html>\">On Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroOnMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run before any events of the special pads take place<\/html>\">On Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnMultipleTokensMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run after any events of the special pads take place<\/html>\">After Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run after any events of the special pads take place<\/html>\">After Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostMultipleTokensMove)]\n[h:inputStr = json.append(inputStr, 'eventPreMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport on the same map occurs.<\/html>\">Before Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPreMacroTeleport)]\n[h:inputStr = json.append(inputStr, 'eventPostMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport on the same map occurs.<\/html>\">After Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPostMacroTeleport)]\n[h:inputStr = json.append(inputStr, 'eventMacroPreInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport to another map occurs.<\/html>\">Before Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreInterTeleport)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport to another map occurs.<\/html>\">After Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostInterTeleport)]\n\n<!-- System -->\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>System<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can set the technical stuff<\/b><br>As a general rule: do not touch unless you <br>know what you are doing<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'libCoordSize|'+libCoordSize+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>Just do not change this value. Its used for the x/y area size of the lib coords<\/html>\">Lib coords size<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxPadsPerRun|'+maxPadsPerRun+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>If you have a map with a LOT of special pads on it (> 500) it is likely that<br>Maptool will crash when initializing them all at once. For this reason Ive<br>implemented this setting to break up large numbers of special pads to scan into<br>smaller bits which requires you to run the alternative initializing macro more than once.<br>The maximum supported amount of special tokens on one map is 1000 so the default<br>setting (500) will require you to run the init macro at most twice. <br><br><b>Change this when:<\/b> This number of pads to scan in one run might be too<br>much for older pcs and Maptool might crash. If this is the case lower the setting.<br><\/html>\">Maximum of pads to scan per run<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxGroupSelect|'+maxGroupSelect+'|<html><span title=\"<html>This setting is used for the group selection feature, specifically the panel. If a too large selection is made (>1000) MT crashes.<br>In addition the tool will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default<br>is 500 but you can lower (to speed things up) or up (to allow bigger selections) then number to a max of 1000 (at your own risk)<\/html>\">Maximum allowed group selection<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxOrderSelect|'+maxOrderSelect+'|<html><span title=\"<html>This setting is used for the order selection panel. If a too large selection is made (roughly over 500) MT crashes. In addition the tool<br>will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default is 200 but you<br>can lower (to speed things up) or up (to allow bigger selections) then number to a max of 500 (at your own risk)<\/html>\">Maximum allowed order selection<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'padNameList|'+padNameList+'|<html><span title=\"<html>This is the entire list of special pads. If you remove any of this list then these will not be initialized.<br>If you somehow have messed this up, clear the entire box click OK and then run OCL. <\/html>\">Special Pads List<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n<!-- run the input -->\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n<!-- process results of input -->\n[H: excludedMaps = \"[]\"]\n[h, foreach(map, allMaps), code: {\n\t[H, if(eval(\"map\"+roll.count)): excludedMaps = json.append(excludedMaps,map)]\n}]\n\n<!-- if startup coords are not set -->\n[h,if(startUpCoords == 0): startUpCoords = \"0,0\"]\n\n[h,if(!summonPropTypesList): summonPropTypesList = \"\"]\n[h,if(!summonSpecialList): summonSpecialList = \"\"]\n\n<!-- convert the macro index into the actual macro name -->\n[h,foreach(trigger, triggerEventList):set(trigger, listGet(macroNameList, eval(trigger)))]\n\n<!-- check redefine broadcast and initiate accordingly -->\n[h,if(oldFSB != fullScreenBroadcast):broadcast(\"You have changed the broadcast setting. For this to take effect you will need to RELOAD the campaign. Note that its a bad idea to run oncampaignload in this case, you really need to reload the campaign!\")]\n\n[H:setLibProperty(\"useStartUpMap\",useStartUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpMap\",startUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpCoords\",startUpCoords,\"lib:EventMacros\")]\n[H:setLibProperty(\"useCentreOnMePad\",useCentreOnMePad,\"lib:EventMacros\")]\n[H:setLibProperty(\"runSwitchForm\",runSwitchForm,\"lib:EventMacros\")]\n[H:setLibProperty(\"disableOCLCheck\",disableOCLCheck,\"lib:EventMacros\")]\n\n[H:setLibProperty(\"excludedMaps\",excludedMaps,\"lib:EventMacros\")]\n[h:setLibProperty(\"useAltImage\", useAltImage,\"lib:EventMacros\")]\n[h:setLibProperty(\"checkMapsOCL\", checkMapsOCL,\"lib:EventMacros\")]\n[h:setLibProperty(\"showGroupPanelOnSelect\", showGroupPanelOnSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"fullScreenBroadcast\", fullScreenBroadcast,\"lib:EventMacros\")]\n[h:setLibProperty(\"numericIdOnly\", numericIdOnly, \"lib:EventMacros\")]\n[h:setLibProperty(\"forceRoomShare\", forceRoomShare, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"baseMapName\", baseMapName,\"lib:EventMacros\")]\n[h:setLibProperty(\"excludeLightTypes\",excludeLightTypes, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"animationPerClient\", animationPerClient,\"lib:EventMacros\")]\n[h:setLibProperty(\"timeLockDelay\", timeLockDelay, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"summonPcPropType\", summonPcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonNpcPropType\", summonNpcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonPropTypesList\", summonPropTypesList,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonSpecialList\", summonSpecialList,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"libCoordSize\", libCoordSize, \"lib:EventMacros\")]\n[h:setLibProperty(\"maxPadsPerRun\", maxPadsPerRun,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxGroupSelect\", maxGroupSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxOrderSelect\", maxOrderSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"padNameList\", padNameList, \"lib:EventMacros\")]\n\n[h:doVBLStamp = if(doVBLStamp && vblSupport, 1, 0)]\n\n<!-- Initialize drawArea -->\n[h, if(getStrProp(\"toggles\", \"drawArea\") == \"\"), CODE:{\n\t[drawArea\t= 0]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n}]\n\n[h:toggles = strPropFromVars(\"forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\nSettings done.",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e6925b5c-e581-413e-868c-bc6aa41ab273",
          "commandChecksum": "c0831de99314e67fc7b58577d8885878",
          "propsChecksum": "59269c3c8f03647c8c6288fd174a2895"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "1",
        "index": 438,
        "label": "welcomeInit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- welcomeInit () ------------------------------------------------>']\n\n<!-- create HTML string -->\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n<!-- create html -->\n[h:output\t=  strformat(\"%{styleHTML}<html><body><font color=red size=5><b>Welcome<\/b><br><br><\/font><table class='btnformat'><tr><td class='btnformat'>\")]\n\n[h:output\t= output + \"\n<b>Bag of Tricks Features<\/b><br>\nWelcome to the Bag of Tricks. It appears that this is the first time you use it within this campaign file<br>\nTo get you started, click on the link below, this will pop-up the BoT feature list, from which you can choose which features you would like to use of the BoT. Simply check the checkboxes in front of the features you want. <br>\n<br>\n<b>Campaign Panel<\/b><br>\nWhen you select the 'lib:OnTokenMove' token and you look at the 'Selection' Panel, you will see numerous macros. At the top you will see '(drag to) Campaign Macros'. This group of macros you can drag directly to either a token or the campaign panel. This way you can use a certain feature at the click of a button. Please note that if you have not all features turned on, certain macros might not work (but thats easy to find out). The top macro is 'Bag of Tricks Macros'. This specific macro will open a menu with all the relevant macros corresponding with the features you have turned on. So you can always choose to just use that macro only. You can do this after you have chosen the features you want.<br>\n<br>\n <a href='macro://videoTutorials@Lib:OnTokenMove/none/Impersonated?'><b>Overview of BoT Video Tutorials ><\/b><\/a><br>\n<br>\n <a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Continue to choose features to install >><\/b><\/a><br>\n\"]\n[h:output\t= strformat(\"%{output}<\/td class='btnformat'><\/tr><\/table><br><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f1e4bf02-c05a-4fa6-8579-da73e9d28a5f",
          "commandChecksum": "6aeb51a9063e80ea5d23651bf7e887d2",
          "propsChecksum": "a0d144002624051910af1104d84d3a37"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "3",
        "index": 440,
        "label": "BoT Features",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,macro(\"featureTable@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>Change the installed BoT features.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "66d6abc8-f5c6-4b4e-a8a8-cfdbb261242c",
          "commandChecksum": "45fd77762c15d28c6c16e8b4e66738b5",
          "propsChecksum": "2bdd1c6754c6df593edab42b7b2ce7a2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.1 Experimental Shit",
        "includeLabel": false,
        "sortBy": "",
        "index": 441,
        "label": "followMe",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------- followMe -------------- -->']\n<!-- this macro surrounds the token with an x number of tokens with y tile size and moves these tokens along with the token -->\n\n<!-- to get this working you need a tile called 'Tile' on the token layer with the state 'pathFeet' \nand you need to unComment the followMe line in deferOntokenMove -->\n\n[tok\t\t= arg(0)]\n[lastPath\t= arg(1)]\n[lastCoord\t= json.get(json.get(lastPath,-1,-1),0)]\n\n<!-- remove ALL existing tiles on BG layer -->\n['ids\t\t= getTokenNames(\",\", json.set(\"{}\", \"setStates\", \"pathFeet\", \"layer\", \"Background\", \"range\", json.set(\"{}\", \"token\", tok, \"distancePerCell\", 0, \"upto\", 2)))']\n[ids\t\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", \"pathFeet\", \"layer\", \"Background\"))]\n[foreach(id, ids): removeToken(id)]\n\n<!-- create x and y -->\n[varsFromStrProp(json.toStrProp(lastCoord))]\n[gs\t\t\t= bot_getGridSize()]\n[x\t\t\t= x/gs]\n[y\t\t\t= y/gs]\n\n<!-- create coord set of group of tiles -->\n[numTiles\t= 2]\n[tileSize\t= 6]\n[coordSet\t= \"[]\"]\n[for(xt, x-numTiles*tileSize, x+numTiles*tileSize+1, tileSize), CODE:{\n\t[for(yt, y-numTiles*tileSize, y+numTiles*tileSize+1, tileSize):coordSet = json.append(coordSet, json.set(\"{}\", \"x\",xt,\"y\",yt, \"useDistance\", 0, \"layer\", \"Background\"))]\n}]\n\n<!-- create new layer of BG tiles -->\n[bgTiles\t= \"[]\"]\n[foreach(coord, coordSet): bgTiles\t= json.append(bgTiles, copyToken(\"Tile\", 1, \"Follow Me Tiles\", coord))]\n\n<!-- in future store bgTiles somewhere you can use them for multiple token use and json.difference them with other sets before you delete them on move. This to prevent deletion tiles that belong to (an)other token(s)-->",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5ed45c88-9451-441b-a468-03007ce3e8bd",
          "commandChecksum": "979d08e484f4337c8c1099c56a1b57db",
          "propsChecksum": "5bf56ce3c0fbccd2e415209606e9c41a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "20",
        "index": 470,
        "label": "seeInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_seeInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- you need to run this macro to set the see invisibility range of the token, set its state and initiate variables-->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\n[h,foreach(tok, toks), code:{\n\t[range = getProperty(\"w42.seeInvisRange\", tok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the 'see invisibility' range for <b>\"+tok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|See Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.seeInvisRange\", range, tok)]\n\t}]\n\t[setState(seeInvisState,1,tok)]\n\t<!-- this property keeps track of the tokens that are within purge range -->\n\t[setProperty(\"w42.inSeeRange\", \"[]\", tok)]\n\t<!-- immediately run seeInvis as its possible that an invisible token is in range -->\n\t[bot_checkInvisibility()]\n\t[broadcast(\"See invisibility range for <b>\" + tok + \"<\/b> is set to: \" + range, bot_ownergm(tok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "605f9efb-6c04-4487-b757-11991a379c61",
          "commandChecksum": "754afa44bb778e1cd4881657178f77b1",
          "propsChecksum": "8705610e9199057ea044c2b9fd18045f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "21",
        "index": 471,
        "label": "sawInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_sawInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- this macro is used to end the see invisibility state and reset variables (also on other tokens) -->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(seeInvisState,0,meTok)]\n\t<!-- this property keeps track of the tokens that are within see range -->\n\t[seeing\t= getProperty(\"w42.inSeeRange\", meTok)]\n\t[foreach(tok, seeing), CODE: {\n\t\t[onMap = findToken(tok)]\n\n\t\t[h, if(onMap != \"\"): owners = json.difference(getOwners(\"json\",tok),\tjson.difference(getOwners(\"json\",meTok), getProperty(\"w42.originalOwners\", tok)))]\n\t\t[h, if(onMap != \"\"): setOwner(owners, tok)]\n\t\t\n\t}]\n\t\n\t['pause(\"owners\")']\n\t\n\t[setProperty(\"w42.inSeeRange\", \"[]\", meTok)]\n\t[broadcast(\"See Invisibility is turned off for <b>\" + getName(meTok), bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "d5b05a78-886a-40c5-b46f-d939a5ec9fd3",
          "commandChecksum": "8e6148dc7a391d20174a39818e76ff97",
          "propsChecksum": "d22b1b8f5f7e32ba8a1b2259eff6ef24"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "30",
        "index": 472,
        "label": "purgeInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_purgeInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- you need to run this macro to set the purge invisibility range of the token, set its state and initiate variables-->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\n[h,foreach(tok, toks), code:{\n\t[range = getProperty(\"w42.purgeInvisRange\", tok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the Purge Invisibility Range for <b>\"+tok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|Purge Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.purgeInvisRange\", range, tok)]\n\t}]\n\t[setState(purgeInvisState,1,tok)]\n\t<!-- this property keeps track of the tokens that are within purge range -->\n\t[setProperty(\"w42.inPurgeRange\", \"[]\", tok)]\n\t<!-- immediately run purgeInvis as its possible that an invisible token is in range -->\n\t[bot_checkInvisibility()]\n\t[broadcast(\"Purge invisibility range for <b>\" + tok + \"<\/b> is set to: \" + range, bot_ownergm(tok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "db829755-cd5c-4c47-be8b-6f695b412bd5",
          "commandChecksum": "4495a93844b6e23d93b279744f1c9db7",
          "propsChecksum": "f3ca10c4dcb9c2210575bac7a4fb062d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "31",
        "index": 473,
        "label": "purgedInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_purgedInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- this macro is used to end the purge invisibility state and reset variables (also on other tokens) -->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(purgeInvisState,0,meTok)]\n\t<!-- this property keeps track of the tokens that are within purge range -->\n\t[purging\t= getProperty(\"w42.inPurgeRange\", meTok)]\n\t[foreach(tok, purging), CODE: {\n\t\t[purging\t= json.difference(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok))]\n\t\t<!-- if you were the only one purging the token, turn visible to owner only on again. -->\n\t\t[if(json.isEmpty(purging)): setOwnerOnlyVisible(1, tok)]\n\t\t<!-- update purgedby property on target token -->\n\t\t[purging\t= setProperty(\"w42.purgedBy\", purging, tok)]\n\t}]\n\t[setProperty(\"w42.inPurgeRange\", \"[]\", meTok)]\n\t[broadcast(\"Invisibility Purge is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "2a2d375a-6d75-4875-9110-75ecbc73ae36",
          "commandChecksum": "5dc407e7ede5d48490c3cecc9842c27e",
          "propsChecksum": "621bd1f6c06889f4f5675ef59a7e5648"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "40",
        "index": 474,
        "label": "anulInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_anulInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- you need to run this macro to set the annul distance of the token -->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[range = getProperty(\"w42.annulInvisRange\", meTok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the Annul Invisibility Range for <b>\"+meTok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|Annul Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.annulInvisRange\", range, meTok)]\n\t}]\n\t\n\t[setState(annulInvisState,1,meTok)]\n\t<!-- immediately run purgeInvis as its possible that an invisible token is in range -->\n\t[bot_checkInvisibility()]\n\t[broadcast(\"Annnul invisibility range for <b>\" + meTok + \"<\/b> is set to: \" + range, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "0db3ca52-bdbc-47d3-b9ac-f06ccbd77922",
          "commandChecksum": "c9e5c8397430ac0f9cb61648dcca05b1",
          "propsChecksum": "b877242dd5223b8e474a4bbcbd7d67ce"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "41",
        "index": 475,
        "label": "anulledInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_anulledInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- you need to run this macro to turn off the annul state -->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(annulInvisState,0,meTok)]\n\t[broadcast(\"Annul Invisibility is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "Yes I know, its 'Anulled' but that didn't fit on one line...",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "6a785018-47bf-4b98-902d-bb552f36ab70",
          "commandChecksum": "49e1c1f9f5ec2773ae43680ae2c48b78",
          "propsChecksum": "bb2ae717dc710b579a94e7e3184fe6e9"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "60",
        "index": 476,
        "label": "checkInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_checkInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n<!-- in case multiple tokens have been moved, grab the first -->\n[h,if(argCount()): meTok = arg(0); meTok = listGet(getSelectedNames(), 0)]\n<!-- ------------------------------------ MOVE INVISIBLE TOKENS ----------------------------------------------------- -->\t\n[h,if(getState(invisState, meTok)), CODE:{\n\t<!-- retrieve array of TOKENS who can currently see your token -->\n\t[seeingToks\t\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", seeInvisState)))]\n\t[purgingToks\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", purgeInvisState)))]\n\t[annulingToks\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", annulInvisState)))]\n\n\t<!-- remove meTok from collections -->\n\t[seeingToks\t\t= json.difference(seeingToks, json.append(\"[]\",meTok))]\n\t[purgingToks\t= json.difference(purgingToks, json.append(\"[]\",meTok))]\n\t[annulingToks\t= json.difference(annulingToks, json.append(\"[]\",meTok))]\n\n\t[currentOwners\t= getOwners(\"json\", meTok)]\n\t[addedOwners\t= \"[]\"]\n\n\t<!-- move shadowToken -->\n\t[shadowTok\t\t= findToken(getName(meTok) + \"(invis)\")]\n\t[assert(shadowTok != \"\", \"Shadow token does not (yet?) exist\",0)]\n\t[units\t\t\t= 0]\n\t[moveToken(getTokenX(units, meTok), getTokenY(units, meTok), units, shadowTok)]\n\n\t<!-- SEEING YOU -->\n\t<!-- retrieve array of TOKENS who can currently see your token (and remove yourself) -->\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", seeInvisState))), json.append(\"[]\",meTok))]\n\n\t[foreach(tok, allToks), CODE:{\n\t\t['broadcast(getName(tok) + \" can see me!\")']\n\t\t[range\t\t\t= getProperty(\"w42.seeInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t<!-- check whether the token is behind VBL canSeeToken(target,source) -->\n\t\t['cst\t\t\t= json.length(json.merge(canSeeToken(meTok, tok),canSeeToken(tok, meTok)))']\n\t\t[cst\t\t\t= isVisible(getTokenX(1,meTok), getTokenY(1,meTok), tok)]\n\t\t<!-- if the invisible token comes within range of an see invisibility token, the ip-token becomes owner of the inv token so it can see it -->\n\t\t['pause(\"distance\",\"range\",\"cst\")']\n\t\t[if(distance <= range && cst): addedOwners\t= json.union( addedOwners, getOwners(\"json\", tok) )]\n\t\t[if(distance <= range): setProperty(\"w42.inSeeRange\", json.union(getProperty(\"w42.inSeeRange\", tok), json.append(\"[]\",shadowTok)), tok)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t setProperty(\"w42.inSeeRange\", json.difference(getProperty(\"w42.inSeeRange\", tok), json.append(\"[]\",shadowTok)), tok)\n\t\t]\n\t}]\n\t<!-- you need to keep track of the token that see you and their ORIGINAL OWNERS! \n\t(its possible that they are invisible too and are seen by others). This should be solved by setting owners only to the OBJECT token -->\n\t[setOwner(json.union(getProperty(\"w42.originalOwners\", shadowTok), addedOwners), shadowTok)]\n\t['pause(\"allToks\",\"currentOwners\",\"seeing\",\"meTok\",\"range\",\"distance\")']\n\n\n\t\n\t<!-- PURGING YOU -->\n\t<!-- retrieve array of TOKENS who can currently purge your token (and remove yourself) -->\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", purgeInvisState))), json.append(\"[]\",meTok))]\n\t<!-- initialize by making certain its invisible -->\n\t[setOwnerOnlyVisible(1, shadowTok)]\n\t<!-- if the invisible token comes within range of an invisibility purge token, the 'visible to owner only' is turned off -->\n\t[purgedBy\t= \"[]\"]\n\t[foreach(tok, allToks), CODE:{\n\t\t[range\t\t\t= getProperty(\"w42.purgeInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range): setOwnerOnlyVisible(0, meTok)]\n\t\t[if(distance <= range): purgedBy = json.append(purgedBy,tok)]\n\t\t[if(distance <= range): setProperty(\"w42.inPurgeRange\", json.union(getProperty(\"w42.inPurgeRange\", tok), json.append(\"[]\",meTok)), tok)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t setProperty(\"w42.inPurgeRange\", json.difference(getProperty(\"w42.inPurgeRange\", tok), json.append(\"[]\",meTok)), tok)\n\t\t]\n\t}]\n\t[if(json.isEmpty(purgedBy)): setOwnerOnlyVisible(1, meTok)]\n\t[setProperty(\"w42.purgedBy\", purgedBy, meTok)]\n\n\n\n\t<!-- ANNULLING YOU -->\n\t<!-- retrieve array of TOKENS who can currently annul your token (and remove yourself) -->\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", annulInvisState))), json.append(\"[]\",meTok))]\n\t<!-- if the invisible token comes within range of an invisibility annul token, the invisibility is turned off completely -->\n\t[foreach(tok, allToks), CODE:{\n\t\t[range\t\t\t= getProperty(\"w42.annulInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range):bot_endInvisibility(meTok)]\n\t}]\n}]\n\n<!-- ------------------------------------ MOVE SEEING TOKENS ----------------------------------------------------- -->\t\n[h,if(getState(seeInvisState, meTok)), CODE:{\n\t<!-- retrieve array of TOKENS who you can currently see (and are invisible) -->\n\t[range\t\t\t= getProperty(\"w42.seeInvisRange\", meTok)]\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState))), json.append(\"[]\",meTok))]\n\t<!-- if the invisible token comes within range of an see invisibility token, the ip-token becomes owner of the inv token so it can see it -->\n\t<!-- add ownership to all tokens on OBJECT layer that you are seeing -->\n\t['pause(\"allToks\",\"invisState\",\"range\")']\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t<!-- check whether the token is behind VBL canSeeToken(target,source) -->\n\t\t['cst\t\t\t= json.length(json.merge(canSeeToken(meTok, tok),canSeeToken(tok, meTok)))']\n\t\t[cst\t\t\t= isVisible(getTokenX(1,tok), getTokenY(1,tok), meTok)]\n\n\t\t['pause(\"meTok\",\"range\",\"allToks\",\"invisState\",\"cst\")']\n\t\t<!-- if the invisible token is within range of an see invisibility token, make the SI token owner of the inv token so it can see it -->\n\t\t<!-- if the invisible token is out of range of an see invisibility token, make sure teh SI token owner is NOT owner of the inv token -->\n\t\t<!-- edge case: the see invis is ALSO owner of the invis token!! so remove orig owners of toke from owners of metok!! -->\n\t\t[shadowTok = getName(tok)+\"(invis)\"]\n\t\t[if(distance <= range && cst): \n\t\t\tsetOwner(json.union(getOwners(\"json\", shadowTok), getOwners(\"json\",meTok)),shadowTok)\n\t\t;\n\t\t\tsetOwner(\n\t\t\t\tjson.difference(\n\t\t\t\t\tgetOwners(\"json\",shadowTok),\n\t\t\t\t\tjson.difference( \n\t\t\t\t\t\tgetOwners(\"json\",meTok), \n\t\t\t\t\t\tgetProperty(\"w42.originalOwners\", tok)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t,shadowTok)\n\t\t]\n\t\t[if(distance <= range && cst): setProperty(\"w42.inSeeRange\", json.union(getProperty(\"w42.inSeeRange\", meTok), json.append(\"[]\",shadowTok)), meTok)]\n\t}]\n}]\n\n<!-- ------------------------------------ MOVE PURGING TOKENS this is the trikcy one !!----------------------------------------------------- -->\t\n[h,if(getState(purgeInvisState, meTok)), CODE:{\n\t<!-- retrieve array of TOKENS who you can currently see (and are invisible) -->\n\t[inPurgeRange\t= getProperty(\"w42.inPurgeRange\", meTok)]\n\t[range\t\t\t= getProperty(\"w42.purgeInvisRange\", meTok)]\n\t[allToks\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState)))]\n\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t<!-- turn off owner only vis if in range-->\n\t\t['pause(\"allToks\",\"distance\",\"range\")']\n\t\t[if(distance <= range), CODE:{\n\t\t\t[setOwnerOnlyVisible(0, tok)]\n\t\t\t<!-- keep track on the invis token whom is purging -->\n\t\t\t[setProperty(\"w42.purgedBy\", json.union(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok)), tok)]\n\t\t\t[setProperty(\"w42.inPurgeRange\", json.union(getProperty(\"w42.inPurgeRange\", meTok), json.append(\"[]\",tok)), meTok)]\n\t\t\t\n\t\t''\t\n\t\t};{\n\t\t\t<!-- turn back on if youre out of range UNLESS another is still purging the tok -->\n\t\t\t[purging\t= json.difference(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok))]\n\t\t\t[setProperty(\"w42.inPurgeRange\", json.difference(getProperty(\"w42.inPurgeRange\", meTok), json.append(\"[]\",tok)), meTok)]\n\t\t\t<!-- if you were the only one purging the token, turn visible to owner only on again. -->\n\t\t\t[if(json.isEmpty(purging)): setOwnerOnlyVisible(1, tok)]\n\t\t\t<!-- update purgedby property on target token -->\n\t\t\t[setProperty(\"w42.purgedBy\", purging, tok)]\n\t\t\t['pause()']\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n};{''}]\n\n<!-- ------------------------------------ MOVE ANNULING TOKENS ----------------------------------------------------- -->\t\n[h,if(getState(annulInvisState, meTok)), CODE:{\n\t<!-- retrieve array of TOKENS who are invisible and in range -->\n\t[range\t\t\t= getProperty(\"w42.annulInvisRange\", meTok)]\n\t[allToks\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState)))]\n\t<!-- end invisibility for those token -->\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range):bot_endInvisibility(tok)]\n\t}]\n}]\n\n[h:'broadcast(\"<b>this function is under construction. Turn off: Invisibility in the BOT settings (toggles tab)<\/b>\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "f6b0ac4e-8ea5-4df4-9bca-dfa74590c0d2",
          "commandChecksum": "36c3232a29320a47465a6ec6c05bce29",
          "propsChecksum": "609b3632aad56e98d41a9fddb3ffebd8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "19: Animated View Area",
        "includeLabel": false,
        "sortBy": "20",
        "index": 477,
        "label": "deferHover",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'abort(0)']\n\n[h:coords\t\t= macro.args]\n[h,if(json.length(coords)==0): abort(0)]\n\n<!-- x1, y1, x2, y2, pS, d || x,y,x1,y1,pixelStep and delay-->\n[h:var = arg(0)]\n[h:varsFromStrProp(var)]\n\n[h:'pause(\"var\",\"x1\",\"y1\",\"x2\",\"y2\",\"pS\",\"d\")']\n[h:setViewArea(x1, y1, x2, y2, pS)]\n[h:coords\t\t= json.remove(coords,0)]\n[h,if(d > 0 ): bot_delay(d)]\n\n[h:'bot_debugInfo(\"coords, coord,x,y\")']\n[h:link\t\t\t= macroLinkText(\"deferHover@Lib:OnTokenMove\", \"none\", coords)]\n[h:execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4e872d13-a922-4371-9b48-c288e70695f5",
          "commandChecksum": "ebf3a8209015ebbd947cf20d51d2f14b",
          "propsChecksum": "053f719b7729142557e4c733e028baf7"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "19: Animated View Area",
        "includeLabel": false,
        "sortBy": "12",
        "index": 480,
        "label": "runAnimateView",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- runAnimateView() ------------------------------------------------------- -->']\n<!-- set of functions to create animation of the map. Players view 'hovers' over the map along a pre set path by the gm. This preset path is created by using the lastpath of a token. UNDER CONSTRUCTION -->\n\n[h:me\t\t\t= getSelectedNames()]\n[h:assert(listCount(me)==1,\"Make sure (only) one token is selected before you run this macro\",0)]\n[h:switchToken(me)]\n\n[h:coords\t= getProperty(\"w42.viewAnimationCoords\")] <!-- previous path store on token (if any) -->\n[h:assert(json.type(coords)!=\"UNKNOWN\", \"There are no animation coords stored on this token run 'Set Animated View' for this token first\",0)]\n\n\n[h:'<!-- ------------------- execAllPlayers (macro name, arguments, players, output to) ----------------------------------------------------- -->']\n[h:bot_execAllPlayers(\"deferHover@Lib:OnTokenMove\", coords)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "761e5f3d-5f85-44ae-b432-960cbb4a94d3",
          "commandChecksum": "a4f4bf93db39be6aa656010fcace4dd7",
          "propsChecksum": "0e570fa75900c0cd016c9054baf0ce77"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "19: Animated View Area",
        "includeLabel": false,
        "sortBy": "11",
        "index": 483,
        "label": "linkViewAnimations",
        "fontSize": "0.90em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- linkViewAnimations() ------------------------------------------------------- -->']\n<!-- set of functions to create animation of the map. Players view 'hovers' over the map along a pre set path by the gm. This preset path is created by using the lastpath of a token. UNDER CONSTRUCTION -->\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:nToks\t\t= listCount(toks)]\n[h:assert(nToks > 1,\"Make more than one token is selected before you run this macro\",0)]\n\n<!-- Build input form -->\n[h:inputStr\t\t= \"[]\"]\n[H:inputStr \t= json.append(inputStr,\"junk|<html>\nThis function will link the animate view of all the selected tokens. <br>\nHere you can give the order in which the view animations should be shown.<br>\nThe lowest number will be shown first, then the next, etc.<br><br>\nNotes:<br>\n- The token where you store the linked tokens on will loose its<br>\noriginal animation coordinates (they get overwritten with the total animation)<br>\n- If no order has been previously set, the first encountered number (if any)<br> \nin the token name will be used. If there is no number, the order is set to 0<br>\n<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\n[h: i = 0]\n[h,foreach(tok,toks), CODE:{\n\t[assert(json.type(getProperty(\"w42.viewAnimationCoords\", tok))!=\"UNKNOWN\", \"There are no animation coords store on token: \"+ tok + \" deselect it and run this macro again OR run Set Animate View for this token first\",0)]\n\t[n\t\t\t= getProperty(\"w42.animationOrder\", tok)]\n\t[if(n==\"\"), CODE:{\n\t\t<!-- if n has not been previously set, retrieve the number from the token name -->\n\t\t[id\t\t= strfind(tok,\"(\\\\d+)\")]\n\t\t[if(getFindCount(id)): n = getGroup(id, 1, 0) ; n = 0]\n\t};{}]\n\t[set(\"n\"+i, if(isNumber(n), n, 0))]\n\t[string\t\t= \"n\"+i+\"|\"+ eval(\"n\"+i) +\"|\"+tok]\n\t[inputStr\t= json.append(inputStr, string)]\n\t[i\t\t\t= i+ 1]\n}]\n\n[H:inputStr \t= json.append(inputStr,\"junk|<html>______________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n[H: inputStr\t= json.append(inputStr, \"storeToken|<enter name>|Token name to store linked coords on\")]\n<!-- put local variables in input form -->\n[H: inputStr\t= json.evaluate(inputStr)]\n<!-- get user input -->\n[H: hasInput\t= abort(input(json.toList(inputStr,\"##\")))]\n\n[h:coordArray\t= \"[]\"]\n[h,count(nToks):coordArray\t=  json.append(coordArray,\"nothing\")]\n\n[h,foreach(tok,toks), CODE:{\n\t[n\t\t\t\t= eval(\"n\"+roll.count)]\n\t[assert(n<nToks,\"You've entered a too high order number. The highest number cannot exceed the number of tokens -1. E.g. if you want to link 3 tokens, use the numbers 0,1 and 2 to set the order\",0)]\n\t[setProperty(\"w42.animationOrder\", n, tok)]\n\t[coords\t\t\t= getProperty(\"w42.viewAnimationCoords\", tok)]\n\t[coordArray\t\t= json.set(coordArray, n, coords)]\n}]\n\n[h:linkedCoords\t= \"[]\"]\n[h,foreach(array,coordArray): linkedCoords = json.merge(linkedCoords, array)]\n\n\n[h:'broadcast(replace(linkedCoords, \",\", \",<br>\"))']\n[h:setProperty(\"w42.viewAnimationCoords\", linkedCoords, storeToken)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1f47ccb1-0144-4de5-a68f-73245ec265d1",
          "commandChecksum": "07bea171a786018711509e5a4ef3f2a4",
          "propsChecksum": "fcb22b669903034604185d613f3ffa98"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": true,
        "sortBy": "60",
        "index": 484,
        "label": "Set View Animation",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_setAnimateView()]",
        "maxWidth": "",
        "tooltip": "<html> Use lastpath of selected token to run a screen animation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7781702b-b612-40a4-9ac4-97e31aa5cd4b",
          "commandChecksum": "e2b628b508d49827fade2049a3424126",
          "propsChecksum": "c7e9128dfd4f38ea7d337c26f5a4f9ee"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": true,
        "sortBy": "60a",
        "index": 485,
        "label": "Link View Animations",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_linkViewAnimations()]",
        "maxWidth": "",
        "tooltip": "<html> Link the view animation of selected tokens and store it on one token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "60a5bc50-6124-435d-9c32-905b5402acc0",
          "commandChecksum": "020f995fb52530177b276067c95d1cc4",
          "propsChecksum": "522ab986a5fe0955a16b3cde58371ef6"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": true,
        "sortBy": "60b",
        "index": 486,
        "label": "Run View Animation",
        "fontSize": "11pt",
        "minWidth": "192",
        "playerEditable": false,
        "command": "[H: bot_runAnimateView()]",
        "maxWidth": "",
        "tooltip": "Run view animation created for selected token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c1acec9e-93b9-4a64-904e-eb1f8d89265d",
          "commandChecksum": "29cc55f3c385b1c798ae5bd75379e13a",
          "propsChecksum": "f3279e5120796c7027a6196892deb006"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115",
        "index": 487,
        "label": "Start Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_startInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b70d906d-81c6-4669-b611-a5d63bb03cf4",
          "commandChecksum": "83dd0c424c9a9ce7536194b595fc240d",
          "propsChecksum": "745efab081527789ff4e291389fa076c"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115a",
        "index": 488,
        "label": "End Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_endInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "181fa7cd-4bd1-41dc-98b7-3e5a1156988e",
          "commandChecksum": "930ae149672c441e37b2f23047e107cf",
          "propsChecksum": "5edb70ca2051ba57c0325006a50f1b81"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115b",
        "index": 489,
        "label": "See Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_seeInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f229dcda-252b-4478-958f-c83310c4c119",
          "commandChecksum": "995bd812fa28b0a4c706971bcf1b32a2",
          "propsChecksum": "cd7c9868ee4393a062009eaa2d3a886e"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115c",
        "index": 490,
        "label": "Saw Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_sawInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8a19ecbb-cdbf-4716-bd6e-b0bc6c08da9f",
          "commandChecksum": "3e5ede72aecc196a876719a77d4b8d0e",
          "propsChecksum": "1d6a688ac256ef51049a4a3a51e07e83"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115e",
        "index": 491,
        "label": "Purge Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_purgeInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ffde6a2a-6dca-46d7-b37e-349b679d1be1",
          "commandChecksum": "935fabc62aedb9975473bc4ed3f837dd",
          "propsChecksum": "426bea69bb15cc2da8f69cc581b36af0"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115f",
        "index": 492,
        "label": "Purged Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_purgedInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e8618263-c83b-4589-8ba0-14d17c781c39",
          "commandChecksum": "e30ab69328ec6b2311acb98a8dd22d1b",
          "propsChecksum": "9d722b8e588ff207af3f5a5a03641530"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115g",
        "index": 493,
        "label": "Anul Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_anulInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "454b98e1-bede-440d-9ee3-2c68de27de0b",
          "commandChecksum": "09307f150bb9b271d8302cd1adc91f23",
          "propsChecksum": "a09c86054aad84a580d2bdb482ad8b30"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115h",
        "index": 494,
        "label": "Anulled Invisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_anulledInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "66ee0fbc-3368-49d5-889b-d03b352588cb",
          "commandChecksum": "9f4bf70ad153a40ec1a7372b28465b96",
          "propsChecksum": "7b1972b79dc23f02d2709ee7f56c575b"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "51",
        "index": 496,
        "label": "ownergm",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = getLibProperty(\"gmNames\", \"lib:EventMacros\")]\n};{\n\t[h,if(isOwnedByAll(tok)):\t\n\t\tmacro.return = getAllPlayerNames() \n\t; \n\t\tmacro.return = json.union(getOwners(\"json\",tok), getLibProperty(\"gmNames\", \"lib:EventMacros\"))\n\t]\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7c8c8a98-8bb6-47ad-8a31-5635e8cbb4f8",
          "commandChecksum": "4ecc738e994738d78c8f9ca5fdcfab20",
          "propsChecksum": "d5eea22a2fed5e000d9a1e16b414c99d"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "17. Message",
        "includeLabel": false,
        "sortBy": "54",
        "index": 497,
        "label": "nowner",
        "fontSize": "1.00em",
        "minWidth": "38",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = getAllPlayerNames(\"json\")]\n};{\n\t[if(isOwnedByAll(tok)):\t\n\t\tmacro.return = []\n\t; \n\t\tmacro.return = json.difference(getAllPlayerNames(\"json\"), getOwners(\"json\",tok))\n\t]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5a765df7-45a3-4fa3-a565-6f8405aefa70",
          "commandChecksum": "aaecfc4cecc6304d01051635503276b5",
          "propsChecksum": "51c372c13e37c0e7dad627486f5e0f75"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "22",
        "index": 498,
        "label": "getTokCDistance",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- bot_getTokenCornerDistance(\"Dragon\", \"Bottom_left\", \"Elf\", \"Top_Right\", 0) -->\n[h:'<!-- returns a json: {\"dx\":12,\"dy\":15} -->']\n\n[h:assert(argCount()==5, \"ERROR: getTokenCornerDistance requires exactly 5 parameter, amount given: \" + argCount(),0)]\n<!-- arg(4): distance returned in:  0: cells,  1: pixels per cell, 2: distance per cell -->\n\n[h:gs\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n[h:upc\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"units per cell\")]\n\n[r1\t= getTokenX(1, arg(0))]\n[r2\t= if(indexOf( lower(arg(1)),\"right\")+1, getTokenWidth(arg(0)), 0) ]\n[r3\t= getTokenX(1, arg(2))]\n[r4\t= if(indexOf( lower(arg(3)),\"right\")+1, getTokenWidth(arg(2)), 0)]\n[r5\t= if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==1, upc, 1)]\n[broadcast(r1 + \"<br>\" +r2 + \"<br>\" +r3 + \"<br>\" +r4 + \"<br>\" +r5 + \"<br>\" )]\n\n[h:dx\t= \n\tround(\n\t\tabs(\n\t\t\tgetTokenX(1, arg(0)) + \n\t\t\tif(indexOf( lower(arg(1)),\"right\")+1, getTokenWidth(arg(0)), 0) \n\t\t\t\t- \n\t\t\tgetTokenX(1, arg(2)) - \n\t\t\tif(indexOf( lower(arg(3)),\"right\")+1, getTokenWidth(arg(2)), 0)\n\t\t) / if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==2, upc, 1),0\n\t)\n]\n\n[h:dy\t= \n\tround(\n\t\tabs(\n\t\t\tgetTokenY(1, arg(0)) + \n\t\t\tif(indexOf( lower(arg(1)),\"bottom\")+1, getTokenHeight(arg(0)), 0) \n\t\t\t\t- \n\t\t\tgetTokenY(1, arg(2)) - \n\t\t\tif(indexOf( lower(arg(3)),\"bottom\")+1, getTokenHeight(arg(2)), 0)\n\t\t) / if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==2, upc, 1),0\n\t)\n]\n\n[h:macro.return =\tjson.set(\"{}\", \"dx\", dx, \"dy\", dy)]",
        "maxWidth": "",
        "tooltip": "<html> getTokenCornerDistance(\"Dragon\", \"Bottom_left\", \"Elf\", \"Top_Right\", 0) <br> returns json with 'dx' and 'dy",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4ed498b2-77a3-4663-8ef0-d1aaeb6004d0",
          "commandChecksum": "9bfd8c7a095848b7c4134fd4dfc50546",
          "propsChecksum": "272749e15386701aee0f806d939c9723"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "a. Aliasmask Usediguise",
        "includeLabel": false,
        "sortBy": "5",
        "index": 499,
        "label": "cycleDisguise",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- -------------------------------------- cycleDisguise () -------------------------------------------------------- -->']\n\n[h:'<!-- \n<html> - Clicking the <i>Cycle Disguise<\/i> button will cycle through the stored images on this token.<\/html> \n-->']\n\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:assert(listCount(toks)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(toks)]\n\n[h:currentImage = getImage(toks)]\n[h:disguises\t= getProperty(\"am.bot.disguise\")]\n[h,if(json.isEmpty(disguises)): disguises\t= json.append(\"[]\", currentImage)]\n\n[h:i\t\t\t= json.indexOf(disguises, currentImage)]\n[h:l=json.length(disguises)]\n[h:nexti\t\t= mod(i+1,json.length(disguises))]\n[h:image\t\t= json.get(disguises, nexti)]\n[h:setTokenImage(image)]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Cycle Disguise<\/i> button will cycle through the stored images on this token.<\/html> ",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6d2dfebf-f51f-451f-8e9d-6fe8ea36ef1f",
          "commandChecksum": "54138d99ac07c66f0ab50085dfb3664a",
          "propsChecksum": "e8802d8c0391e97e898893f06df3e4eb"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "15. Summon",
        "includeLabel": false,
        "sortBy": "25",
        "index": 501,
        "label": "summonToken",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: '<!-- summonToken -->']\n[H: '<!-- based on Orpheus WoD campaign macro -->']\n[h:me = getSelected()]\n[h:assert(listCount(me) <= 1, \"Make sure only one token is selected\",0)]\n[h, if(listCount(me) == 1), CODE:{\n\t[switchToken(me)]\n\t[h: X = getTokenX(0)]\n\t[h: Y = getTokenY(0)]\n\t[H: PrimePC\t= getName() ]\n}; {\n\t[h: X = 0]\n\t[h: Y = 0]\n\t[H: PrimePC\t= \"\"]\n}]\n\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n[h, if(argCount() > 1): conditions = arg(1); conditions = \"{}\"]\n\n[H: '<!-- no new scope!! -->']\n[h: bot_getValidTokens(useCurrentMap, conditions)]\n\n[H: '<!-- User choice of what to use, at which level, on who -->']\n[h:inputStr\t\t= \"junk|<html><b>Summon Token<\/b> - More token types can be added from the Settings macro<\/html>|-|LABEL|SPAN=TRUE\"]\n[h,if(listCount(fancyPCList)\t> 1):\tinputStr = listAppend(inputStr, \"pcNumber | \" \t+ fancyPCList\t+ \" | PC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t\t; pcNumber\t\t= 0]\n[h,if(listCount(fancyNPCList)\t> 1):\tinputStr = listAppend(inputStr, \"npcNumber | \" \t+ fancyNPCList\t+ \" | NPC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; npcNumber\t\t= 0]\n[h,if(listCount(fancyCharList)\t> 1):\tinputStr = listAppend(inputStr, \"charNumber | \"\t+ fancyCharList\t+ \" | (N)PC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; charNumber\t= 0]\n[h,if(listCount(fancyAllList)\t> 1):\tinputStr = listAppend(inputStr, \"allNumber | \" \t+ fancyAllList\t+ \" | ALL | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; allNumber\t\t= 0]\n\n[h, foreach(propType, propTypesList), CODE:{\n\t[fancyList\t= eval(\"fancy\"+propType+\"List\")]\n\t[if(listCount(fancyList)\t> 1):\tinputStr = listAppend(inputStr, propType + \"Number | \" + fancyList + \" | \"+propType+\" | LIST | ICON=TRUE  ICONSIZE=30\", '@') ; set(propType + \"Number\", 0)]\n}]\n[h, if(listCount(fancySpecialList) > 1):inputStr \t= listAppend(inputStr, \"specialNumber | \" \t+ fancySpecialList\t+ \" | Special | LIST | ICON=TRUE  ICONSIZE=30\", '@')]\n\n[h:'<!-- ask for number -->']\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Number of each selected token to summon:<\/b><\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"bot_amount|1|give amount\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"bot_spread|0|Spread summoned tokens|CHECK\", '@')]\n\n[h:'<!-- ask for coords -->']\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Summon Token(s) to:<\/b><\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html>If you select a token before you run this macro then its<br>coords will be used here<\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"X|\"+X+\"|X-coordinate to place token\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"Y|\"+Y+\"|Y-coordinate to place token\", '@')]\n\n[h:'<!-- show coords of selected token-->']\n[h, if(PrimePC != \"\"):inputStr\t\t= listAppend(inputStr,\"junk|\"+X+\",\"+Y+\"|<html><b>Location of \"+PrimePC+\"<\/b>|LABEL\", '@')]\n\n[h:'<!-- create the dialog string -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h: updates = json.set(\"{}\", \"useDistance\", 0)]\n[h: updates = json.set(updates, \"x\", X+1)]\n[h: updates = json.set(updates, \"y\", Y)]\n\n[h:summonedList = json.append(\"\",me)]\n\n[r,if(pcNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(pcList, pcNumber), bot_amount, baseMapName, updates))]\n[r,if(npcNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(npcList, npcNumber), bot_amount, baseMapName, updates))]\n[r,if(charNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(charList, charNumber), bot_amount, baseMapName, updates))]\n[r,if(allNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(allList, allNumber), bot_amount, baseMapName, updates))]\n[r, foreach(propType, propTypesList, \"\"), CODE:{\n\t[r,if(eval(propType+\"Number\")):\tsummonedList = json.merge(summonedList, copyToken(listGet(eval(propType+\"List\"), eval(propType+\"Number\")), bot_amount, baseMapName, updates))]\n}]\n\n[r,if(specialNumber):\tsummonedList = json.merge(summonedList, copyToken(listGet(specialList, specialNumber), bot_amount, baseMapName, updates))]\n\n[h, if(bot_spread), CODE:{\n\t[selectTokens(summonedList, 1, \"json\")]\n\t[msg = \"This message is needed to spread the tokens\"]\n\t[pause(\"msg\")]\n\t[bot_formationSquare()]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6295430f-e59e-41e8-b88d-410fb4a351a9",
          "commandChecksum": "a24c6e3250f54997450fd38bb56e5454",
          "propsChecksum": "dcac38365ddab099c97db0754f527ce6"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "25",
        "index": 502,
        "label": "Embarkation",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:timeOut()]\n[h:'<!----------------- EmbarkationVehicle ---------------------------->']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'<!----------------- INITIALIZE VALUES ---------------------------->']\n[h:ok\t\t\t= 0]\n<!-- maximum amount of passengers in vehicle -->\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'<!-- create the input for the DDB, select visible tokens upto 10 squares -->']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'<!-- no new scope, so charList and fancyCharlist are defined variables! -->']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'<!-- add any token currently embarked to the (fancy)charList -->']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'<!----------------- USER INPUT ---------------------------->']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'<!-- build the entire input string -->']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'<!-- which should end up something like]\n\t[input(]\n\t\t[Bla bla,]\n\t\t[optional message in case of failed idiot check,]\n\t\t[passenger0|DDB|passenger,]\n\t\t[passenger1) -->']\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h:'<!----------------- END INPUT SECTION  ---------------------------->']\n\n[h:'<!----------------- NUMBERS TO NAMES ---------------------------->']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:'<!-- Move the Tokens, either Embark or De-Embark --> ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t['<!-- disEmbark Move to Vehicle --> ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX,meY,0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t['<!-- Embark: Move to VPCU--> ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1,vpcuY+1,0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"Passengers\", newEmbarkedList, me)]\n\n<!-- 0:message, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:tmpManualRolls, 6:target, 7:broadcast,\t8:altMessage,\t9:altUserList, 10:gmOnly -->\n[h: message(\"Embarkation done\", \"Embarkation done\", \"#063404\", ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68310b38-07fd-4278-951c-944b126f8924",
          "commandChecksum": "301a312514d201f95e6a95c5a0e87fce",
          "propsChecksum": "4bea2420912518ceb67946e3b59b2b6a"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "23",
        "index": 504,
        "label": "Embarkation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_embarkation()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can move (N)PC tokens inside a vehicle.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0fdef21f-ed98-4bf6-8a48-d5c0a82e18ab",
          "commandChecksum": "2dd3e081596b1132d19a7426602d7ef9",
          "propsChecksum": "f478ed18481e80c59bc0d99a77ceb71e"
        }
      },
            {
        "autoExecute": true,
        "color": "cyan",
        "fontColor": "teal",
        "group": "15. Summon",
        "includeLabel": false,
        "sortBy": "24",
        "index": 503,
        "label": "toggleEmbark",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------- toggleEmbark ---------------------------->']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'<!----------------- INITIALIZE VALUES ---------------------------->']\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:currPassengers\t= getProperty(\"w42.Passengers\", me)]\n[h:embarkToggle\t\t= getProperty(\"w42.embarkToggle\", me)]\n[h:assert(listCount(currPassengers)>0,\"There are no passengers on this vehicle\",0)]\n[h:assert(isNumber(embarkToggle), \"This vehicle is not (correctly) initiated\",0)]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n\n[H:nX = \"-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1,\t\t-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1\"]\n[h:ny = \"-1,\t-1,\t-1,\t\t0,\t0,\t\t1,\t1,\t1,\t\t-2,\t-2,\t-2,\t\t0,\t0,\t\t2,\t2,\t2\"]\n\n[if(embarkToggle), CODE:{\n\t<!-- disEmbark Move to Vehicle -->\n\t[foreach(embarked, currPassengers):moveToken(meX+listGet(nX, roll.count), meY+listGet(nY, roll.count),0,embarked)]\n};{\n\t<!-- Embark: Move to VPCU -->\n\t[foreach(toEmbark, currPassengers):moveToken(vpcuX+1+listGet(nX, roll.count),vpcuY+1+listGet(nY, roll.count),0,toEmbark )]\n}]\n\n[h:setProperty(\"w42.embarkToggle\",1 - embarkToggle, me)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d6413df-5ef6-4e6b-8af5-4b2a1196dc93",
          "commandChecksum": "6ce62d7694d6538ede3d05fc280f22f8",
          "propsChecksum": "e5b7017ac27d6eb30a4fe1a7f53e295f"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "25",
        "index": 502,
        "label": "Embarkation",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:timeOut()]\n[h:'<!----------------- EmbarkationVehicle ---------------------------->']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'<!----------------- INITIALIZE VALUES ---------------------------->']\n[h:ok\t\t\t= 0]\n<!-- maximum amount of passengers in vehicle -->\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'<!-- create the input for the DDB, select visible tokens upto 10 squares -->']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'<!-- no new scope, so charList and fancyCharlist are defined variables! -->']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'<!-- add any token currently embarked to the (fancy)charList -->']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'<!----------------- USER INPUT ---------------------------->']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'<!-- build the entire input string -->']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'<!-- create the dialog string, this is interesting cause I have little clue what exactly happens here -->']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'<!-- which should end up something like]\n\t[input(]\n\t\t[Bla bla,]\n\t\t[optional message in case of failed idiot check,]\n\t\t[passenger0|DDB|passenger,]\n\t\t[passenger1) -->']\n\n[h:'<!-- ask for input-->']\n[h:abort(eval(inputStr))]\n\n[h:'<!----------------- END INPUT SECTION  ---------------------------->']\n\n[h:'<!----------------- NUMBERS TO NAMES ---------------------------->']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:'<!-- Move the Tokens, either Embark or De-Embark --> ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t['<!-- disEmbark Move to Vehicle --> ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX,meY,0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t['<!-- Embark: Move to VPCU--> ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1,vpcuY+1,0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"Passengers\", newEmbarkedList, me)]\n\n<!-- 0:message, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:tmpManualRolls, 6:target, 7:broadcast,\t8:altMessage,\t9:altUserList, 10:gmOnly -->\n[h: message(\"Embarkation done\", \"Embarkation done\", \"#063404\", ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68310b38-07fd-4278-951c-944b126f8924",
          "commandChecksum": "301a312514d201f95e6a95c5a0e87fce",
          "propsChecksum": "4bea2420912518ceb67946e3b59b2b6a"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "23",
        "index": 504,
        "label": "Embarkation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_embarkation()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can move (N)PC tokens inside a vehicle.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0fdef21f-ed98-4bf6-8a48-d5c0a82e18ab",
          "commandChecksum": "2dd3e081596b1132d19a7426602d7ef9",
          "propsChecksum": "f478ed18481e80c59bc0d99a77ceb71e"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "23",
        "index": 505,
        "label": "Toggle Embark",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[r:bot_toggleEmbark()]",
        "maxWidth": "",
        "tooltip": "<html>IF PCs are embarked on a vehicle you can quickly (dis)embark them<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dc5df9f2-daf0-4610-9175-d982ebc1a873",
          "commandChecksum": "32621cfd11a158c9e5250ffcf6e62c0f",
          "propsChecksum": "9f0dc04bf04a3556dcba0a03fc82d0f2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "2",
        "index": 508,
        "label": "sendMacroChat",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:'<!-- ---------------------------------------- sendMacroChat -------------------------------------------------------------- -->']\n[h: arguments\t\t\t= macro.args]\n[h: title\t\t\t\t= json.get(arguments,0)]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n\n[r, if(forceRoomShare != 1), CODE:{\n\t[r, if(json.length(arguments)\t> 2), CODE:{\n\t\t[h,if(title==\"\"): title = \"Click to view image...\" ; title = \"Click to view image: \" + title ]\n\t\t[r: macroLink(title, \"shareIMG@lib:OnTokenMove\", \"none\", arguments)]\t\n\t};{\n\t\t[h,if(title==\"\"): title = \"Click to view description...\" ; title = \"Click to view description: \" + title ]\n\t\t[r: macroLink(title, \"shareTXT@lib:OnTokenMove\", \"none\", arguments)]\n\t}]\n};{}]\n\n[h, if(forceRoomShare), CODE:{\n\t[if(json.length(arguments)\t> 2), CODE:{\n\t\t[bot_execAllPlayers(\"shareIMG@lib:OnTokenMove\", arguments)]\n\t};{\n\t\t[bot_execAllPlayers(\"shareTXT@lib:OnTokenMove\", arguments)]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3cd33281-375b-4a86-bf39-c640e1977fe5",
          "commandChecksum": "7baad8a53a23cdb2290f012f5c98f363",
          "propsChecksum": "8f2b392ab94f9148795ddad8d15d9f22"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "3",
        "index": 509,
        "label": "shareIMG",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:'<!-- ---------------------------------------- shareIMG -------------------------------------------------------------- -->']\n[h: arguments\t= macro.args]\n[h: title\t\t= json.get(arguments, 0)]\n[h,if(title==\"\"): title = \"Shared image\"]\n[h: image\t\t= json.get(arguments, 1)]\n[h: height\t\t= json.get(arguments, 2)]\n\n['pause(\"title\", \"image\", \"height\")']\n\n[h: background\t= tableImage(\"tbl_Image\",27)]\n[h: style\t\t= \"font-family:'Footlight MT Light'; margin:20;  font-size:11px  ;   background-image: url(\" + background + \")\"]\n[h: zoomIn\t\t= \"<img src=\" + tableImage(\"tbl_Image\",28) + \" border='0' alt='Zoom in on image'><\/img>\"]\n[h: zoomOut\t\t= \"<img src=\" + tableImage(\"tbl_Image\",29) + \" border='0' alt='Zoom out on image'><\/img>\"]\n\n[frame(title):{\n\t<html>\n\t<body style=\"[r:style]\">\n\t[r: bot_frameOpen(6)]\n\t\t[if(!startsWith(image, \"http\")), CODE:{\n\t\t\t<!-- if its an external picture (from a website) then the zoom buttons dont work -->\n\t\t\t<table align=\"center\"  border=\"0\"><tr>\n\t\t\t\t<td align=\"center\" border=\"1\" width=\"40px\" bgcolor=\"silver\" style=\"border-style:outset; margin:2 0 2 2\">\t\n\t\t\t\t\t[r: macrolink(zoomIn,\"shareIMG@lib:OntokenMove\",\"none\",json.append(title, image, height+100))]\n\t\t\t\t<\/td>\n\t\t\t\t<td align=\"center\" border=\"1\" width=\"40px\" bgcolor=\"silver\" style=\"border-style:outset; margin:2 0 2 2\">\n\t\t\t\t\t[r: macrolink(zoomOut,\"shareIMG@lib:OntokenMove\",\"none\",json.append(title, image, height-100))]\n\t\t\t\t<\/td>\n\t\t\t<\/tr><\/table>\n\t\t};{}]\n\t\t<table border=\"3\" align=\"center\">\n\t\t\t<tr><td border=\"1\">\n\t\t\t\t<img src=[r: image]-[r: height]><\/img>\n\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t[r: bot_frameClose(6)]\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d71d260-5b36-4d38-8efe-f3c3d37fe238",
          "commandChecksum": "7bdf4b9b56b72fa088e19bf87c91cdbc",
          "propsChecksum": "2b832e95cb0948f33fbdd3755a9d753c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "4",
        "index": 510,
        "label": "shareTXT",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:'<!-- ---------------------------------------- shareTXT -------------------------------------------------------------- -->']\n[h: title\t\t= \tjson.get(macro.args,0)]\n[h,if(title==\"\"): title = \"Shared text\"]\n\n[h: text\t\t= \tjson.get(macro.args,1)]\n[h: background\t= \ttableImage(\"tbl_Image\",27)]\n[h: initiate\t= \t\"font-family:'Footlight MT Light'; font-size:11px; margin:20; background-image: url(\" + background + \")\"]\n\n[frame(title):{\n\t<html>\n\t<body style\t= \"[r:initiate]\">\n\t[r: bot_frameOpen(3)]\n\t\t<table hspace=\"20\" vspace=\"20\"><tr><td>\n\t\t\t[r: text]\n\t\t<\/td><\/tr><\/table>\n\t[r: bot_frameClose(3)]\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2c1cc656-57b4-4eab-99e3-515662c40aa5",
          "commandChecksum": "e3cdfafad69d484e657c74e46edb2efd",
          "propsChecksum": "b87e2fa3fbe7db41ef5781ba5cde6d3b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "5",
        "index": 511,
        "label": "showInfoLink",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:title = json.get(macro.args,0)]\n[h,if(title==\"\"): title = \"Info Link\"]\n[h:infoLink = json.get(macro.args,1)]\n\n[frame(title):{\n\t[r: bot_frameOpen(4)]\n\t[r: infoLink]\n\t[r: bot_frameClose(4)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "45d5e43b-2ac9-4875-ba5a-5d3d39593843",
          "commandChecksum": "a3a7c347bd9d293e0ede5203f9c1681c",
          "propsChecksum": "3009f6d2672d059e6cc1464c2e37e104"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "6",
        "index": 512,
        "label": "roomDescrHelp",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[frame (\"ROOM DESCRIPTOR REFERENCE\"):{\n\t[r:bot_frameOpen(4)]\n\t<b>NILDIKS ROOM DESCRIPTOR - HELP<\/b>\n\t<br>\n\t<b>CORE<\/b><br>\n\tWhen you select a token (ANY token) and then click on the book image in the BoT menu (utils tab) then a window will pop-up showing the text that is in the <b>GM notes<\/b> section of that token.<br>\n\tNext to that it will show the POTRAIT and HANDOUT images for that token as a link. Clicking on those will share that image with the players<br>\n\t<br>\n\t<b>SPECIAL FEAUTRES<\/b><br>\n\tIn addition to the text shown you can add a couple of special features by adding tags around the text. The available tags are:<br>\n\t<br>\n\t<b><share><\/b>Any text between these tags can be shared with players by clicking on the link that will appear at the bottom of this text.<b></share><\/b><br>\n\t<br>\n\t<b><image><\/b>tableImage(\"encounters\",1)<b></image><\/b><br>\n\tBasically any function/macro that returns the asset link of the image can be put between those tags.<br>\n\t<br>\n\t<b><infolink><\/b>Any text here will appear in a separate pop-up window when you click on the link (the name of the link will be the title text.<b></infolink><\/b><br>\n\t<br>\n\t<b><title><\/b>Title of the tagged link (either share, image or infolink). This must be placed in front of the tag you use, the use if <b>optional<\/b>.<b></title><\/b><br>\n\t<br>\n\t<b>COMMON HTML TAGS<\/b><br>\n\t<b><h1><\/b>Header type 1<b></h1><\/b> (or h2, h3, etc.)<br>\n\t<b><b>bold</b><\/b><br>\n\t<b><i><\/b><i>italic<\/i><b></i><\/b><br>\n\t<b><u><\/b><u>underline<\/u><b></u><\/b><br>\n\t<b><a href=http://www.d20srd.org/srd/monsters/kobold.htm><\/b>kobold stats (web link)<b></a><\/b><br>\n\t<br>\n\t<b>COPY PASTE SECTION<\/b><br>\n\tBelow tags you can copy paste straight into your own text for quick use.<br>\n\t<br>\n\t<u>SPECIAL<\/u><br>\n\t    \t<title> </title>\t\t<br>\n\t    \t<infolink> </infolink>\t<br>\n\t    \t<share> </share>\t\t<br>\n\t    \t<image> </image>\t\t<br>\n\t<br>\n\t<u>HTML<\/u><br>\n\t    \t<h1> </h1>\t\t\t\t<br>\n\t    \t<b> </b>\t\t\t\t<br>\n\t    \t<i> </i>\t\t\t\t<br>\n\t    \t<u> </u>\t\t\t\t<br>\n\t    \t<a href=http:// > <a></a>\t\t<br>\t\n\t<br>\n\t<u>GRAB IMAGE<\/u><br>\n\t    \ttblImage(\"tblName\",1)<br>\n\t    \tgetTokenHandout()<br>\n\t    \tgetTokenPortrait()<br>\n\t    \tgetImage('image:Dragon')\t    \t(map independent)<br>\n\t    \tgetImage('dragon')\t\t\t                   (current map only)<br>\n\t    \tgetStateImage('dead')<br>\n\t\n\t[r:bot_frameClose(4)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "654c62aa-a268-4c5a-a806-370b00cedfab",
          "commandChecksum": "7b82b0aa1933b9cf4fcb4256f3d1c677",
          "propsChecksum": "39b6cfe4a85a31db05ffdbb4976c744f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "999",
        "index": 513,
        "label": "<image src=\" asset://1badb8f7d4e390d6c9c058f49c90c744\"><\/image>",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"roomDescrHelp@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0ef83a10-8cba-43d6-9ce9-efc53d271de3",
          "commandChecksum": "ecca08a65c5e4c196fe65875acb781bd",
          "propsChecksum": "bbf3364d61a4c003efa724f854ebbbf3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "4",
        "index": 516,
        "label": "ALL Logging",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: lname = json.get(logger,\"name\")]\n   [h: log.setLevel(lname,\"DEBUG\")]\n}]",
        "maxWidth": "",
        "tooltip": "<html>DO NOT USE. Its will break things<br>\nThis will turn on ALL logging in the console\n<\/html3",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a1ea2e14-17c8-44da-a6c0-acca9e4221ef",
          "commandChecksum": "8b3e18daa1a76a239b2b2c0833217d73",
          "propsChecksum": "c9bfe7f8c70f7085b510bb3cfb090b30"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "2",
        "index": 518,
        "label": "NO Logging",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: lname = json.get(logger,\"name\")]\n   [h: log.setLevel(lname,\"INFO\")]\n}]",
        "maxWidth": "",
        "tooltip": "turns off ALL logging!",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "20b1fc2f-9535-46d3-8cb3-388200bfbdf8",
          "commandChecksum": "da214dcb96223c118e664a85503a8b8a",
          "propsChecksum": "5939622cf6f261e36870d2991e314b3b"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "1",
        "index": 519,
        "label": "Macro Logging",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "\n[h: level = \"DEBUG\"]\n[H: lname = \"net.rptools.maptool.client.MapToolLineParser\"]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.<br>\"]\n[h: log.setLevel(lname,level)]\n\n[h: level = \"DEBUG\"]\n[H: lname = \"net.rptools.maptool.client.VariableResolver \"]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.\"]\n[h: log.setLevel(lname,level)]\n",
        "maxWidth": "",
        "tooltip": "Turns on macro logging in the log file and the console",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b783bbd7-e136-4c06-b325-ec0fe0397b4e",
          "commandChecksum": "3a98e9baec45116c56dc96326a501d00",
          "propsChecksum": "13221c7533f7e2de0d2a1ca7ef364569"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "3",
        "index": 520,
        "label": "Set Logging",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h: loggerList = \"\"]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: loggerList = listAppend(loggerList,json.get(logger,\"name\"))]\n}]\n[h:status=input(\n    \"junkVar|Select a Logger and Level||LABEL|SPAN=TRUE\",\n    \"lname|\"+loggerList+\"|Logger|LIST|VALUE=STRING\",\n    \"level|DEBUG,INFO,WARN,ERROR,FATAL|Level|LIST|VALUE=STRING\")]\n[h:abort(status)]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.\"]\n[h: log.setLevel(lname,level)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "822d59e4-2cbc-4dec-a5bf-028e0868389d",
          "commandChecksum": "facab8ae54bb73b9736c2b7558a6e1f2",
          "propsChecksum": "09501a118e49a90bddecfdc3238a4288"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "23",
        "index": 524,
        "label": "CoMScan",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "<!-- scan all maps looking for centreOnMePads -->\n[h:result = replace(json.indent(bot_seekToken(1,\"centreOnMePad\",'[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]', getAllMapNames(),0,1),2),\"centreOnMePad\", \"\")]\n\n<!-- initiate end result json array -->\n[h:newResult = \"[]\"]\n\n<!-- build json array with each map and map-location build up -->\n[h,foreach(map, result), CODE:{\n\t[locations = json.get(result, map)]\n\t[newResult = json.append(newResult, json.set(\"{}\", \"map\", map, \"spot\", \"\"))]\n\t[foreach(spot, locations),if(spot != \"\"), CODE:{\n\t\t[newResult = json.append(newResult, json.set(\"{}\", \"map\", map, \"spot\", \" \" + spot))]\n}]\n\n}]\n<!-- store end result in lib:eventmacros -->\n[h:setLibProperty(\"centreOnMepads\", json.sort(newResult,\"spot\", \"map\"), \"lib:EventMacros\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eca9a181-1f91-4e53-b445-7e59bb0ce24e",
          "commandChecksum": "9c14084585a36403c1ad565e9fa34761",
          "propsChecksum": "77a9d3206e4ef26fea5823421d17a96f"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "24",
        "index": 525,
        "label": "switchMap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- switchMap ([mapName[, players]]) ------------------------------------------------>']\n<!-- The argument players must be either a list of player names or 1 to select ALL players -->\n\n<!-- <html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.\n-->\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n\n[h:mapList\t\t= listSort(getAllMapNames(),\"N+\")]\n[h:comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t<!-- centre on me pad locations -->\n\n[h:locationList = \"\"]\n[h,foreach(location, comLocations,\"<br>\"), CODE:{\n\t[map\t\t\t= json.get(location, \"map\")]\n\t[spot\t\t\t= json.get(location, \"spot\")]\n\t[if(!listContains(mapList, map)), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[assert(0,\"error encountere, maplist needs to be updated, please run again\",0)]\n\t}]\n\t[locationList\t= listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:allPlayers\t= getAllPlayerNames()]\n\n[h,if(argCount() > 0): newMap\t= arg(0) ; newMap\t= oldMap]\n[h:assert(listFind(mapList, newMap) != -1, \"The map \"+arg(0)+\" does not exist\",0)]\n\n[h,if(argCount() > 1), CODE:{\n\t<!-- in case both arguments have been given, the input can be omitted and the players can be switched to the map -->\n\t[userList\t\t= arg(1)]\n\t[if(userList == 1): userList = getAllPlayerNames()]\n\n\t<!-- move players -->\n\t[playerList = \"\"]\n\n\t[FOREACH(player, userList), if(listContains(allPlayers, player)): playerList = listAppend(playerList, player) ; broadcast(\"The player: \"+player+\" does not exist!\")]\n\t[selCount\t\t= 0]\n''\n};{\n\t<!-- in case one or no arguments have been given, show the input and ask for map and players to switch map for -->\n\t<!-- make sure that at least the current map is part of the comLocation, if not rescan -->\n\t[if(listFind(locationList, oldMap) == -1), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t<!-- centre on me pad locations -->\n\t\t[locationList = \"\"]\n\t\t[foreach(location, comLocations,\"<br>\"), CODE:{\n\t\t\t[map = json.get(location, \"map\")]\n\t\t\t[spot = json.get(location, \"spot\")]\n\t\t\t[locationList = listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t[newMap\t\t= listFind(locationList, newMap)]\n\t[userList\t= allPlayers]\n\t[selected\t= getSelectedNames()]\n\t[selCount\t= listCount(selected)]\n\n\n\t<!-- input string -->\n\t[\t\t\t\t\t\t\tinputStr = \"junk|Force Selected Players to Map|-|LABEL|SPAN=TRUE\"]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"newMap|\"+locationList+\"|Select map|RADIO| SELECT=\"+newMap,\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"selCount|1|Move selected token(s)?|CHECK\",\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"junk|(\"+selected+\")<br> |-|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Select Players|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[FOREACH(player, userList):\tinputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Res-scan all maps for new locations<br>|When checked this macro will scan ALL maps looking for<br>tokens that are called <i>centrOnMePad Some Location Name<\/i><br>and adds <i>Some Location Name<\/i> to the above list of locations<br>when you choose that location the map will be centred around<br><i>that<\/i> pad. Obviously <i>Some Location Name<\/i> can be any<br>alphanumerical string you like!|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"rescan|0|Re-scan|CHECK\",\"@\")]\n\n\t<!-- ask for input-->\n\t[abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\t\n\t<!-- move players -->\n\t[playerList = \"\"]\n\t[FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t''\n\t}]\n''\n}]\n\n<!-- get new map and location -->\n[h:newLocation = json.get(comLocations, newMap)]\n[h:newMap = json.get(newLocation, \"map\")]\n[h:newLoc = json.get(newLocation, \"spot\")]\n[h:comPad = \"centreOnMePad\" + newLoc]\n\n<!-- move tokens (if any) -->\n[h:setCurrentMap(newMap)]\n[h,if(findToken(comPad)!=\"\"), CODE:{\n\t[X = getTokenX(0, comPad)]\n\t[Y = getTokenY(0, comPad)]\n};{\n\t[X = 0]\n\t[Y = 0]\n}]\n\n[h,if(rescan): bot_CoMScan()]\t\n\n[h, if(selCount == 1), CODE: {\n\t[FOREACH(tok, selected),if(oldMap != newMap), CODE:{\n\t\t[moveTokenFromMap(tok, oldMap, X+roll.count, Y)]\n\t};{\n\t\t[moveToken(X+roll.count, Y, 0, tok)]\n\t}]\n};{}]\n\n[h:setCurrentMap(oldMap)]\n\n[h:bot_execAllPlayers(\"gotoMap@lib:OnTokenMove\",json.append(\"[]\",newMap,newLoc), playerList)]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br>\n<br>\nIf you select tokens before you use this macro, then the option will be added to move<br>\nthe selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br>\nIf you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i><br>\nthen these will show up as location in this macro (after a 'rescan').<br>\n<br>\nIf there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eadd2405-b728-456e-8a05-503771210dc2",
          "commandChecksum": "34baab7aad409671057d0d7760630b4f",
          "propsChecksum": "9951f41566c7162863daf39d5969f94f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.1 Experimental Shit",
        "includeLabel": false,
        "sortBy": "",
        "index": 526,
        "label": "(new)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:x=getLibProperty(\"padNameList\", \"lib:eventmacros\")]<br>\n[h,if(!listContains(x,\"SoundPad\")):setLibProperty(\"padNameList\", listAppend(x, \"SoundPad\"),\"lib:eventmacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fb1c9510-b3e8-42ce-b66c-a106cd86343b",
          "commandChecksum": "cb1e076d8ab6f29610f75c3c44c9e3c6",
          "propsChecksum": "a7f79e0423f8477e3d32f9146929ddb7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "71",
        "index": 527,
        "label": "getRangedDistance",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- --------------------------------------- getRangedDistance ---------------------------------------- -->']\n\n<!-- getRangedDistance(source,target): range -->\n[H: source = arg(0)]\n[H: target = arg(1)]\n\n<!-- source and target must be defined -->\n[H: assert(! json.isEmpty(source) && ! json.isEmpty(target),\"<b>getRangedDistance(source,target): range<\/b> - Source or target not defined.\",0)]\n\n<!-- If elevation isnt set then set to 0 -->\n[H: source.elevation = getProperty(\"Elevation\",source)]\n[H, if(! isNumber(source.elevation)): source.elevation = 0]\n[H: target.elevation = getProperty(\"Elevation\",target)]\n[H, if(! isNumber(target.elevation)): target.elevation = 0]\n\n<!-- get elevation difference and factor in size. Used big formula for processing speed -->\n[H, if(source.elevation != target.elevation), code: {\n   [H, if(source.elevation < target.elevation): distance.vertical = max(0,target.elevation - (source.elevation + (listFind(\"Large,Huge,Gargantuan,NA,Colossal\",getSize(source)) + 1)*5));\n      distance.vertical = max(0,source.elevation - (target.elevation + (listFind(\"Large,Huge,Gargantuan,NA,Colossal\",getSize(target)) + 1)*5))]\n};{\n   [H: distance.vertical = 0]\n}]\n\n[H, if(! distance.vertical), code: {\n   [H: totalDistance = getDistance(source,1,target,\"ONE_TWO_ONE\")]\n};{\n   <!-- count squares, no metric in between -->\n   [H: distance.direct = getDistance(source,1,target,\"ONE_ONE_ONE\")]\n   <!-- get number of diagonal moves -->\n   [H: horizontal.diagonals = floor((getDistance(source,1,target,\"NO_DIAGONALS\") - distance.direct)/5)]\n   <!-- its assumed when changing elevation that you move in a diagonal fashion until at elevation -->\n   [H: vertical.diagonals = min(distance.direct,distance.vertical)]\n   <!-- subtract horizontal diags used from vertical diags needed because we can move diag in vert and horizontal direction for same cost -->\n   [H: extra.diagonals =  floor((max(vertical.diagonals,horizontal.diagonals) - horizontal.diagonals)/5)]\n   <!-- manually calc distance based on number of diags moved (1-2-1) and add the leftover horizonal and vertical distances -->\n   [H: totalDistance = floor((horizontal.diagonals + extra.diagonals) * 0.5) * 5 + distance.direct + distance.vertical - vertical.diagonals]\n}]\n\n[H: macro.return = totalDistance]\n",
        "maxWidth": "",
        "tooltip": "created by Aliasmask",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b22afdea-31d4-48b5-99cf-1323eb5312bf",
          "commandChecksum": "8abc20158e6976945187d9fefabd3d0e",
          "propsChecksum": "9508f07a4a31c472864e54a8082c8aca"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "70",
        "index": 528,
        "label": "changeElevation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------------- changeElevation()  ------------------------->']\n[h:assert(listCount(getSelected())==1,\"Make sure (only) one token is selected\",0)]\n[h:switchToken(getSelected())]\n\n[H: elevation.value = getProperty(\"Elevation\")]\n[H, if(! isNumber(elevation.value)): elevation.value = 0]\n\n[H: abort(input(\"tip|<html><b><i>Either set current elevation or put adjustment value in.<\/i><\/b><\/html>||LABEL|SPAN=TRUE\",\n   strformat('elevation.input|%{elevation.value}|Current Elevation|TEXT'),\n   \"elevation.adjustment|0|Adjust Elevation|TEXT\"\n))]\n\n<!-- error checking -->\n[H, if(! isNumber(elevation.input)): elevation.input = 0]\n[H, if(! isNumber(elevation.adjustment)): elevation.adjustment = 0]\n\n<!-- get new elevation -->\n[H, if(elevation.input != elevation.value), code: {\n   [elevation.new = elevation.input]\n};{\n   [if(elevation.adjustment > 0), code: {\n      [elevation.new = elevation.value + elevation.adjustment]\n   };{\n      [elevation.new = max(0,elevation.value - elevation.adjustment)]\n   }]\n}]\n\n<!-- set states -->\n[H, if(elevation.new > 0): setState(\"flying\",1)]\n[H, if(elevation.new < 0): setState(\"burrowing\",1)]\n[H, if(elevation.new <= 0): setState(\"flying\",0)]\n[H, if(elevation.new >= 0): setState(\"burrowing\",0)]\n\n<!-- set elevation value -->\n[H: setProperty(\"Elevation\",elevation.new)]\n\n<!-- output elevation changes -->\n[H: tokenImage = getTokenImage()]\n\n[H: output = strformat('\n   <table style=\"border-spacing:0px;border-style:solid;border-color:black;border-width:1pt;padding:0px\">\n      <tr>\n         <td width=\"34\" style=\"padding:0px\">%{tokenImage}<\/td>\n         <td width=\"250\" style=\"background-color:aqua;padding:0px 5px 2px 5px;\">%{token.name} moves to Elevation %{elevation.new}.<\/td>\n      <\/tr>\n   <\/table>\n')]\n\n[H: broadcast(output)]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "created by Aliasmask",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "674b8e35-de9f-4900-ad3b-aee74cf2e7e6",
          "commandChecksum": "139f71bc3d0f9d73e995dacf18f89047",
          "propsChecksum": "87c6cf492f7e696701e461e9fd937e7c"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "1",
        "index": 531,
        "label": "Language2Script",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:assert(isGM(), \"GM Only, 0\")]\n[h:Languages\t= getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n[h:choices\t\t= getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\")]\n\n[h:tables\t\t= listSort(getTableNames(),\"A+\")]\n[h:exampleTxt\t= \"This script looks like this\"]\n\n[h:scripts\t\t= \"\"]\n[h:names\t\t= \"none\"]\n\n[h:showScript\t= \"<table><tr>\"]\n[h,foreach(tbl, tables), if(startsWith(tbl, \"script_\")), CODE:{\n\t[name\t\t= substring(tbl, 7, length(tbl))]\n\t[scripts\t= listAppend(scripts, tbl)]\n\t[names\t\t= listAppend(names, name)]\n\t[showScript\t= showScript + \"<font size=5>\"+name+\"<\/font><\/td><td>\" + bot_textToScript(exampleTxt, tbl) + \"<\/tr><tr>\"]\n};{}]\n[showScript\t\t= showScript + \"<\/tr><\/table>\"]\n\n[h:inputStr\t\t= \"[]\"]\n[H, foreach(language,Languages), CODE:{\n\t[choice\t\t= json.get(choices,language)]\n\t[nChoice\t= listFind(scripts,choice)+1]\n\t[inputStr\t= json.append(inputStr,strformat(\n\t\tlanguage+\"_link|\"+names+\"|Pick script to link to \"+language+\"|LIST|VALUE=STRING SELECT=\"+nChoice\n\t))]\n\n}]\n\n[h:abort(input(\n\t\t\"junk|<html>\n\t\tHere you can link a language to a certain special script.<br>\n\t\tThe encoded message will show up in that script instead of<br>\n\t\tnormal text, giving it an extra effect. \n\t\t<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"junk|<html>\"+showScript+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"junk|<html><br><br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\tjson.toList(json.evaluate(inputStr),\"##\")\n))]\n\n[json.script = \"{}\"]\n[foreach(language, languages), if(eval(language+\"_link\")!=\"none\"): \n\tjson.script = json.set(json.script, language, \"script_\"+eval(language+\"_link\"))\n]\n\n}]\n[h:setLibProperty(\"w42.bot.whisperPanel.script\", json.script, \"lib:eventMacros\")]",
        "maxWidth": "",
        "tooltip": "Link the languages to scripts",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f3a04460-a121-4f30-a5df-ca6bae597f50",
          "commandChecksum": "38e54cf5df5386711d79aaf82ac20019",
          "propsChecksum": "92b5a1fbc07deae2adc1fe70d09a62f1"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "1a",
        "index": 539,
        "label": "diagnose",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": true,
        "command": "[h:'<!-- ------------------------------------- diagnose (onCampaignLoad) ----------------------------------- -->']\n<!-- \n<html>Map Diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br>\nIt checks whether token names contain non-alphanumerical characters and checks the libs for the<br>\nsame and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br>\nyou to the token. <\/html> \n-->\n\n<!-- checks for BoT installation errors -->\n<!-- NO NEW SCOPE !!! -->\n<!-- THREE CODE LEVELS -->\n<!-- only return the install checks during oncampaignload. Give full output when run outside of OCL -->\n[h,if(argCount() > 0): onCampaignLoad\t= arg(0)  ; onCampaignLoad = 0]\n\n[h,if(!onCampaignLoad), CODE:{\n\t<!-- required background variables for processing -->\n\t[info\t\t= getInfo(\"client\")]\n\t[libs\t\t= json.get(info, \"library tokens\")]\n\t[botVersion\t= json.get(libs, \"lib:OnTokenMove\")]\n\t[baseMap\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[mapList\t= getAllMapNames(\"json\")]\n\t[oldMap\t\t= getCurrentMapName()]\n\t[abort(input(\"checkLevel|Light, Medium, Heavy|<html>\n\tHow thorough should the Token Name Check be?<br>\n\tNote that 'Heavy' might result in a lot\tof 'error'<br>\n\treports that are not a threat at all!<\/html>|RADIO|SELECT=1\"))]\n\n\t<!-- build regexString for the illegal character check -->\n\t<!-- make sure that the dash is ALWAYS at the end!! or the regex will fail -->\n\t[regIllCharChk\t= \":'\\\\\\$\" + if(checkLevel, \"&?@;\", \"\") + if(checkLevel==2, \"+=#|<>.-\", \"\")]\n};{}]\n\n[h:'<!-- --------------------- ------------------------------------------------ ---------------------------- -->']\n[h:'<!-- this is the part where the bot states, tokens and tables are checked. WHICH are checked, depends on the features installed. These can be edited in diagnoseFeature -->']\n<!-- create the lists corresponding with the macro menu groups based on the installation settings -->\n[h:varsFromStrProp(getLibProperty('bot.fg.diagArrays',  'lib:OnTokenMove'))]\n[h:varsFromStrProp(getLibProperty('bot.fg.diagLists',  'lib:OnTokenMove'))]\n<!-- creation of:\n\tdiagStateArray\tdiagStateList\n\tdiagTokenArray\tdiagTokenList\n\tdiagTableArray\tdiagTableList\n -->\n[h:'<!-- --------------------- ------------------------------------------------ ---------------------------- -->']\n\n[h:'<!-- --------------------- check if all BOT STATES are added to the campaign---------------------------- -->']\n[h:allStates\t\t= getTokenStates(\"json\")]\n[h:found\t\t\t= json.intersection(allStates, diagStateArray))]\n[h:notFound\t\t\t= json.difference(diagStateArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \" x <u><font color='red'>The following states are currently <b>NOT<\/b> defined for this campaign:<\/font><\/u><br>\"]\n\t[foreach(state, notFound): output\t= output + \"<b> - \"+state+\"<\/b>: used in the Bag of Tricks for \"+listGet(diagStateList, json.indexOf(diagStateArray, state))+\"<br>\"]\n\t[stateOutput\t= output + \"If you're not planning to make use of any of these functions, you can ignore this message.\"]\n};{\n\t[stateOutput\t= \" v All necessary Bag of Tricks states have been defined\"]\n}]\n\n[h:'<!-- --------------------- check BOT TOGGLE SETTINGS ---------------------------- -->']\n\n<!-- strPropFromVars(\"forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doInvisibility, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea\", \"UNSUFFIXED\") -->\n[h:toggles = getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:output\t\t\t= \"<u><font color='green'><b>The following BoT Toggles are currently turned ON (in the settings): <\/font><\/u><\/b>\"]\n[h,foreach(toggle, toggles, \"\",\";\"), if(indexValueStrProp(toggle, 0) == 1 || indexValueStrProp(toggle, 0) == 2): output\t= listAppend(output, indexKeyStrProp(toggle, 0),\", \")]\n[h:togglesOutput\t\t= output]\n\n[h:'<!-- ---- check if all invis states are created when invis is turned on in settings ---------- -->']\n[h, if(listContains(togglesOutput, \"doInvisibility\")), CODE:{ \n\t\n\t[invisState\t\t\t= getLibProperty('invisState','lib:EventMacros')]\n\t[seeInvisState\t\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\t[purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\t[annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\t[invisStates\t\t= json.append(\"[]\", invisState, seeInvisState, purgeInvisState,annulInvisState)]\n\t[numStates\t\t\t= json.length(json.intersection(allStates, invisStates))]\n\t[if(numStates != 4), CODE:{\n\t\t<!-- if not all four states have been defined AND invis is turned on in the setting: boom!-->\n\t\t<!-- so turn if off in the settings -->\n\t\t[toggles = setStrProp(toggles, \"doInvisibility\", 0)]\n\t\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t\t[invisOutput\t= \" x <u><font color='red'>In the Settings, Invisibility is turned on, however there are \" + numStates + \" invisibility defined, while 4 are required!! <b>Setting is TURNED OFF!<b><\/font><\/u>\"]\n\t};{\n\t\t[invisOutput\t= \" v Invisibility is used and all required states are defined\"]\n}]\n};{\n\t[invisOutput\t\t= \" v Invisibility is not used\"]\n}]\n\n\n[h:'<!-- --------------------- check if all BOT TOKENS are added to the campaign---------------------------- -->']\n[h:setCurrentMap(baseMap)]\n[h:allToks\t\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")))]\n[h:setCurrentMap(oldMap)]\n[h:found\t\t\t= json.intersection(allToks, diagTokenArray))]\n[h:notFound\t\t\t= json.difference(diagTokenArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \" x <u><font color='red'>The following Tokens are currently <b>NOT<\/b> present in this campaign file:<\/font><\/u><br>\"]\n\t[foreach(state, notFound): output\t= output + \"<b> - \"+state+\"<\/b>: used in the Bag of Tricks for \"+listGet(diagTokenList, json.indexOf(diagTokenArray, state))+\"<br>\"]\n\t[tokOutput\t\t= output + \"If you're not planning to make use of any of these functions, you can ignore this message.\"]\n};{\n\t[tokOutput\t\t= \" v All necessary Bag of Tricks tokens have been found\"]\n}]\n\n[h:'<!-- --------------------- check if all BOT TABLES are added to the campaign---------------------------- -->']\n[h:tableJson\t\t= json.get(getInfo(\"campaign\"),\"tables\")]\n[h:tableGroups\t\t= json.toList(tableJson)]\n[h:found\t\t\t= json.intersection(tableJson, diagTableArray))]\n[h:notFound\t\t\t= json.difference(diagTableArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \" x <u><font color='red'>The following table(s) is/are currently <b>NOT<\/b> present in this campaign <\/font><\/u><font color='blue'><a href='https://forums.rptools.net/viewtopic.php?p=274503#p274503'>(link to the special pads zip file)<\/a><\/font>:<br>\"]\n\t[foreach(table, notFound): output\t= output + \"<b> - \"+table+\"<\/b>: \"+listGet(diagTableList, json.indexOf(diagTableArray, table))+\".<br>\"]\n\t[tableOutput\t= output]\n\n\t[if(!json.contains(tableJson, \"tbl_Image\")), CODE:{\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t};{\n\t\t[right\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 24, 15) + \"'><\/image>\"]\n\t\t[wrong\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 25, 15) + \"'><\/image>\"]\n\t}]\n};{\n\t[tableOutput\t= \" v All necessary Bag of Tricks tables are installed\"]\n\t[if(table(\"tbl_Image\", 25) != \"Wrong\"), CODE:{\n\t\t[tableOutput\t= tableOutput + \"<br> x However 'tbl_Image' is not up to date. You can extract it from <font color='blue'><a href='http://bit.ly/GGVCzN'>here<\/a><\/font>\"]\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t};{\n\t\t[right\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 24, 15) + \"'><\/image>\"]\n\t\t[wrong\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 25, 15) + \"'><\/image>\"]\n\t}]\n}]\n\n[h:libList\t\t\t= json.fields(json.get(info, \"library tokens\"))]\n[h:hasOwner\t\t\t= \"\"]\n\n[h,if(onCampaignLoad), CODE:{\n\t<!-- --------------------- check if all lib:tokens are un-owned ---------------------------- -->\n\t[foreach(map, mapList), CODE:{\n\t\t[setCurrentMap(map)]\n\t\t[foreach(libTok, libList), if(findToken(libTok) != \"\"), CODE:{\n\t\t\t[if(isOwnedByAll(libTok) || getOwners(\",\",libTok) != \"\"):\thasOwner = listAppend(hasOwner, strformat(\"%{libTok} (%{map})\"))]\n\t\t''\n\t\t}]\n\t''\t\n\t}]\n''\n};{\n\t<!-- \n\t- if mapname contains illegal chars\n\t- if mapname starts or is entirely a number\n\t- check for wrong characters in token names\n\t- check if all lib:tokens are un-owned \n\t- check if lib:token on correct layer\n\t- check if lib:token is visible\n\t- optionally: check if the ID of tokens are numeric\n\t -->\n\t[isHidden\t\t\t= \"\"]\n\t[h:txtOutput\t\t= \"<b><u><font color='red'>ERRORS FOUND: <\/font><\/u><\/b><br>If any errors have been found in a token, a hyperlink is shown which will goto the corresponding map and select the token (if possible). Keep in mind however that the listed tokens likely have characters in their name that might break these hyperlinks, which will result in an error report. In this case just go to the map and search it manually<br><br>\"]\n\t<!-- the following string is used to create clickable links to the tokens -->\n\t[h:result\t\t\t= \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{map}", "%s", "3", "0", "0"]'>%s<\/a>\"]\n\n\t[foreach(map, mapList), CODE:{\n\t\t[txtOutput\t\t= txtOutput + strformat(\"<b><u>%{map}<\/u><\/b><br>\")]\n\t\t[setCurrentMap(map)]\n\t\t\n\t\t<!-- check if map name contains illegal characters -->\n\t\t[warningName\t= if(getFindCount(strfind(map,\"[^,\\\\w\\\\s\\\\-._]\")) ||  getFindCount(strfind(map,\",\")),1,0)]\n\t\t[if(warningName):\ttxtOutput = txtOutput + strformat(\"<font color=red>This map contains non-alphanumerical characters, that can potentially break Bag of Tricks or Framework macros. After you fixed the name, run Diagnose again!!<\/font><br>\")]\n\t\t<!-- check if map name either starts with a number or is a number entirely (both cause issues) -->\n\t\t[warningName\t= if(isNumber(substring(map,0,1)), 1, 0)]\n\t\t[if(warningName):\ttxtOutput = txtOutput + strformat(\"<font color=red>Either the name of this map starts with a number or the map name IS a number. Both cases will lead to errors for the Bag of Tricks.<\/font><br>\")]\n\t\t\n\t\t<!-- check if anything is wrong with the lib tokens on this map -->\n\t\t[foreach(libTok, libList), if(findToken(libTok) != \"\"), CODE:{\n\t\t\t[hasOwner = \"\"]\n\t\t\t[isHidden = \"\"]\n\t\t\t[if(isOwnedByAll(libTok) || getOwners(\",\",libTok) != \"\"):\thasOwner\t\t= listAppend(hasOwner,\t\tstrformat(\"%{libTok} (%{map})\"))]\n\t\t\t[if(!getVisible(libTok)):\t\t\t\t\t\t\t\t\tisHidden\t\t= listAppend(isHidden,\t\tstrformat(\"%{libTok} (%{map})\"))]\n\n\t\t\t<!-- check for owners on libs -->\n\t\t\t[h,if(listCount(hasOwner)):\t\ttxtOutput\t= txtOutput + strformat(\"The following lib(s) have a(n) owner(s) set. If the lib is for general use (all players) then you need to correct this (uncheck all owners): \")]\n\t\t\t[h:txtOutputL\t= \"\"]\n\t\t\t[h,foreach(tok, hasOwner): \t\ttxtOutputL\t= listAppend(txtOutputL, strformat(result, tok, tok))]\n\t\t\t[h:txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<br><br>\", \"\")]\n\n\t\t\t<!-- check if libs are hidden -->\n\t\t\t[h,if(listCount(isHidden)):\t\ttxtOutput\t= txtOutput + strformat(\"The following lib(s) are NOT visible to players. Make sure they are: \")]\n\t\t\t[h:txtOutputL\t= \"\"]\n\t\t\t[h,foreach(tok, isHidden):\t\ttxtOutputL\t= listAppend(txtOutputL, strformat(result, tok, tok))]\n\t\t\t[h:txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<br><br>\", \"\")]\n\t\t''\n\t\t}]\n\t\t\n\t\t<!-- check if theres any token on the map with a potential buggy name -->\n\t\t[H:tokListP\t= getTokenNames(\"%\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t\t[h:tokList\t= getTokenNames(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\n\t\t[h:hasWrongTokName\t= \"[]\"]\n\n\t\t<!-- check is any token contains a , in its name -->\n\t\t[h:regResult\t= strfind(tokListP,\"[^%]*(,+)[^%]*\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t\t\t\n\t\t<!-- remove the token entries that contained a , in their name -->\n\t\t[h:tokListC\t= json.difference(tokList, hasWrongTokName)]\n\t\t[h:tokListC\t= json.toList(tokListC)]\n\n\t\t<!-- check the tokens for any illegal character -->\n\t\t[h:regResult\t= strfind(tokListC,\"[^,]*([\"+regIllCharChk+\"]+)[^,]*\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t<!-- create a list of these tokens -->\n\t\t[if(json.length(hasWrongTokName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>NAMES<\/b> have non alphanumerical characters in their name and <i>might<\/i> render an issue:<br><font color='red'>\")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasWrongTokName):txtOutputL\t= listAppend(txtOutputL, id)]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br><\/font>\"]\n\n\t\t<!-- check the remaining tokens for trailing or leading spaces -->\n\t\t[h:hasSpaceTokName\t= \"[]\"]\n\t\t[h:regResult\t= strfind(tokListC,\"(?<=,)\\\\s[^,]*|[^,]*\\\\s(?=,)\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasSpaceTokName = json.append(hasSpaceTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t<!-- create a list of these tokens -->\n\t\t[if(json.length(hasSpaceTokName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>NAMES<\/b> have SPACES in their name (either trailing or leading) and <i>might<\/i> render an issue:<br><font color='red'>\")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasSpaceTokName):txtOutputL\t= listAppend(txtOutputL, id)]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br><\/font>\"]\n\n\t\t\n\t\t<!-- check whether the ID of the tokens are NOT numerical -->\n\t\t<!-- code (for the most part) by lmarkus -->\n\t\t[hasWrongIdName\t= \"[]\"]\n\t\t[idList\t= getTokens(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t\t[splices\t= bot_createSplices(idList)]\n\t\t[foreach(splice, splices), CODE:{\n\t\t\t[foreach(id, splice), if(length(id) != 32): hasWrongIdName = json.append(hasWrongIdName, id)]\n\t\t\t\n\t\t''\n\t\t}]\n\t\t<!-- add the mapname to the tokens and create a clickable output -->\n\t\t[if(json.length(hasWrongIdName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>ID's<\/b> have been <b>fixed<\/b> (numerical token ids can lead to a lot of issues in maptool. By copy pasting the original they get a new ID. Run Diagnose again just to be sure that the new name is not a number):<b> \")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasWrongIdName), CODE:{\n\t\t\t[txtOutputL\t= listAppend(txtOutputL, getName(strformat(\"%032d\",id)))]\n\t\t\t[copyToken(strformat(\"%032d\",id),1,\"\",json.set(\"{}\",\"name\",getName(strformat(\"%032d\",id)),\"delta\",1,\"x\",0,\"y\",0)) ]\n\t\t\t[removeToken(strformat(\"%032d\",id)) ]\n\t\t}]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br>\"]\n\t''\n\t}]\n''\n}]\n[h:setCurrentMap(oldMap)]\n\n[h,if(hasOwner != \"\"):\n   libOwnerOutput   = \" x <u><font color='red'>The following lib:Tokens have an owner set and trusted macros <b>WILL NOT WORK!<\/b>: <\/font><\/u><br>\"+hasOwner+\". If this is a lib:token of a player, then this is no issue. If this however is a lib:token belonging to the gm or Framework then it most likely will pose a problem. To fix this, double click on these lib:Tokens, goto the ownership tab and make sure ALL checkboxes are UNchecked\"\n;\n   libOwnerOutput   = \" v All lib:Tokens have no owners set (this is good!).\"\n]\n\n[if(!onCampaignLoad), CODE:{\n\t[r,frame(\"Initialization result\")\t\t\t\t:{[r:txtOutPut]}]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>Maps diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9489ff09-c78c-4aa0-991b-7db1a9c731b0",
          "commandChecksum": "fdd78a381e9f6924b0e31c47d62307f6",
          "propsChecksum": "dad01d1c1f26ad708894ba2d7c865729"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "99",
        "index": 540,
        "label": "setDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- setDoor Stamp version---------------------------------------------->']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n currentVBLAngle=0;\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n drawVBL=1;\n windowVBL=0;\n keyholeVBL=0;\n crackVBL=0;\n halfVBL=0;\n fullVBL=1;\n stepSize=0;\n crackStepSize=0;\n halfStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n halfOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpenDoorX=0;\n crackOpenDoorY=0;\n halfOpenDoorX=0;\n halfOpenDoorY=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n choice= \"fullVBL\";\n')]\n\n<!-- FIRST initialize ALL vars -->\n[h:varsFromStrProp(initList)]\n\n<!-- look for potential double door -->\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n<!-- THEN initialize any values already stored on the door -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n<!-- setup macro event link -->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t<!-- create macro list from the Event Button Macros group -->\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:vblSupport\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:drawVBL\t\t\t= if(drawVBL && vblSupport, 1, 0)]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(getTokenWidth() != getTokenHeight()):\twarning = listAppend(warning, \"The image you are using is NOT square. IF you are using VBL then this may result in pieces of VBL remaining on the map. The easiest solution is to set the door to a preset size like 'Large'.\", \"<br><br>\")]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n<!-- get the VBL under the door -->\n[h:hasVbl\t\t= !json.isEmpty(json.get(json.get(bot_VBLGrenade(1,0),0),\"points\"))]\n[h:removeVBL\t= 0]\n\n[h: abort(input(\n\tif(vblSupport, \"tab0|Door option|| TAB\", \"\"),\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t- when using VBL: there is NO VBL where the door-opening is.<br>\n\t\t- when using VBL: the UNROTATED* door image has the HINGES at the CENTRE and has the HANDLE on the EAST side<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\",\n\t\n\tif(vblSupport, \"tab1|VBL Options|| TAB\", \"\"),\n\tif(vblSupport, \"junk|<html><b>The below options are ONLY availabel if you check 'VBL for doors'<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"\"),\n\tif(vblSupport, \"drawVBL|\"+drawVBL+\"|Use vision blocking for door|CHECK\", \"\"),\n\tif(vblSupport && hasVbl, \"removeVBL|0|<html><span title='<html><b>When checked: ALL VBL on the ENTIRE token will be erased (so not only the door line)<\/html>'>Remove current VBL on door<\/html><\/span><\/html>|CHECK\", \"\"),\n\tif(vblSupport, \"junk|<html><b>When you check any of these a menu will pop-up when you toggle the door<\/b><br>Players are allowed to:<\/html>|-|LABEL|SPAN=TRUE\", \"\"),\n\tif(vblSupport, \"windowVBL|\"+windowVBL+\"|peek through a window in the door|CHECK\", \"\"),\n\tif(vblSupport, \"keyholeVBL|\"+keyholeVBL+\"|peek through the key hole|CHECK\", \"\"),\n\tif(vblSupport, \"crackVBL|\"+crackVBL+\"|crack the door and peek|CHECK\", \"\"),\n\tif(vblSupport, \"halfVBL|\"+halfVBL+\"|open the door half way|CHECK\", \"\"),\n\tif(vblSupport, \"fullVBL|\"+fullVBL+\"|open the door fully|CHECK\", \"\")\n))]\n\n<!-- make sure that if drawVBL is set that at least 1 choice is set. -->\n[h,if(drawVBL && !sum(windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL)): fullVBL  = 1]\n\n<!-- idiot checks and setting properties -->\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, drawVBL, openDistance, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n[h,if(animateTime == 0): animateTime = 1]\n\n<!--------------------------------------------------------------------->\n<!-------------------------the big loop ------------------------------->\n<!--------------------------------------------------------------------->\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t<!-- set other properties -->\n\t[h:currentVBLAngle\t= currentJavaAngle]\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\t<!-- set the door shape to TOP DOWN -->\n\t[h,if(vblSupport): setTokenShape(\"TOP DOWN\", mainDoor)]\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t<!-- rotating door -->\n\t\t[stepSize\t\t=  openAngle/animateTime]\n\t\t[crackStepSize\t= 10/animateTime]\n\t\t[halfStepSize\t= 45/animateTime]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t[crackOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*10,360)]\n\t\t[halfOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*45,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t<!-- sliding door -->\n\t\t[stepSize\t\t= openDistance/animateTime]\n\t\t[crackStepSize\t= (openDistance/10)/animateTime]\n\t\t[halfStepSize\t= (openDistance/2)/animateTime]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t<!-- 2=left, 3=right, 4=north, 5=south -->\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t['pause(\"openMethod\",\"currentX\",\"currentY\",\"closedDoorX\",\"closedDoorY\",\"openDoorX\",\"openDoorY\",\"openDistance\",\"xDistance\",\"yDistance\")']\n\t\t[crackOpenDoorX\t= currentX + floor(xDistance/10)]\n\t\t[crackOpenDoorY\t= currentY + floor(yDistance/10)]\n\t\t[halfOpenDoorX\t= currentX + floor(xDistance/2)]\n\t\t[halfOpenDoorY\t= currentY + floor(yDistance/2)]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t<!-- setup double door -->\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\",\t\"closedDoorX=\"\t+getTokenX(1,doubleDoorName)+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\";closedDoorY=\"\t+getTokenY(1,doubleDoorName)+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\";currentVBLAngle=\"\t+bot_getTokenFacing(doubleDoorName, 1), doubleDoorName)\n\t]\n\t<!-- set the double door shape to TOP DOWN -->\n\t[h,if(vblSupport && doubleDoor): setTokenShape(\"TOP DOWN\", doubleDoorName)]\n\n\t<!-- setup token switch -->\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t<!-- lock the door is set to such -->\n\t[h:setState(\"Locked\",isLocked)]\n\n\t<!-- add gm Note -->\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t<!-- setup the macro link -->\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, currentVBLAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t<!-- remove current VBL on the door VBLGrenade (tokOnly (1/0), clearVBL(1/0), tok)-->\n\t[h,if(removeVBL): bot_VBLGrenade(1,1, mainDoor)]\n\t[h,if(removeVBL && doubleDoor): bot_VBLGrenade(1,1, doubleDoorName)]\n\n\t<!-- draw VBL on the door (this function uses the doorData so it has to AFTER that is set) -->\n\t[h,if(drawVBL), CODE:{\n\t\t<!-- define the following vars for createVBL: applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset -->\n\t\t[xOffset\t= round(getTokenWidth() / 2, 0)]\n\n\t\t[vblSetup\t= strformat(\n\t\t\t\"applyVBL=1; VBLType=3; scaleX=100; scaleY=100; offsetX=%{xOffset}; offsetY=0; thickness=2; fill=0; scale=0.5; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;\"\n\t\t)]\n\n\t\t<!-- get the new VBL settings and apply the new VBL cross to its current position -->\n\t\t[setProperty(\"w42.bot.vblSetup\", vblSetup, mainDoor)]\n\n\t\t<!-- createVBL (tok,check for vbl,isDoor) -->\n\t\t[bot_createVBL(mainDoor,0,1)]\n\t\t[if(doubleDoor): bot_createVBL(doubleDoorName,0,1)]\n\t}]\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b869ed3e-9036-4655-8392-97a70352ee07",
          "commandChecksum": "339cd358a34d5c8e811e6e98fbf7ac77",
          "propsChecksum": "a9e82bfd6211113eae7a524f6d8c696e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "1",
        "index": 541,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t<!-- a trigger button is used next to the door -->\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t<!-- name of the token operating the door -->\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t<!-- door is openened with a macro (likely by the gm) -->\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n<!-- INITIALIZE VALUES -->\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n[h:drawVBL\t\t\t\t= if(drawVBL && vblSupport, 1,0)]\n<!-- MAKE ASSERTIONS -->\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n<!-- STOP KEY HOLE OR WINDOW VIEW -->\n[h:choice\t= getProperty(\"clearedVBL\", mainDoor)]\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t[isClosed\t\t= 1]\n\t[setProperty(\"clearedVBL\", \"\", mainDoor)]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n<!-- DOOR EVENT TRIGGER -->\n<!-- if an event is linked to the door being operated -->\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n<!-- CHECK VBL OPTIONS -->\n[h,if(drawVBL && !isClosed && choice == \"\" || !drawVBL): choice = \"fullVBL\"]\n[h,if(drawVBL && isClosed), CODE:{\n\t[nothing\t= 1]\n\t[propList\t= \"nothing, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n<!-- @@@@leave out until repaired!!! -->\n['windowVBL = 0']\n['keyholeVBL = 0']\n\t[if(windowVBL+keyholeVBL+crackVBL+halfVBL+fullVBL > 1), CODE:{\n\t\t[optionList = \"\"]\n\t\t[choices\t= \"Do nothing, Peek through the window, Peek through the key hole, Crack the door open, Open the door halfway, Open the door all the way\"]\n\t\t[foreach(item, propList): optionList = if(eval(item), listAppend(optionList, listGet(choices, roll.count)), optionList)]\n\t\t<!-- some menu is required -->\n\t\t[abort(input(\n\t\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\t\"choice|\"+optionList+\"|You...|RADIO|VALUE=STRING\"\n\t\t))]\n\t\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t\t[abort(if(choice == \"nothing\", 0,1))]\n\t}; {\n\t\t<!-- no menu is required, set choice to the only value set -->\n\t\t[choice = \"\"]\n\t\t[foreach(item, propList): choice = if(eval(item), item, choice)]\n\t\t<!-- when no choice is set at all set it to full vbl (door full open -->\n\t\t[if(choice == \"\"):choice = \"fullVBL\"]\n\t}]\n}; {}]\n\n[h:setProperty(\"clearedVBL\", choice, mainDoor)]\n[h:'pause(\"choice\")']\n\n<!-- PROCESS VBL OPTIONS: KEYHOLE AND WINDOW -->\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->\n\t[isClosed\t\t= 0]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n<!-- openMethod: <2 = rotating (CCW 0/CW 1); >=2 = sliding (W 2/E 3/N 4/S 5)-->\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t<!-- ROTATING DOOR-->\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\n\t<!-- toggle the door -->\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[doubleStartPos\t\t= bot_getTokenFacing(mainDoor+'a')]\n\t\t[setTokenFacing(doubleEndPos, mainDoor+\"a\")]\n\t}; {\n\t\t[doubleOldPos\t\t= 0]\n\t}]\n\n\t[if(drawVBL): bot_moveStamp()]\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t<!-- SLIDING DOOR-->\n\t<!-- toggle the door -->\n\t[if(choice == \"crackVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(crackOpenDoorX, crackOpenDoorY, 1, mainDoor)\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"halfVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(halfOpenDoorX, halfOpenDoorY, 1, mainDoor)\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"fullVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(openDoorX, openDoorY, 1, mainDoor)\t\t\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[xDirection\t= if(openMethod < 4, 1, 0)]\n\t\t[newXPos\t= if(isClosed, openDoorX, closedDoorX)]\n\t\t[newYPos\t= if(isClosed, openDoorY, closedDoorY)]\n\t\t[DDoorX\t\t= if(xDirection, doubleDoorParam - newXPos, getTokenX(1, mainDoor+'a'))]\n\t\t[DDoorY\t\t= if(xDirection, getTokenY(1, mainDoor+'a'), doubleDoorParam - newYPos)]\n\t\t[moveToken(DDoorX, DDoorY, 1, mainDoor+\"a\")]\n\t}]\n\t[isClosed \t= 1 - isClosed]\n\t[if(drawVBL):bot_moveStamp()]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, choice, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, choice, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, choice, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f6cbe0bc-1f71-4f17-be26-2ac5754fd676",
          "commandChecksum": "3eb0f088e42bbd01e3811f5cde080a0f",
          "propsChecksum": "7a7cc597ab108f93084633c81bee8687"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "1",
        "index": 555,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t<!-- a trigger button is used next to the door -->\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t<!-- name of the token operating the door -->\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t<!-- door is openened with a macro (likely by the gm) -->\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n<!-- INITIALIZE VALUES -->\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n<!-- MAKE ASSERTIONS -->\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n<!-- DOOR EVENT TRIGGER -->\n<!-- if an event is linked to the door being operated -->\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n<!-- openMethod: <2 = rotating (CCW 0/CW 1); >=2 = sliding (W 2/E 3/N 4/S 5)-->\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t<!-- ROTATING DOOR-->\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t\n\t<!-- toggle the door -->\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[doubleOldPos\t= 0]\n\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t<!-- SLIDING DOOR-->\n\t<!-- toggle the door -->\n\n\t[isClosed \t= 1 - isClosed]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3533a1df-b628-4237-9102-4862c81676c9",
          "commandChecksum": "836d33158c56ca1c26da6cbe13187322",
          "propsChecksum": "3a01037758bba808aac6add618bcb9ee"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "2",
        "index": 542,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n[H, if(init), code: {\n\t<!-- Assertions and initializing properties -->\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[choice\t\t\t= arg(3)]\n\t[isClosed\t\t= arg(4)]\n\t<!-- Abort when player is on other map -->\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[if(drawVBL), CODE:{\n\t\t<!-- mt version VBL support check -->\n\t\t[if(!getLibProperty('vblSupport','lib:EventMacros')):drawVBL = 0]\n\t};{}]\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t<!-- initialize timers -->\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\n<!-- ROTATION INIT -->\n\t<!-- check if door is open or closed, and if in between reset its position to either open or closed -->\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n<!-- SLIDING INIT -->\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t<!-- does the door slides left right (x) or up down (y) -->\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n<!-- ROTATION -->\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tendPos = totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tstartPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tstartPos = totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n<!-- /ROTATION -->\n\n<!-- SLIDING -->\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tendPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tendPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tstartPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tstartPos\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t<!-- if the door is not open, make sure that its in the correct open position -->\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n<!-- /SLIDING -->\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[if(choice == \"crackVBL\"):\tcurrentStepSize = direction * crackStepSize]\n\t[if(choice == \"halfVBL\"):\tcurrentStepSize = direction * halfStepSize]\n\t[if(choice == \"fullVBL\"):\tcurrentStepSize = direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n<!-- ------------------------------------------------------>\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t<!-- ROTATING -->\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor && choice == \"fullVBL\"): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t}; {\n\t\t<!-- SLIDING -->\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, choice, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t};{}]\n\n\t\t[if(doubleDoor && choice == \"fullVBL\"): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\t}]\n}]\n\n<!-- ------------------------------------------------------>\n\n<!-- Check if animation is finished -->\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t<!-- if not, rotate door yet another step -->\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\tchoice\t\t\t= %{choice}; \n\t\t\tdrawVBL\t\t\t= %{drawVBL};\n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t\t<!-- only the initiator must set the VBL -->\n\t\t[doVBL\t= 0]\n\t}; {\n\t\t<!-- if youre the only one running (or the initiator) also set the door visible again -->\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t\t[doVBL\t= 1]\n\t}]\n\t\n\t[if(drawVBL && doVBL), CODE:{\n\t\t[mainDoor\t\t= me]\n\t\t[isClosed \t\t= bot_isDoorClosed(mainDoor)]\n\t\t[bot_moveStamp(me)]\n\t\t[if(doubleDoor): bot_moveStamp(me + 'a')]\n\t}; {}]\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2d2330ab-2ba5-4e4e-be55-a4cc9a24e472",
          "commandChecksum": "9ca84639869988eea580128d631d09df",
          "propsChecksum": "84d601cd3e024d30e6afe8b61f35ed2e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "2",
        "index": 556,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t<!-- Assertions and initializing properties -->\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\n\t<!-- Abort when player is on other map -->\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t<!-- initialize timers -->\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n<!-- ROTATION INIT -->\n\t<!-- check if door is open or closed, and if in between reset its position to either open or closed -->\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n<!-- SLIDING INIT -->\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t<!-- does the door slides left right (x) or up down (y) -->\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n<!-- ROTATION -->\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n<!-- /ROTATION -->\n\n<!-- SLIDING -->\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t<!-- if the door is not open, make sure that its in the correct open position -->\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n<!-- /SLIDING -->\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n<!-- ------------------------------------------------------>\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t<!-- ROTATING -->\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t<!-- SLIDING -->\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n<!-- ------------------------------------------------------>\n\n<!-- Check if animation is finished -->\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t<!-- if not, rotate door yet another step -->\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t<!-- if youre the only one running (or the initiator) also set the door visible again -->\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "186ca96e-15fc-4e1c-8b1a-f31da62dae73",
          "commandChecksum": "b90143e816d05b7dc07530820ee1e099",
          "propsChecksum": "fd36a33bc82f9e29f22afb381981c251"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "7",
        "index": 543,
        "label": "setVBLDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- setVBLDoor --------------------------------------- -->']\n<!-- IGNORE OUTPUT, NO NEW SCOPE -->\n\n<!-- USED FOR KEY HOLE AND WINDOW -->\n\n<!-- the following assumptions are currently made:\nFor a token with NO facing: The Hinge of the door starts in the centre of the total image and the door runs right. That means that the doorknob is in the right/east side. \n-->\n\n<!-- How does this work: as ALL doors start in the centre and point east you ONLY need to keep track of whether its opened/closed, sliding/rotating and it current angle. \n\nFor rotating doors you can simply erase the VBL of where it WAS and draw the VBL of where is IS. As the x/y coords never changes only the facing, you only need to erase the start angle and draw the end angle\n\nFor sliding doors you only need to erase when it opens and draw when it closes. The spot where it draws/erases is ALWAYS THE SAME so you need the x/y coords of the closed position together with its facing angle and with that you can draw/erase when it closes/opens\n\nFor keyhole and windows it works the same as sliding only the area is defined smaller. \n -->\n\n<!-- currently for vbl to work a token MUST ben impersonated -->\n[h,if(argCount() > 0): mainDoor = arg(0)]\n[switchToken(mainDoor)]\n[gridSize\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n\n<!-- switchId, openMethod, doubleDoor, description, currentVBLAngle, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n<!-- initiate variables -->\n[varsFromStrProp(\"r=0; points=[]; scale=1; thickness=2; fill=0; close=0; x=0;y=0;w=0;h=0\")]\n\n[shape\t= \"polygon\"]\n[doorX\t= closedDoorX]\n[doorY\t= closedDoorY]\n[xOffset= round(getTokenWidth() / 2, 0)]\n[rx\t\t= doorX + xOffset] <!-- rotational offset -->\n[ry\t\t= doorY + round(getTokenHeight() / 2, 0)]\n[x1\t\t= rx+2] <!-- the + 2 is to prevent the erase function form cutting in the vbl wall -->\n[x2\t\t= doorX + getTokenWidth()]\n[y1\t\t= ry]\n[y2\t\t= ry]\n\n<!-- calculate the X coords of the door. -->\n[h,switch(choice),CODE:\n\tcase \"keyholeVBL\": {\n\t\t<!-- key hole 1 pixel per 50 pixes grid-->\n\t\t[mDoor\t\t= rx + round(getTokenWidth() / 4, 0)] <!-- x coord of centre of the door -->\n\t\t[width\t\t= max(1, floor(gridSize/50))]\n\t\t[x1\t\t\t= mDoor - width]\n\t\t[x2\t\t\t= mDoor + width]\n\t}; \n\tcase \"windowVBL\": {\n\t\t<!-- window width 25% of cell -->\n\t\t[mDoor\t\t= rx + round(getTokenWidth() / 4, 0)] <!-- x coord of centre of the door -->\n\t\t[width\t\t= max(2, floor(gridSize/8))]\n\t\t[x1\t\t\t= mDoor - width]\n\t\t[x2\t\t\t= mDoor + width]\n\t\t['pause(\"mDoor\",\"rx\",\"x1\",\"x2\",\"width\",\"gridSize\")']\t\n\t}; \n\tdefault: {\n\t\t[error = \"Unknown VBL choice: \"+choice]\n\t\t[pause(\"error\")]\n\t}\n]\n\n<!-- 'r' needs to be set depending on the current facing of the door. Default facing (== no facing) is 270. Since in this case we do NOT want to rotate the VBL; -->\n[re \t= currentVBLAngle]\n[rd \t= bot_getTokenFacing(mainDoor, 1)]\n\n<!-- store new currentVBLAngle on door -->\n[currentVBLAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[setProperty(\"w42.bot.doorData\", setStrProp(getProperty(\"w42.bot.doorData\", mainDoor), \"currentVBLAngle\", currentVBLAngle), mainDoor)]\n\n<!-- key hole or window, angle will remain unchanged so just need the current angle -->\n[if(isClosed), CODE:{\n\t<!-- nothing needs to be erased -->\n\t[points1\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[points2\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[ePoints\t= json.append('[]', points1, points2) ]\t\t\t\n\n\t<!-- redraw door VBL where de door now is -->\n\t[points1\t= json.set(\"{ }\", \"x\", x1, \"y\", y1) ]\n\t[points2\t= json.set(\"{ }\", \"x\", x2, \"y\", y2) ]\n\t[dPoints\t= json.append('[]', points1, points2) ]\t\t\t\n};{\n\t<!-- erase door VBL where the door originally was, so not current position !!-->\n\t[points1\t= json.set(\"{ }\", \"x\", x1, \"y\", y1) ]\n\t[points2\t= json.set(\"{ }\", \"x\", x2, \"y\", y2) ]\n\t[ePoints\t= json.append('[]', points1, points2) ]\t\t\t\n\n\t<!-- nothing needs to be drawn -->\n\t[points1\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[points2\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[dPoints\t= json.append('[]', points1, points2) ]\t\t\t\n}]\n\n[jsonVBL = \"[]\"]\n['VBLData = json.fromStrProp(strPropFromVars(\"shape, x, y, w, h, points, r, scale, thickness, fill, close\", \"UNSUFFIXED\"))']\n[eShape\t\t= json.set(\"{ }\", \"shape\", \"polygon\", \"rx\", rx, \"ry\", ry, \"r\", re, \"close\", 0, \"thickness\", 2, \"scale\", 1, \"points\", ePoints)] \n[dShape\t\t= json.set(\"{ }\", \"shape\", \"polygon\", \"rx\", rx, \"ry\", ry, \"r\", rd, \"close\", 0, \"thickness\", 2, \"scale\", 1, \"points\", dPoints)] \n\n[eJsonVBL\t= json.append(jsonVBL, eShape)]\t\n[dJsonVBL\t= json.append(jsonVBL, dShape)]\t\n\n['pause(\"eJsonVBL\",\"dJsonVBL\", \"isClosed\", \"doubleDoor\", \"choice\")']\n[eraseVBL(eJsonVBL)]\n[drawVBL(dJsonVBL)]\n\n[selectTokens(getTokens(\",\", '{ pc:1 }'),1,\",\")]\n[exposeFOW()]\n[deselectTokens()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cc6d3212-020c-44f9-9f6b-50a5430247e0",
          "commandChecksum": "f9d948e6855ad009efb7f787c5ac5b82",
          "propsChecksum": "d51684cd31c48695069682d1e6d3c540"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "10",
        "index": 544,
        "label": "startInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_startInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:'<!-- you need to run this macro when you make a token invisible -->']\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t<!-- set the invisibility state -->\n\t[setState(invisState, 1, meTok)]\n\t<!-- create a property that stores the original owners as this will change when the invisibility is purged -->\n\t\n\t[setProperty(\"w42.originalOwners\", getOwners(\"json\", meTok), meTok)]\n\t<!-- this property keeps track of current tokens within purge/see range sight -->\n\t[setProperty(\"w42.purgedBy\", \"[]\", meTok)]\n\t<!-- start invisibility -->\n\t[setOwnerOnlyVisible(1, meTok)]\n\n\t[broadcast(\"Invisibility is turned on for <b>\" + meTok, bot_ownergm(meTok))]\n\n\t[tCopyID = copyToken(meTok, 1, \"\", json.set(\"{}\",\"layer\", \"object\", \"name\", getName(meTok)+\"(invis)\"))]\n\n\t['<!-- Invoke additional work on copied token -->']\n\t<!-- immediately run purgeInvis as its possible that a purging token is in range, do this in the linked macro -->\n\t[link1 = macroLinkText(\"createShadow@\" + getMacroLocation(), \"self\", tCopyID)]\n\t[execLink(link1, 1)]\n\n\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "8b262cca-f1d2-4cba-b567-68aeedf41f40",
          "commandChecksum": "6dc42fa7135fd523fa7fe2993a9b9566",
          "propsChecksum": "7a0b2da9f0796f9c3f884886c1bf2714"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "1",
        "index": 545,
        "label": "createShadow",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------- createShadow ------------------------- -->']\n<!-- technically its not creating a shadow but changing it while deferred (as you cant change with copyToken -->\n[h:'<!-- called form bot_startInvisibility ']\n\n[h: meTok = arg(0)]\n[h: switchToken(meTok)]\n[h: setTokenOpacity(0.60)]\n[h: setHasSight(0)]\n[h: setVisible(1)]\n[h: setOwnerOnlyVisible(1)]\n\n<!-- run check deferred, so shadowtoken exists -->\n[h:link1 = macroLinkText(\"checkInvisibility@\" + getMacroLocation(), \"self\", meTok)]\n[h:execLink(link1, 1)]\n\n\n[h:' bot_checkInvisibility(meTok)']\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "b88231d1-bddd-492b-9073-b3601c41967e",
          "commandChecksum": "9e5c01fd38fdf1c881e8fc514c4e1750",
          "propsChecksum": "c5e60f5bc82d75b0e84886d4044f45b1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "11",
        "index": 546,
        "label": "endInvisibility",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_endInvisibility Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n[h:\"<!-- you need to run this macro when you make a token invisible -->\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t<!-- end the invisibility state -->\n\t[setState(invisState, 0, meTok)]\n\t<!-- set the owners back to the original owners -->\n\t[setOwner(getProperty(\"w42.originalOwners\", meTok),meTok)]\n\n\t<!-- reset the purged/seenby property -->\n\t[setProperty(\"w42.purgedBy\", \"[]\", meTok)]\n\t<!-- end invisibility -->\n\t[setOwnerOnlyVisible(0, meTok)]\n\n\t<!-- remove shadow token -->\n\t[shadowToken = findToken(getName(meTok)+\"(invis)\")]\n\t[if(shadowToken!=\"\"): removeToken(getName(meTok)+\"(invis)\")]\n\t\n\t[broadcast(\"Invisibility is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "168e6af5-e0fe-4956-8baf-39b684add255",
          "commandChecksum": "8944b893a6518c1c92ae2a3d2fc57927",
          "propsChecksum": "00a2d96778038963f042b25185c68fe3"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "2",
        "index": 550,
        "label": "resetRanges",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- bot_reset invis ranges Macro --> <!-- IGNORE OUTPUT , NO NEW SCOPE-->']\n\n[resetProperty(\"w42.seeInvisRange\")]\n[resetProperty(\"w42.purgeInvisRange\")]\n[resetProperty(\"w42.annulInvisRange\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": true,
        "compare": [],
        "metadata":         {
          "uuid": "5083e811-fc8f-4136-89a2-bd40f168eb10",
          "commandChecksum": "e613dbf64fd3217cd13fc38800a6b2a7",
          "propsChecksum": "08f01f3bed52e193185d33df9715b0fa"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115h",
        "index": 551,
        "label": "Reset Ranges",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_resetRanges()]",
        "maxWidth": "",
        "tooltip": "resets the invisibility related ranges of the selected tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1968ac0b-348d-4b0f-aa61-c77855eba66c",
          "commandChecksum": "5dfd9821d08b0b8ef67a616ae9c838b5",
          "propsChecksum": "6f7eec385782610cd6498e1b0bb35f17"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "115h",
        "index": 552,
        "label": "Change Elevation",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_changeElevation()]",
        "maxWidth": "",
        "tooltip": "Sets flying or burrowing (or swimming) of selected token. Is used for getRangedDistance Macro that is used in the invisibility macros",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "74c146f4-648c-44a2-842c-a791747a3112",
          "commandChecksum": "80f0b6f4c52d7d25009bbdf6e1fdffca",
          "propsChecksum": "549b538ff0549ce7347712ee279bf2be"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "99",
        "index": 554,
        "label": "setDoorBCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- --------------------------------------- setDoor Stamp version---------------------------------------------->']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n stepSize=0;\n crackStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpenDoorX=0;\n crackOpenDoorY=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n')]\n\n<!-- FIRST initialize ALL vars -->\n[h:varsFromStrProp(initList)]\n\n<!-- look for potential double door -->\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n<!-- THEN initialize any values already stored on the door -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n<!-- setup macro event link -->\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t<!-- create macro list from the Event Button Macros group -->\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n\n[h: abort(input(\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\"\n))]\n\n<!-- idiot checks and setting properties -->\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, openDistance\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n[h,if(animateTime == 0): animateTime = 1]\n\n<!--------------------------------------------------------------------->\n<!-------------------------the big loop ------------------------------->\n<!--------------------------------------------------------------------->\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t<!-- set other properties -->\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t<!-- rotating door -->\n\t\t[stepSize\t\t=  openAngle/animateTime]\n\t\t[crackStepSize\t= 10/animateTime]\n\t\t[halfStepSize\t= 45/animateTime]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t[crackOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*10,360)]\n\t\t[halfOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*45,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t<!-- sliding door -->\n\t\t[stepSize\t\t= openDistance/animateTime]\n\t\t[crackStepSize\t= (openDistance/10)/animateTime]\n\t\t[halfStepSize\t= (openDistance/2)/animateTime]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t<!-- 2=left, 3=right, 4=north, 5=south -->\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t['pause(\"openMethod\",\"currentX\",\"currentY\",\"closedDoorX\",\"closedDoorY\",\"openDoorX\",\"openDoorY\",\"openDistance\",\"xDistance\",\"yDistance\")']\n\t\t[crackOpenDoorX\t= currentX + floor(xDistance/10)]\n\t\t[crackOpenDoorY\t= currentY + floor(yDistance/10)]\n\t\t[halfOpenDoorX\t= currentX + floor(xDistance/2)]\n\t\t[halfOpenDoorY\t= currentY + floor(yDistance/2)]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t<!-- setup double door -->\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\", \"closedDoorX=\"+getTokenX(1,doubleDoorName)+\";closedDoorY=\"+getTokenY(1,doubleDoorName))]\n\n\t<!-- setup token switch -->\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t<!-- lock the door is set to such -->\n\t[h:setState(\"Locked\",isLocked)]\n\n\t<!-- add gm Note -->\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t<!-- setup the macro link -->\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9ad79c0b-e260-4d88-966b-57e752dc66d6",
          "commandChecksum": "a73620b2df9701117a4a332e57e80036",
          "propsChecksum": "16d3fce0250376bdd910f6d2432c0a4b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "1",
        "index": 541,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t<!-- a trigger button is used next to the door -->\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t<!-- name of the token operating the door -->\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t<!-- door is openened with a macro (likely by the gm) -->\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n<!-- INITIALIZE VALUES -->\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n[h:drawVBL\t\t\t\t= if(drawVBL && vblSupport, 1,0)]\n<!-- MAKE ASSERTIONS -->\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n<!-- STOP KEY HOLE OR WINDOW VIEW -->\n[h:choice\t= getProperty(\"clearedVBL\", mainDoor)]\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t[isClosed\t\t= 1]\n\t[setProperty(\"clearedVBL\", \"\", mainDoor)]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n<!-- DOOR EVENT TRIGGER -->\n<!-- if an event is linked to the door being operated -->\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n<!-- CHECK VBL OPTIONS -->\n[h,if(drawVBL && !isClosed && choice == \"\" || !drawVBL): choice = \"fullVBL\"]\n[h,if(drawVBL && isClosed), CODE:{\n\t[nothing\t= 1]\n\t[propList\t= \"nothing, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n<!-- @@@@leave out until repaired!!! -->\n['windowVBL = 0']\n['keyholeVBL = 0']\n\t[if(windowVBL+keyholeVBL+crackVBL+halfVBL+fullVBL > 1), CODE:{\n\t\t[optionList = \"\"]\n\t\t[choices\t= \"Do nothing, Peek through the window, Peek through the key hole, Crack the door open, Open the door halfway, Open the door all the way\"]\n\t\t[foreach(item, propList): optionList = if(eval(item), listAppend(optionList, listGet(choices, roll.count)), optionList)]\n\t\t<!-- some menu is required -->\n\t\t[abort(input(\n\t\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\t\"choice|\"+optionList+\"|You...|RADIO|VALUE=STRING\"\n\t\t))]\n\t\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t\t[abort(if(choice == \"nothing\", 0,1))]\n\t}; {\n\t\t<!-- no menu is required, set choice to the only value set -->\n\t\t[choice = \"\"]\n\t\t[foreach(item, propList): choice = if(eval(item), item, choice)]\n\t\t<!-- when no choice is set at all set it to full vbl (door full open -->\n\t\t[if(choice == \"\"):choice = \"fullVBL\"]\n\t}]\n}; {}]\n\n[h:setProperty(\"clearedVBL\", choice, mainDoor)]\n[h:'pause(\"choice\")']\n\n<!-- PROCESS VBL OPTIONS: KEYHOLE AND WINDOW -->\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t<!-- needed params: closedAngle, isClosed, mainDoor, openMethod, choice -->\n\t[isClosed\t\t= 0]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n<!-- openMethod: <2 = rotating (CCW 0/CW 1); >=2 = sliding (W 2/E 3/N 4/S 5)-->\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t<!-- ROTATING DOOR-->\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\n\t<!-- toggle the door -->\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[doubleStartPos\t\t= bot_getTokenFacing(mainDoor+'a')]\n\t\t[setTokenFacing(doubleEndPos, mainDoor+\"a\")]\n\t}; {\n\t\t[doubleOldPos\t\t= 0]\n\t}]\n\n\t[if(drawVBL): bot_moveStamp()]\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t<!-- SLIDING DOOR-->\n\t<!-- toggle the door -->\n\t[if(choice == \"crackVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(crackOpenDoorX, crackOpenDoorY, 1, mainDoor)\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"halfVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(halfOpenDoorX, halfOpenDoorY, 1, mainDoor)\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"fullVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(openDoorX, openDoorY, 1, mainDoor)\t\t\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[xDirection\t= if(openMethod < 4, 1, 0)]\n\t\t[newXPos\t= if(isClosed, openDoorX, closedDoorX)]\n\t\t[newYPos\t= if(isClosed, openDoorY, closedDoorY)]\n\t\t[DDoorX\t\t= if(xDirection, doubleDoorParam - newXPos, getTokenX(1, mainDoor+'a'))]\n\t\t[DDoorY\t\t= if(xDirection, getTokenY(1, mainDoor+'a'), doubleDoorParam - newYPos)]\n\t\t[moveToken(DDoorX, DDoorY, 1, mainDoor+\"a\")]\n\t}]\n\t[isClosed \t= 1 - isClosed]\n\t[if(drawVBL):bot_moveStamp()]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, choice, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, choice, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, choice, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f6cbe0bc-1f71-4f17-be26-2ac5754fd676",
          "commandChecksum": "3eb0f088e42bbd01e3811f5cde080a0f",
          "propsChecksum": "7a7cc597ab108f93084633c81bee8687"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "1",
        "index": 555,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h: '<!-- ----------------------------------------- toggleDoor -------------------------------------------------------------->']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t<!-- a trigger button is used next to the door -->\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t<!-- name of the token operating the door -->\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t<!-- door is openened with a macro (likely by the gm) -->\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n<!-- INITIALIZE VALUES -->\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n<!-- MAKE ASSERTIONS -->\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n<!-- DOOR EVENT TRIGGER -->\n<!-- if an event is linked to the door being operated -->\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n<!-- openMethod: <2 = rotating (CCW 0/CW 1); >=2 = sliding (W 2/E 3/N 4/S 5)-->\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t<!-- ROTATING DOOR-->\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t\n\t<!-- toggle the door -->\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[doubleOldPos\t= 0]\n\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t<!-- SLIDING DOOR-->\n\t<!-- toggle the door -->\n\n\t[isClosed \t= 1 - isClosed]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3533a1df-b628-4237-9102-4862c81676c9",
          "commandChecksum": "836d33158c56ca1c26da6cbe13187322",
          "propsChecksum": "3a01037758bba808aac6add618bcb9ee"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "2",
        "index": 542,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n[H, if(init), code: {\n\t<!-- Assertions and initializing properties -->\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[choice\t\t\t= arg(3)]\n\t[isClosed\t\t= arg(4)]\n\t<!-- Abort when player is on other map -->\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[if(drawVBL), CODE:{\n\t\t<!-- mt version VBL support check -->\n\t\t[if(!getLibProperty('vblSupport','lib:EventMacros')):drawVBL = 0]\n\t};{}]\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t<!-- initialize timers -->\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\n<!-- ROTATION INIT -->\n\t<!-- check if door is open or closed, and if in between reset its position to either open or closed -->\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n<!-- SLIDING INIT -->\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t<!-- does the door slides left right (x) or up down (y) -->\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n<!-- ROTATION -->\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tendPos = totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tstartPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tstartPos = totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n<!-- /ROTATION -->\n\n<!-- SLIDING -->\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tendPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tendPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tstartPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tstartPos\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t<!-- if the door is not open, make sure that its in the correct open position -->\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n<!-- /SLIDING -->\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[if(choice == \"crackVBL\"):\tcurrentStepSize = direction * crackStepSize]\n\t[if(choice == \"halfVBL\"):\tcurrentStepSize = direction * halfStepSize]\n\t[if(choice == \"fullVBL\"):\tcurrentStepSize = direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n<!-- ------------------------------------------------------>\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t<!-- ROTATING -->\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor && choice == \"fullVBL\"): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t}; {\n\t\t<!-- SLIDING -->\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, choice, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t};{}]\n\n\t\t[if(doubleDoor && choice == \"fullVBL\"): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\t}]\n}]\n\n<!-- ------------------------------------------------------>\n\n<!-- Check if animation is finished -->\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t<!-- if not, rotate door yet another step -->\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\tchoice\t\t\t= %{choice}; \n\t\t\tdrawVBL\t\t\t= %{drawVBL};\n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t\t<!-- only the initiator must set the VBL -->\n\t\t[doVBL\t= 0]\n\t}; {\n\t\t<!-- if youre the only one running (or the initiator) also set the door visible again -->\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t\t[doVBL\t= 1]\n\t}]\n\t\n\t[if(drawVBL && doVBL), CODE:{\n\t\t[mainDoor\t\t= me]\n\t\t[isClosed \t\t= bot_isDoorClosed(mainDoor)]\n\t\t[bot_moveStamp(me)]\n\t\t[if(doubleDoor): bot_moveStamp(me + 'a')]\n\t}; {}]\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2d2330ab-2ba5-4e4e-be55-a4cc9a24e472",
          "commandChecksum": "9ca84639869988eea580128d631d09df",
          "propsChecksum": "84d601cd3e024d30e6afe8b61f35ed2e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "2",
        "index": 556,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ------------------------------------------- deferToggleDoor --------------------------------------- -->']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t<!-- Assertions and initializing properties -->\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\n\t<!-- Abort when player is on other map -->\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t<!-- switchId, openMethod, doubleDoor, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection -->\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t<!-- initialize timers -->\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n<!-- ROTATION INIT -->\n\t<!-- check if door is open or closed, and if in between reset its position to either open or closed -->\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n<!-- SLIDING INIT -->\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t<!-- does the door slides left right (x) or up down (y) -->\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n<!-- ROTATION -->\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n<!-- /ROTATION -->\n\n<!-- SLIDING -->\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t<!-- if the door is not open, make sure that its in the correct open position -->\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n<!-- /SLIDING -->\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n<!-- if newPos is on the other side of endPos than the currentPos it will have an opposite sign and thus the multiplication result will be negative -->\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n<!-- ------------------------------------------------------>\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t<!-- ROTATING -->\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t<!-- SLIDING -->\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n<!-- ------------------------------------------------------>\n\n<!-- Check if animation is finished -->\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t<!-- if not, rotate door yet another step -->\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t<!-- delete the animated door and make the maindoor visible again. but not if you are the initiator in which case me = maindoor and maindoor = '' -->\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t<!-- if youre the only one running (or the initiator) also set the door visible again -->\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "186ca96e-15fc-4e1c-8b1a-f31da62dae73",
          "commandChecksum": "b90143e816d05b7dc07530820ee1e099",
          "propsChecksum": "fd36a33bc82f9e29f22afb381981c251"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "11",
        "index": 557,
        "label": "SoundPad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- SoundPad -------------------------------->']\n<!-- couple of assertions -->\n[h: return(isPC(tok, getCurrentMapName()), \"\")]\n[h: ownerNames\t\t= getOwners(\"json\", tok, getCurrentMapName())]\n[h: return(json.length(ownerNames), \"\")]\n\n<!-- retrieve settings -->\n[h:varsFromStrProp(getProperty(\"w42.bot.soundSettings\",padName))]\t<!-- uri,startVolume,distStart,maxVolume,distMaxVolume -->\n[h: soundExists\t\t= json.length(getSoundProperties(uri))]\n\n<!--\tcalculate sound effect per soundpad depending on the distance to the player token \n\t\tdistStart is the max distance where the sound is still audible \n\t\tgiven that sound does not 'scale'  linearly but exponentiolly a square factor is used to adjust the volume -->\n[h: dist\t\t\t= getDistance(padName, 1, tok)]\n[h, if (dist > distStart), CODE:{\n\t[execFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)]\n\n};{\n\t<!-- check whether token is required to be in an area -->\n\t[if(effectArea != 0):\n\t\tonArea\t\t= bot_isOnDrawing(lastPath, effectArea)\n\t;\n\t\tonArea\t\t= 1\n\t]\n\t\n\t[if(onArea):\n\t\texecFunction(if(soundExists,\"editStream\", \"playStream\"), json.append(\n\t\t\t\"[]\", uri, \"-1\",\tstartVolume + \n\t\t\t\t\t\t\t\tsquare(1 - \n\t\t\t\t\t\t\t\t\tmax(0,dist-distMaxVolume) /\n\t\t\t\t\t\t\t\t\tmax(0.1,distStart-distMaxVolume)\n\t\t\t\t\t\t\t\t) * \n\t\t\t\t\t\t\t\t(maxVolume-startVolume)\n\t\t), 0, ownerNames)\n\t;\n\t\texecFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)\n\t]\n\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2a440d73-382a-40f8-b7c0-6927ab09a6c9",
          "commandChecksum": "87383b79679968b3e94d6e6993bc7b59",
          "propsChecksum": "37ff87b8f53a190a70f65127457f16a8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "11",
        "index": 558,
        "label": "chkSounds",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!--------------------- bot_chkSounds (playerTok, Map, forceStop || CLIENT, forceStop) --------------------------->']\n\n<!-- \nThis funciton is called when a token position is changed currently that is:\n- mapTeleport\n- Teleport\n- SwitchMap (gotoMap() specifically)\n\n-->\n\n[h,if(argCount()==2), CODE:{\n\t[ownerNames\t= arg(0)]\n\t[forceStop\t= arg(1)]\n\t[padNames= json.get(getLibProperty(\"allMapsPads\", \"lib:EventMacros\"), getCurrentMapName())]\n};{\n\t[tok\t\t= arg(0)]\n\t[srcMap\t\t= arg(1)]\n\t[forceStop\t= arg(2)]\n\t[if(argCount()>3): padNames\t= arg(3) ; padNames = json.get(getLibProperty(\"allMapsPads\", \"lib:EventMacros\"), getCurrentMapName())]\n\t[return(if(tok==\"\",0,1), \"\")]\n\t[return(isPC(tok, SrcMap), \"\")]\n\t[ownerNames\t= getOwners(\"json\", tok, SrcMap)]\n\t[return(json.length(ownerNames), \"\")]\n}]\n\n[h,foreach(padName, padNames), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t[varsFromStrProp(getProperty(\"w42.bot.soundSettings\",padName))]  <!-- uri -->\n\t[if(forceStop), CODE:{\n\t\t[soundExists\t= json.length(getSoundProperties(uri))]\n\t\t[if (soundExists): execFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)]\n\t};{\n\t\t[bot_SoundPad()]\t\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7ddb9eba-6e26-407f-8d68-8d7b44c660b1",
          "commandChecksum": "4d1084e3de1c6480219cf7d1db0b7af8",
          "propsChecksum": "717da470673068ebc90a8c2886c9760d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "11",
        "index": 559,
        "label": "setupSound",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!----------------------------- bot_setupSound () -------------------------------->']\n\n[h:tok\t\t\t= getSelectedNames()]\n[h:assert(listCount(tok)==1, \"Make sure (only) one token is selected\",0)]\n\n<!-- add SoundPad to settings if its not part yet -->\n[h:x=getLibProperty(\"padNameList\", \"lib:eventmacros\")]<br>\n[h,if(!listContains(x,\"SoundPad\")):setLibProperty(\"padNameList\", listAppend(x, \"SoundPad\"),\"lib:eventmacros\")]\n\n[h:'assert(startsWith(tok, \"SoundPad\"), \"Selected token name should start with 'SoundPad'\",0)']\n[h:isSoundPad\t= startsWith(tok, \"SoundPad\")]\n[h:switchToken(tok)]\n\n<!-- initialize variables -->\n[h:varsFromStrProp(\"\n\turi=http://webadres.to.file.mp3 OR file:/C:/folder/file.mp3;\n\tstartVolume=0;\n\tdistStart=30;\n\tmaxVolume=1;\n\tdistMaxVolume=1;\n\teffectArea=;\n\tflag=0;\n\tflagTriggered=0;\n\")]\n\n[h:settings\t\t= getProperty(\"w42.bot.soundSettings\")]\n[h:varsFromStrProp(settings)]\n\n[h:abort(input(\n\t\"junk|<html>\"+if(isSoundPad,\n\t\t\"<b>Note that this IS a SoundPad.<\/b><br>\",\n\t\t\"<b>Note that this is NOT a SoundPad.<\/b><br>\"\n\t)\n\t+\"<u>SoundPads<\/u> are triggered based on proximity of a token to it.<br>\"\n\t+\"<u>Other tokens<\/u> only play a sound when they're triggered by their event.<br>\"\n\t+\"<b>For example<\/b> a PadStart token (teleport) will play its linked sound when you move onto it,<br>\"\n\t+\"while a SoundPad token will play its linked sound when you move close (enough) to it.<br>\"\n\t+\"Hence the below settings will differ whether you've selected a SoundPad or not<br><br>\"\n\t+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\n\t\"uri|\"+uri+\"|Set URI/URL of the sound||WIDTH=40\",\n\t\"startVolume|\"+startVolume+\"|Set volume of sound at furthest distance (value between 0 and 1)||WIDTH=4\",\n\n\tif(!isSoundPad, \n\t\t\"flag|\"+flag+\"|Play sound only once (use flag)||WIDTH=4\",\n\t\t\"\"\n\t),\n\tif(!isSoundPad, \n\t\t\"flagTriggered|\"+flagTriggered+\"|(use flag:) 0=pad is active ; 1=pad is inactive||WIDTH=4\",\n\t\t\"\"\n\t),\n\n\t\"distStart|\"+distStart+\"| Set furthest distance at which sound is \"+if(isSoundPad,\"first\", \"still\")+\" heard||WIDTH=4\",\n\t\"maxVolume|\"+maxVolume+\"|Set volume of sound at closest distance (value between 0 and 1)||WIDTH=4\",\n\t\"distMaxVolume|\"+distMaxVolume+\"|Set distance at which sound is at max volume||WIDTH=4\",\n\n\tif(isSoundPad, \n\t\t\t\t\"junk|<html>\"\n\t\t+\"<b>Optional: area check!<\/b> You can draw an are on (e.g.) the hidden layer. In the draw explorer<br>\"\n\t\t+\"you can give this drawing a name (right mouseclick on drawing --> 'Set Name')<br>\"\n\t\t+\"here you can enter that given name (make sure there are no duplicate names!<br>\"\n\t\t+\"now an owned pc token must be AND near enough of the pad AND end its move on the drawing<br>\"\n\t\t+\"in this way you can contain the sound within an area. <br>\"\n\t\t+\"Please note that the related MT function is a bit buggy so it might not work with 1 cell wide areas.\"\n\t\t+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"\"\n\t),\n\t\n\tif(isSoundPad, \n\t\t\"effectArea|\"+effectArea+\"|Optionally: set the NAME of the area the token MUST be on||WIDTH=15\",\n\t\t\"\"\n\t)\n))]\n\n[h:settings\t\t\t= strPropFromVars(\"uri,startVolume,distStart,maxVolume,distMaxVolume,effectArea,flag,flagTriggered\",\"UNSUFFIXED\")]\n[h: setProperty(\"w42.bot.soundSettings\", settings)]\n\n[h: id\t\t\t\t= findDrawings(getCurrentMapName(),effectArea)] \n[h,if(id==\"\" && effectArea !=0):broadcast(\"<font color='red'><b>Settings have been saved. Do note however that the area <u>\"+ effectArea +\"<\/u> does not exist!!\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3ee190a2-e7ea-45fd-8650-1aa0b5dab62c",
          "commandChecksum": "83260b127d4046e1e26d0108a55c0c3e",
          "propsChecksum": "6a7d9c34e2b823c6084ba78a5ca3f4c7"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "81",
        "index": 560,
        "label": "Setup Sound",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_setupSound()]",
        "maxWidth": "",
        "tooltip": "Used to setup soundPad tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "08c8d340-7eee-4e82-92e9-37ad5e70c102",
          "commandChecksum": "930d8272df24a15def5ef1eb3eb35123",
          "propsChecksum": "5904d1075e34a704bb8c187bb163c6df"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "24",
        "index": 561,
        "label": "switchMap BCK",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- switchMap ([mapName[, players]]) ------------------------------------------------>']\n<!-- The argument players must be either a list of player names or 1 to select ALL players -->\n\n<!-- <html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.\n-->\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n\n[h:mapList\t\t= listSort(getAllMapNames(),\"N+\")]\n[h:comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t<!-- centre on me pad locations -->\n\n[h:locationList = \"\"]\n[h,foreach(location, comLocations,\"<br>\"), CODE:{\n\t[map\t\t\t= json.get(location, \"map\")]\n\t[spot\t\t\t= json.get(location, \"spot\")]\n\t[if(!listContains(mapList, map)), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[assert(0,\"error encountere, maplist needs to be updated, please run again\",0)]\n\t}]\n\t[locationList\t= listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:allPlayers\t= getAllPlayerNames()]\n\n[h,if(argCount() > 0): newMap\t= arg(0) ; newMap\t= oldMap]\n[h:assert(listFind(mapList, newMap) != -1, \"The map \"+arg(0)+\" does not exist\",0)]\n\n[h,if(argCount() > 1), CODE:{\n\t<!-- in case both arguments have been given, the input can be omitted and the players can be switched to the map -->\n\t[userList\t\t= arg(1)]\n\t[if(userList == 1): userList = getAllPlayerNames()]\n\n\t<!-- move players -->\n\t[playerList = \"\"]\n\n\t[FOREACH(player, userList), if(listContains(allPlayers, player)): playerList = listAppend(playerList, player) ; broadcast(\"The player: \"+player+\" does not exist!\")]\n\t[selCount\t\t= 0]\n''\n};{\n\t<!-- in case one or no arguments have been given, show the input and ask for map and players to switch map for -->\n\t<!-- make sure that at least the current map is part of the comLocation, if not rescan -->\n\t[if(listFind(locationList, oldMap) == -1), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t<!-- centre on me pad locations -->\n\t\t[locationList = \"\"]\n\t\t[foreach(location, comLocations,\"<br>\"), CODE:{\n\t\t\t[map = json.get(location, \"map\")]\n\t\t\t[spot = json.get(location, \"spot\")]\n\t\t\t[locationList = listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t[newMap\t\t= listFind(locationList, newMap)]\n\t[userList\t= allPlayers]\n\t[selected\t= getSelectedNames()]\n\t[selCount\t= listCount(selected)]\n\n\n\t<!-- input string -->\n\t[\t\t\t\t\t\t\tinputStr = \"junk|Force Selected Players to Map|-|LABEL|SPAN=TRUE\"]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"newMap|\"+locationList+\"|Select map|RADIO| SELECT=\"+newMap,\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"selCount|1|Move selected token(s)?|CHECK\",\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"junk|(\"+selected+\")<br> |-|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Select Players|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[FOREACH(player, userList):\tinputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Res-scan all maps for new locations<br>|When checked this macro will scan ALL maps looking for<br>tokens that are called <i>centrOnMePad Some Location Name<\/i><br>and adds <i>Some Location Name<\/i> to the above list of locations<br>when you choose that location the map will be centred around<br><i>that<\/i> pad. Obviously <i>Some Location Name<\/i> can be any<br>alphanumerical string you like!|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"rescan|0|Re-scan|CHECK\",\"@\")]\n\n\t<!-- ask for input-->\n\t[abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\t\n\t<!-- move players -->\n\t[playerList = \"\"]\n\t[FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t''\n\t}]\n''\n}]\n\n<!-- get new map and location -->\n[h:newLocation = json.get(comLocations, newMap)]\n[h:newMap = json.get(newLocation, \"map\")]\n[h:newLoc = json.get(newLocation, \"spot\")]\n[h:comPad = \"centreOnMePad\" + newLoc]\n\n<!-- move tokens (if any) -->\n[h:setCurrentMap(newMap)]\n[h,if(findToken(comPad)!=\"\"), CODE:{\n\t[X = getTokenX(0, comPad)]\n\t[Y = getTokenY(0, comPad)]\n};{\n\t[X = 0]\n\t[Y = 0]\n}]\n\n[h,if(rescan): bot_CoMScan()]\t\n\n[h, if(selCount == 1), CODE: {\n\t[h,FOREACH(tok, selected),if(oldMap != newMap): moveTokenFromMap(tok, oldMap, X+roll.count, Y)]\n\t[h,FOREACH(tok, selected),if(oldMap == newMap): moveToken(X+roll.count, Y, 0, tok)]\n\t[h:setCurrentMap(oldMap)]\n};{\n}]\n\n[h:setCurrentMap(oldMap)]\n\n[h:bot_execAllPlayers(\"gotoMap@lib:OnTokenMove\",json.append(\"[]\",newMap,newLoc), playerList)]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br>\n<br>\nIf you select tokens before you use this macro, then the option will be added to move<br>\nthe selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br>\nIf you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i><br>\nthen these will show up as location in this macro (after a 'rescan').<br>\n<br>\nIf there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "19a0c9ea-13dd-4d47-ae76-b44894722b1b",
          "commandChecksum": "5ac9dfeef293b0038a6ce7d699d79b02",
          "propsChecksum": "d3726e32236f839d4b64ff31eeb222e6"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "6",
        "index": 562,
        "label": "changeAdress",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ----------------------------- changeAdress --------------------------------->']\n\n[h:mapList\t\t\t= getAllMapNames(\"json\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:oldAddress\t\t= \"https://www.eyecom.nl/temp/\"]\n[h:newAddress\t\t= \"http://wolph42.ddns.net:4242/sounds/Bot_Inn/\"]\n\n[oldAddress\t\t\t= \"\"]\n[n\t\t\t\t\t= 0]\n[h,while(oldAddress == \"\"), CODE:{\n\t[currentMap\t\t= json.get(mapList, n)]\n\t[setCurrentMap(currentMap)]\n\n\t[tokList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t[foreach(padName, tokList), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t\t[var\t\t= getStrProp(getProperty(\"w42.bot.soundSettings\",padName),\"uri\")]  <!-- uri -->\n\t\t[id\t\t\t= strfind(var, \"(.*)\\\\/\")]\t\t\n\t\t[if(getFindCount(id)): oldAddress\t= getGroup(id,1,0)]\n\t}]\n\t[n = n + 1]\n\t[setCurrentMap(oldMap)]\n\t[assert(n < json.length(mapList), \"Aborting function as no SoundPads were found in campaign\",0)]\n}]\n\n[h:abort(input(\n\t\"oldAddress|\"+oldAddress+\"|Give old address to replace||WIDTH=40\", \n\t\"newAddress|\"+oldAddress+\"|Give new addres to use||WIDTH=40\"\n))]\n\n[H,foreach(currentMap,mapList), CODE:{\n\t[setCurrentMap(currentMap)]\n\t[tokList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t[foreach(padName, tokList), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t\t[var\t= getProperty(\"w42.bot.soundSettings\",padName))]  <!-- uri -->\n\t\t[nVar\t= replace(var, oldAddress, newAddress)]\n\t\t[setProperty(\"w42.bot.soundSettings\", nVar, padName)]\n\t}]\n}]\n\n[h:setCurrentMap(oldMap)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4b1ede26-ee9f-48e2-bca7-bcf57c71603f",
          "commandChecksum": "da524c6f34669294f4f1801ed6637866",
          "propsChecksum": "70314fdbf2791cfb9ec6ac3fcdeb6577"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "21",
        "index": 563,
        "label": "clearSound",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------ clearSound() ------------------------------>']\n\n[h:stopSound(\"*\", 1)]",
        "maxWidth": "",
        "tooltip": "Clears all buffered sounds (both played so far and the ones setup in setup_sound",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "440fa4ae-d7ae-47be-8e01-9d3b38092794",
          "commandChecksum": "5ea7c55d5d2374155257a62bf2a3b209",
          "propsChecksum": "37e73a001a34a5de9f7a5a02c4f8c5df"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "86",
        "index": 564,
        "label": "Message Mngr",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[macro(\"notes@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d00eecfa-856b-4b21-a1a4-e8f1a1325c63",
          "commandChecksum": "feb221bc6a453e452d039dc3cf47f852",
          "propsChecksum": "5530af463e3fef0439d9e924f4333fe3"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "85",
        "index": 565,
        "label": "Change Sound URI",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[macro(\"changeAdress@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "915b0ab9-fc11-487e-bb66-65a63de9568b",
          "commandChecksum": "02db3153f6110da915e495ba783e5ea6",
          "propsChecksum": "93ea386ec70f91803dfedb978324e228"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "85",
        "index": 566,
        "label": "Clear All Sound",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[macro(\"clearSound@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "This stop ALL sounds currently streaming/playing AND removes them from memory",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "900c7ba0-0ae1-44d2-89f7-f35119ac4973",
          "commandChecksum": "1579047e542db0fc989af11a32baaf8b",
          "propsChecksum": "5dd5d669b132a4a11947d075d987d6e7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "11",
        "index": 567,
        "label": "playPadSound",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!--------------------- bot_playPadSound (padName, tok) --------------------------->']\n\n<!-- \nThis function is called when an eventPad (e.g. PadStart) is triggered and a sound is linked to it\n-->\n[h:padName\t= arg(0)]\n[h:me\t\t= arg(1)]\n\n[h:settings\t\t= getProperty(\"w42.bot.soundSettings\", padName)]\n[h,if(settings != \"\"), CODE:{\n\t[varsFromStrProp(settings)]\t<!-- uri,startVolume,distStart,maxVolume,distMaxVolume -->\n\t[return(json.length(getOwners(\"json\", me)), \"\")]\n\n\t[if(flag): flagPlay = !flagTriggered; flagPlay = 1]\n\t[if(flagPlay), CODE:{\n\t\t[cond\t= json.set(\"{}\", \"range\", json.set(\"{}\", \"upto\", distStart, \"distancePerCell\", 1, \"token\",padName), \"pc\",1)]\n\t\t[toks\t= getTokenNames(\"json\", cond)]\n\t\t\n\t\t[foreach(tok,toks), CODE:{\n\t\t\t[ownerNames\t\t= getOwners(\"json\", tok)]\n\t\t\t[dist\t\t\t= getDistance(padName, 1, tok)]\n\t\t\t['pause(\"toks\", \"tok\", \"dist\", \"cond\",\"distStart\",\"distMaxVolume\",\"padName\", \"me\",\"ownerNames\")']\n\t\t\t[execFunction(\"playStream\", json.append(\n\t\t\t\t\"[]\", uri, \"1\",\tstartVolume + \n\t\t\t\t\t\t\t\t\tsquare(1 - \n\t\t\t\t\t\t\t\t\t\tmax(0,dist-distMaxVolume) /\n\t\t\t\t\t\t\t\t\t\tmax(0.1,distStart-distMaxVolume)\n\t\t\t\t\t\t\t\t\t) * \n\t\t\t\t\t\t\t\t\t(maxVolume-startVolume)\n\t\t\t\t), 0, ownerNames)\n\t\t\t]\n\t\t''\n\t\t}]\n\n\t\t[if(flag): flagTriggered = 1]\n\t\t[settings\t\t\t= strPropFromVars(\n\t\t\t\"uri,startVolume,distStart,maxVolume,distMaxVolume,effectArea,flag,flagTriggered\",\"UNSUFFIXED\"\n\t\t)]\n\t\t[setProperty(\"w42.bot.soundSettings\", settings, padName)]\n\t''\n\t};{}]\n''\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6fad182f-02c0-4638-9834-b4ce3aa81dee",
          "commandChecksum": "29bfc6cc05c5076e261c24a188d7e600",
          "propsChecksum": "52dd676cd2c29197a3aa41ba588e6da6"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "2",
        "index": 568,
        "label": "pickLanguage",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:Languages\t= getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n[h:players\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\", \"lib:eventMacros\")]\n\n[h,if(json.type(players)==\"UNKNOWN\"): players = \"{}\"]\n[h:player\t\t= getPlayerName()]\n[h:currLanguage\t= json.get(players, player+\"LAN\")]\n[h:currTok\t\t= json.get(players, player+\"TOK\")]\n[h:ownedToks\t= getOwnedNames(player)]\n\n[h:assert(listCount(ownedToks),\"Make sure there is at least one token on the map that you own!\",0)]\n\n[h,foreach(language,Languages): set(language,0)]\n[h,foreach(language,currLanguage): set(language,1)]\n\n[h:inpLanguages=\"\"]\n[h,foreach(language,languages):\n    inpLanguages = listAppend(inpLanguages,language+\"|\"+eval(language)+\"|\"+language+\"|CHECK\",\"##\")\n]\n\n\n[h:abort(input(\n\t\"junk|<html><b>Choose the languages that your character speaks:<br><\/html>|-|LABEL|SPAN=TRUE\",\n\tinpLanguages,\n\t\"junk|<html><b>Choose the Tokenname of the character you play:<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"ownedTok|\"+ownedToks+\"|Choose|LIST|VALUE=STRING SELECT=\"+listfind(ownedToks,currTok)\n))]\n\n[h:langList = \"\"]\n[h,foreach(language,languages):\n    langList = if(eval(language), listappend(langList, language),langList)\n]\n\n[h:setLibProperty(\"w42.bot.whisperPanel.playerChoices\", json.set(players, player+\"LAN\", langList, player+\"TOK\", ownedTok), \"lib:eventMacros\")]\n[broadcast(strformat(\"<b><font color='red'>%{player} has chosen the following languages to use in the whisper tool: %{langlist}\"),bot_selfgm())]",
        "maxWidth": "",
        "tooltip": "Choose the languages that you speak",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0b8e3d93-3c3f-4723-9acc-56e4c7344605",
          "commandChecksum": "fd625ab3ab574ac297a5dd6c525412a5",
          "propsChecksum": "e9923fa08223e3fc3a7cfdd531a81ca9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "10",
        "index": 569,
        "label": "whisperFrame",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------- WHISPERFRAME ----------------------------- -->']\n\n<!-- \n<html>This opens a frame where you can send formatted text to specific players.<br>\n<u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br>\nimpersonate the selected token, without actually needing to impersonate it.<br>\n<br>\n<b>Notes<\/b> <br>\n- you must either be the gm or own the selected token to do this.<br>\n- the impersonation ONLY works with <i>all players<\/i> check box <br>\n  selected. (So not when some or all the individual player checkboxes are<br>\n  selected!!)<\/html>\n -->\n[h:lastSettings\t\t\t= arg(0)]\n[h:'broadcast(\"hi\"+ lastSettings)']\n[h: keepItShort\t\t\t= 8]<!-- 0=turn off; else it sets the max length of both player and character name in the whisperbox-->\n[H: allPlayerNames\t\t= json.difference(getAllPlayerNames(\"json\"), json.fromList(getPlayerName())  )]\n\n[h: players\t\t\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\", \"lib:eventMacros\")]\n\n\n[h, if(json.type(players)!=\"OBJECT\"): \n\tLanguages\t\t\t= \"\"\n;\n\tLanguages\t\t\t= json.get(players, getPlayerName()+\"LAN\")\n]\n\n[h:check\t\t\t\t\t= getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\")]\n[h,if(json.type(check)==\"UNKNOWN\"): setLibProperty(\"w42.bot.whisperPanel.script\", \"{}\",\"lib:eventMacros\")]\n\n[h,foreach(language,Languages): set(language,0)]\n[H: count\t\t\t\t= 0]\n\n[h, if(json.type(lastSettings) != \"OBJECT\"), CODE: {\n\t[lastSettings\t= getLibProperty(\"w42.bot.whisperPanel.lastSettings\")]\n\n\t[if(json.type(lastSettings) == \"UNKNOWN\"): \n\t\tlastSettings\t= '{\"color\":\"Black\",\"bold\":\"0\",\"italic\":\"0\",\"underline\":\"0\",\"allPlayers\":\"0\",\"impersonate\":\"0\",\"currLanguage\":\"\"}'\n\t]\n};{}]\n\n[foreach(setting, lastSettings): set(setting, json.get(lastSettings, setting))]\n\n\n[frame(\"Whisper\", \"width=250; height=300\"): {\n\t<html><head><title>Whisper<\/title><\/head><body>\n\t<form name=\"Whisper\" method=\"json\" action='[R: macroLinkText(\"sendWhisper@this\",\"none\")]'>\n\n\t<!-- predefine checkboxes so they show up in the macro.args -->\n\t<input type=\"hidden\" name=\"italic\"\t\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"bold\"\t\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"underline\"\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"allPlayers\"\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"impersonate\"\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"currLanguage\"\tvalue=\"Common\"/>\n\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td colspan=5><small>([R: macroLink(\"<b>Refresh Player & Language List<\/b>\", \"whisperFrame@this\", \"none\")])<\/small><\/td><\/tr><tr>\n\t\t<td><b>Plyr  <\/b><\/td><td>Address<\/td><td>|Overhear|<\/td><td>Out Rnge  <\/td><td><b>Char<\/b><\/td><\/tr><tr>\n\t\t[r,foreach(player, allPlayerNames, \"<\/tr><tr>\"), CODE:{\n\t\t\t[h,if(json.contains(players, player+\"TOK\")): character\t= json.get(players, player+\"TOK\")) ; character = \"\"]\n\n\t\t\t[h,if(keepItShort): playerStr\t= substring(player, 0, min(length(player), keepItShort))\t\t; playerStr\t= player]\n\t\t\t[h,if(keepItShort): charStr\t\t= substring(character, 0, min(length(character), keepItShort))\t; charStr\t= character]\n\n\t\t\t[h:checked\t\t= json.get(lastSettings, player)]\n\t\t\t[h:checked\t\t= if(checked == \"\", \"Not\", checked)]\n\t\t\t<td>[r:playerStr]<\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Address\"\t\t[r:if(checked == \"Address\",\t\t\"CHECKED\", \"\")]><\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Overhear\"\t[r:if(checked == \"Overhear\",\t\"CHECKED\", \"\")]><\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Not\"\t\t\t[r:if(checked == \"Not\", \t\t\"CHECKED\", \"\")]><\/td>\n\t\t\t[r,if(character !=\"\"): '<td>'+charStr+'<\/td><td style=\"text-align:center\">']\n\t\t}]\n\t<\/tr><\/table>\n\t\t\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td><input type=\"checkbox\" name=\"allPlayers\"\tvalue=\"1\" [R: checked\t= if(allPlayers,\t\"CHECKED\", \"\")] ><\/td><td> Address All (no whisper)<\/td><\/tr><tr>\n\t\t<td><input type=\"checkbox\" name=\"impersonate\"\tvalue=\"1\" [R: checked\t= if(impersonate,\t\"CHECKED\", \"\")] ><\/td><td> Impersonate (selected token)<\/td>\n\t<\/tr><\/table>\n\t\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td><textarea name=\"whisperText\" cols=\"30\" rows=\"5\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table cellpadding=\"4\" cellspacing=\"0\">\n\t\t\n\t\t[r,if(listcount(Languages)), CODE:{\n\t\t\t<tr><td>Message Language: <\/td>\n\t\t\t<td><select name=\"currLanguage\">\n\t\t\t\t[r,foreach(language, Languages, \"\"):'\n\t\t\t\t\t<option value=\"'+language+'\"' + if(currLanguage == language,\" selected\",\t\" \") + '>'+language+'\t\t<\/option>\n\t\t\t\t']\n\t\t\t<\/select><\/td><\/tr>\n\t\t};{}]\n\t\t<\/tr><\/table>\n\t\t\n\t\t<table cellpadding=\"0\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td><select name='color'>\n\t\t\t\t<option value='black'\t[r:if(color == 'black',\t\t'selected',\t'')]>Black\t\t<\/option>\n\t\t\t\t<option value='gray'\t[r:if(color == 'gray',\t\t'selected',\t'')]>Gray\t\t<\/option>\n\t\t\t\t<option value='maroon'\t[r:if(color == 'maroon',\t'selected',\t'')]>Maroon\t\t<\/option>\t\n\t\t\t\t<option value='red'\t\t[r:if(color == 'red',\t\t'selected',\t'')]>Red\t\t<\/option>\n\t\t\t\t<option value='yellow'\t[r:if(color == 'yellow',\t'selected',\t'')]>Yellow\t\t<\/option>\n\t\t\t\t<option value='green'\t[r:if(color == 'green',\t\t'selected',\t'')]>Green\t\t<\/option>\n\t\t\t\t<option value='blue'\t[r:if(color == 'blue',\t\t'selected',\t'')]>Blue\t\t<\/option>\n\t\t\t\t<option value='navy'\t[r:if(color == 'navy',\t\t'selected',\t'')]>Dark Blue\t<\/option>\n\t\t\t\t<option value='purple'\t[r:if(color == 'purple',\t'selected',\t'')]>Purple\t\t<\/option>\n\t\t\t<\/select><\/td>\n\t\t\t<td><input type='checkbox' name='italic'\t\tvalue='1'\t[r:if(italic,\t\t'checked', '')]>\t<\/td><td><i>Italic<\/i>\t\t<\/input><\/td>\n\t\t\t\t<td><input type='checkbox' name='bold'\t\t\tvalue='1'\t[r:if(bold,\t\t\t'checked', '')]>\t<\/td><td><b>Bold<\/b>\t\t<\/input><\/td>\n\t\t\t\t<td><input type='checkbox' name='underline'\tvalue='1'\t[r:if(underline,\t'checked', '')]>\t<\/td><td><u>Underline<\/u>\t<\/input><\/td><\/tr>\n\t\t<\/font><\/table>\n\n\t\t<table cellpadding=\"4\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td align=\"center\"><input type='submit' value='Send Message' ><\/td>\n\t\t\t<td><\/td>\n\t\t\t<td align=\"center\"><input type='submit' value='Manual & Settings' ><\/td>\n\t\t<\/tr><\/table>\n\t\t\n\t<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "27a55656-56de-4116-a5bf-200130344042",
          "commandChecksum": "eb702fb30e4595f916a1180e484d8450",
          "propsChecksum": "117fad4d14a6655a38f4363f54e157b8"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "11",
        "index": 571,
        "label": "sendWhisper",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'broadcast(macro.args)']\n\n[h:'<!-- ---------------- SENDWHISPER ----------------------------- -->']\n\n[H: args\t\t\t\t= arg(0) ]\n\n[h: button\t\t\t\t= json.get(args, \"Whisper\")]\n[h,switch(button),code:\n\tcase \"Manual & Settings\": {\n\t  [macro(\"WhisperManual@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Pick Languages & Token\": {\n\t  [macro(\"pickLanguage@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Set Languages\": {\n\t  [macro(\"setLanguages@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Link Script to Language\": {\n\t  [macro(\"Language2Script@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\t\n\tdefault: {}\n]\n\n\n[h:setLibProperty(\"w42.bot.whisperPanel.lastSettings\", args,\"lib:EventMacros\")]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[H:allPlayerNames\t\t= json.difference(getAllPlayerNames(\"json\"), json.fromList(thisPlayer)  )]\n\n<!-- \"italic\":\"0\",\"bold\":\"0\",\"underline\":\"0\",\"allPlayers\":\"0\",\"impersonate\":\"0\",\"numPlayers\":\"1\",\"whisperText\":\"\",\"currLanguage\":\"Common\",\"color\":\"black\",\"Whisper\":\"Send\" -->\n[h,foreach(setting, args), CODE:{\n\t[val \t\t\t= json.get(args, setting)]\n\t[if(isNumber(val)): val = number(val)]\t\n\t[set(setting, val)]\n}]\n\n\n[h:italicOpen\t\t= if(italic,\t\"<i>\",\t\"\")]\n[h:italicClose\t\t= if(italic,\t\"<\/i>\",\t\"\")]\n[h:boldOpen\t\t= if(bold,\t\t\"<b>\",\t\"\")]\n[h:boldClose\t\t= if(bold,\t\t\"<\/b>\",\t\"\")]\n[h:underlineOpen\t= if(underline,\t\"<b>\",\t\"\")]\n[h:underlineClose\t= if(underline,\t\"<\/b>\",\t\"\")]\n[h:'<!-- {\"JanLAN\":\"Dwarves, Druidic\",\"JanTOK\":\"wEagle 10\",\"KeesLAN\":\"\",\"KeesTOK\":\"centreToken\",\"JoopLAN\":\"Dwarves, Elfish, Druidic, Ranger\"} -->']\n[h:playerSet\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\",\"lib:EventMacros\")]\n[h:hasSet\t\t\t= if(json.type(playerSet)==\"UNKNOWN\", 0, 1)]\n\n[h:\tscramWisperText\t= bot_scrambleText(whisperText, currLanguage) ]\n\n[h: whisperText\t\t= strformat(\"<font color=%{color}>%{italicOpen}%{boldOpen}%{underlineOpen}%{whisperText}%{underlineClose}%{boldClose}%{italicClose}<\/font>\")]\n[h: messageScram\t= strformat(\"<font color=%{color}>%{italicOpen}%{boldOpen}%{underlineOpen}%{scramWisperText}%{underlineClose}%{boldClose}%{italicClose}<\/font>\")]\n\n[h,if(impersonate), CODE:{\n\t[fromWho\t\t= getSelectedNames()]\n\t[if(!listCount(fromWho) && hasSet): fromWho = json.get(playerSet, thisPlayer+\"TOK\")]\t\t\t\t<!-- if impersonate is checked but no token selected: use the char of the players-->\n\t[assert(listCount(fromWho) == 1, \"ABORTED: make sure you have (only) one token selected\",0)]\n\t[assert(if(isGM() || isOwner(thisPlayer, fromWho),1,0),\"ABORTED: you do not own this token\",0)]\n};{\n\t[fromWho\t\t= thisPlayer]\n}]\n\n[h,if(allPlayers), CODE:{\n\t[foreach(player, allPlayerNames):args = json.set(args, player, \"Address\")]\t\t\t\t<!-- set type to address for all player in args-->\n};{}]\n\n[h:addressHeader\t= \"%{fromwho} addresses %{addressed} in %{currLanguage} this is overheared by %{overheared}\"]\n[h:overhearHeader\t= \"%{overheared} overhear %{fromwho} who addresses %{addressed} in %{currLanguage}\"]\n[h:addressed\t\t\t= \"\"]\n[h:overheared\t\t= \"\"]\n[h:nPlayers\t\t\t= 0]\n[h:count\t\t\t= 0]\n[h,foreach(player, allPlayerNames), CODE: {\n\t[type \t\t\t= json.get(args, player)]\t\t\t\t\t\t\t\t\t\t\t<!-- type = address, overhear or not -->\n\t[if(type != \"Not\"), CODE:{\n\t\t[nPlayers\t\t= nPlayers\t+ 1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t['<!-- playerset: {\"JohnLAN\":\"Dwarves, Druidic\",\"JohnTOK\":\"Tim the Enchanter\"} -->']\n\t\t[if(impersonate && hasSet): \n\t\t\tname = json.get(playerSet, player+\"TOK\")\n\t\t; \n\t\t\tname =  player)\n\t\t]\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<!-- if impersonated pick the char the player plays, else the player name -->\n\n\t\t[if(hasSet): \n\t\t\tlan\t\t= json.get(playerSet, player+\"LAN\"))\n\t\t;\n\t\t\tlan\t\t= \"\"\n\t\t]\t\t\t\t\t\t\t\t<!-- get the languages for the player -->\n\n\t\t\n\t\t[message\t= if(listContains(lan, currLanguage)||currLanguage==\"Common\", whisperText,messageScram)]\t\t<!-- set the message to that player, either scrambled or not -->\n\n\t\t[set(\"playerNAME\"+count, player)]\t\t\t\t\t\t\t\t\t\t\t<!-- set the name for the player ; for a var number-->\n\t\t[set(\"playerCHAR\"+count, name)]\t\t\t\t\t\t\t\t\t\t\t<!-- set the name USED in the header for the player ; for a var number-->\n\t\t[set(\"playerMESS\"+count, message)]\t\t\t\t\t\t\t\t\t\t<!-- set the message for the player ; for same var number-->\n\n\t\t[if(type == \"Address\"), CODE:{\n\t\t\t[addressed = listappend(addressed, name)]\t\t\t\t\t\t\t\t\t<!-- create list of whom is addressed -->\n\t\t\t[set(\"playerHEAD\"+count, addressHeader)]\t\t\t\t\t\t\t\t<!-- set the message header for the player ; for same var number-->\n\t\t\t[set(\"playerCOLR\"+count, \"black-white\")]\t\t\t\t\t\t\t\t<!-- set the message header color for the player ; for same var number-->\n\t\t''\n\t\t};{\t<!-- type = Overheared -->\n\t\t\t[overheared = listappend(overheared, name)]\t\t\t\t\t\t\t\t<!-- create list of whom heard the conversation -->\n\t\t\t[set(\"playerHEAD\"+count, overhearHeader)]\t\t\t\t\t\t\t<!-- set the message header for the player ; for same var number-->\n\t\t\t[set(\"playerCOLR\"+count, \"gray-white\")]\t\t\t\t\t\t\t\t<!-- set the message header color for the player ; for same var number-->\n\t\t''\n\t\t}]\n\t[count = count + 1]\n\t''\t\n\t};{''}] \n['pause(\"allPlayerNames\",\"player\",\"type\",\"playerNAME\"+count,\"nPlayers\",\"count\",\"addressed\",\"overheared\")']\n\n\n''\n}]\n\n<!-- -------------------------- OUTPUT --------------------------------- -->\n[h,if(overheared == \"\"):\t\t\toverheared = \"no one\"]\n[h,if(addressed == \"\"):\t\t\t\taddressed = \"no one\"]\n[h,if(currLanguage == \"Common\"):\tcurrLanguage = \"\" ; currLanguage = replace(\" in \" + currLanguage, \"_\", \" \")]\n[h:addressHeader\t= strformat(\"%{fromwho} addresses %{addressed}%{currLanguage}, this is overheared by %{overheared}\")]\n[h:overhearHeader\t= strformat(\"%{overheared} are overhearing %{fromwho}, who addresses %{addressed}%{currLanguage}\")]\n[h:tok\t\t\t\t= if(fromWho != thisPlayer, fromWho, \"\")]\n\n[count(nPlayers), CODE:{\n\t[name\t\t= eval(\"playerCHAR\"+roll.count)]\n\t[message\t= eval(\"playerMESS\"+roll.count)]\n\t[header\t\t= replace(strformat(eval(\"playerHEAD\"+roll.count)), name, \"you\")]\t<!-- replace the address with 'you' -->\n\t[header\t\t= replace(header,\",(?!.*?,)\",\" and \")]\t\t\t\t\t\t\t\t\t<!-- turn tim,tom,john into tim,tom and john | Thank you @Aliasmask!-->\n\t[color\t\t= eval(\"playerCOLR\"+roll.count)]\n\t[player\t\t= eval(\"playerNAME\"+roll.count)]\n\t[bot_message(message, header, color, player, tok, \"\", 1, \"100%\", 1)]\n\t['pause(\"fromWho\",\"addressed\",\"overheared\",\"addressHeader\",\"overhearHeader\",\"name\",\"message\",\"header\",\"player\")']\n}]\n\n[addressed\t\t= replace(addressed,\",(?!.*?,)\",\" and \")]\n[overheared\t\t= replace(overheared,\",(?!.*?,)\",\" and \")]\n[if(overheared == \"no one\" && addressed == \"no one\"): \n\theader\t\t= \"You are talking to yourself\"\n;\n\theader\t\t= \"You address %{addressed}%{currLanguage}, this is overheared by %{overheared}\"\n]\n\n[bot_message(whisperText, strformat(header), \"black-white\", thisPlayer, tok, \"\", 1, \"100%\", 1)]\t<!-- message to self -->\n\n<!-- -------------------------- STORE CHOICES IN WHISPERFRAME --------------------------------- -->\n[H: bot_whisperFrame(args)]\n\ntest text: Pick up the bloody phone!",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "61856332-9350-463d-be9d-a188ca44b7e1",
          "commandChecksum": "82688b015bb4a3e331575832872c9ef7",
          "propsChecksum": "59b27b49baa315153d9795f5f287c383"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "15",
        "index": 572,
        "label": "WhisperManual",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------- Manual ----------------------------- -->']\n\n[frame(\"Whisper frame explained\", \"width=250; height=300\"): {\n<html><head><title>Whisper frame explained<\/title><\/head><body>\n<form name=\"Whisper\" method=\"json\" action='[R: macroLinkText(\"sendWhisper@this\",\"none\")]'>\n\t<table cellpadding=\"0\" cellspacing=\"0\"><font size=\"150%\"><tr>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Pick Languages & Token\" ><\/td>\n\t\t[r,if(isGM()):'\n\t\t<td>            <\/td>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Set Languages\" ><\/td>\n\t\t<td>            <\/td>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Link Script to Language\" ><\/td>\n\t\t']\n\t<\/tr><\/table>\n\t\t\n\t<h3>Whisper Frame User Manual and Settings<\/h3>\n\t<h4><font color=red>What do the Buttons Do?<\/h4>\n\tI`ll start with the button(s) on the top. The GM has a <b>Set Languages<\/b> button where she\n\tcan enter a list of Languages used by the players. I would strongly advice against \n\tentering all languages of the game as that could potentiall make the tool hard to use.<br><br>\n\n\tThe other button the GM has is <b>Link Script to Language<\/b>, this button allows to replace\n\tnormal text to images of text, like elvish or dwarfish runes. The images are drawn from script\n\ttables that can be found in the maptool Tables panel. A gm can create his own set as long as it\n\tcomplies with the other tables (similar setup) and the table name starts with script_. <br><br>\n\t\t\n\tWhen the GM is done, the players can click on the <b>Pick Languages & Token<\/b> button and select the\n\tlanguages their Character speaks.<br>\n\tNext to that the player can choose the token that represents her character. This is used\n\twhen you address someone while <b>impersonated<\/b> and is used as the default for \n\t'impersonation' (more on this later).\n\t\n\t<h4><font color=red>How Does the Whisperframe work?<\/h4>\n\tI`ll go through the items from top  to bottom.<br><br>\n\t<b>REFRESH Player& Language List<\/b><br>\n\tWhen players log in or out or when you update your chosen languages you can click on Refresh\n\tto update the Whisperframe with these changes.<br><br>\n\n\t<b>WHO<\/b><br>\n\tHere you find a list of players who are connected to the server. Per player there are 3 options:<br>\n\t<u>Address:<\/u> you are directly speaking (addressing) that player<br>\n\t<u>Overhear:<\/u> you are NOT addressing that player, but they`re nearby and can hear you<br>\n\t<u>Out Range:<\/u> this player cannot hear anything you say. <br><br>\n\t\n\t<b>ADDRESS ALL<\/b><br>\n\tThis fully overrides the 'WHO' settings and addresses ALL players (or characters, depending on\n\tyour impersonation settings (see below).<br><br>\n\t\n\t<b>IMPERSONATE<\/b><br>\n\t<u>CHECKED<\/u> = In character. This means that you speak as the token that you have selected\n\tOR if you have no token selected you speak as your default character (which you picked in\n\tpick languages). You address the other players in their character names!<br>\n\t<u>UNCHECKED<\/u> = Out of character. This means that you speak as Player, using your player\n\tname and address the other players in their players names<br><br>\n\n\t<b>TEXTBOX<\/b><br>\n\tHere you enter the mesage you want to sent<br><br>\n\n\t<b>LANGUAGE<\/b><br>\n\tYou will onlly see this box if you actually picked one or more languages from the Settings-->\n\tPick Languages menu. When you choose  a language an other player (who you either address or can \n\thear you) does NOT speak, that player will het garbled text. Only players that speak the language\n\tyou chose (and are addressed by you or can hear the conversation) can read and understand the \n\tmessage. <br><br>\n\t\n\t<b>COLOR, BOLD, ITALIC, etc,<\/b><br>\n\tWith these you can format the text that you send.<br><br>\n\n\t<b>SEND<\/b><br>\n\tSend message.<br><br>\n\t\n\t\n\t\n\t\n<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1645238a-6f67-4a0b-bce8-ddb518a4b805",
          "commandChecksum": "0e833d8ee245a927ced78f94ad15a7cb",
          "propsChecksum": "b23ef191a4124780a38f5d66c1bab80a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "",
        "index": 574,
        "label": "textToScript",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:text\t\t\t= arg(0)]\n[h:script\t\t= arg(1)]\n\n[h:translated\t= \"\"]\n[h:lst\t\t\t= stringToList(text,\"\",\"@\")]\n\n[h,foreach(char, lst, \"\", \"@\"), CODE:{\n\t<!-- switch blows up with some characters, this prevents that excep the $ is still an issue -->\n\t[if(char==\"\\$\"): char=\" \"]\n\t[if(!listContains(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\", char)):char = \" \"]\n\t[switch(char):\n\t\tcase \"\":asset\t= \"   \";\n\t\tcase \" \":asset\t= \"   \";\n\t\tcase \"a\":asset\t= \"<img src='\"+tableImage(script,101)+\"'>\";\n\t\tcase \"b\":asset\t= \"<img src='\"+tableImage(script,102)+\"'>\";\n\t\tcase \"c\":asset\t= \"<img src='\"+tableImage(script,103)+\"'>\";\n\t\tcase \"d\":asset\t= \"<img src='\"+tableImage(script,104)+\"'>\";\n\t\tcase \"e\":asset\t= \"<img src='\"+tableImage(script,105)+\"'>\";\n\t\tcase \"f\":asset\t= \"<img src='\"+tableImage(script,106)+\"'>\";\n\t\tcase \"g\":asset\t= \"<img src='\"+tableImage(script,107)+\"'>\";\n\t\tcase \"h\":asset\t= \"<img src='\"+tableImage(script,108)+\"'>\";\n\t\tcase \"i\":asset\t= \"<img src='\"+tableImage(script,109)+\"'>\";\n\t\tcase \"j\":asset\t= \"<img src='\"+tableImage(script,110)+\"'>\";\n\t\tcase \"k\":asset\t= \"<img src='\"+tableImage(script,111)+\"'>\";\n\t\tcase \"l\":asset\t= \"<img src='\"+tableImage(script,112)+\"'>\";\n\t\tcase \"m\":asset\t= \"<img src='\"+tableImage(script,113)+\"'>\";\n\t\tcase \"n\":asset\t= \"<img src='\"+tableImage(script,114)+\"'>\";\n\t\tcase \"o\":asset\t= \"<img src='\"+tableImage(script,115)+\"'>\";\n\t\tcase \"p\":asset\t= \"<img src='\"+tableImage(script,116)+\"'>\";\n\t\tcase \"q\":asset\t= \"<img src='\"+tableImage(script,117)+\"'>\";\n\t\tcase \"r\":asset\t= \"<img src='\"+tableImage(script,118)+\"'>\";\n\t\tcase \"s\":asset\t= \"<img src='\"+tableImage(script,119)+\"'>\";\n\t\tcase \"t\":asset\t= \"<img src='\"+tableImage(script,120)+\"'>\";\n\t\tcase \"u\":asset\t= \"<img src='\"+tableImage(script,121)+\"'>\";\n\t\tcase \"v\":asset\t= \"<img src='\"+tableImage(script,122)+\"'>\";\n\t\tcase \"w\":asset\t= \"<img src='\"+tableImage(script,123)+\"'>\";\n\t\tcase \"x\":asset\t= \"<img src='\"+tableImage(script,124)+\"'>\";\n\t\tcase \"y\":asset\t= \"<img src='\"+tableImage(script,125)+\"'>\";\n\t\tcase \"z\":asset\t= \"<img src='\"+tableImage(script,126)+\"'>\";\n\t\tcase \"1\":asset\t= \"<img src='\"+tableImage(script,1)  +\"'>\";\n\t\tcase \"2\":asset\t= \"<img src='\"+tableImage(script,2)  +\"'>\";\n\t\tcase \"3\":asset\t= \"<img src='\"+tableImage(script,3)  +\"'>\";\n\t\tcase \"4\":asset\t= \"<img src='\"+tableImage(script,4)  +\"'>\";\n\t\tcase \"5\":asset\t= \"<img src='\"+tableImage(script,5)  +\"'>\";\n\t\tcase \"6\":asset\t= \"<img src='\"+tableImage(script,6)  +\"'>\";\n\t\tcase \"7\":asset\t= \"<img src='\"+tableImage(script,7)  +\"'>\";\n\t\tcase \"8\":asset\t= \"<img src='\"+tableImage(script,8)  +\"'>\";\n\t\tcase \"9\":asset\t= \"<img src='\"+tableImage(script,9)  +\"'>\";\n\t\tcase \"0\":asset\t= \"<img src='\"+tableImage(script,0)  +\"'>\";\n\t\tdefault:\tasset\t= \"\"\n\t]\n\t[translated\t= translated + asset]\n}]\n[h:macro.return = translated]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4bf6fe21-d742-44eb-b84e-c706c6ce2d5c",
          "commandChecksum": "217955151708a723433389af36aea521",
          "propsChecksum": "0919cd88b2df871757c3470f1405b9b8"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "1",
        "index": 575,
        "label": "setLanguages",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:assert(isGM(), \"GM Only, 0\")]\n[h:Languages = getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n\n[h:abort(input(\n\t\t\"junk|<html>Enter the list of Languages used in game seperated by comma ','.<br><b>Do NOT use any spaces ' '. Use underscore '_' instead. <\/b><br>Note that the 'Common' language is automatically added to the list and set as default.<br>So don't add that one here!<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"Languages|\"+Languages+\"|Languages||WIDTH=50\"\n))]\n[hasSpaces\t= 0]\n[h,foreach(lan, Languages): hasSpaces = max(hasSpaces, if(getFindCount(strfind(lan, \" \")), 1,0))]\n\n\n[h:assert(!hasSpaces, \"<b><font color='red'>RTFM dimwit: DO NOT USE SPACES in the language names, use _ instead, function aborted!!\",0)]\n[h,if(listCount(Languages) && !listContains(Languages, \"Common\") ): Languages = listappend(\"Common\", Languages)]\t\t<!-- add Common to the list if languages are set. Leave empty else -->\n[h:setLibProperty(\"w42.bot.whisperPanel.languages\", trim(Languages), \"lib:eventMacros\")]",
        "maxWidth": "",
        "tooltip": "Choose the languages that the players can speak",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3fcba275-95d0-44d1-9f1d-d0eef2a593e9",
          "commandChecksum": "85d0f05cc158a3ec144b0dada3bc6e75",
          "propsChecksum": "94dbd403581ef2e016da30dee77d3bfc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "65",
        "index": 576,
        "label": "scrambleText",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:text\t\t\t= arg(0)]\n[h:language\t\t= arg(1)]\n[h:script\t\t= json.get(getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\"), language)]\n[h:script\t\t= if(json.contains(json.get(getInfo(\"campaign\"),\"tables\"), script),  script, \"\")]\n\n[h:cText\t\t= \"\"]\n[h:l\t\t\t= length(text)]\n[h,for(i,l-1,0,-2):cText = cText + substring(text, i, i+1)]\n[h,for(i,l-2,1,-2):cText = cText + substring(text, i, i+1)]\n[h,if(script != \"\"): cText\t= bot_textToScript(cText, script)]\n\n[h:macro.return = cText]\n",
        "maxWidth": "",
        "tooltip": "Scramble Text",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52baddcb-8100-4c30-b685-d3fe6d57abf1",
          "commandChecksum": "2887294f2669908734810e1adfa12f75",
          "propsChecksum": "bef68f5770ba6623ec09ce32bbe348b6"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "3a",
        "index": 577,
        "label": "videoTutorials",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------------------------- videoTutorials () ------------------------------------------------>']\n\n<!-- create HTML string -->\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n<!-- create html -->\n[h:output\t=  strformat(\"%{styleHTML}<html><body><table class='btnformat'><tr><td class='btnformat'>\")]\n\n[h:output\t= output + \"\n\t<table  style='width:100%' ><tr>\t<td>\n\t\t<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><Back to the welcome screen<\/a><br>\n\t<\/td><td style='text-align:right'>\n\t\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'>Continue to choose features to install ><\/a><br>\n\t<\/td><\/tr>\n\t<\/table>\n\t\t\n\t<table style='font-family:verdana'><tr><td><\/td><\/tr>\n\t<tr style='color:#ffffff;background-color:#ff0000;text-align: center; height:70px;font-size:150%;'><td colspan=2><b>BAG OF TRICKS - VIDEO TUTORIALS<\/b><\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/i8L4XTEI7Sw'><b>Choose BoT features <\/b><\/a><\/td><td>When you install the BoT for the first time, this screen is the first one you get. Here a short vid on what to choose!<\/td><\/tr>\n\t<tr><td><\/td><\/tr>\n\t<tr style='text-indent: 0px;background-color:#cccccc'><td><a href='http://bit.ly/RP6hYA'><b>Full Overview<\/b><\/a><\/td><td>Shows most functionalities of the bag of tricks, it deals with roughly 75% of the features.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://youtu.be/wVIzObJtK4c?t=1'>\t\t\t\t\t\t0:00<\/a><\/td><td>\tSettings<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=1841s'>\t30:41<\/a><\/td><td>\tALL the different teleport pads explained<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=3720s'>\t1:02:00<\/a><\/td><td>Special areas (e.g. difficult terrain)<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=4545s'>\t1:15:45<\/a><\/td><td>(Animated) doors<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=5340s'>\t1:29:00<\/a><\/td><td>Animated token movement<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=5610s'>\t1:33:30<\/a><\/td><td>Most of the utility functions (e.g. switch map, show handout, etc.)<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td colspan=2><b><i>Note: <\/b>The BoT is under constant construction and new stuff is added or old stuff updated on a regular basis. This makes the tutorials somewhat outdated over time. When I've created a newer version I remove the time slot in the above list, so not all start times are automatically end times of the previous topic!<\/i><\/td><\/tr>\n\t<tr><td><br><\/td><\/tr>\n\t<tr style='text-indent: 0px;background-color:#cccccc'><td><a href='http://bit.ly/1f5wn6X'><b>Interactive Pads<\/b><\/a><\/td><td> Shows how to setup Roofs, Canopy, Foliage & Bridges including VBL swapping for houses, make them change or dissapear when you move over them.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=0s'>\t\t0:00<\/a><\/td><td>\tQuick Install of the Bag of Tricks<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=150s'>\t2:30<\/a><\/td><td>\tRoofs<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=240s'>\t4:00<\/a><\/td><td>\tCanopy & Foliage<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=420s'>\t7:00<\/a><\/td><td>\tLinked Pads<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=660s'>\t11:00<\/a><\/td><td>\tBridges<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=890s'>\t14:50<\/a><\/td><td>\tSwapping Vision Blocking Layers (VBL) between house & roof and forcing movement through door.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td colspan=2><b><i>Note: <\/b>I've added 'Tunnels' in a later BoT version (and thus not in this video) which work opposite from bridges but are installed in the same way. Read the manual for more info.<\/i><\/td><\/tr>\n\t<tr><td><br><\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/fs7WdCQwi-Y'><b>Animated View<\/b><\/a><\/td><td>Shows how to set up an animation to introduce your new map to the players by showing them a pan and zoom view of that map.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/pzMHfc'><b>Build Forest<\/b><\/a><\/td><td>Shows you how to build an entire forest with a few clicks. This is a rather old tutorial, but it still works the same. The extra feature that has been added since is that its now also possible to automatically add VBL to all the tree trunks in the forest.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/YEhS4a'><b>Event Areas <\/b><\/a><\/td><td>Shows how to set up areas that limit movement and spring traps when moving over them. <\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1iYQkA3'><b>Fleeing Crowd<\/b><\/a><\/td><td>Shows you how to quickly fill a (town) square with folk and then letting them flee as a dragon lands in the middle of them.<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/iXV32ruh9ro'><b>Invisibility<\/b><\/a><\/td><td>Shows how to make tokens invisible for players, and how to use spells to 'see invisibility' or 'purge' it or 'dispell' it when tokens get in range.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1rhqlce'><b>Map Editor<\/b><\/a><\/td><td>One of my more nifty BoT inventions. It shows how to quickly create a map filled with different tokens.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1e536cg'><b>ShadowPads<\/b><\/a><\/td><td>Shows how to set up multi level building where you can 'watch' tokens move on the ground floor map from the first floor map (and vice versa).<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/PLYdqQzEcrA'><b>SoundPads<\/b><\/a><\/td><td>Shows how to setup and use the SoundPads. Tokens that stream sound to the client at a volume that is dependent on the distance of the player token to the soundpad.<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/1aZ-4Ip9RvI'><b>Switch Maps<\/b><\/a><\/td><td>Shows how to setup and use CentreOnMePads in combination with the upgraded Switch Map macro. Which automatically teleports selected tokens AND forces all players consoles to the new map.<\/td><\/tr>\n\t<tr><td><a href='https://www.youtube.com/watch?v=HLaby6Fblpo'><b>Whisperframe<\/b><\/a><\/td><td>Shows how to setup and use the updated whisperframe, you can now speak in e.g. elfish and players who don't speak that language cannot understand what you say.<\/td><\/tr>\n\t\n\t<tr><td colspan=2><br><br><a href='https://www.youtube.com/user/TheWolph42/videos'><b>The entire BoT tutorial channel<\/b><\/a>\n\t<\/td><\/tr><\/table>\n<br>\n\t<table  style='width:100%' ><tr>\t<td>\n\t\t<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><Back to the welcome screen<\/a><br>\n\t<\/td><td style='text-align:right'>\n\t\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'>Continue to choose features to install ><\/a><br>\n\t<\/td><\/tr>\n\t<\/table>\n\n\"]\n[h:output\t= strformat(\"%{output}<\/td class='btnformat'><\/tr><\/table><br><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame5(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0e87ca57-f5ae-4160-bab9-08e1d468e937",
          "commandChecksum": "3d5aacdc40d2575934e7df7d3bf032bd",
          "propsChecksum": "74ebfaf7a4a115517ea5571bcae4511a"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "31",
        "index": 579,
        "label": "isOnDrawing",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!------------------ isOnDrawing(lastPath, areaName) ------------------------------>']\n\n[h: lp\t\t\t\t= arg(0)]\n[h: area\t\t\t= arg(1)]\n[h: id\t\t\t\t= findDrawings(getCurrentMapName(),area)] \n[h:\tmd\t\t\t\t= \"[]\"]\n[h, if(id !=\"\"): \n\tmd\t\t\t\t= movedOverDrawing(getCurrentMapName(),id,lp)\n; \n\tbroadcast(area+\" does not exist\")\n]\n\n[h, if(json.length(md)):lpmd\t= replace(json.get(md, -1, -1), \"([x|y])2\", \"\\$1\");return(0,0)]\n[h: lplp\t\t\t= json.get(lp, -1, -1)]\n[h: macro.return\t= json.equals(lplp,lpmd)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "78f741be-d19d-452c-96dc-559a82cb7f32",
          "commandChecksum": "4db1fea7945a9e638b6cf8257a7b0024",
          "propsChecksum": "06c93d2b13c6c8837ca76711f6f441a1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20: Table Creator",
        "includeLabel": false,
        "sortBy": "10",
        "index": 580,
        "label": "xls2Table",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------- xls2Table ----------------------------- -->']\n\n<!-- \n<html>This opens a frame where you can \n -->\n\n\n[frame(\"xls2Tbl\", \"width=270; height=550; temporary=1\"): {\n\t<html><head><title>EXCEL TO MT TABLE<\/title><\/head><body>\n\t<form name=\"x2t\" method=\"json\" action='[R: macroLinkText(\"processX2T@this\",\"all\")]'>\n\n\t<b>Paste List here (straight from excel):<\/b>\n\tThis creates a MAPTOOL table. If a table with the same name exists this will overwrite the ENTIRE table!\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<tr><td><b>Name of Table<\/b><\/td><\/tr>\n\t\t<td><textarea name=\"tblName\" cols=\"30\" rows=\"1\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<tr><td><b>Content of Table<\/b><\/td><\/tr>\n\t\t<td><textarea name=\"tblContent\" cols=\"30\" rows=\"20\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table cellpadding=\"4\" cellspacing=\"0\">\n\t\t\n\t\t<table cellpadding=\"4\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td align=\"center\"><input type='submit' value='Build Table' ><\/td>\n\t\t\t<td><\/td>\n\t\t<\/tr><\/table>\n\t\t\n\t<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send ",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad3241ad-6e63-438d-8c64-1db3bb026060",
          "commandChecksum": "3e4e29360182ea4db392488f2fba35af",
          "propsChecksum": "237f10e763ad28561d1d3890ed6e41e9"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "20: Table Creator",
        "includeLabel": false,
        "sortBy": "11",
        "index": 581,
        "label": "processX2T",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'<!-- ---------------- processX2T ----------------------------- -->']\n[h:'broadcast(macro.args)']\n\n[h:tblName\t\t= json.get(macro.args, \"tblName\")]\n[h:tblContent\t= json.get(macro.args, \"tblContent\")]\n[h:content\t\t= encode(tblContent)]\n\n[h:tab\t\t\t= \"%09\"]\n[h:nl\t\t\t= \"%0A\"]\n\n<!-- will overwrite existing table!! -->\n[h:createTable(tblName,1,1)]\n\n[h,foreach(line, content, \"<br>\", \"%0A\"), CODE:{\n\t[r\t\t= roll.count]\n\t[n\t\t= listCount(line, \"%09\")]\n\t[if(n), CODE:{ <!-- ignore empty lines -->\n\t\t[assert(n>1, \"too few entries (tabs) in the following line: \"+line,0)]\n\t\t\n\t\t[i1\t\t= listGet(line, 0, \"%09\")]\t\t\t<!-- first entry should be number if not use roll.count -->\n\t\t[i1\t\t= if(isNumber(i1),i1,roll.count)]\t\n\t\n\t\t[if(n>2), CODE:{\t\t\t\t\t\t\t<!-- if there are 3 entries assum start-end-value -->\n\t\t\t[i2\t\t= listGet(line, 1, \"%09\")]\t\t<!-- check if 2nd entry is number else use i1 -->\n\t\t\t[i2\t\t= if(isNumber(i2),i2,i1)]\n\t\t\t[val\t= decode(listGet(line, 2, \"%09\"))]\t<!-- assume 3rd entry to be the value -->\n\t\t''\n\t\t};{\n\t\t\t[i2\t\t= i1)]\t\t\t\t\t\t\t<!-- if only 2 entriess use same value for start end  -->\n\t\t\t[val\t= decode(listGet(line, 1, \"%09\"))]\t\t<!-- assume last entry to be the value -->\n\t\t''\n\t\t}]\n\t\t\n\t\t[addTableEntry(tblName, i1, i2, val)]\n\t''\n\t}]\n''\n}]\n\n<i>[r:tblName]<\/i> created with <b>[r:r+1]<\/b> entries!",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "20547d78-6582-4ec1-bdb1-3d23b220132e",
          "commandChecksum": "a56a0dbeae15cbb4078597d49105a682",
          "propsChecksum": "1fe62950556c215af295d8065b106dc5"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "z. Version",
        "includeLabel": false,
        "sortBy": "9",
        "index": 582,
        "label": "Token Version 48",
        "fontSize": "1.00em",
        "minWidth": "190",
        "playerEditable": false,
        "command": "[h:libversion = \"48\"]\n[h:setLibProperty(\"libversion\", libversion, \"lib:OnTokenMove\")]\n[h:setLibProperty(\"libversion\", libversion, \"lib:EventMacros\")]\n\n[h:credits = \"<b>Credits<\/b><br>\nThe Bag of Tricks is created by Wolph42. For any questions, remarks or requests, simply post in the <font color='blue'><a href='https://forums.rptools.net/viewtopic.php?f=46&t=28409&p=274496#p274496'>BoT Thread<\/a><\/font> on the rptools forum.<br><br>\nA couple of macros were based on the code of others, here an overview of who the original creators are and my improvements to their code:\n<table>\n\t<tr><td><b><u>What<\/b><\/u><\/td><td><b><u>Who<\/b><\/u><\/td><td><b><u>Improvements<\/u<\/b><\/td><\/tr>\n\t<tr><td>SoundPads<\/td><td>Blackwing<\/td><td>Rewrote the code so it fits in the BoT, optimized code and added additional sound check after map switch (works with both teleports as well as switchmap)<\/td><\/tr>\n\t<tr><td>Dicebox<\/td><td>Rumble<\/td><td>rewrote most of the code, redid the dice images, added d5 die and the options tab<\/td><\/tr>\n\t<tr><td>Disguise macro<\/td><td>Aliasmaks<\/td><td>added the option so you can also create a disguise list by selecting image:tokens together with the disguise token<\/td><\/tr>\n\t<tr><td>Whisper frame<\/td><td>LMarkus<\/td><td>completely rewrote it, biggest change: rpg language support. The idea from the script signs additions came from Takehara<\/td><\/tr>\n\t<tr><td>Delete Macros<\/td><td>Rumble<\/td><td>added copy/paste function and an 'all macros' panel where you can meta select all macros or groups of macros.<\/td><\/tr>\n\t<tr><td>Message Manager<\/td><td>Plothos<\/td><td>added text formatting and images (select a token and then use 'add selected image').<\/td><\/tr>\n\t<tr><td>Input String Builder<\/td><td>Bubblobill<\/td><td>no addition!.<\/td><\/tr>\n\t<tr><td>Fancy Frames<\/td><td>Nildik<\/td><td>Added 'Frame Overview' function!. Fixed titles of incompatible frames<\/td><\/tr>\n\t<tr><td>Room Description Tokens<\/td><td>Nildik<\/td><td>Added option to force share immediately to players screen<\/td><\/tr>\n<\/table>\n\n\"]\n\n[h:output = credits + \"<br>\n<b>Version 48<\/b><br>\n<b>New Features<\/b>\n- possibility to create MT tables by copy pasting from excel<br>\n- update to soundPads: \n + added flag to eventPad triggered soundpad so you can set it to only play once.<br>\n + added sounddistance to the other tokens for the sound triggerpath as well<br>\n + To all the teleports and eventpads you can now also link a sound that plays when the pad is activated.<br>\n - Added video tutorials to splashscreen<br>\n- Added script signs to whisper frame, thanks to Takehara.<br>\n\n<b>bugfixes<br><\/b>\n- bugfix in whisperframe.<br>\n- Bug fixes soundPad, turned off new scope in teleport and mapteleport functions (so lastpath is passed on)<br>\n- Bug fixes in animate door<br>\n\n\n<b>Version 47<\/b><br>\nNew Feature\nAdded soundpads as originally designed by Blackwing. <br>\n- bugfix in switch map<br>\n- bugfix in switch map<br>\n- removed debug code from seektoken<br>\n- added hilltopVBL function to libeventmacro<br>\n- added bot_owner() and bot_nowner() functions to the BoT<br>\n- bug fix in embarkation<br>\n- bug fix in onmultipletokensmove icw a post move trigger macro<br>\n\n<b>Version 46<\/b><br>\nNew Features<br>\n- REMOVED TOKEN VBL FROM DOORS. Exchanged it for 'crack open door'. You can keep moving it further open if you want. For VBL you will have to use token vbl itself.<br>\n- Complete do over of the invisibility macros. <br>\n-- Players no longer 'own' the token if the can see a visible token. <br>\n-- added VBL check so you cant see an invisible token through a wall. <br>\n-- Also you can now set elevation for a token. The invisibility macros keep track of this when checking for range. <br>\n-- New macros buttons have been added to the bot panel and campaign panel.<br>\nFixes<br>\n- fixed Nildiks frame overview<br>\n- fixed assertion error (and added one) in crowd function<br>\n- added check in link animate view and clear assertion (order numbering mistake) <br>\n- fixed issue where moving of teleportsborder would execute another teleport.<br>\n- added invisibility use check to diagnose (breaks when turned on but states not defined.<br>\n- fixed several bugs in whisperframe and added 'keepitshort' var to whisperframe where you can set the max length of both player and character name as it shows up in the panel. this keeps things a bit more compact<br>\n- moved the linked triggermacros in ontokenmove a bit around so they are in context of ontokenmove.<br>\n- made whisperframe more compact, saving screen estate.<br>\n- got notebook and manual running again.<br>\n<br>\n<b>Version 45<\/b><br>\nNew Features:<br>\n- Full overhaul of the whisperframe. It now supports languages, meaning you can send messages and only those who speak the language can understand the message. (that and other stuff)<br>\n- Added changeElevation and getRangedDistance macros. Further worked required to integrate,but they work. Elevation is now taken into account when using the invisibility functions.<br>\nFIXES:<br>\n- fixed bug in ontokenmove with linked eventtriggers (these are created in lib:eventmacros and linked in the settings to the ontokenmove event)<br>\n- Also changed the naming for better understanding and added clarifying texts.<br>\n- fixed issue with resizing roofs when using the transparent roof option<br>\n- updated invisibility, need to check if it works. <br>\n- fixed macro buttons layout (removed the padding) <br>\n- fixed dicetool issue, but expect a LOT more issues due to newly introduced 'bug' in MT <br>\n- fixed switchmap issue I think 3x over<br>\n- removed <v40 history from this macro <br>\n- fixed idiot mistake in broadcast OCL (started manual when connecting to server) <br>\n- fixed division by zero bug in crowd control <br>\n- fixed all http links in the BoT (broken due to new topic or dropbox screwing things over) <br>\n- added additional argument to 'seekToken()' function to force json output<br>\n<br>\n<b>Version 44<\/b><br>\nNew Features:<br>\n- when you load the campaign youll see a blue button in the chat with the manual<br>\n- its now possible to add a piece of text after the 'centreOnMePad' tokens e.g. 'centrOnMePad First Floor' AND have multiple 'centreOnMePad' tokens like this on one map. When you use the 'switchmap' macro these location will show up and the map will centre on the location chosen!<br>\nFIXES:<br>\n- Shadowpad tokens are now one size smaller than the original token (unless they're freesize or fine size).<br>\n- Added fix to 'set reference' macro for shadowpads. It cleans previous settings from the pads, should they reside there. Can also be used to fix a broken shadowpad.<br>\n- Fixed wrong referencetoken calculation for shadowpads and other stuff wrong with shadowpads<br>\n- Fixed door VBL compatibility for later versions of MT.<br>\n- Fixed issue with Nildiks room descriptor.<br>\n- applied Derfs' fix for door lever proximity<br>\n- fixed feet when moving through vbl<br>\n- Added overview of turned on Toggles (in the BoT settings) during OCL (on request of bobifle).<br>\n- Renamed 'titlelink' tag in Nildiks room description to 'title' tag.<br>\n- Made 'title' tag generic (as in its fully optional, resets after use and can be placed for any of the Nildiks special tags.<br>\n- Updated the descriptor help and added a 'copy paste' section where the links can easily be grabbed.<br>\n- Added Room Descriptor Help button to menu.<br>\nTABLE UPDATE REQUIRED: tbl_Image <br>\n- Implemented Nildiks room descriptor update (titlelink and infolink).<br>\n- Fixed stupid mistake in summonToken macro created while working on Embarkation.<br>\n- Fixed error report when setting door animation to 0.<br>\n- Fixed hard coded invisibility states.<br>\n<b>Version 43<\/b><br>\nNew Feature: added Embarkation of tokens into vehicles or containers which you can then use to move the tokens around. <br><br>\n- fixed bug in limit movement.<br>\n- fixed bug in delete properties.<br>\n- fixed bug in disguise button.<br>\n- added 'cycle disguise' macro, not added to the enchilada\n- added bot_message() width parameter also to header text on suggestion of full bleed.<br>\n- added additional parameter to bot_message() to allow you to set the width of the table. <br>\n- updates to the function manual. <br>\n- added bot_getTokCDistance() including manual entry. Function calculates distance between the corners of two tokens, returns distance in either cells, pixels or dpc<br>\n- added back link to the introduction window<br>\n- fixed error message on clean install<br>\n<b>Version 42<\/b><br>\nAdded Vew Area Animation. Three functions to create an 'animated overflight scene' for your players. On a new map you can run a macro and then all the views of the players are moved over the map while zooming in or out. The animation is based on the lastpath of a token. The macros are:<br>\n- Set View Animation: turn the last path of a token into a view area animation\n- Link View Animations: link the animations of several tokens into one big animation\n- Run View Animation: select the token where the animation is stored and run this macro to show the animation on ALL clients. \nExanded the invisibility functions. All available macros and corresponding functions now are:<br>\nStart Invisibility\t      bot_startInvisibility()\t\t<br> \nEnd Invisibility  \t      bot_endInvisibility()    \t<br>\nSee Invisibility  \t      bot_seeInvisibility()     \t<br>\nSaw Invisibility  \t      bot_sawInvisibility()     \t<br>\nPurge Invisibility\t      bot_purgeInvisibility()   \t<br>\nPurged Invisibilit\t      bot_purgedInvisibilityy() \t<br>\nAnul Invisibility \t      bot_anulInvisibility()    \t<br>\nAnnuled Invisibili\t      bot_annuledInvisibility()\t<br>\nbot_checkInvisibility()<br>\nSee manual for more info concerning these macros. <br>\nAdded these functions to the BoT Virtual Macro Panel. And fixed the original invisibility buttons on the campaign panel<br>\nOther stuff:<br>\nFixed FU in bot_getTokenFacing()<br>\n<b>Version 41<\/b><br>\nNew Feature: This new version contains a full set of macro to make use of invisibility and invisibility purge. It works with onTokenMove and checks for purgin when a token moves. See the manual for more info. <br>\nOther stuff<br>\n- Updated manual for bot_getTokenFacing() and bot_setTokenFacing(), the descriptions were erroneous (the functions remain unchanged).<br>\n- added Jamz purple feet (invisible tokens) .<br>\n- setDoor can now be used when multiple doors are selected. ALL doors will be set according the given settings.<br>\n- fixed handout text issue.<br>\n- Experiment with follow me tokens (maybe for future follow me random dungeon).<br>\n- Added size options to polymorph/disguise macro. And fixed a bug in there as well.<br>\n- updated clean token names (search and replace characters. Added semicolon and open character.<br>\n- set 'allow players to edit macro' back to false for 177 macros<br>\n- updated installation instructions<br>\n- fixed settigns bug in 40b<br>\n- fixed vbl check OCL for MT 1.4+ <br>\n- tbl check in manual <br>\n<b>Version 40<\/b><br>\nOn request added a 'BoT features' options list. This will pop up on first install and you can choose which features are available and which not. It additionally shows an entire overview of all features and the required dependencies needed to use certain features. To accomplish this.<br>\nThe other stuff changed:<br>\n- Complete overhaul of the virtual menus, faster now and more versatile. <br>\n- The optional features now influence the virtual menu. <br>\n- Diagnose is now updated with the foptional features  as well. <br>\n- Settings has been updated with the optional features<br>\n- upgraded bot_showHTML to better format the html output. <br>\n- removed 'player editable' from 179 macros on ontokenmove to prevent A LOT of debugging headache...<br>\n- Reorganised all macro groups. <br>\n- Fixed small FU in onselect frame. <br>\n\n\"]\n[r:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2f6fe9a4-c8e7-4f90-bd3d-ec717c89254d",
          "commandChecksum": "1d488cd1ec6c04984f4c55109548b3e9",
          "propsChecksum": "53d6f246d5faff8fd80233ef62319758"
        }
      }
    ]
  }}
}
