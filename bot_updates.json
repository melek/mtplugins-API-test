{
  "Lib:EventMacros": {"47e":   {
    "mtversion": "1.8.5",
    "timestamp": "2021-05-06T10:05:04.8523086-07:00",
    "notes": "",
    "gmnotes": "",
    "properties":     {
      "-----------------": "",
      "------------------": "",
      "-------------------": "",
      "---------------|ALT INIT|-------------------": "",
      "---------------|ANIMATED VIEW AREA|-------------------": "",
      "---------------|AREAS |-------------------": "",
      "---------------|COPY PASTE DELETE MACROS|-------------------": "",
      "---------------|CROWD|-------------------": "",
      "---------------|DICE BOX|-------------------": "",
      "---------------|FEATURE GROUPS INSTALLED|-------------------": "",
      "---------------|HIDDEN SETTINGS|-------------------": "",
      "---------------|HOVER|-------------------": "",
      "---------------|MAP EDITOR|-------------------": "",
      "---------------|MASS VBL|-------------------": "",
      "---------------|SEEK TOKENS|-------------------": "",
      "---------------|SETTINGS|-------------------": "",
      "---------------|SYSTEM|-------------------": "",
      "---------------|TABLES|-------------------": "",
      "---------------|TEXT ANIMATION|-------------------": "",
      "---------------|THE PADS|-------------------": "",
      "---------------|TIMER FUNCTIONS|-------------------": "",
      "---------------|TREE TRUNKS|-------------------": "",
      "---------------|Whisperframe|-------------------": "",
      "---------------|languages|-------------------": "",
      "-------|drawing|---------": "",
      "____Library_Basic_Data____": "",
      "____Library_Meta_Data____": "",
      "abortProcess": 1,
      "allCoordsArray": "",
      "allMapsPads":       {
        "Forest new": "Canopy Canopy 1, Canopy Canopy 2, Canopy Canopy 3, Canopy Canopy 4, Canopy Canopy 5, Canopy Canopy 6, Canopy Canopy 7, Canopy Canopy 8, Canopy Canopy 14, Canopy Canopy 15, Canopy Canopy 46, Canopy Canopy 63, Canopy Canopy 68, Canopy Canopy 106, Canopy Canopy 126, Canopy Canopy 139, Canopy Canopy 147, Canopy Canopy 151, Canopy Canopy 156, Canopy Canopy 160, Canopy Canopy 165, Canopy Canopy 166, Canopy Canopy 172, Canopy Canopy 174, Canopy Canopy 176, Canopy Canopy 179, Canopy Canopy 183, Canopy Canopy 195, Canopy Canopy 204, Canopy Canopy 210, Canopy Canopy 213, Canopy Canopy 223, Canopy Canopy 245, Canopy Canopy 247, Canopy Canopy 260, Canopy Canopy 266, Canopy Canopy 268, Canopy Canopy 274, Canopy Canopy 295, Canopy Canopy 297, Canopy Canopy 298, Canopy Canopy 300, Canopy Canopy 308, Canopy Canopy 337, Canopy Canopy 345, Canopy Canopy 364, Canopy Canopy 365, Canopy Canopy 366, Canopy Canopy 372, Canopy Canopy 376, Canopy Canopy 378, Canopy Canopy 379, Canopy Canopy 390, Canopy Canopy 393, Canopy Canopy 397, Canopy Canopy 399, Canopy Canopy 403, Canopy Canopy 406, Canopy Canopy 429, Canopy Canopy 430, Canopy Canopy 442, Canopy Canopy 453, Canopy Canopy 467, Canopy Canopy 476, Canopy Canopy 479, Canopy Canopy 483, Canopy Canopy 484, Canopy Canopy 495, Canopy Canopy 505, Canopy Canopy 506, Canopy Canopy 507, Canopy Canopy 516, Canopy Canopy 521, Canopy Canopy 532, Canopy Canopy 536, Canopy Canopy 543, Canopy Canopy 558, Canopy Canopy 568, Canopy Canopy 577, Canopy Canopy 580, Canopy Canopy 594, Canopy Canopy 604, Canopy Canopy 613, Canopy Canopy 624, Canopy Canopy 627, Canopy Canopy 662, Canopy Canopy 663, Canopy Canopy 672, Canopy Canopy 674, Canopy Canopy 683, Canopy Canopy 684, Canopy Canopy 685, Canopy Canopy 692, Canopy Canopy 720, Canopy Canopy 724, Canopy Canopy 730, Canopy Canopy 735, Canopy Canopy 737, Canopy Canopy 741, Canopy Canopy 769, Canopy Canopy 776, Canopy Canopy 806, Canopy Canopy 807, Canopy Canopy 828, Canopy Canopy 845, Canopy Canopy 846, Canopy Canopy 850, Canopy Canopy 860, Canopy Canopy 861, Canopy Canopy 868, Canopy Canopy 872, Canopy Canopy 890, Canopy Canopy 901, Canopy Canopy 931, Canopy Canopy 938, Canopy Canopy 945, Canopy Canopy 947, Canopy Canopy 949, Canopy Canopy 958, Canopy Canopy 960, Canopy Canopy 981, Canopy Canopy 984, Canopy Canopy 990, Canopy Canopy 993, Canopy Canopy 995, Canopy Canopy 997, Canopy Canopy 1007, Canopy Canopy 1010, Canopy Canopy 1023, Canopy Canopy 1030, Canopy Canopy 1032, Canopy Canopy 1047, Canopy Canopy 1050, Canopy Canopy 1057, Canopy Canopy 1064, Canopy Canopy 1065, Canopy Canopy 1071, Canopy Canopy 1084, Canopy Canopy 1085, Canopy Canopy 1090, Canopy Canopy 1096, Canopy Canopy 1104, Canopy Canopy 1108, Canopy Canopy 1110, Canopy Canopy 1111, Canopy Canopy 1125, Canopy Canopy 1135, Canopy Canopy 1138, Canopy Canopy 1141, Canopy Canopy 1142, Canopy Canopy 1147, Canopy Canopy 1152, Canopy Canopy 1155, Canopy Canopy 1158, Canopy Canopy 1173, Canopy Canopy 1176, Canopy Canopy 1178, Canopy Canopy 1181, Canopy Canopy 1189, Canopy Canopy 1207, Canopy Canopy 1217, Canopy Canopy 1220, Canopy Canopy 1221, Canopy Canopy 1233, Canopy Canopy 1240, Canopy Canopy 1275, Canopy Canopy 1279, Canopy Canopy 1305, Canopy Canopy 1319, Canopy Canopy 1326, Canopy Canopy 1330, Canopy Canopy 1342, Canopy Canopy 1351, Canopy Canopy 1355, Canopy Canopy 1362, Canopy Canopy 1367, Canopy Canopy 1372, Canopy Canopy 1375, Canopy Canopy 1377, Canopy Canopy 1380, Canopy Canopy 1384, Canopy Canopy 1394, Canopy Canopy 1412, Canopy Canopy 1431, Canopy Canopy 1455, Canopy Canopy 1456, Canopy Canopy 1460, Canopy Canopy 1462, Canopy Canopy 1469, Canopy Canopy 1472, Canopy Canopy 1489, Canopy Canopy 1491, Canopy Canopy 1494, Canopy Canopy 1501, Canopy Canopy 1513, Canopy Canopy 1514, Canopy Canopy 1518, Canopy Canopy 1530, Canopy Canopy 1531, Canopy Canopy 1540, Canopy Canopy 1542, Canopy Canopy 1544, Canopy Canopy 1567, Canopy Canopy 1569, Canopy Canopy 1587, Canopy Canopy 1613, Canopy Canopy 1617, Canopy Canopy 1623, Canopy Canopy 1625, Canopy Canopy 1638, Canopy Canopy 1651, Canopy Canopy 1652, Canopy Canopy 1671, Canopy Canopy 1672, Canopy Canopy 1686, Canopy Canopy 1687, Canopy Canopy 1704, Canopy Canopy 1713, Canopy Canopy 1731, Canopy Canopy 1733, Canopy Canopy 1736, Canopy Canopy 1779, Canopy Canopy 1785, Canopy Canopy 1812, Canopy Canopy 1815, Canopy Canopy 1821, Canopy Canopy 1830, Canopy Canopy 1839, Canopy Canopy 1877",
        "Sound Test First Floor": "InterJump 32, SoundPad Ground floor noise, SoundPad Snoring 1, SoundPad Snoring 2",
        "BASE": "Ward 1, EventPad 1, EventPad 2, EventPad 3, PadStart 1, PadStart 2, PadEnd 1, PadEnd 2, InterPad 1, InterPad 2, PadStartBorder 1, PadStartBorder 2, PadStartBorder Horizontal, PadStartBorder Verticle, PadEndBorder 1, PadEndBorder 2, PadEndBorder Horizontal, PadEndBorder Verticle, InterPadBorder 1, InterPadBorder 2, InterPadBorder horizontal, InterPadBorder vertical, PadJump 1, InterJump 1, PadJumpBorder 1, PadJumpBorder 2, PadJumpBorder Horizontal, PadJumpBorder Vertical, InterJumpBorder 1, InterJumpBorder 3, InterJumpBorder Horizontal, InterJumpBorder Vertical, MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4, Roof 1, Foliage 1, Canopy 1, Canopy 2, Canopy 3, Canopy 4, Canopy 5, Canopy 6, Canopy 7, Canopy 8, Canopy 9",
        "Sound Test Ground Floor": "PadStart 1, PadEnd 1, InterJump 31, SoundPad Bard Music, SoundPad Fireplace Sounds, SoundPad Tavern sounds",
        "ShadowPad Example": "ShadowPad 1 Floor, ShadowPad 1 Ground",
        "Limited Sight": "EventPad 2, EventPad 3, EventPad 4, InterPad 3",
        "Life": "",
        "Teleports 2": "InterPad 2, InterPadBorder 1, InterPadBorder 2, InterPadBorder 10, InterPadBorder horizontal, InterPadBorder vertical, InterJump 2, InterJump 21, InterJumpBorder 2, InterJumpBorder 4, InterJumpBorder Horizontal, InterJumpBorder Vertical",
        "Shadow Pad Tutorial": "ShadowPad 1 Floor, ShadowPad 1 Ground, PadStart 1, PadEnd 1",
        "Example Map of Special pads": "Ward 1, Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2, Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4, Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3, Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2, EventPad 1, EventPad 2, EventPad 3, PadStart 2, PadStart 4, PadStart 10, PadStart You cant see me, PadEnd 2, PadEnd 4, PadEnd 10, PadEnd You cant see me, InterPad 1, InterPad 3, PadStartBorder 1, PadEndBorder 1, InterPadBorder 10, PadJump 1, InterJump 10, PadJumpBorder 1, PadJumpBorder 2, InterJumpBorder 10, MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4, Roof 1, Foliage 1, Foliage 2, Canopy 1",
        "Difficult Terrain": "",
        "Follow Me Tiles": ""
      },
      "allMapsPadsJson":       {
        "Forest new":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "Canopy Canopy 1, Canopy Canopy 2, Canopy Canopy 3, Canopy Canopy 4, Canopy Canopy 5, Canopy Canopy 6, Canopy Canopy 7, Canopy Canopy 8, Canopy Canopy 14, Canopy Canopy 15, Canopy Canopy 46, Canopy Canopy 63, Canopy Canopy 68, Canopy Canopy 106, Canopy Canopy 126, Canopy Canopy 139, Canopy Canopy 147, Canopy Canopy 151, Canopy Canopy 156, Canopy Canopy 160, Canopy Canopy 165, Canopy Canopy 166, Canopy Canopy 172, Canopy Canopy 174, Canopy Canopy 176, Canopy Canopy 179, Canopy Canopy 183, Canopy Canopy 195, Canopy Canopy 204, Canopy Canopy 210, Canopy Canopy 213, Canopy Canopy 223, Canopy Canopy 245, Canopy Canopy 247, Canopy Canopy 260, Canopy Canopy 266, Canopy Canopy 268, Canopy Canopy 274, Canopy Canopy 295, Canopy Canopy 297, Canopy Canopy 298, Canopy Canopy 300, Canopy Canopy 308, Canopy Canopy 337, Canopy Canopy 345, Canopy Canopy 364, Canopy Canopy 365, Canopy Canopy 366, Canopy Canopy 372, Canopy Canopy 376, Canopy Canopy 378, Canopy Canopy 379, Canopy Canopy 390, Canopy Canopy 393, Canopy Canopy 397, Canopy Canopy 399, Canopy Canopy 403, Canopy Canopy 406, Canopy Canopy 429, Canopy Canopy 430, Canopy Canopy 442, Canopy Canopy 453, Canopy Canopy 467, Canopy Canopy 476, Canopy Canopy 479, Canopy Canopy 483, Canopy Canopy 484, Canopy Canopy 495, Canopy Canopy 505, Canopy Canopy 506, Canopy Canopy 507, Canopy Canopy 516, Canopy Canopy 521, Canopy Canopy 532, Canopy Canopy 536, Canopy Canopy 543, Canopy Canopy 558, Canopy Canopy 568, Canopy Canopy 577, Canopy Canopy 580, Canopy Canopy 594, Canopy Canopy 604, Canopy Canopy 613, Canopy Canopy 624, Canopy Canopy 627, Canopy Canopy 662, Canopy Canopy 663, Canopy Canopy 672, Canopy Canopy 674, Canopy Canopy 683, Canopy Canopy 684, Canopy Canopy 685, Canopy Canopy 692, Canopy Canopy 720, Canopy Canopy 724, Canopy Canopy 730, Canopy Canopy 735, Canopy Canopy 737, Canopy Canopy 741, Canopy Canopy 769, Canopy Canopy 776, Canopy Canopy 806, Canopy Canopy 807, Canopy Canopy 828, Canopy Canopy 845, Canopy Canopy 846, Canopy Canopy 850, Canopy Canopy 860, Canopy Canopy 861, Canopy Canopy 868, Canopy Canopy 872, Canopy Canopy 890, Canopy Canopy 901, Canopy Canopy 931, Canopy Canopy 938, Canopy Canopy 945, Canopy Canopy 947, Canopy Canopy 949, Canopy Canopy 958, Canopy Canopy 960, Canopy Canopy 981, Canopy Canopy 984, Canopy Canopy 990, Canopy Canopy 993, Canopy Canopy 995, Canopy Canopy 997, Canopy Canopy 1007, Canopy Canopy 1010, Canopy Canopy 1023, Canopy Canopy 1030, Canopy Canopy 1032, Canopy Canopy 1047, Canopy Canopy 1050, Canopy Canopy 1057, Canopy Canopy 1064, Canopy Canopy 1065, Canopy Canopy 1071, Canopy Canopy 1084, Canopy Canopy 1085, Canopy Canopy 1090, Canopy Canopy 1096, Canopy Canopy 1104, Canopy Canopy 1108, Canopy Canopy 1110, Canopy Canopy 1111, Canopy Canopy 1125, Canopy Canopy 1135, Canopy Canopy 1138, Canopy Canopy 1141, Canopy Canopy 1142, Canopy Canopy 1147, Canopy Canopy 1152, Canopy Canopy 1155, Canopy Canopy 1158, Canopy Canopy 1173, Canopy Canopy 1176, Canopy Canopy 1178, Canopy Canopy 1181, Canopy Canopy 1189, Canopy Canopy 1207, Canopy Canopy 1217, Canopy Canopy 1220, Canopy Canopy 1221, Canopy Canopy 1233, Canopy Canopy 1240, Canopy Canopy 1275, Canopy Canopy 1279, Canopy Canopy 1305, Canopy Canopy 1319, Canopy Canopy 1326, Canopy Canopy 1330, Canopy Canopy 1342, Canopy Canopy 1351, Canopy Canopy 1355, Canopy Canopy 1362, Canopy Canopy 1367, Canopy Canopy 1372, Canopy Canopy 1375, Canopy Canopy 1377, Canopy Canopy 1380, Canopy Canopy 1384, Canopy Canopy 1394, Canopy Canopy 1412, Canopy Canopy 1431, Canopy Canopy 1455, Canopy Canopy 1456, Canopy Canopy 1460, Canopy Canopy 1462, Canopy Canopy 1469, Canopy Canopy 1472, Canopy Canopy 1489, Canopy Canopy 1491, Canopy Canopy 1494, Canopy Canopy 1501, Canopy Canopy 1513, Canopy Canopy 1514, Canopy Canopy 1518, Canopy Canopy 1530, Canopy Canopy 1531, Canopy Canopy 1540, Canopy Canopy 1542, Canopy Canopy 1544, Canopy Canopy 1567, Canopy Canopy 1569, Canopy Canopy 1587, Canopy Canopy 1613, Canopy Canopy 1617, Canopy Canopy 1623, Canopy Canopy 1625, Canopy Canopy 1638, Canopy Canopy 1651, Canopy Canopy 1652, Canopy Canopy 1671, Canopy Canopy 1672, Canopy Canopy 1686, Canopy Canopy 1687, Canopy Canopy 1704, Canopy Canopy 1713, Canopy Canopy 1731, Canopy Canopy 1733, Canopy Canopy 1736, Canopy Canopy 1779, Canopy Canopy 1785, Canopy Canopy 1812, Canopy Canopy 1815, Canopy Canopy 1821, Canopy Canopy 1830, Canopy Canopy 1839, Canopy Canopy 1877",
          "VPCU": "",
          "SoundPad": ""
        },
        "Sound Test First Floor":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "InterJump 32",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": "SoundPad Ground floor noise, SoundPad Snoring 1, SoundPad Snoring 2"
        },
        "BASE":         {
          "Ward": "Ward 1",
          "Linked": "",
          "EventPad": "EventPad 1, EventPad 2, EventPad 3",
          "ShadowPad": "",
          "PadStart": "PadStart 1, PadStart 2",
          "PadEnd": "PadEnd 1, PadEnd 2",
          "InterPad": "InterPad 1, InterPad 2",
          "PadStartBorder": "PadStartBorder 1, PadStartBorder 2, PadStartBorder Horizontal, PadStartBorder Verticle",
          "PadEndBorder": "PadEndBorder 1, PadEndBorder 2, PadEndBorder Horizontal, PadEndBorder Verticle",
          "InterPadBorder": "InterPadBorder 1, InterPadBorder 2, InterPadBorder horizontal, InterPadBorder vertical",
          "PadJump": "PadJump 1",
          "InterJump": "InterJump 1",
          "PadJumpBorder": "PadJumpBorder 1, PadJumpBorder 2, PadJumpBorder Horizontal, PadJumpBorder Vertical",
          "InterJumpBorder": "InterJumpBorder 1, InterJumpBorder 3, InterJumpBorder Horizontal, InterJumpBorder Vertical",
          "MappedPad": "MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4",
          "Roof": "Roof 1",
          "Foliage": "Foliage 1",
          "Canopy": "Canopy 1, Canopy 2, Canopy 3, Canopy 4, Canopy 5, Canopy 6, Canopy 7, Canopy 8, Canopy 9",
          "VPCU": "",
          "SoundPad": ""
        },
        "Sound Test Ground Floor":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "PadStart 1",
          "PadEnd": "PadEnd 1",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "InterJump 31",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": "SoundPad Bard Music, SoundPad Fireplace Sounds, SoundPad Tavern sounds"
        },
        "ShadowPad Example":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "ShadowPad 1 Floor, ShadowPad 1 Ground",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Limited Sight":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "EventPad 2, EventPad 3, EventPad 4",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "InterPad 3",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Life":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Teleports 2":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "InterPad 2",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "InterPadBorder 1, InterPadBorder 2, InterPadBorder 10, InterPadBorder horizontal, InterPadBorder vertical",
          "PadJump": "",
          "InterJump": "InterJump 2, InterJump 21",
          "PadJumpBorder": "",
          "InterJumpBorder": "InterJumpBorder 2, InterJumpBorder 4, InterJumpBorder Horizontal, InterJumpBorder Vertical",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Shadow Pad Tutorial":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "ShadowPad 1 Floor, ShadowPad 1 Ground",
          "PadStart": "PadStart 1",
          "PadEnd": "PadEnd 1",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Example Map of Special pads":         {
          "Ward": "Ward 1",
          "Linked": "Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2, Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4, Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3, Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2",
          "EventPad": "EventPad 1, EventPad 2, EventPad 3",
          "ShadowPad": "",
          "PadStart": "PadStart 2, PadStart 4, PadStart 10, PadStart You cant see me",
          "PadEnd": "PadEnd 2, PadEnd 4, PadEnd 10, PadEnd You cant see me",
          "InterPad": "InterPad 1, InterPad 3",
          "PadStartBorder": "PadStartBorder 1",
          "PadEndBorder": "PadEndBorder 1",
          "InterPadBorder": "InterPadBorder 10",
          "PadJump": "PadJump 1",
          "InterJump": "InterJump 10",
          "PadJumpBorder": "PadJumpBorder 1, PadJumpBorder 2",
          "InterJumpBorder": "InterJumpBorder 10",
          "MappedPad": "MappedPad 1, MappedPad 2, MappedPad 3, MappedPad 4",
          "Roof": "Roof 1",
          "Foliage": "Foliage 1, Foliage 2",
          "Canopy": "Canopy 1",
          "VPCU": "",
          "SoundPad": ""
        },
        "Difficult Terrain":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        },
        "Follow Me Tiles":         {
          "Ward": "",
          "Linked": "",
          "EventPad": "",
          "ShadowPad": "",
          "PadStart": "",
          "PadEnd": "",
          "InterPad": "",
          "PadStartBorder": "",
          "PadEndBorder": "",
          "InterPadBorder": "",
          "PadJump": "",
          "InterJump": "",
          "PadJumpBorder": "",
          "InterJumpBorder": "",
          "MappedPad": "",
          "Roof": "",
          "Foliage": "",
          "Canopy": "",
          "VPCU": "",
          "SoundPad": ""
        }
      },
      "animationPerClient": 0,
      "annulInvisState": "invisibility_annul",
      "baseMapName": "Grasslands",
      "centreOnMePads":       [
                {
          "map": "BASE",
          "spot": ""
        },
                {
          "map": "BASE",
          "spot": " another place another time"
        },
                {
          "map": "Difficult Terrain",
          "spot": ""
        },
                {
          "map": "Example Map of Special pads",
          "spot": ""
        },
                {
          "map": "Follow Me Tiles",
          "spot": ""
        },
                {
          "map": "Forest",
          "spot": ""
        },
                {
          "map": "Forest new",
          "spot": ""
        },
                {
          "map": "Life",
          "spot": ""
        },
                {
          "map": "Limited Sight",
          "spot": ""
        },
                {
          "map": "Shadow Pad Tutorial",
          "spot": ""
        },
                {
          "map": "ShadowPad Example",
          "spot": ""
        },
                {
          "map": "Sound Test First Floor",
          "spot": ""
        },
                {
          "map": "Sound Test Ground Floor",
          "spot": ""
        },
                {
          "map": "Sound Test Ground Floor",
          "spot": " Bar Entrance"
        },
                {
          "map": "Teleports 2",
          "spot": ""
        },
                {
          "map": "VBL",
          "spot": ""
        }
      ],
      "checkMapsOCL": 0,
      "checkSwitchInterMap": 1,
      "circleXrange5":       [
        -5,
        -5,
        -5,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5
      ],
      "circleXrange6":       [
        -6,
        -6,
        -6,
        -5,
        -5,
        -5,
        -5,
        -5,
        -5,
        -5,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -4,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -3,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -2,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        2,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        3,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        4,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        6,
        6,
        6
      ],
      "circleYrange5":       [
        -1,
        0,
        1,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -1,
        0,
        1
      ],
      "circleYrange6":       [
        -1,
        0,
        1,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        -4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        4,
        -3,
        -2,
        -1,
        0,
        1,
        2,
        3,
        -1,
        0,
        1
      ],
      "coneXrange_11_180_25":       [
        0,
        -1,
        -2,
        -2,
        -2,
        -3,
        -3,
        -3,
        -4,
        -4,
        -4,
        -4,
        -4,
        -5,
        -5,
        -5,
        -5,
        -5,
        -6,
        -6,
        -6,
        -6,
        -6,
        -6,
        -6,
        -7,
        -7,
        -7,
        -7,
        -7,
        -7,
        -7,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -8,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -9,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -10,
        -11,
        -11,
        -11,
        -11,
        -11,
        -11,
        -11,
        -12,
        -12,
        -12
      ],
      "coneYrange_11_180_25":       [
        0,
        0,
        0,
        -1,
        1,
        -1,
        1,
        0,
        0,
        -1,
        2,
        1,
        -2,
        1,
        0,
        2,
        -2,
        -1,
        2,
        1,
        3,
        -1,
        0,
        -3,
        -2,
        2,
        3,
        -3,
        0,
        1,
        -2,
        -1,
        4,
        3,
        2,
        1,
        0,
        -1,
        -2,
        -3,
        -4,
        4,
        2,
        1,
        -4,
        0,
        -1,
        -2,
        -3,
        3,
        5,
        2,
        -3,
        -4,
        -5,
        1,
        0,
        -1,
        -2,
        3,
        4,
        -2,
        -3,
        2,
        1,
        0,
        -1,
        3,
        -1,
        1,
        0
      ],
      "cpDel.backUpMacros":       {
        "Green Team Teleport":         {
          "index": 12,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1, 'Green')]",
          "label": "Green Team Teleport",
          "applyToSelected": false,
          "fontSize": "0.90em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Trap":         {
          "index": 8,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'']\n\n\n\n[h:me = arg(0)]\n[h:event = arg(1)]\n[h:triggerType = arg(5)]\n\n\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:attackRoll = d20]\n[h:roll=1d6]\n[h,if(attackRoll > Dexterity):HP=HP-roll]\n[h,if(attackRoll > Dexterity):broadcast(\"You have triggered a trap and sustained \"+roll+\" hits.<br>\")]",
          "label": "Standard Trap",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "Red Team Teleport":         {
          "index": 11,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1, 'Red')]",
          "label": "Red Team Teleport",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Pit":         {
          "index": 19,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'']\n\n\n\n\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(padName): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've fallen into a pit<br>\")]\n\t[h: AgTest = \"Failed\"]\n}; {\n\t[h:'']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly fell into a pit, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\n\t[h:'']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t=  json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t=  json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
          "label": "Standard Pit",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "Limit Movement":         {
          "index": 6,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:' ']\n[h:\"toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement: is the max amount the token is allowed to move.\n\t- lastPath: an array of coordinates of the path over which the token has moved\n\t- startingLocation: the coordinates where the token started (in the form of an array)\n\t- currentLocation: the coordinates where the token ended (in the form of an array)\n\t- usedMove: the amount of cells moved (getMoveCount())\n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of cells a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move']\n\t}; {\t\n\t\t[limitMovement = 4*Dexterity]\n\t}]\n-->\"]\n\n[tok \t\t\t= getSelectedNames()]\n[if(listCount(tok) > 1), CODE:{\n\t\n\t\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t\n\t[singleMove = 0]\n}; {\n\t\n\t\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[h:output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[h:output = output + strformat(\"In total you moved: %{usedMove}\")]\n[broadcast(output)]\n}]\n\n[message\t\t= \"You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> cells. The maximum allowed movement is <b>%{limitMovement}<\/b> cells.\"]\n[if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t\n\t[broadcast(strformat(message))]\n\t\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
          "label": "Limit Movement",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "CORE",
          "autoExecute": true,
          "tooltip": ""
        },
        "onCampaignLoad":         {
          "index": 5,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "1",
          "minWidth": "90",
          "color": "yellow",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[H:'\n\n\n']\n\n[H: '']\n\n[h:prefix = \"bot_\"]\n\n[h:defineFunction(prefix+\"limitMovement\", \"Limit Movement@this\" ,1,0) ]",
          "label": "onCampaignLoad",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "CORE",
          "autoExecute": true,
          "tooltip": ""
        },
        "Standard Net Trap":         {
          "index": 18,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'']\n\n\n\n\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n[h:netTrapPad\t\t\t= \"net trap 1\"]\n\n\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(netTrapPad): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've triggered a net trap<br>\")]\n\t[h: AgTest = \"Failed\"]\n\t[h: setState('Trapped', 1, me)]\n}; {\n\t[h:'']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly triggered a trip wire, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\t[h: setState('Trapped', 0, me)]\n\n\t[h:'']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
          "label": "Standard Net Trap",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "REMOVE THIS":         {
          "index": 20,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:' ']\n[h:\"toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement: is the max amount the token is allowed to move.\n\t- lastPath: an array of coordinates of the path over which the token has moved\n\t- startingLocation: the coordinates where the token started (in the form of an array)\n\t- currentLocation: the coordinates where the token ended (in the form of an array)\n\t- usedMove: the amount of cells moved (getMoveCount())\n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of cells a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move']\n\t}; {\t\n\t\t[limitMovement = 4*Dexterity]\n\t}]\n-->\"]\n\n[tok \t\t\t= getSelectedNames()]\n[if(listCount(tok) > 1), CODE:{\n\t\n\t\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t\n\t[singleMove = 0]\n}; {\n\t\n\t\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[h:output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[h:output = output + strformat(\"In total you moved: %{usedMove}\")]\n[broadcast(output)]\n}]\n\n[message\t\t= \"You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> cells. The maximum allowed movement is <b>%{limitMovement}<\/b> cells.\"]\n[if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t\n\t[broadcast(strformat(message))]\n\t\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
          "label": "REMOVE THIS",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "",
          "autoExecute": true,
          "tooltip": ""
        },
        "Limit Sight":         {
          "index": 3,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'']\n[h:'']\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n\n[h:triggerType\t\t\t= arg(5)]\n\n\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n\n[h:\t\t\t\t\t\tsightLevel = getProperty(\"w42.bot.sightLevel\")]\n[h,if(sightLevel == \"\"):\tsightLevel = 0]\n\n\n[h:sightType = getSightType()]\n[h,if(!startsWith(sightType, \"Limited \")):setProperty(\"w42.bot.oldSightType\", sightType)]\n\n\n\n[h,if(event == \"movedOn\"):\tsightLevel = min(4,sightLevel + 1)]\n[h,if(event == \"movedOff\"):\tsightLevel = max(0,sightLevel - 1)]\n\n\n[h:setProperty(\"w42.bot.sightLevel\", sightLevel)]\n[h, if(sightLevel):setSightType(\"Limited \"+sightLevel); setSightType(getProperty(\"w42.bot.oldSightType\"))]",
          "label": "Limit Sight",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "pad events",
          "autoExecute": true,
          "tooltip": ""
        },
        "InterTel Msg":         {
          "index": 15,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(tok+\" is being teleported from \"+oldMap+\" to \"+newMap,\"Inter map teleport\", 0,\"default\",\"300\",\"50\")]",
          "label": "InterTel Msg",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Typical Door":         {
          "index": 9,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": false,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:'']\n[h:'']\n\n[h:'']\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:thisPlayer\t\t\t= arg(1)]\n[h:tokList\t\t\t\t= arg(2)]\n[h:byStanders\t\t\t= arg(3)]\n[h:door\t\t\t\t\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n[h:doorIsOpened\t\t\t= arg(6)]\n[h:isLocked\t\t\t\t= arg(7)]\n\n\n[h:assert(triggerType == \"door\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to door: \"+door, 0)]\n\n\n[h:switchToken(me)]\n\n\n\n[h, if(isLocked), CODE:{\n\t\n\n\t\n\t[broadcast(\"You try to open the door but it won't budge, perhaps its locked?\",thisPlayer)]\n\n\t\n\t[broadcast(me+\" tries to open the door but it appears to be locked\",byStanders)]\n\t\n\t\n\t[abort(0)]\n}; {\n\t\n\t\n\t[if(doorIsOpened): broadcast(\"The door makes a loud 'SQUEEEEEK' noise when you open the door\", thisPlayer); broadcast(\"You close the door with an audible 'CLICK' \", thisPlayer)]\n\t\n\t[if(doorIsOpened): broadcast(\"With a loud 'SQUEEEEEK' the door opens\", byStanders); broadcast(\"The door closes with an audible 'CLICK' \", byStanders)]\n}]",
          "label": "Typical Door",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "door events",
          "autoExecute": true,
          "tooltip": ""
        },
        "onTokenMoveTrigger":         {
          "index": 16,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:broadcast(arg(0)+\" moved!\"]",
          "label": "onTokenMoveTrigger",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Teleport All":         {
          "index": 10,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_execAssignPads(1)]",
          "label": "Teleport All",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Tel Pre Message":         {
          "index": 14,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:bot_animateText(\"Teleporting in 5,     4,     3,     2,    1     \", \"Test message\",0,\"default\",\"300\",\"50\")]",
          "label": "Tel Pre Message",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        },
        "Teleport Message":         {
          "index": 13,
          "fontColor": "black",
          "maxWith": "",
          "sortBy": "",
          "minWidth": "90",
          "color": "default",
          "playerEditable": true,
          "includeLabel": false,
          "compare":           [
            "group",
            "sortPrefix",
            "command",
            "includeLabel",
            "autoExecute",
            "applyToSelected"
          ],
          "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"Message for you sir \"+tok, \"Test message\",0,\"default\",\"300\",\"50\")]",
          "label": "Teleport Message",
          "applyToSelected": false,
          "fontSize": "1.00em",
          "group": "Event list macros",
          "autoExecute": true,
          "tooltip": ""
        }
      },
      "cpDel.groupList": "__no group name__, CORE, door events, Event list macros, pad events",
      "cpDel.macroList": "",
      "cpDel.macrosInGroup":       {
        "__no group name__": "REMOVE THIS",
        "CORE": "Limit Movement, onCampaignLoad",
        "door events": "Typical Door",
        "Event list macros": "Green Team Teleport, Red Team Teleport, InterTel Msg, onTokenMoveTrigger, Teleport All, Tel Pre Message, Teleport Message",
        "pad events": "Standard Trap, Standard Pit, Standard Net Trap, Limit Sight"
      },
      "crowd":       [
        "Canopy Canopy 14",
        "Canopy Canopy 15",
        "Canopy Canopy 46",
        "Canopy Canopy 63",
        "Canopy Canopy 68",
        "Canopy Canopy 106",
        "Canopy Canopy 126",
        "Canopy Canopy 139",
        "Canopy Canopy 147",
        "Canopy Canopy 151",
        "Canopy Canopy 156",
        "Canopy Canopy 160",
        "Canopy Canopy 165",
        "Canopy Canopy 166",
        "Canopy Canopy 172",
        "Canopy Canopy 174",
        "Canopy Canopy 176",
        "Canopy Canopy 179",
        "Canopy Canopy 183",
        "Canopy Canopy 195",
        "Canopy Canopy 204",
        "Canopy Canopy 210",
        "Canopy Canopy 213",
        "Canopy Canopy 223",
        "Canopy Canopy 245",
        "Canopy Canopy 247",
        "Canopy Canopy 260",
        "Canopy Canopy 266",
        "Canopy Canopy 268",
        "Canopy Canopy 274",
        "Canopy Canopy 295",
        "Canopy Canopy 297",
        "Canopy Canopy 298",
        "Canopy Canopy 300",
        "Canopy Canopy 308",
        "Canopy Canopy 337",
        "Canopy Canopy 345",
        "Canopy Canopy 364",
        "Canopy Canopy 365",
        "Canopy Canopy 366",
        "Canopy Canopy 372",
        "Canopy Canopy 376",
        "Canopy Canopy 378",
        "Canopy Canopy 379",
        "Canopy Canopy 390",
        "Canopy Canopy 393",
        "Canopy Canopy 397",
        "Canopy Canopy 399",
        "Canopy Canopy 403",
        "Canopy Canopy 406",
        "Canopy Canopy 429",
        "Canopy Canopy 430",
        "Canopy Canopy 442",
        "Canopy Canopy 453",
        "Canopy Canopy 467",
        "Canopy Canopy 476",
        "Canopy Canopy 479",
        "Canopy Canopy 483",
        "Canopy Canopy 484",
        "Canopy Canopy 495",
        "Canopy Canopy 505",
        "Canopy Canopy 506",
        "Canopy Canopy 507",
        "Canopy Canopy 516",
        "Canopy Canopy 521",
        "Canopy Canopy 532",
        "Canopy Canopy 536",
        "Canopy Canopy 543",
        "Canopy Canopy 558",
        "Canopy Canopy 568",
        "Canopy Canopy 577",
        "Canopy Canopy 580",
        "Canopy Canopy 594",
        "Canopy Canopy 604",
        "Canopy Canopy 613",
        "Canopy Canopy 624",
        "Canopy Canopy 627",
        "Canopy Canopy 662",
        "Canopy Canopy 663",
        "Canopy Canopy 672",
        "Canopy Canopy 674",
        "Canopy Canopy 683",
        "Canopy Canopy 684",
        "Canopy Canopy 685",
        "Canopy Canopy 692",
        "Canopy Canopy 720",
        "Canopy Canopy 724",
        "Canopy Canopy 730",
        "Canopy Canopy 735",
        "Canopy Canopy 737",
        "Canopy Canopy 741",
        "Canopy Canopy 769",
        "Canopy Canopy 776",
        "Canopy Canopy 806",
        "Canopy Canopy 807",
        "Canopy Canopy 828",
        "Canopy Canopy 845",
        "Canopy Canopy 846",
        "Canopy Canopy 850",
        "Canopy Canopy 860",
        "Canopy Canopy 861",
        "Canopy Canopy 868",
        "Canopy Canopy 872",
        "Canopy Canopy 890",
        "Canopy Canopy 901",
        "Canopy Canopy 931",
        "Canopy Canopy 938",
        "Canopy Canopy 945",
        "Canopy Canopy 947",
        "Canopy Canopy 949",
        "Canopy Canopy 958",
        "Canopy Canopy 960",
        "Canopy Canopy 981",
        "Canopy Canopy 984",
        "Canopy Canopy 990",
        "Canopy Canopy 993",
        "Canopy Canopy 995",
        "Canopy Canopy 997",
        "Canopy Canopy 1007",
        "Canopy Canopy 1010",
        "Canopy Canopy 1023",
        "Canopy Canopy 1030",
        "Canopy Canopy 1032",
        "Canopy Canopy 1047",
        "Canopy Canopy 1050",
        "Canopy Canopy 1057",
        "Canopy Canopy 1064",
        "Canopy Canopy 1065",
        "Canopy Canopy 1071",
        "Canopy Canopy 1084",
        "Canopy Canopy 1085",
        "Canopy Canopy 1090",
        "Canopy Canopy 1096",
        "Canopy Canopy 1104",
        "Canopy Canopy 1108",
        "Canopy Canopy 1110",
        "Canopy Canopy 1111",
        "Canopy Canopy 1125",
        "Canopy Canopy 1135",
        "Canopy Canopy 1138",
        "Canopy Canopy 1141",
        "Canopy Canopy 1142",
        "Canopy Canopy 1147",
        "Canopy Canopy 1152",
        "Canopy Canopy 1155",
        "Canopy Canopy 1158",
        "Canopy Canopy 1173",
        "Canopy Canopy 1176",
        "Canopy Canopy 1178",
        "Canopy Canopy 1181",
        "Canopy Canopy 1189",
        "Canopy Canopy 1207",
        "Canopy Canopy 1217",
        "Canopy Canopy 1220",
        "Canopy Canopy 1221",
        "Canopy Canopy 1233",
        "Canopy Canopy 1240",
        "Canopy Canopy 1275",
        "Canopy Canopy 1279",
        "Canopy Canopy 1305",
        "Canopy Canopy 1319",
        "Canopy Canopy 1326",
        "Canopy Canopy 1330",
        "Canopy Canopy 1342",
        "Canopy Canopy 1351",
        "Canopy Canopy 1355",
        "Canopy Canopy 1362",
        "Canopy Canopy 1367",
        "Canopy Canopy 1372",
        "Canopy Canopy 1375",
        "Canopy Canopy 1377",
        "Canopy Canopy 1380",
        "Canopy Canopy 1384",
        "Canopy Canopy 1394",
        "Canopy Canopy 1412",
        "Canopy Canopy 1431",
        "Canopy Canopy 1455",
        "Canopy Canopy 1456",
        "Canopy Canopy 1460",
        "Canopy Canopy 1462",
        "Canopy Canopy 1469",
        "Canopy Canopy 1472",
        "Canopy Canopy 1489",
        "Canopy Canopy 1491",
        "Canopy Canopy 1494",
        "Canopy Canopy 1501",
        "Canopy Canopy 1513",
        "Canopy Canopy 1514",
        "Canopy Canopy 1518",
        "Canopy Canopy 1530",
        "Canopy Canopy 1531",
        "Canopy Canopy 1540",
        "Canopy Canopy 1542",
        "Canopy Canopy 1544",
        "Canopy Canopy 1567",
        "Canopy Canopy 1569",
        "Canopy Canopy 1587",
        "Canopy Canopy 1613",
        "Canopy Canopy 1617",
        "Canopy Canopy 1623",
        "Canopy Canopy 1625",
        "Canopy Canopy 1638",
        "Canopy Canopy 1651",
        "Canopy Canopy 1652",
        "Canopy Canopy 1671",
        "Canopy Canopy 1672",
        "Canopy Canopy 1686",
        "Canopy Canopy 1687",
        "Canopy Canopy 1704",
        "Canopy Canopy 1713",
        "Canopy Canopy 1731",
        "Canopy Canopy 1733",
        "Canopy Canopy 1736",
        "Canopy Canopy 1779",
        "Canopy Canopy 1785",
        "Canopy Canopy 1812",
        "Canopy Canopy 1815",
        "Canopy Canopy 1821",
        "Canopy Canopy 1830",
        "Canopy Canopy 1839",
        "Canopy Canopy 1877"
      ],
      "crowd.antagonist": "",
      "crowd.images": [],
      "crowd.speed": "",
      "crowd.tokens":       [
        "Crowd_01",
        "Crowd_02",
        "Crowd_03",
        "Crowd_04",
        "Crowd_05",
        "Crowd_06",
        "Crowd_07",
        "Crowd_08",
        "Crowd_09",
        "Crowd_10"
      ],
      "crowd.xMax": 14,
      "crowd.xMin": 0,
      "crowd.yMax": 14,
      "crowd.yMin": 2,
      "delay": "",
      "dieList0": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList1": "4, 6, 8, 10",
      "dieList2": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList3": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList4": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList5": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList6": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList7": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList8": "4, 5, 6, 8, 10, 12, 20, 100",
      "dieList9": "4, 5, 6, 8, 10, 12, 20, 100",
      "disableOCLCheck": 0,
      "drawTokenMap": "",
      "drawTokenName": "Area Marker",
      "excludeLightTypes": "Deflector, Flame, Grenade, Horde Melee, Special, Ranges, Suppress, bla",
      "excludedMaps":       [
        "Forest",
        "VBL"
      ],
      "fieldToks":       [
        "0000000089DAD88B1C61000000000000",
        "000000008DDAD88B2361000000000000",
        "0000000091DAD88B2F61000000000000",
        "0000000095DAD88B3B61000000000000",
        "000000009ADAD88B4761000000000000",
        "000000009EDAD88B5361000000000000",
        "00000000A3DAD88B6461000000000000",
        "00000000A8DAD88B6C61000000000000",
        "00000000ACDAD88B7761000000000000",
        "00000000B0DAD88B8361000000000000",
        "00000000B4DAD88B9161000000000000",
        "00000000B9DAD88B9B61000000000000",
        "00000000BEDAD88BAC61000000000000",
        "00000000C2DAD88BB361000000000000",
        "00000000C6DAD88BC161000000000000",
        "00000000CBDAD88BCB61000000000000",
        "00000000CFDAD88BD761000000000000",
        "00000000D3DAD88BE461000000000000",
        "00000000D8DAD88BF461000000000000",
        "00000000DDDAD88BFB61000000000000",
        "00000000E1DAD88B0962000000000000",
        "00000000E6DAD88B1362000000000000",
        "00000000EADAD88B2162000000000000",
        "00000000EFDAD88B2B62000000000000",
        "00000000F4DAD88B3C62000000000000",
        "00000000F9DAD88B4562000000000000",
        "00000000FEDAD88B5162000000000000",
        "0000000003DBD88B5D62000000000000",
        "0000000007DBD88B6C62000000000000",
        "000000000CDBD88B7762000000000000",
        "0000000012DBD88B8462000000000000",
        "0000000016DBD88B8D62000000000000",
        "000000001BDBD88B9962000000000000",
        "000000001FDBD88BA562000000000000",
        "0000000023DBD88BB162000000000000",
        "0000000028DBD88BBD62000000000000",
        "000000002DDBD88BCC62000000000000",
        "0000000032DBD88BD562000000000000",
        "0000000036DBD88BE362000000000000",
        "000000003BDBD88BED62000000000000",
        "0000000040DBD88BFC62000000000000",
        "0000000045DBD88B0863000000000000"
      ],
      "forceRoomShare": 2,
      "fullScreenBroadcast": 0,
      "fullScreenMode": 0,
      "gmNames": ["melek"],
      "height": "",
      "height1": "",
      "invisState": "invisibility",
      "languages": "",
      "lastAnimatedTextSettings": "",
      "lastLinkId": "",
      "lastLinkSettings": "currentMap=;lastLinkId=",
      "lastMassVBLSettings": "option=0 ; searchStr=tree ; doTokenLayer=0 ; doObjectLayer=1 ; doHiddenLayer=0 ; doBackgroundLayer=1 ; scaleOption=0 ; scale=0.5 ; storeVBL=1 ; vblName=maptrees ; ",
      "lastSelection.GroupSelect": [],
      "libAuthor": "",
      "libAuthorURL": "",
      "libMap": "",
      "libName": "",
      "libTitle": "",
      "libURL": "",
      "libUpdateURL": "",
      "libVersion": "47e",
      "libcoordsize": 30,
      "linkedAreas":       {
        "Difficult Terrain Map": {},
        "Difficult Terrain Map.W42.Limit":         {
          "difficult area": "Limit Movement",
          "Very difficult terrain": "Limit Movement"
        },
        "BASE": {},
        "BASE.W42.Limit": {},
        "Limited Sight": {"Limit Vision Area": "eventMacro=Limit Sight ; eventTriggerList=movedOn, movedOff ; "},
        "Limited Sight.W42.Limit": {}
      },
      "linkedMappedPads":       {
        "Forest new": {},
        "Sound Test First Floor": {},
        "BASE": {},
        "Sound Test Ground Floor": {},
        "ShadowPad Example": {},
        "Limited Sight": {},
        "Life": {},
        "Teleports 2": {},
        "Shadow Pad Tutorial": {},
        "Example Map of Special pads":         {
          "1": "Linked 1 Canopy 2, Linked 1 Foliage 3, Linked 1 Roof 2",
          "2": "Linked 2 Bridge 1, Linked 2 Bridge 2, Linked 2 Canopy 1, Linked 2 Foliage 1, Linked 2 Roof 1, Linked 2 Roof 2, Linked 2 Roof 3, Linked 2 Roof 4",
          "3": "Linked 3 Bridge 1, Linked 3 Bridge 2, Linked 3 Roof 1, Linked 3 Roof 2, Linked 3 Roof 3",
          "4": "Linked 4 Roof 1, Linked 4 Roof 2, Linked 4 Roof 3, Linked 4 Tunnel 1, Linked 4 Tunnel 2"
        },
        "Difficult Terrain": {},
        "Follow Me Tiles": {}
      },
      "macroCopies": "",
      "mapField.xMax": -8,
      "mapField.xMin": -14,
      "mapField.yMax": 22,
      "mapField.yMin": 17,
      "mappedCoords": "",
      "maxGroupSelect": 500,
      "maxOrderSelect": 300,
      "maxPadsPerRun": 500,
      "numericIdOnly": 0,
      "onTokenMoveEvent": "",
      "optionsList0": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList1": "showMod=0 ; showTarget=0 ; showExplode=0 ; showResults=0 ; showTooltip=0 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList2": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList3": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList4": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList5": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList6": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList7": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList8": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "optionsList9": "showMod=1 ; showTarget=1 ; showExplode=1 ; showResults=1 ; showTooltip=1 ; modifier=0 ; target=0 ; explode=0 ; showGMOption=all ; eachRollOption=totalRoll ; ",
      "padNameList": "Ward, Linked, EventPad, ShadowPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJump, PadDrop, InterJump, InterDrop, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, MappedPad, Roof, Foliage, Canopy, VPCU, SoundPad",
      "pixelStep": "",
      "players": "",
      "plothos.bot.messages": {},
      "purgeInvisState": "invisibility_purge",
      "purgeState": "invisibility_purge",
      "rpe.allIndexes": "33, 29, 30, 34, 35, 28, 12, 15, 11, 14, 10, 13, 16, 6, 5, 3, 27, 23, 26, 24, 20, 22, 9",
      "rpe.macroGroups":       {
        " ": "",
        "Benchmark Macros": "33, 29, 30, 34, 35",
        "Event list macros": "28, 12, 15, 11, 14, 10, 13, 16",
        "CORE": "6, 5",
        "Event Pad Macros": "3, 27, 23, 26, 24",
        "Event Button macros": "20, 22",
        "Event Door Macros": 9
      },
      "rpe.options":       {
        "editMode": 0,
        "reSort": 0,
        "cleanComment": 0,
        "loadLastOnStart": 0,
        "formWidth": 92,
        "formHeight": 18,
        "openDialog": 0,
        "saveTA": 0,
        "notepadFormat": 0,
        "macroSelect": 0,
        "stdButtons": 0
      },
      "runSwitchForm": 0,
      "seeInvisState": "invisibility_see",
      "seekTokensLastSettings": "findTok=centreOnMePad ; showImage=0 ; showName=1 ; showLayer=0 ; copyTok=0 ; libTok=0 ; doTokenLayer=1 ; doObjectLayer=1 ; doHiddenLayer=1 ; doBackgroundLayer=1",
      "showAreaTokens":       {
        "BASE": {},
        "Difficult Terrain Map":         {
          "difficult area": "83B41DD7CCBE493D2C20000001001CC4, 83B41DD7CFBE493D3220000001001CC7, 83B41DD7D2BE493D3D20000001001CD2, 83B41DD7D5BE493D4820000001001CD5, 83B41DD7D8BE493D5320000001001CD0, 83B41DD7DCBE493D5E20000001001CD4, 83B41DD7E0BE493D6920000001001CC0, 83B41DD7E4BE493D7420000001001CC4, 83B41DD7EABE493D8420000001001CC2, 83B41DD7EDBE493D8A20000001001CC5, 83B41DD7FBBE493D9A20000001001CD3, 83B41DD7FEBE493DA020000001001CD6, 83B41DD703BF493DAF20000001001D03, 83B41DD706BF493DB620000001001D06, 83B41DD726BF493DC620000001001D06, 83B41DD729BF493DCC20000001001D01, 83B41DD72DBF493DD720000001001D05, 83B41DD730BF493DE220000001001D10, 83B41DD738BF493DF220000001001D10, 83B41DD750BF493DF820000001001D50, 83B41DD753BF493D0321000001001D53, 83B41DD757BF493D0E21000001001D57, 83B41DD75ABF493D1921000001001D52, 83B41DD75DBF493D2421000001001D55, 83B41DD760BF493D2F21000001001D40, 83B41DD765BF493D3F21000001001D45, 83B41DD768BF493D4521000001001D40, 83B41DD76BBF493D5021000001001D43, 83B41DD76EBF493D5B21000001001D46, 83B41DD772BF493D6621000001001D52, 83B41DD775BF493D7121000001001D55, 83B41DD778BF493D7C21000001001D50, 83B41DD78ABF493D8C21000001001D82, 83B41DD78DBF493D9221000001001D85, 83B41DD791BF493D9D21000001001D91, 83B41DD794BF493DA821000001001D94, 83B41DD798BF493DB321000001001D90, 83B41DD79BBF493DBE21000001001D93, 83B41DD7A8BF493DCE21000001001D80, 83B41DD7ABBF493DD421000001001D83, 83B41DD7AFBF493DDF21000001001D87, 83B41DD7B2BF493DEA21000001001D92, 83B41DD7C8BF493DFA21000001001DC0, 83B41DD7CBBF493D0022000001001DC3, 83B41DD7D8BF493D1022000001001DD0, 83B41DD7DBBF493D1622000001001DD3, 83B41DD7E6BF493D2622000001001DC6, 83B41DD7E9BF493D2C22000001001DC1, 83B41DD7F7BF493D3C22000001001DD7, 83B41DD7FABF493D4222000001001DD2, 83B41DD7FEBF493D4F22000001001DD6, 83B41DD701C0493D5822000001000001, 83B41DD704C0493D6322000001000004, 83B41DD708C0493D6E22000001000000, 83B41DD70BC0493D7922000001000003, 83B41DD70EC0493D8422000001000006, 83B41DD72AC0493D9422000001000002, 83B41DD72DC0493D9A22000001000005, 83B41DD73BC0493DAA22000001000013, 83B41DD73EC0493DB022000001000016, 83B41DD741C0493DBB22000001000041, 83B41DD745C0493DC622000001000045, 83B41DD74BC0493DD622000001000043, 83B41DD74EC0493DDC22000001000046, 83B41DD75FC0493DEC22000001000057, 83B41DD762C0493DF222000001000042, 83B41DD766C0493DFD22000001000046, 83B41DD769C0493D0823000001000041, 83B41DD76CC0493D1323000001000044, 83B41DD76FC0493D1E23000001000047, 83B41DD77DC0493D2E23000001000055, 83B41DD780C0493D3423000001000080, 83B41DD78EC0493D4423000001000086, 83B41DD791C0493D4A23000001000091, 83B41DD795C0493D5523000001000095, 83B41DD798C0493D6023000001000090, 83B41DD79CC0493D6B23000001000094, 83B41DD79FC0493D7623000001000097, 83B41DD7A3C0493D8123000001000083, 83B41DD7A6C0493D8C23000001000086, 83B41DD7B6C0493D9C23000001000096, 83B41DD7B9C0493DA223000001000091, 83B41DD7BCC0493DAD23000001000094, 83B41DD7BFC0493DB823000001000097, 83B41DD7C3C0493DC3230000010000C3, 83B41DD7C6C0493DCE230000010000C6, 83B41DD7D3C0493DDE230000010000D3, 83B41DD7D6C0493DE4230000010000D6, 83B41DD7E2C0493DF4230000010000C2, 83B41DD7E5C0493DFA230000010000C5, 83B41DD7F4C0493D0A240000010000D4, 83B41DD7F7C0493D10240000010000D7, 83B41DD708C1493D2024000001000100, 83B41DD70BC1493D2624000001000103, 83B41DD70EC1493D3124000001000106, 83B41DD713C1493D4024000001000113, 83B41DD716C1493D4724000001000116, 83B41DD719C1493D5224000001000111, 83B41DD724C1493D6224000001000104, 83B41DD727C1493D6824000001000107, 83B41DD731C1493D7824000001000111, 83B41DD735C1493D7E24000001000115, 83B41DD738C1493D8924000001000110, 83B41DD73CC1493D9424000001000114, 83B41DD748C1493DA424000001000140, 83B41DD74BC1493DAA24000001000143, 83B41DD759C1493DBA24000001000151, 83B41DD75DC1493DC024000001000155, 83B41DD76EC1493DD024000001000146, 83B41DD771C1493DD624000001000151, 83B41DD774C1493DE124000001000154, 83B41DD778C1493DEC24000001000150, 83B41DD77BC1493DF724000001000153, 83B41DD77FC1493D0225000001000157, 83B41DD783C1493D0D25000001000183, 83B41DD787C1493D1825000001000187, 83B41DD78BC1493D2325000001000183, 83B41DD78EC1493D2E25000001000186, 83B41DD798C1493D3E25000001000190, 83B41DD79CC1493D4425000001000194, 83B41DD7A7C1493D5425000001000187, 83B41DD7AAC1493D5A25000001000182, 83B41DD7B8C1493D6A25000001000190, 83B41DD7BBC1493D7025000001000193, 83B41DD7C5C1493D80250000010001C5, 83B41DD7C9C1493D86250000010001C1, 83B41DD7CCC1493D91250000010001C4, 83B41DD7D0C1493D9C250000010001D0, 83B41DD7D3C1493DA7250000010001D3, 83B41DD7D6C1493DB2250000010001D6, 83B41DD7E6C1493DC2250000010001C6, 83B41DD7E9C1493DC8250000010001C1, 83B41DD7EDC1493DD3250000010001C5, 83B41DD7F0C1493DDE250000010001D0, 83B41DD7F3C1493DE9250000010001D3, 83B41DD7F8C1493DF4250000010001D0, 83B41DD702C2493D0426000001000002, 83B41DD706C2493D0A26000001000006, 83B41DD70BC2493D1A26000001000003, 83B41DD70EC2493D2026000001000006, 83B41DD712C2493D2B26000001000012, 83B41DD72EC2493D3626000001000006, 83B41DD734C2493D4126000001000014, 83B41DD737C2493D4C26000001000017, 83B41DD73AC2493D5726000001000012, 83B41DD73EC2493D6226000001000016, 83B41DD742C2493D6D26000001000042, 83B41DD745C2493D7826000001000045, 83B41DD748C2493D8326000001000040, 83B41DD753C2493D9326000001000053, 83B41DD756C2493D9926000001000056, 83B41DD75AC2493DA426000001000052, 83B41DD75DC2493DAF26000001000055, 83B41DD761C2493DBA26000001000041",
          "Very difficult terrain": "83B41DD717074E3D5333000001040517, 83B41DD71A074E3D5933000001040512, 83B41DD71D074E3D6433000001040515, 83B41DD720074E3D6F33000001040500, 83B41DD723074E3D7A33000001040503, 83B41DD726074E3D8533000001040506, 83B41DD72C074E3D9533000001040504, 83B41DD72F074E3D9B33000001040507, 83B41DD73D074E3DAB33000001040515, 83B41DD740074E3DB133000001040540, 83B41DD746074E3DC133000001040546, 83B41DD749074E3DC733000001040541, 83B41DD75B074E3DD733000001040553, 83B41DD75D074E3DDD33000001040555, 83B41DD761074E3DE833000001040541, 83B41DD764074E3DF333000001040544, 83B41DD767074E3DFE33000001040547, 83B41DD76C074E3D0E34000001040544, 83B41DD76F074E3D1434000001040547, 83B41DD77C074E3D2434000001040554, 83B41DD77F074E3D2A34000001040557, 83B41DD784074E3D3A34000001040584, 83B41DD787074E3D4034000001040587, 83B41DD78B074E3D4B34000001040583, 83B41DD78E074E3D5634000001040586, 83B41DD7A2074E3D6634000001040582, 83B41DD7A5074E3D6C34000001040585, 83B41DD7A8074E3D7734000001040580, 83B41DD7AC074E3D8234000001040584, 83B41DD7AF074E3D8D34000001040587, 83B41DD7B2074E3D9834000001040592, 83B41DD7CC074E3DA8340000010405C4, 83B41DD7CF074E3DAE340000010405C7, 83B41DD7DC074E3DBE340000010405D4, 83B41DD7DF074E3DC4340000010405D7, 83B41DD7E3074E3DCF340000010405C3, 83B41DD7E6074E3DDA340000010405C6, 83B41DD7F2074E3DEA340000010405D2, 83B41DD7F5074E3DF0340000010405D5, 83B41DD7F9074E3DFB340000010405D1, 83B41DD7FC074E3D06350000010405D4, 83B41DD7FF074E3D11350000010405D7, 83B41DD702084E3D1C35000001040802, 83B41DD711084E3D2C35000001040811, 83B41DD714084E3D3235000001040814, 83B41DD721084E3D4235000001040801, 83B41DD724084E3D4835000001040804, 83B41DD727084E3D5335000001040807, 83B41DD72B084E3D5E35000001040803, 83B41DD72E084E3D6935000001040806, 83B41DD731084E3D7435000001040811, 83B41DD73E084E3D8435000001040816, 83B41DD741084E3D8A35000001040841, 83B41DD745084E3D9535000001040845, 83B41DD748084E3DA035000001040840, 83B41DD74C084E3DAB35000001040844, 83B41DD74F084E3DB635000001040847, 83B41DD752084E3DC135000001040852, 83B41DD755084E3DCC35000001040855, 83B41DD763084E3DDC35000001040843, 83B41DD766084E3DE235000001040846, 83B41DD77F084E3DF235000001040857, 83B41DD782084E3DF835000001040882, 83B41DD785084E3D0336000001040885, 83B41DD788084E3D0E36000001040880, 83B41DD795084E3D1E36000001040895, 83B41DD798084E3D2436000001040890, 83B41DD79B084E3D2F36000001040893, 83B41DD79E084E3D3A36000001040896, 83B41DD7AD084E3D4A36000001040885, 83B41DD7B0084E3D5036000001040890, 83B41DD7B4084E3D5B36000001040894, 83B41DD7B7084E3D6636000001040897, 83B41DD7BA084E3D7136000001040892, 83B41DD7BE084E3D7C36000001040896, 83B41DD7C9084E3D8C360000010408C1, 83B41DD7CD084E3D92360000010408C5, 83B41DD7D9084E3DA2360000010408D1, 83B41DD7DC084E3DA8360000010408D4, 83B41DD7E0084E3DB3360000010408C0, 83B41DD7E3084E3DBE360000010408C3, 83B41DD7EB084E3DCE360000010408C3, 83B41DD7EE084E3DD4360000010408C6, 83B41DD7FE084E3DE4360000010408D6, 83B41DD701094E3DEA36000001040901, 83B41DD705094E3DF536000001040905, 83B41DD708094E3D0037000001040900, 83B41DD70B094E3D0B37000001040903, 83B41DD70F094E3D1637000001040907, 83B41DD71A094E3D2637000001040912, 83B41DD71E094E3D2C37000001040916, 83B41DD721094E3D3737000001040901, 83B41DD724094E3D4237000001040904, 83B41DD728094E3D4D37000001040900, 83B41DD72B094E3D5837000001040903, 83B41DD72E094E3D6337000001040906, 83B41DD732094E3D6E37000001040912, 83B41DD73D094E3D7E37000001040915, 83B41DD741094E3D8437000001040941, 83B41DD74F094E3D9437000001040947, 83B41DD752094E3D9A37000001040952, 83B41DD763094E3DAA37000001040943, 83B41DD766094E3DB037000001040946, 83B41DD769094E3DBB37000001040941, 83B41DD76D094E3DC637000001040945, 83B41DD770094E3DD137000001040950, 83B41DD774094E3DDC37000001040954, 83B41DD78D094E3DEC37000001040985, 83B41DD790094E3DF237000001040990, 83B41DD793094E3DFD37000001040993, 83B41DD796094E3D0838000001040996, 83B41DD7A2094E3D1838000001040982, 83B41DD7A5094E3D1E38000001040985, 83B41DD7A8094E3D2938000001040980, 83B41DD7AB094E3D3438000001040983, 83B41DD7B3094E3D4438000001040993"
        }
      },
      "showGroupPanelOnSelect": 0,
      "speed": 50,
      "startUpCoords": "1,19",
      "startUpMap": "BASE",
      "stepSize": 26,
      "storedAreas":       {
        "Difficult Terrain Map":         {
          "difficult area":           [
                        {
              "x": 400,
              "y": 900
            },
                        {
              "x": 500,
              "y": 800
            },
                        {
              "x": 600,
              "y": 700
            },
                        {
              "x": 700,
              "y": 600
            },
                        {
              "x": 800,
              "y": 500
            },
                        {
              "x": 650,
              "y": 0
            },
                        {
              "x": 400,
              "y": 800
            },
                        {
              "x": 500,
              "y": 700
            },
                        {
              "x": 300,
              "y": 900
            },
                        {
              "x": 700,
              "y": 500
            },
                        {
              "x": 600,
              "y": 600
            },
                        {
              "x": 800,
              "y": 400
            },
                        {
              "x": 550,
              "y": -50
            },
                        {
              "x": 150,
              "y": 900
            },
                        {
              "x": 700,
              "y": 350
            },
                        {
              "x": 750,
              "y": 300
            },
                        {
              "x": 500,
              "y": 900
            },
                        {
              "x": 700,
              "y": 700
            },
                        {
              "x": 600,
              "y": 800
            },
                        {
              "x": 800,
              "y": 600
            },
                        {
              "x": 700,
              "y": 800
            },
                        {
              "x": 600,
              "y": 900
            },
                        {
              "x": 800,
              "y": 700
            },
                        {
              "x": 250,
              "y": 950
            },
                        {
              "x": 350,
              "y": 850
            },
                        {
              "x": 450,
              "y": 750
            },
                        {
              "x": 550,
              "y": 650
            },
                        {
              "x": 750,
              "y": 450
            },
                        {
              "x": 650,
              "y": 550
            },
                        {
              "x": 700,
              "y": -50
            },
                        {
              "x": 450,
              "y": 950
            },
                        {
              "x": 650,
              "y": 750
            },
                        {
              "x": 550,
              "y": 850
            },
                        {
              "x": 750,
              "y": 650
            },
                        {
              "x": 500,
              "y": 1000
            },
                        {
              "x": 450,
              "y": 200
            },
                        {
              "x": 500,
              "y": 150
            },
                        {
              "x": 600,
              "y": -50
            },
                        {
              "x": 550,
              "y": 100
            },
                        {
              "x": 500,
              "y": 200
            },
                        {
              "x": 700,
              "y": 0
            },
                        {
              "x": 600,
              "y": 100
            },
                        {
              "x": 500,
              "y": 100
            },
                        {
              "x": 600,
              "y": 0
            },
                        {
              "x": 500,
              "y": 0
            },
                        {
              "x": 500,
              "y": -150
            },
                        {
              "x": 550,
              "y": -100
            },
                        {
              "x": 300,
              "y": 1000
            },
                        {
              "x": 700,
              "y": 400
            },
                        {
              "x": 300,
              "y": 800
            },
                        {
              "x": 200,
              "y": 900
            },
                        {
              "x": 700,
              "y": 50
            },
                        {
              "x": 250,
              "y": 1000
            },
                        {
              "x": 600,
              "y": 200
            },
                        {
              "x": 700,
              "y": 100
            },
                        {
              "x": 500,
              "y": 750
            },
                        {
              "x": 350,
              "y": 900
            },
                        {
              "x": 300,
              "y": 950
            },
                        {
              "x": 400,
              "y": 850
            },
                        {
              "x": 450,
              "y": 800
            },
                        {
              "x": 600,
              "y": 650
            },
                        {
              "x": 650,
              "y": 600
            },
                        {
              "x": 700,
              "y": 550
            },
                        {
              "x": 550,
              "y": 700
            },
                        {
              "x": 500,
              "y": -200
            },
                        {
              "x": 800,
              "y": 450
            },
                        {
              "x": 600,
              "y": -100
            },
                        {
              "x": 750,
              "y": 500
            },
                        {
              "x": 700,
              "y": 200
            },
                        {
              "x": 500,
              "y": 950
            },
                        {
              "x": 550,
              "y": 900
            },
                        {
              "x": 600,
              "y": 850
            },
                        {
              "x": 700,
              "y": 750
            },
                        {
              "x": 650,
              "y": 800
            },
                        {
              "x": 750,
              "y": 700
            },
                        {
              "x": 800,
              "y": 650
            },
                        {
              "x": 700,
              "y": 300
            },
                        {
              "x": 600,
              "y": 50
            },
                        {
              "x": 350,
              "y": 1050
            },
                        {
              "x": 600,
              "y": 250
            },
                        {
              "x": 750,
              "y": 100
            },
                        {
              "x": 650,
              "y": 200
            },
                        {
              "x": 700,
              "y": 150
            },
                        {
              "x": 500,
              "y": 50
            },
                        {
              "x": 600,
              "y": 150
            },
                        {
              "x": 650,
              "y": 100
            },
                        {
              "x": 550,
              "y": 200
            },
                        {
              "x": 450,
              "y": 1000
            },
                        {
              "x": 400,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 1050
            },
                        {
              "x": 700,
              "y": 250
            },
                        {
              "x": 750,
              "y": 200
            },
                        {
              "x": 750,
              "y": 0
            },
                        {
              "x": 450,
              "y": 1050
            },
                        {
              "x": 200,
              "y": 950
            },
                        {
              "x": 750,
              "y": 400
            },
                        {
              "x": 300,
              "y": 850
            },
                        {
              "x": 250,
              "y": 900
            },
                        {
              "x": 350,
              "y": 800
            },
                        {
              "x": 700,
              "y": 450
            },
                        {
              "x": 550,
              "y": 600
            },
                        {
              "x": 500,
              "y": 650
            },
                        {
              "x": 800,
              "y": 350
            },
                        {
              "x": 400,
              "y": 750
            },
                        {
              "x": 450,
              "y": 700
            },
                        {
              "x": 500,
              "y": -50
            },
                        {
              "x": 550,
              "y": -150
            },
                        {
              "x": 550,
              "y": 0
            },
                        {
              "x": 450,
              "y": 850
            },
                        {
              "x": 350,
              "y": 950
            },
                        {
              "x": 650,
              "y": 650
            },
                        {
              "x": 550,
              "y": 750
            },
                        {
              "x": 750,
              "y": 550
            },
                        {
              "x": 450,
              "y": 150
            },
                        {
              "x": 400,
              "y": 1000
            },
                        {
              "x": 650,
              "y": 50
            },
                        {
              "x": 150,
              "y": 950
            },
                        {
              "x": 750,
              "y": 350
            },
                        {
              "x": 200,
              "y": 1000
            },
                        {
              "x": 650,
              "y": -100
            },
                        {
              "x": 600,
              "y": -150
            },
                        {
              "x": 750,
              "y": 250
            },
                        {
              "x": 750,
              "y": 50
            },
                        {
              "x": 750,
              "y": -50
            },
                        {
              "x": 650,
              "y": 150
            },
                        {
              "x": 550,
              "y": 250
            },
                        {
              "x": 550,
              "y": 950
            },
                        {
              "x": 750,
              "y": 750
            },
                        {
              "x": 650,
              "y": 850
            },
                        {
              "x": 650,
              "y": 250
            },
                        {
              "x": 750,
              "y": 150
            },
                        {
              "x": 650,
              "y": -50
            },
                        {
              "x": 550,
              "y": 50
            },
                        {
              "x": 350,
              "y": 1000
            },
                        {
              "x": 500,
              "y": -100
            },
                        {
              "x": 300,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 1000
            },
                        {
              "x": 500,
              "y": 1050
            },
                        {
              "x": 800,
              "y": 750
            },
                        {
              "x": 750,
              "y": 800
            },
                        {
              "x": 700,
              "y": 850
            },
                        {
              "x": 600,
              "y": 950
            },
                        {
              "x": 250,
              "y": 1050
            },
                        {
              "x": 550,
              "y": 150
            },
                        {
              "x": 400,
              "y": 950
            },
                        {
              "x": 500,
              "y": 850
            },
                        {
              "x": 550,
              "y": 800
            },
                        {
              "x": 600,
              "y": 750
            },
                        {
              "x": 650,
              "y": 700
            },
                        {
              "x": 700,
              "y": 650
            },
                        {
              "x": 750,
              "y": 600
            },
                        {
              "x": 450,
              "y": 900
            },
                        {
              "x": 800,
              "y": 550
            },
                        {
              "x": 700,
              "y": -100
            }
          ],
          "Very difficult terrain":           [
                        {
              "x": 450,
              "y": -100
            },
                        {
              "x": 400,
              "y": -150
            },
                        {
              "x": 450,
              "y": -50
            },
                        {
              "x": 650,
              "y": 400
            },
                        {
              "x": 200,
              "y": 850
            },
                        {
              "x": 250,
              "y": 800
            },
                        {
              "x": 300,
              "y": 750
            },
                        {
              "x": 550,
              "y": 500
            },
                        {
              "x": 500,
              "y": 550
            },
                        {
              "x": 450,
              "y": 600
            },
                        {
              "x": 400,
              "y": 650
            },
                        {
              "x": 600,
              "y": 450
            },
                        {
              "x": 350,
              "y": 700
            },
                        {
              "x": 450,
              "y": 0
            },
                        {
              "x": 250,
              "y": 300
            },
                        {
              "x": 350,
              "y": 200
            },
                        {
              "x": 450,
              "y": 100
            },
                        {
              "x": 350,
              "y": 100
            },
                        {
              "x": 400,
              "y": 150
            },
                        {
              "x": 300,
              "y": 250
            },
                        {
              "x": 450,
              "y": -150
            },
                        {
              "x": 400,
              "y": 250
            },
                        {
              "x": 350,
              "y": 300
            },
                        {
              "x": 250,
              "y": 400
            },
                        {
              "x": 200,
              "y": 450
            },
                        {
              "x": 300,
              "y": 350
            },
                        {
              "x": 400,
              "y": 0
            },
                        {
              "x": 400,
              "y": 300
            },
                        {
              "x": 200,
              "y": 500
            },
                        {
              "x": 300,
              "y": 400
            },
                        {
              "x": 200,
              "y": 400
            },
                        {
              "x": 300,
              "y": 300
            },
                        {
              "x": 400,
              "y": 200
            },
                        {
              "x": 450,
              "y": -200
            },
                        {
              "x": 400,
              "y": -250
            },
                        {
              "x": 400,
              "y": 700
            },
                        {
              "x": 600,
              "y": 500
            },
                        {
              "x": 500,
              "y": 600
            },
                        {
              "x": 400,
              "y": 400
            },
                        {
              "x": 300,
              "y": 500
            },
                        {
              "x": 200,
              "y": 600
            },
                        {
              "x": 500,
              "y": 300
            },
                        {
              "x": 300,
              "y": 600
            },
                        {
              "x": 400,
              "y": 500
            },
                        {
              "x": 500,
              "y": 400
            },
                        {
              "x": 200,
              "y": 700
            },
                        {
              "x": 600,
              "y": 300
            },
                        {
              "x": 400,
              "y": 600
            },
                        {
              "x": 500,
              "y": 500
            },
                        {
              "x": 600,
              "y": 400
            },
                        {
              "x": 200,
              "y": 800
            },
                        {
              "x": 300,
              "y": 700
            },
                        {
              "x": 400,
              "y": 50
            },
                        {
              "x": 300,
              "y": 550
            },
                        {
              "x": 350,
              "y": 500
            },
                        {
              "x": 400,
              "y": 450
            },
                        {
              "x": 450,
              "y": 400
            },
                        {
              "x": 250,
              "y": 600
            },
                        {
              "x": 550,
              "y": 300
            },
                        {
              "x": 200,
              "y": 650
            },
                        {
              "x": 150,
              "y": 700
            },
                        {
              "x": 500,
              "y": 350
            },
                        {
              "x": 350,
              "y": 400
            },
                        {
              "x": 300,
              "y": 450
            },
                        {
              "x": 250,
              "y": 500
            },
                        {
              "x": 500,
              "y": 250
            },
                        {
              "x": 200,
              "y": 550
            },
                        {
              "x": 450,
              "y": 300
            },
                        {
              "x": 400,
              "y": 350
            },
                        {
              "x": 150,
              "y": 800
            },
                        {
              "x": 650,
              "y": 300
            },
                        {
              "x": 350,
              "y": 600
            },
                        {
              "x": 600,
              "y": 350
            },
                        {
              "x": 200,
              "y": 750
            },
                        {
              "x": 250,
              "y": 700
            },
                        {
              "x": 550,
              "y": 400
            },
                        {
              "x": 500,
              "y": 450
            },
                        {
              "x": 450,
              "y": 500
            },
                        {
              "x": 300,
              "y": 650
            },
                        {
              "x": 400,
              "y": 550
            },
                        {
              "x": 600,
              "y": 550
            },
                        {
              "x": 650,
              "y": 500
            },
                        {
              "x": 400,
              "y": -100
            },
                        {
              "x": 400,
              "y": 100
            },
                        {
              "x": 300,
              "y": 200
            },
                        {
              "x": 350,
              "y": 0
            },
                        {
              "x": 400,
              "y": -50
            },
                        {
              "x": 250,
              "y": 350
            },
                        {
              "x": 350,
              "y": 250
            },
                        {
              "x": 250,
              "y": 850
            },
                        {
              "x": 350,
              "y": 750
            },
                        {
              "x": 450,
              "y": 650
            },
                        {
              "x": 650,
              "y": 450
            },
                        {
              "x": 550,
              "y": 550
            },
                        {
              "x": 650,
              "y": 350
            },
                        {
              "x": 150,
              "y": 850
            },
                        {
              "x": 250,
              "y": 750
            },
                        {
              "x": 550,
              "y": 450
            },
                        {
              "x": 350,
              "y": 650
            },
                        {
              "x": 450,
              "y": 550
            },
                        {
              "x": 250,
              "y": 250
            },
                        {
              "x": 350,
              "y": 150
            },
                        {
              "x": 450,
              "y": 350
            },
                        {
              "x": 250,
              "y": 550
            },
                        {
              "x": 350,
              "y": 450
            },
                        {
              "x": 450,
              "y": 50
            },
                        {
              "x": 150,
              "y": 750
            },
                        {
              "x": 550,
              "y": 350
            },
                        {
              "x": 350,
              "y": 550
            },
                        {
              "x": 450,
              "y": 450
            },
                        {
              "x": 250,
              "y": 650
            },
                        {
              "x": 350,
              "y": 50
            },
                        {
              "x": 400,
              "y": -200
            },
                        {
              "x": 250,
              "y": 450
            },
                        {
              "x": 450,
              "y": 250
            },
                        {
              "x": 350,
              "y": 350
            }
          ]
        },
        "BASE": {},
        "Limited Sight": {"Limit Vision Area":         [
                    {
            "x": -1000,
            "y": -350
          },
                    {
            "x": 250,
            "y": -100
          },
                    {
            "x": 200,
            "y": -150
          },
                    {
            "x": -50,
            "y": -600
          },
                    {
            "x": 150,
            "y": -400
          },
                    {
            "x": 100,
            "y": -450
          },
                    {
            "x": 400,
            "y": -150
          },
                    {
            "x": 250,
            "y": -300
          },
                    {
            "x": 200,
            "y": -350
          },
                    {
            "x": 300,
            "y": -250
          },
                    {
            "x": 350,
            "y": -200
          },
                    {
            "x": -1600,
            "y": -650
          },
                    {
            "x": -1650,
            "y": -600
          },
                    {
            "x": -1700,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -700
          },
                    {
            "x": -1600,
            "y": -550
          },
                    {
            "x": -1650,
            "y": -500
          },
                    {
            "x": -1700,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -600
          },
                    {
            "x": -1500,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -700
          },
                    {
            "x": 200,
            "y": -200
          },
                    {
            "x": 300,
            "y": -100
          },
                    {
            "x": -1650,
            "y": 0
          },
                    {
            "x": -400,
            "y": -350
          },
                    {
            "x": -350,
            "y": -400
          },
                    {
            "x": -300,
            "y": -450
          },
                    {
            "x": -250,
            "y": -500
          },
                    {
            "x": -100,
            "y": -650
          },
                    {
            "x": -150,
            "y": -600
          },
                    {
            "x": -200,
            "y": -550
          },
                    {
            "x": 300,
            "y": 50
          },
                    {
            "x": -1600,
            "y": 350
          },
                    {
            "x": -1650,
            "y": 300
          },
                    {
            "x": -1700,
            "y": 250
          },
                    {
            "x": -1550,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 450
          },
                    {
            "x": 400,
            "y": 300
          },
                    {
            "x": 300,
            "y": 400
          },
                    {
            "x": -1600,
            "y": -400
          },
                    {
            "x": -1700,
            "y": -300
          },
                    {
            "x": -1500,
            "y": -500
          },
                    {
            "x": -1300,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -600
          },
                    {
            "x": 400,
            "y": 200
          },
                    {
            "x": 200,
            "y": 50
          },
                    {
            "x": 200,
            "y": 400
          },
                    {
            "x": 300,
            "y": 300
          },
                    {
            "x": 150,
            "y": -500
          },
                    {
            "x": 100,
            "y": -550
          },
                    {
            "x": 400,
            "y": -250
          },
                    {
            "x": 250,
            "y": -400
          },
                    {
            "x": 200,
            "y": -450
          },
                    {
            "x": 300,
            "y": -350
          },
                    {
            "x": 350,
            "y": -300
          },
                    {
            "x": -1550,
            "y": 0
          },
                    {
            "x": -1600,
            "y": 250
          },
                    {
            "x": -1650,
            "y": 200
          },
                    {
            "x": -1700,
            "y": 150
          },
                    {
            "x": 300,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 300
          },
                    {
            "x": -1500,
            "y": 350
          },
                    {
            "x": -200,
            "y": -400
          },
                    {
            "x": -100,
            "y": -500
          },
                    {
            "x": 400,
            "y": -650
          },
                    {
            "x": 350,
            "y": -700
          },
                    {
            "x": 400,
            "y": 50
          },
                    {
            "x": -1150,
            "y": -350
          },
                    {
            "x": -1050,
            "y": -450
          },
                    {
            "x": -1650,
            "y": 550
          },
                    {
            "x": -1550,
            "y": 650
          },
                    {
            "x": 0,
            "y": -550
          },
                    {
            "x": 0,
            "y": -650
          },
                    {
            "x": -1650,
            "y": 500
          },
                    {
            "x": -1700,
            "y": 450
          },
                    {
            "x": -1600,
            "y": 550
          },
                    {
            "x": -1550,
            "y": 600
          },
                    {
            "x": -1500,
            "y": 650
          },
                    {
            "x": 100,
            "y": -350
          },
                    {
            "x": 250,
            "y": -200
          },
                    {
            "x": 200,
            "y": -250
          },
                    {
            "x": 300,
            "y": -150
          },
                    {
            "x": 350,
            "y": -100
          },
                    {
            "x": -50,
            "y": -700
          },
                    {
            "x": -1650,
            "y": 400
          },
                    {
            "x": -1700,
            "y": 350
          },
                    {
            "x": -1600,
            "y": 450
          },
                    {
            "x": -1550,
            "y": 500
          },
                    {
            "x": -1500,
            "y": 550
          },
                    {
            "x": 250,
            "y": -650
          },
                    {
            "x": 350,
            "y": -550
          },
                    {
            "x": 350,
            "y": -650
          },
                    {
            "x": 200,
            "y": -100
          },
                    {
            "x": 250,
            "y": -550
          },
                    {
            "x": 350,
            "y": -450
          },
                    {
            "x": 150,
            "y": -650
          },
                    {
            "x": 250,
            "y": -450
          },
                    {
            "x": 350,
            "y": -350
          },
                    {
            "x": 150,
            "y": -550
          },
                    {
            "x": 400,
            "y": -50
          },
                    {
            "x": -1600,
            "y": -500
          },
                    {
            "x": -1700,
            "y": -400
          },
                    {
            "x": -1500,
            "y": -600
          },
                    {
            "x": -900,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -700
          },
                    {
            "x": -500,
            "y": -350
          },
                    {
            "x": -450,
            "y": -400
          },
                    {
            "x": -400,
            "y": -450
          },
                    {
            "x": -350,
            "y": -500
          },
                    {
            "x": -150,
            "y": -700
          },
                    {
            "x": -200,
            "y": -650
          },
                    {
            "x": -250,
            "y": -600
          },
                    {
            "x": -300,
            "y": -550
          },
                    {
            "x": -300,
            "y": -350
          },
                    {
            "x": -250,
            "y": -400
          },
                    {
            "x": -200,
            "y": -450
          },
                    {
            "x": -150,
            "y": -500
          },
                    {
            "x": -100,
            "y": -550
          },
                    {
            "x": -1400,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -300
          },
                    {
            "x": -1700,
            "y": -200
          },
                    {
            "x": -1500,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -700
          },
                    {
            "x": -1300,
            "y": -600
          },
                    {
            "x": 350,
            "y": 50
          },
                    {
            "x": -1650,
            "y": 650
          },
                    {
            "x": -1600,
            "y": 100
          },
                    {
            "x": -1500,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 100
          },
                    {
            "x": 250,
            "y": 50
          },
                    {
            "x": -1600,
            "y": 300
          },
                    {
            "x": -1700,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 0
          },
                    {
            "x": -900,
            "y": -400
          },
                    {
            "x": -800,
            "y": -500
          },
                    {
            "x": -600,
            "y": -700
          },
                    {
            "x": -700,
            "y": -600
          },
                    {
            "x": -300,
            "y": -400
          },
                    {
            "x": -200,
            "y": -500
          },
                    {
            "x": -100,
            "y": -600
          },
                    {
            "x": -800,
            "y": -400
          },
                    {
            "x": -700,
            "y": -500
          },
                    {
            "x": -500,
            "y": -700
          },
                    {
            "x": -600,
            "y": -600
          },
                    {
            "x": -1700,
            "y": 100
          },
                    {
            "x": -1600,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 300
          },
                    {
            "x": -100,
            "y": -400
          },
                    {
            "x": -1700,
            "y": 400
          },
                    {
            "x": -1600,
            "y": 500
          },
                    {
            "x": -1500,
            "y": 600
          },
                    {
            "x": -1700,
            "y": 300
          },
                    {
            "x": -1600,
            "y": 400
          },
                    {
            "x": -1500,
            "y": 500
          },
                    {
            "x": 0,
            "y": -700
          },
                    {
            "x": 0,
            "y": -500
          },
                    {
            "x": -1700,
            "y": 500
          },
                    {
            "x": -1600,
            "y": 600
          },
                    {
            "x": -1500,
            "y": 700
          },
                    {
            "x": -1700,
            "y": 600
          },
                    {
            "x": -1600,
            "y": 700
          },
                    {
            "x": 0,
            "y": -600
          },
                    {
            "x": -1600,
            "y": 50
          },
                    {
            "x": -1700,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -600
          },
                    {
            "x": -1500,
            "y": -700
          },
                    {
            "x": 400,
            "y": -450
          },
                    {
            "x": 250,
            "y": -600
          },
                    {
            "x": 200,
            "y": -650
          },
                    {
            "x": 300,
            "y": -550
          },
                    {
            "x": 350,
            "y": -500
          },
                    {
            "x": 150,
            "y": -700
          },
                    {
            "x": 400,
            "y": 400
          },
                    {
            "x": -850,
            "y": -700
          },
                    {
            "x": -900,
            "y": -650
          },
                    {
            "x": -950,
            "y": -600
          },
                    {
            "x": 400,
            "y": -300
          },
                    {
            "x": 300,
            "y": -400
          },
                    {
            "x": 200,
            "y": -500
          },
                    {
            "x": 100,
            "y": -600
          },
                    {
            "x": -1400,
            "y": -400
          },
                    {
            "x": -1300,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -200
          },
                    {
            "x": -1700,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -300
          },
                    {
            "x": -1100,
            "y": -700
          },
                    {
            "x": -1200,
            "y": -600
          },
                    {
            "x": -400,
            "y": -400
          },
                    {
            "x": -300,
            "y": -500
          },
                    {
            "x": -100,
            "y": -700
          },
                    {
            "x": -200,
            "y": -600
          },
                    {
            "x": -950,
            "y": -500
          },
                    {
            "x": -750,
            "y": -700
          },
                    {
            "x": -800,
            "y": -650
          },
                    {
            "x": -850,
            "y": -600
          },
                    {
            "x": -900,
            "y": -550
          },
                    {
            "x": -950,
            "y": -700
          },
                    {
            "x": 50,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -650
          },
                    {
            "x": 50,
            "y": -450
          },
                    {
            "x": -1650,
            "y": 700
          },
                    {
            "x": -1700,
            "y": 650
          },
                    {
            "x": -1650,
            "y": 600
          },
                    {
            "x": -1700,
            "y": 550
          },
                    {
            "x": -1600,
            "y": 650
          },
                    {
            "x": -1550,
            "y": 700
          },
                    {
            "x": 100,
            "y": -400
          },
                    {
            "x": 400,
            "y": -100
          },
                    {
            "x": 200,
            "y": -300
          },
                    {
            "x": 300,
            "y": -200
          },
                    {
            "x": -1650,
            "y": 50
          },
                    {
            "x": -800,
            "y": -700
          },
                    {
            "x": -900,
            "y": -600
          },
                    {
            "x": 400,
            "y": -350
          },
                    {
            "x": 250,
            "y": -500
          },
                    {
            "x": 200,
            "y": -550
          },
                    {
            "x": 300,
            "y": -450
          },
                    {
            "x": 350,
            "y": -400
          },
                    {
            "x": 100,
            "y": -650
          },
                    {
            "x": 150,
            "y": -600
          },
                    {
            "x": -900,
            "y": -500
          },
                    {
            "x": -700,
            "y": -700
          },
                    {
            "x": -800,
            "y": -600
          },
                    {
            "x": 400,
            "y": -550
          },
                    {
            "x": 250,
            "y": -700
          },
                    {
            "x": 300,
            "y": -650
          },
                    {
            "x": 350,
            "y": -600
          },
                    {
            "x": 100,
            "y": -500
          },
                    {
            "x": 400,
            "y": -200
          },
                    {
            "x": 200,
            "y": -400
          },
                    {
            "x": 300,
            "y": -300
          },
                    {
            "x": 200,
            "y": -600
          },
                    {
            "x": 300,
            "y": -500
          },
                    {
            "x": 400,
            "y": -400
          },
                    {
            "x": 100,
            "y": -700
          },
                    {
            "x": -50,
            "y": -400
          },
                    {
            "x": 50,
            "y": -600
          },
                    {
            "x": 50,
            "y": -500
          },
                    {
            "x": 50,
            "y": -400
          },
                    {
            "x": 50,
            "y": -700
          },
                    {
            "x": 400,
            "y": -600
          },
                    {
            "x": 300,
            "y": -700
          },
                    {
            "x": 250,
            "y": 0
          },
                    {
            "x": -1500,
            "y": 50
          },
                    {
            "x": 400,
            "y": -500
          },
                    {
            "x": 200,
            "y": -700
          },
                    {
            "x": 300,
            "y": -600
          },
                    {
            "x": -1700,
            "y": -50
          },
                    {
            "x": 250,
            "y": 200
          },
                    {
            "x": 200,
            "y": 250
          },
                    {
            "x": 300,
            "y": 150
          },
                    {
            "x": 350,
            "y": 100
          },
                    {
            "x": -950,
            "y": -350
          },
                    {
            "x": -850,
            "y": -450
          },
                    {
            "x": -750,
            "y": -550
          },
                    {
            "x": -650,
            "y": -650
          },
                    {
            "x": -850,
            "y": -350
          },
                    {
            "x": -750,
            "y": -450
          },
                    {
            "x": -550,
            "y": -650
          },
                    {
            "x": -650,
            "y": -550
          },
                    {
            "x": 250,
            "y": 100
          },
                    {
            "x": 200,
            "y": 150
          },
                    {
            "x": -650,
            "y": -350
          },
                    {
            "x": -550,
            "y": -450
          },
                    {
            "x": -450,
            "y": -550
          },
                    {
            "x": -350,
            "y": -650
          },
                    {
            "x": -750,
            "y": -350
          },
                    {
            "x": -650,
            "y": -450
          },
                    {
            "x": -450,
            "y": -650
          },
                    {
            "x": -550,
            "y": -550
          },
                    {
            "x": -950,
            "y": -450
          },
                    {
            "x": -750,
            "y": -650
          },
                    {
            "x": -850,
            "y": -550
          },
                    {
            "x": -950,
            "y": -550
          },
                    {
            "x": -850,
            "y": -650
          },
                    {
            "x": 350,
            "y": 400
          },
                    {
            "x": 400,
            "y": 350
          },
                    {
            "x": -1400,
            "y": -350
          },
                    {
            "x": -1350,
            "y": -400
          },
                    {
            "x": -1450,
            "y": -450
          },
                    {
            "x": -1300,
            "y": -450
          },
                    {
            "x": -1250,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -150
          },
                    {
            "x": -1650,
            "y": -250
          },
                    {
            "x": -1650,
            "y": -100
          },
                    {
            "x": -1550,
            "y": -200
          },
                    {
            "x": -1550,
            "y": -350
          },
                    {
            "x": -1500,
            "y": -250
          },
                    {
            "x": -1050,
            "y": -700
          },
                    {
            "x": -1250,
            "y": -650
          },
                    {
            "x": -1100,
            "y": -650
          },
                    {
            "x": -1150,
            "y": -600
          },
                    {
            "x": -1350,
            "y": -550
          },
                    {
            "x": -1200,
            "y": -550
          },
                    {
            "x": -950,
            "y": -650
          },
                    {
            "x": -1000,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -400
          },
                    {
            "x": -1000,
            "y": -500
          },
                    {
            "x": -1200,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -500
          },
                    {
            "x": -1500,
            "y": -100
          },
                    {
            "x": -1000,
            "y": -600
          },
                    {
            "x": -950,
            "y": -400
          },
                    {
            "x": -900,
            "y": -450
          },
                    {
            "x": -850,
            "y": -500
          },
                    {
            "x": -650,
            "y": -700
          },
                    {
            "x": -700,
            "y": -650
          },
                    {
            "x": -750,
            "y": -600
          },
                    {
            "x": -800,
            "y": -550
          },
                    {
            "x": -1300,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -200
          },
                    {
            "x": -1000,
            "y": -700
          },
                    {
            "x": -1100,
            "y": -600
          },
                    {
            "x": 50,
            "y": -650
          },
                    {
            "x": 50,
            "y": -550
          },
                    {
            "x": 350,
            "y": 0
          },
                    {
            "x": -1700,
            "y": 50
          },
                    {
            "x": -600,
            "y": -350
          },
                    {
            "x": -550,
            "y": -400
          },
                    {
            "x": -500,
            "y": -450
          },
                    {
            "x": -450,
            "y": -500
          },
                    {
            "x": -250,
            "y": -700
          },
                    {
            "x": -300,
            "y": -650
          },
                    {
            "x": -350,
            "y": -600
          },
                    {
            "x": -400,
            "y": -550
          },
                    {
            "x": 250,
            "y": 350
          },
                    {
            "x": 350,
            "y": 250
          },
                    {
            "x": 250,
            "y": 250
          },
                    {
            "x": 350,
            "y": 150
          },
                    {
            "x": -100,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -700
          },
                    {
            "x": -1700,
            "y": -650
          },
                    {
            "x": 250,
            "y": 150
          },
                    {
            "x": 350,
            "y": 350
          },
                    {
            "x": -700,
            "y": -400
          },
                    {
            "x": -600,
            "y": -500
          },
                    {
            "x": -400,
            "y": -700
          },
                    {
            "x": -500,
            "y": -600
          },
                    {
            "x": 400,
            "y": -700
          },
                    {
            "x": -1650,
            "y": -50
          },
                    {
            "x": 250,
            "y": -50
          },
                    {
            "x": 350,
            "y": -50
          },
                    {
            "x": -500,
            "y": -400
          },
                    {
            "x": -400,
            "y": -500
          },
                    {
            "x": -200,
            "y": -700
          },
                    {
            "x": -300,
            "y": -600
          },
                    {
            "x": -900,
            "y": -350
          },
                    {
            "x": -850,
            "y": -400
          },
                    {
            "x": -800,
            "y": -450
          },
                    {
            "x": -750,
            "y": -500
          },
                    {
            "x": -550,
            "y": -700
          },
                    {
            "x": -600,
            "y": -650
          },
                    {
            "x": -650,
            "y": -600
          },
                    {
            "x": -700,
            "y": -550
          },
                    {
            "x": -700,
            "y": -350
          },
                    {
            "x": -650,
            "y": -400
          },
                    {
            "x": -600,
            "y": -450
          },
                    {
            "x": -550,
            "y": -500
          },
                    {
            "x": -500,
            "y": -550
          },
                    {
            "x": -350,
            "y": -700
          },
                    {
            "x": -400,
            "y": -650
          },
                    {
            "x": -450,
            "y": -600
          },
                    {
            "x": -1650,
            "y": 150
          },
                    {
            "x": -1550,
            "y": 250
          },
                    {
            "x": -1500,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 100
          },
                    {
            "x": -1500,
            "y": 150
          },
                    {
            "x": -1700,
            "y": 700
          },
                    {
            "x": 200,
            "y": 200
          },
                    {
            "x": 300,
            "y": 100
          },
                    {
            "x": 400,
            "y": 150
          },
                    {
            "x": 250,
            "y": 300
          },
                    {
            "x": 200,
            "y": 350
          },
                    {
            "x": 300,
            "y": 250
          },
                    {
            "x": 350,
            "y": 200
          },
                    {
            "x": 200,
            "y": 0
          },
                    {
            "x": 150,
            "y": -450
          },
                    {
            "x": 250,
            "y": -350
          },
                    {
            "x": 350,
            "y": -250
          },
                    {
            "x": -1450,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -350
          },
                    {
            "x": -1650,
            "y": -300
          },
                    {
            "x": -1700,
            "y": -250
          },
                    {
            "x": -1550,
            "y": -400
          },
                    {
            "x": -1500,
            "y": -450
          },
                    {
            "x": -1250,
            "y": -700
          },
                    {
            "x": -1300,
            "y": -650
          },
                    {
            "x": -1350,
            "y": -600
          },
                    {
            "x": -1400,
            "y": -550
          },
                    {
            "x": 150,
            "y": -350
          },
                    {
            "x": 250,
            "y": -250
          },
                    {
            "x": 350,
            "y": -150
          },
                    {
            "x": 300,
            "y": 0
          },
                    {
            "x": 250,
            "y": 400
          },
                    {
            "x": 300,
            "y": 350
          },
                    {
            "x": 350,
            "y": 300
          },
                    {
            "x": 400,
            "y": 250
          },
                    {
            "x": -50,
            "y": -550
          },
                    {
            "x": -1700,
            "y": -700
          },
                    {
            "x": 400,
            "y": 0
          },
                    {
            "x": -1350,
            "y": -350
          },
                    {
            "x": -1250,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -150
          },
                    {
            "x": -1550,
            "y": 50
          },
                    {
            "x": -1050,
            "y": -650
          },
                    {
            "x": -1150,
            "y": -550
          },
                    {
            "x": -1600,
            "y": -700
          },
                    {
            "x": -1700,
            "y": -600
          },
                    {
            "x": 250,
            "y": -150
          },
                    {
            "x": -50,
            "y": -650
          },
                    {
            "x": -200,
            "y": -350
          },
                    {
            "x": -150,
            "y": -400
          },
                    {
            "x": -100,
            "y": -450
          },
                    {
            "x": -50,
            "y": -350
          },
                    {
            "x": -50,
            "y": -450
          },
                    {
            "x": -1200,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -400
          },
                    {
            "x": -1100,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -500
          },
                    {
            "x": -1000,
            "y": -550
          },
                    {
            "x": -1650,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -550
          },
                    {
            "x": -1450,
            "y": -650
          },
                    {
            "x": 0,
            "y": -450
          },
                    {
            "x": 0,
            "y": -350
          },
                    {
            "x": -1650,
            "y": 450
          },
                    {
            "x": -1550,
            "y": 550
          },
                    {
            "x": -250,
            "y": -350
          },
                    {
            "x": -150,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -350
          },
                    {
            "x": -350,
            "y": -350
          },
                    {
            "x": -250,
            "y": -450
          },
                    {
            "x": -150,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -50
          },
                    {
            "x": -600,
            "y": -400
          },
                    {
            "x": -500,
            "y": -500
          },
                    {
            "x": -300,
            "y": -700
          },
                    {
            "x": -400,
            "y": -600
          },
                    {
            "x": -450,
            "y": -350
          },
                    {
            "x": -350,
            "y": -450
          },
                    {
            "x": -250,
            "y": -550
          },
                    {
            "x": -150,
            "y": -650
          },
                    {
            "x": -550,
            "y": -350
          },
                    {
            "x": -450,
            "y": -450
          },
                    {
            "x": -250,
            "y": -650
          },
                    {
            "x": -350,
            "y": -550
          },
                    {
            "x": -150,
            "y": -350
          },
                    {
            "x": 400,
            "y": 100
          },
                    {
            "x": 200,
            "y": 300
          },
                    {
            "x": 300,
            "y": 200
          },
                    {
            "x": -1600,
            "y": 150
          },
                    {
            "x": -1650,
            "y": 100
          },
                    {
            "x": -1550,
            "y": 200
          },
                    {
            "x": -1500,
            "y": 250
          },
                    {
            "x": -1600,
            "y": -50
          },
                    {
            "x": -1550,
            "y": 150
          },
                    {
            "x": -800,
            "y": -350
          },
                    {
            "x": -750,
            "y": -400
          },
                    {
            "x": -700,
            "y": -450
          },
                    {
            "x": -650,
            "y": -500
          },
                    {
            "x": -600,
            "y": -550
          },
                    {
            "x": -450,
            "y": -700
          },
                    {
            "x": -500,
            "y": -650
          },
                    {
            "x": -550,
            "y": -600
          },
                    {
            "x": 200,
            "y": 100
          },
                    {
            "x": -1650,
            "y": 250
          },
                    {
            "x": -1550,
            "y": 350
          },
                    {
            "x": -50,
            "y": -500
          },
                    {
            "x": -1450,
            "y": -350
          },
                    {
            "x": -1350,
            "y": -450
          },
                    {
            "x": -1650,
            "y": -150
          },
                    {
            "x": -1550,
            "y": -250
          },
                    {
            "x": -1150,
            "y": -650
          },
                    {
            "x": -1250,
            "y": -550
          },
                    {
            "x": -1450,
            "y": -400
          },
                    {
            "x": -1400,
            "y": -450
          },
                    {
            "x": -1350,
            "y": -500
          },
                    {
            "x": -1600,
            "y": -250
          },
                    {
            "x": -1650,
            "y": -200
          },
                    {
            "x": -1700,
            "y": -150
          },
                    {
            "x": -1550,
            "y": -300
          },
                    {
            "x": -1500,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -700
          },
                    {
            "x": -1200,
            "y": -650
          },
                    {
            "x": -1250,
            "y": -600
          },
                    {
            "x": -1300,
            "y": -550
          },
                    {
            "x": -1250,
            "y": -350
          },
                    {
            "x": -1150,
            "y": -450
          },
                    {
            "x": -1050,
            "y": -550
          },
                    {
            "x": 0,
            "y": -400
          },
                    {
            "x": -1600,
            "y": 0
          },
                    {
            "x": -1650,
            "y": -400
          },
                    {
            "x": -1700,
            "y": -350
          },
                    {
            "x": -1600,
            "y": -450
          },
                    {
            "x": -1550,
            "y": -500
          },
                    {
            "x": -1500,
            "y": -550
          },
                    {
            "x": -1350,
            "y": -700
          },
                    {
            "x": -1400,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -600
          },
                    {
            "x": -1700,
            "y": 0
          },
                    {
            "x": -1650,
            "y": -350
          },
                    {
            "x": -1550,
            "y": -450
          },
                    {
            "x": -1350,
            "y": -650
          },
                    {
            "x": -1450,
            "y": -550
          },
                    {
            "x": -1300,
            "y": -350
          },
                    {
            "x": -1250,
            "y": -400
          },
                    {
            "x": -1200,
            "y": -450
          },
                    {
            "x": -1150,
            "y": -500
          },
                    {
            "x": -1550,
            "y": -100
          },
                    {
            "x": -1500,
            "y": -150
          },
                    {
            "x": -1000,
            "y": -650
          },
                    {
            "x": -1050,
            "y": -600
          },
                    {
            "x": -1100,
            "y": -550
          },
                    {
            "x": 200,
            "y": -50
          },
                    {
            "x": -1100,
            "y": -350
          },
                    {
            "x": -1050,
            "y": -400
          },
                    {
            "x": -1000,
            "y": -450
          },
                    {
            "x": -1650,
            "y": -550
          },
                    {
            "x": -1550,
            "y": -650
          },
                    {
            "x": -1650,
            "y": 350
          },
                    {
            "x": -1550,
            "y": 450
          }
        ]}
      },
      "storedVBL":       {
        "BASE": {"maptrees":         [
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6735,
            "y": 3160
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6045,
            "y": 3146
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5271,
            "y": 3239
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 7395,
            "y": 3197
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6692,
            "y": 2464
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5995,
            "y": 2467
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 5306,
            "y": 2522
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 7394,
            "y": 2504
          },
                    {
            "w": 25,
            "shape": "cross",
            "h": 25,
            "x": 6419,
            "y": 1729
          }
        ]},
        "BASE_ON": {"maptrees": 0}
      },
      "summonNpcPropType": "Character",
      "summonPcPropType": "Character",
      "summonPropTypesList": "Character",
      "summonSpecialList": "AssignedPad Green 1,  EventPad (Generic),  EventPad 1,  EventPad 2,  InterPad,  InterPad 1,  InterPad 2,  InterPadBorder 1,  InterPadBorder 2,  InterPadBorder horizontal,  InterPadBorder vertical,  MappedPad,  MappedPad 1,  MappedPad 2,  MappedPad 3,  MappedPad 4,  PadDrop,  PadDrop 1,  PadDropBorder 1,  PadDropBorder 2,  PadEnd 1,  PadEnd 2,  PadEndBorder 1,  PadEndBorder 2,  PadJump,  PadJump 1,  PadJumpBorder 1,  PadJumpBorder 2,  PadJumpBorder Horizontal,  PadJumpBorder Vertical,  PadStart,  PadStart 1,  PadStart 2,  PadStartBorder 1,  PadStartBorder 2,  PadStartBorder Horizontal,  PadStartBorder Verticle,AssignedPad Green 1,  EventPad (Generic),  EventPad 1,  EventPad 2,  InterPad,  InterPad 1,  InterPad 2,  InterPadBorder 1,  InterPadBorder 2,  InterPadBorder horizontal,  InterPadBorder vertical,  MappedPad,  MappedPad 1,  MappedPad 2,  MappedPad 3,  MappedPad 4,  PadDrop,  PadDrop 1,  PadDropBorder 1,  PadDropBorder 2,  PadEnd 1,  PadEnd 2,  PadEndBorder 1,  PadEndBorder 2,  PadJump,  PadJump 1,  PadJumpBorder 1,  PadJumpBorder 2,  PadJumpBorder Horizontal,  PadJumpBorder Vertical,  PadStart,  PadStart 1,  PadStart 2,  PadStartBorder 1,  PadStartBorder 2,  PadStartBorder Horizontal,  PadStartBorder Verticle, Canopy 1,  Canopy 2,  Canopy 3,  Canopy 4,  Canopy 5,  Canopy 6,  Canopy 7,  Canopy 8,  Canopy 9",
      "tbl.Dwarf":       {
        "1": {"Name": "Al"},
        "2": {"Name": "Ath"},
        "3": {"Name": "Athran"},
        "4": {"Name": "Bal"},
        "5": {"Name": "Bala"},
        "6": {"Name": "Bara"},
        "7": {"Name": "Bel"},
        "8": {"Name": "Bela"},
        "9": {"Name": "Ber"},
        "10": {"Name": "Bok"},
        "11": {"Name": "Bor"},
        "12": {"Name": "Bur"},
        "13": {"Name": "Da"},
        "14": {"Name": "Dam"},
        "15": {"Name": "Dora"},
        "16": {"Name": "Drok"},
        "17": {"Name": "Drong"},
        "18": {"Name": "Dur"},
        "19": {"Name": "Dwal"},
        "20": {"Name": "El"},
        "21": {"Name": "Ela"},
        "22": {"Name": "Elan"},
        "23": {"Name": "Elda"},
        "24": {"Name": "Fa"},
        "25": {"Name": "Far"},
        "26": {"Name": "Fara"},
        "27": {"Name": "Fim"},
        "28": {"Name": "Fima"},
        "29": {"Name": "Firen"},
        "30": {"Name": "Fur"},
        "31": {"Name": "Fura"},
        "32": {"Name": "Ga"},
        "33": {"Name": "Gim"},
        "34": {"Name": "Gol"},
        "35": {"Name": "Gollen"},
        "36": {"Name": "Got"},
        "37": {"Name": "Gota"},
        "38": {"Name": "Grim"},
        "39": {"Name": "Gro"},
        "40": {"Name": "Grun"},
        "41": {"Name": "Hak"},
        "42": {"Name": "Haka"},
        "43": {"Name": "Har"},
        "44": {"Name": "Hega"},
        "45": {"Name": "Hur"},
        "46": {"Name": "Kad"},
        "47": {"Name": "Kar"},
        "48": {"Name": "Kara"},
        "49": {"Name": "Kaz"},
        "50": {"Name": "Kaza"},
        "51": {"Name": "Krag"},
        "52": {"Name": "Logaz"},
        "53": {"Name": "Lok"},
        "54": {"Name": "Lun"},
        "55": {"Name": "Mo"},
        "56": {"Name": "Mola"},
        "57": {"Name": "Mor"},
        "58": {"Name": "Mora"},
        "59": {"Name": "No"},
        "60": {"Name": "Nola"},
        "61": {"Name": "Nor"},
        "62": {"Name": "Noran"},
        "63": {"Name": "Nun"},
        "64": {"Name": "Oda"},
        "65": {"Name": "Oka"},
        "66": {"Name": "Olla"},
        "67": {"Name": "Olf"},
        "68": {"Name": "Oth"},
        "69": {"Name": "Othra"},
        "70": {"Name": "Ro"},
        "71": {"Name": "Ror"},
        "72": {"Name": "Roran"},
        "73": {"Name": "Ska"},
        "74": {"Name": "Skalla"},
        "75": {"Name": "Skalf"},
        "76": {"Name": "Skar"},
        "77": {"Name": "Skor"},
        "78": {"Name": "Skora"},
        "79": {"Name": "Snor"},
        "80": {"Name": "Snora"},
        "81": {"Name": "Svcn"},
        "82": {"Name": "Thar"},
        "83": {"Name": "Trior"},
        "84": {"Name": "Thora"},
        "85": {"Name": "Thron"},
        "86": {"Name": "Thrun"},
        "87": {"Name": "Triura"},
        "88": {"Name": "Un"},
        "89": {"Name": "Utha"},
        "90": {"Name": "Ulla"},
        "91": {"Name": "Vala"},
        "92": {"Name": "Var"},
        "93": {"Name": "Vara"},
        "94": {"Name": "Zak"},
        "95": {"Name": "Zaka"},
        "96": {"Name": "Zakan"},
        "97": {"Name": "Zar"},
        "98": {"Name": "Zara"},
        "99": {"Name": "Zam"},
        "100": {"Name": "Zama"}
      },
      "tbl.Taverns":       {
        "1-2":         {
          "1_Usual": "Black",
          "1_Off": "Alabaster",
          "1_Disturbing": "Angry",
          "2_Usual": "Anchorage",
          "2_Off": "Barge",
          "2_Disturbing": "Baron"
        },
        "3-4":         {
          "1_Usual": "Blessed",
          "1_Off": "Bellowing",
          "1_Disturbing": "Banished",
          "2_Usual": "Arms",
          "2_Off": "Barrel",
          "2_Disturbing": "Bowels"
        },
        "5-6":         {
          "1_Usual": "Shining",
          "1_Off": "Brass",
          "1_Disturbing": "Barbarian%27s",
          "2_Usual": "Boat",
          "2_Off": "Beard",
          "2_Disturbing": "Brain"
        },
        "7-8":         {
          "1_Usual": "Blue",
          "1_Off": "Broken",
          "1_Disturbing": "Bloody",
          "2_Usual": "Bucket",
          "2_Off": "Candle",
          "2_Disturbing": "Cage"
        },
        "9-10":         {
          "1_Usual": "Broken",
          "1_Off": "Bucking",
          "1_Disturbing": "Bruised",
          "2_Usual": "Castle",
          "2_Off": "Captain",
          "2_Disturbing": "Cannon"
        },
        "11-12":         {
          "1_Usual": "Brown",
          "1_Off": "Charging",
          "1_Disturbing": "Caged",
          "2_Usual": "Chalice",
          "2_Off": "Carrot",
          "2_Disturbing": "Cave"
        },
        "13-14":         {
          "1_Usual": "Cheerful",
          "1_Off": "Charred",
          "1_Disturbing": "Chaotic",
          "2_Usual": "Club",
          "2_Off": "End",
          "2_Disturbing": "Coffin"
        },
        "15-16":         {
          "1_Usual": "Cheery",
          "1_Off": "Crooked",
          "1_Disturbing": "Constipated",
          "2_Usual": "Corner",
          "2_Off": "Chicken",
          "2_Disturbing": "Dung"
        },
        "17-18":         {
          "1_Usual": "Cosy",
          "1_Off": "Crying",
          "1_Disturbing": "Crazed",
          "2_Usual": "Cup",
          "2_Off": "Cow",
          "2_Disturbing": "Egg"
        },
        "19-20":         {
          "1_Usual": "Earnest",
          "1_Off": "Damp",
          "1_Disturbing": "Dense",
          "2_Usual": "Dog",
          "2_Off": "Coward",
          "2_Disturbing": "Eye"
        },
        "21-22":         {
          "1_Usual": "Eastern",
          "1_Off": "Deep",
          "1_Disturbing": "Disturbing",
          "2_Usual": "Door",
          "2_Off": "Dog",
          "2_Disturbing": "Eyeball"
        },
        "23-24":         {
          "1_Usual": "Elegant",
          "1_Off": "Dripping",
          "1_Disturbing": "Evil",
          "2_Usual": "Dragon",
          "2_Off": "Fire",
          "2_Disturbing": "Fang"
        },
        "25-26":         {
          "1_Usual": "Fair",
          "1_Off": "Drunken",
          "1_Disturbing": "Flatulent",
          "2_Usual": "Dwelling",
          "2_Off": "Fist",
          "2_Disturbing": "Feet"
        },
        "27-28":         {
          "1_Usual": "Fourth",
          "1_Off": "Ebon",
          "1_Disturbing": "Flayed",
          "2_Usual": "End",
          "2_Off": "Flail",
          "2_Disturbing": "Ghost"
        },
        "29-30":         {
          "1_Usual": "Friendly",
          "1_Off": "Eight",
          "1_Disturbing": "Fleshy",
          "2_Usual": "Feather",
          "2_Off": "Friar",
          "2_Disturbing": "Goblin"
        },
        "31-32":         {
          "1_Usual": "Gilded",
          "1_Off": "Empty",
          "1_Disturbing": "Forbidden",
          "2_Usual": "Garden",
          "2_Off": "Goat",
          "2_Disturbing": "Grave"
        },
        "33-34":         {
          "1_Usual": "Golden",
          "1_Off": "Fast",
          "1_Disturbing": "Fornicating",
          "2_Usual": "Gate",
          "2_Off": "Hand",
          "2_Disturbing": "Halberd"
        },
        "35-36":         {
          "1_Usual": "Good",
          "1_Off": "Flossy",
          "1_Disturbing": "Greedy",
          "2_Usual": "Goblet",
          "2_Off": "Hermit",
          "2_Disturbing": "John"
        },
        "37-38":         {
          "1_Usual": "Gray",
          "1_Off": "Garish",
          "1_Disturbing": "Gutted",
          "2_Usual": "Griffin",
          "2_Off": "Hoof",
          "2_Disturbing": "Leech"
        },
        "39-40":         {
          "1_Usual": "Green",
          "1_Off": "Giant",
          "1_Disturbing": "Hanged",
          "2_Usual": "Harbour",
          "2_Off": "Hook",
          "2_Disturbing": "Loo"
        },
        "41-42":         {
          "1_Usual": "Gray",
          "1_Off": "Glaring",
          "1_Disturbing": "Haunted",
          "2_Usual": "Haven",
          "2_Off": "Horse",
          "2_Disturbing": "Master"
        },
        "43-44":         {
          "1_Usual": "Half-way",
          "1_Off": "Hazy",
          "1_Disturbing": "Horny",
          "2_Usual": "Head",
          "2_Off": "Knight",
          "2_Disturbing": "Mistress"
        },
        "45-46":         {
          "1_Usual": "Happy",
          "1_Off": "Iron",
          "1_Disturbing": "Reapers",
          "2_Usual": "Hearth",
          "2_Off": "Lamb",
          "2_Disturbing": "Nail"
        },
        "47-48":         {
          "1_Usual": "Harvester%EF%BF%BDs",
          "1_Off": "Lonely",
          "1_Disturbing": "Ill",
          "2_Usual": "Return",
          "2_Off": "Lantern",
          "2_Disturbing": "Nickers"
        },
        "49-50":         {
          "1_Usual": "Hearty",
          "1_Off": "Nosey",
          "1_Disturbing": "Licking",
          "2_Usual": "Homestead",
          "2_Off": "Lemon",
          "2_Disturbing": "Ogre"
        },
        "51-52":         {
          "1_Usual": "Heavenly",
          "1_Off": "Plump",
          "1_Disturbing": "Mutated",
          "2_Usual": "Hoof",
          "2_Off": "Lover",
          "2_Disturbing": "Orc"
        },
        "53-54":         {
          "1_Usual": "Leaning",
          "1_Off": "Poncy",
          "1_Disturbing": "Nasty",
          "2_Usual": "Horse",
          "2_Off": "Maiden",
          "2_Disturbing": "Pee"
        },
        "55-56":         {
          "1_Usual": "Wanderer%EF%BF%BDs",
          "1_Off": "Purple",
          "1_Disturbing": "Nicked",
          "2_Usual": "House",
          "2_Off": "Man",
          "2_Disturbing": "Rat"
        },
        "57-58":         {
          "1_Usual": "Lost",
          "1_Off": "Raving",
          "1_Disturbing": "Offensive",
          "2_Usual": "Lodge",
          "2_Off": "Mask",
          "2_Disturbing": "RatCatcher"
        },
        "59-60":         {
          "1_Usual": "Lovely",
          "1_Off": "Rearing",
          "1_Disturbing": "Possessed",
          "2_Usual": "Maiden",
          "2_Off": "Mast",
          "2_Disturbing": "Shoe"
        },
        "61-62":         {
          "1_Usual": "Merry",
          "1_Off": "Restless",
          "1_Disturbing": "Rampaging",
          "2_Usual": "Mare",
          "2_Off": "Monk",
          "2_Disturbing": "Skull"
        },
        "63-64":         {
          "1_Usual": "Northern",
          "1_Off": "Running",
          "1_Disturbing": "Rampant",
          "2_Usual": "Mule",
          "2_Off": "Monkey",
          "2_Disturbing": "Snotling"
        },
        "65-66":         {
          "1_Usual": "Roamer%EF%BF%BDs",
          "1_Off": "Rusty",
          "1_Disturbing": "Randy",
          "2_Usual": "Pint",
          "2_Off": "Mule",
          "2_Disturbing": "Squib"
        },
        "67-68":         {
          "1_Usual": "Reaver%EF%BF%BDs",
          "1_Off": "Shady",
          "1_Disturbing": "Raunchy",
          "2_Usual": "Quarter",
          "2_Off": "Peasant",
          "2_Disturbing": "Squid"
        },
        "69-70":         {
          "1_Usual": "Southern",
          "1_Off": "Silken",
          "1_Disturbing": "Rotten",
          "2_Usual": "Pony",
          "2_Off": "Pig",
          "2_Disturbing": "Surgeon"
        },
        "71-72":         {
          "1_Usual": "Traveller%EF%BF%BDs",
          "1_Off": "Sleepy",
          "1_Disturbing": "Sceptic",
          "2_Usual": "Mansion",
          "2_Off": "Poney",
          "2_Disturbing": "Tart"
        },
        "73-74":         {
          "1_Usual": "Rover%EF%BF%BDs",
          "1_Off": "Slick",
          "1_Disturbing": "Screaming",
          "2_Usual": "Rat",
          "2_Off": "Prince",
          "2_Disturbing": "Testicle"
        },
        "75-76":         {
          "1_Usual": "Silver",
          "1_Off": "Smelly",
          "1_Disturbing": "Seductive",
          "2_Usual": "Retreat",
          "2_Off": "Purse",
          "2_Disturbing": "Throat"
        },
        "77-78":         {
          "1_Usual": "Sovereign",
          "1_Off": "Spending",
          "1_Disturbing": "Skinned",
          "2_Usual": "Rooms",
          "2_Off": "Ruin",
          "2_Disturbing": "Toe"
        },
        "79-80":         {
          "1_Usual": "Thirsty",
          "1_Off": "Steel",
          "1_Disturbing": "Slaughtered",
          "2_Usual": "Shelter",
          "2_Off": "Spirit",
          "2_Disturbing": "Toenail"
        },
        "81-82":         {
          "1_Usual": "Thriving",
          "1_Off": "Stony",
          "1_Disturbing": "Sleazy",
          "2_Usual": "Sign",
          "2_Off": "Stable",
          "2_Disturbing": "Tongue"
        },
        "83-84":         {
          "1_Usual": "Three",
          "1_Off": "Tangy",
          "1_Disturbing": "Slimy",
          "2_Usual": "Snug",
          "2_Off": "Stew",
          "2_Disturbing": "Tooth"
        },
        "85-86":         {
          "1_Usual": "Tilean",
          "1_Off": "Thirteenth",
          "1_Disturbing": "Snorting",
          "2_Usual": "Stallion",
          "2_Off": "Stove",
          "2_Disturbing": "Troll"
        },
        "87-88":         {
          "1_Usual": "Tilted",
          "1_Off": "Tilted",
          "1_Disturbing": "Snotty",
          "2_Usual": "Steed",
          "2_Off": "Toad",
          "2_Disturbing": "Turd"
        },
        "89-90":         {
          "1_Usual": "Two",
          "1_Off": "Tiny",
          "1_Disturbing": "Sour",
          "2_Usual": "Table",
          "2_Off": "Tomato",
          "2_Disturbing": "Warlock"
        },
        "91-92":         {
          "1_Usual": "Voyager%EF%BF%BDs",
          "1_Off": "Unhappy",
          "1_Disturbing": "Stinking",
          "2_Usual": "Tankard",
          "2_Off": "Wagon",
          "2_Disturbing": "Wart"
        },
        "93-94":         {
          "1_Usual": "Weary",
          "1_Off": "Velvet",
          "1_Disturbing": "Twisted",
          "2_Usual": "Unicorn",
          "2_Off": "Warrior",
          "2_Disturbing": "Wench"
        },
        "95-96":         {
          "1_Usual": "Western",
          "1_Off": "Watery",
          "1_Disturbing": "Ugly",
          "2_Usual": "Wagon",
          "2_Off": "Willow",
          "2_Disturbing": "Witch"
        },
        "97-98":         {
          "1_Usual": "White",
          "1_Off": "Weary",
          "1_Disturbing": "Unholy",
          "2_Usual": "Place",
          "2_Off": "Wings",
          "2_Disturbing": "Wrench"
        },
        "99-100":         {
          "1_Usual": "Yellow",
          "1_Off": "Weeping",
          "1_Disturbing": "Unsavoury",
          "2_Usual": "Resthouse",
          "2_Off": "Woman",
          "2_Disturbing": "Zombie"
        }
      },
      "tbl.Weapons":       {
        "tableColumnSize": 9,
        "Buckler":         {
          "Class+%28Thingie%29": "{Melee,+Parrying}",
          "Damage": "%5Br:SB-4%5D",
          "Type": "I",
          "Range": 3,
          "Reload": "",
          "Pen": "",
          "Special": "Balanced,++Defensive,",
          "tHander": "",
          "Enc": 10,
          "%3Cnew+column%3E": ""
        },
        "Dagger":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-3",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 10,
          "%3Cnew+column%3E": ""
        },
        "Demilance+%28Cavalry+Spear%29":         {
          "Class+%28Thingie%29": "Melee,+Cavalry",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Impact,+Tiring",
          "tHander": "",
          "Enc": 75,
          "%3Cnew+column%3E": ""
        },
        "Flail":         {
          "Class+%28Thingie%29": "Melee,+Flail",
          "Damage": "SB%2B1",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Tiring",
          "tHander": 1,
          "Enc": 95,
          "%3Cnew+column%3E": ""
        },
        "Foil":         {
          "Class+%28Thingie%29": "Melee,+Fencing",
          "Damage": "SB-2",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Precise",
          "tHander": "",
          "Enc": 40,
          "%3Cnew+column%3E": ""
        },
        "Gauntlet%2FKnuckle-duster":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-3",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Pummelling",
          "tHander": "",
          "Enc": 1,
          "%3Cnew+column%3E": ""
        },
        "Great+Sword":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Hammer":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Axe":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Mace":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Pick":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Great+Club":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Slow",
          "tHander": 1,
          "Enc": 200,
          "%3Cnew+column%3E": ""
        },
        "Halberd":         {
          "Class+%28Thingie%29": "Melee,+Two-handed",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Special",
          "tHander": 1,
          "Enc": 175,
          "%3Cnew+column%3E": ""
        },
        "Sword":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Hammer":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Axe":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Mace":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Pick":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Club":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Improvised":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-4",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "None",
          "tHander": "",
          "Enc": 35,
          "%3Cnew+column%3E": ""
        },
        "Lance":         {
          "Class+%28Thingie%29": "Melee,+Cavalry",
          "Damage": "SB%2B1",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast,+Impact,++Tiring",
          "tHander": "",
          "Enc": 100,
          "%3Cnew+column%3E": ""
        },
        "Main+Gauche":         {
          "Class+%28Thingie%29": "Melee,+Parrying",
          "Damage": "SB-3",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Balanced,++Defensive",
          "tHander": "",
          "Enc": 15,
          "%3Cnew+column%3E": ""
        },
        "Morning+Star":         {
          "Class+%28Thingie%29": "Melee,+Flail",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Impact,+Tiring",
          "tHander": "",
          "Enc": 60,
          "%3Cnew+column%3E": ""
        },
        "Quarter+Staff":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-2",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Defensive,+Pummelling",
          "tHander": 1,
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Rapier":         {
          "Class+%28Thingie%29": "Melee,+Fencing",
          "Damage": "SB-1",
          "Type": "R",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast",
          "tHander": "",
          "Enc": 40,
          "%3Cnew+column%3E": ""
        },
        "Shield":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB-2",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Defensive,+Special",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        },
        "Spear":         {
          "Class+%28Thingie%29": "Melee,+Ordinary",
          "Damage": "SB",
          "Type": "I",
          "Range": "",
          "Reload": "",
          "Pen": "",
          "Special": "Fast",
          "tHander": "",
          "Enc": 50,
          "%3Cnew+column%3E": ""
        }
      },
      "tbl.tiny":       {
        "tableColumnSize": 4,
        "1":         {
          "greet": "hi",
          "name": "Jo"
        },
        "2-5":         {
          "greet": "ho",
          "name": "Sue"
        },
        "6":         {
          "greet": "he",
          "name": "tom"
        }
      },
      "timeLockDelay": 300,
      "tmpDraWArea": [],
      "toggles": "forceSelectClient=0 ; roofHaloColor=red ; doSwitchInterMap=0 ; doScaleTeleport=0 ; doGroups=1 ; doSnap2Grid=0 ; doVBLStamp=0 ; doResetFoW=0 ; doVBLCheck=0 ; doTriggerOnZeroMove=0 ; doCentreOnTok=0 ; doLockMovement=1 ; doFullScreenMode=0 ; doInvisibility=0 ; doShowPath=0 ; canSelectShadowTok=2 ; doSpecialPads=1 ; doFirstPointPath=1 ; doInnerPointsPath=1 ; limitMovement=0 ; eventMacroPreTokenMove=<none> ; eventMacroPreMultipleTokenMove=<none> ; eventMacroOnTokenMove=<none> ; eventMacroOnMultipleTokensMove=<none> ; eventPreMacroTeleport=<none> ; eventPostMacroTeleport=<none> ; eventMacroPreInterTeleport=<none> ; eventMacroPostInterTeleport=<none> ; eventMacroPostTokenMove=<none> ; eventMacroPostMultipleTokensMove=<none> ; movementLock=0 ; excludePropertyTypes=SpecialPad, libSystem, libSettings, none,brush ; drawArea=0",
      "treeTrunkImages": "asset://c9aab0b63e46d35910f9a921699299fb, asset://e8e2668d56b085bb3ad5b5441acbfd00, asset://0ca50b2dda25958fd74d167be8ff3248, asset://40755cd269a7ed04bf9c193d379822a6, asset://ca5ab391760ab396b8ff7bf8a30cf6b3, asset://f25f97f3a795fd2f10bd33b6a0e92381, asset://ac135e3b38d806e570aaa79ca7d63bf8, asset://b62d85d6b5b4cf883eb80c7f3104edf1, asset://8c51d7c434a64f6113713e75ce96888a, asset://bf9602ddb33418dac36d824f9582f6f2, asset://48e6e30912173007bd2baa12e03d0adb",
      "useAltImage": 1,
      "useCentreOnMePad": 0,
      "useStartUpMap": 1,
      "useStoredPath": 0,
      "vblExtendPx": 0,
      "vblSnap2Grid": 1,
      "vblSupport": 1,
      "w42.animatedViewSettings": "delay=0 ; stepSize=15 ; width=3000 ; height=1500 ; width1=3000 ; height1=1500 ; useStoredPath=0",
      "w42.bot.cleanSettings": "charComma=1 ; charSemicolon=1 ; charColon=1 ; charApostrophe=1 ; charGrave=0 ; charAcute=0 ; charAmpersand=1 ; charQuestion=1 ; charAt=1 ; charSpace=1 ; charPlus=0 ; charDash=1 ; charEqual=0 ; charHash=0 ; charBar=0 ; charLesser=0 ; charGreater=0 ; charPeriod=0 ; charDollar=1 ; lyrBackGround=1 ; lyrHidden=1 ; lyrObject=1 ; lyrToken=1 ; ",
      "w42.bot.dbdb":       {
        "t0":         {
          "Dungeon Tile 10": 270,
          "Dungeon Tile 24": 180
        },
        "t1":         {
          "Dungeon Tile 03": 0,
          "Dungeon Tile 06": 180,
          "Dungeon Tile 09": 90,
          "Dungeon Tile 27": 0,
          "Dungeon Tile 32": 180,
          "Dungeon Tile 45": 90,
          "Dungeon Tile 69": 270,
          "Dungeon Tile150 Mercutio": 0,
          "Dungeon Tile158 Bogie": 0,
          "Dungeon Tile161 Bogie": 0,
          "Dungeon Tile164 Bogie": 0,
          "Dungeon Tile165 Bogie": 0
        },
        "t12":         {
          "Dungeon Tile 02": 0,
          "Dungeon Tile 13": 0,
          "Dungeon Tile 16": 270,
          "Dungeon Tile 17": 0,
          "Dungeon Tile 26": 0,
          "Dungeon Tile 29": 90,
          "Dungeon Tile142 Maxxx": 90,
          "Dungeon Tile143 Maxxx": 90,
          "Dungeon Tile160 Bogie": 0,
          "Dungeon Tile163 Bogie": 0
        },
        "t13":         {
          "Dungeon Tile 01": 180,
          "Dungeon Tile 11": 180,
          "Dungeon Tile 25": 180,
          "Dungeon Tile 42": 180,
          "Dungeon Tile 57": 90,
          "Dungeon Tile 58": 90,
          "Dungeon Tile 60": 90,
          "Dungeon Tile151 Mercutio": 180,
          "Dungeon Tile157 Bogie": 180,
          "test1": 180
        },
        "t123":         {
          "Dungeon Tile 04": 90,
          "Dungeon Tile 07": 90,
          "Dungeon Tile 14": 270,
          "Dungeon Tile 30": 270,
          "Dungeon Tile 52": 270,
          "Dungeon Tile 70": 180,
          "Dungeon Tile 72": 0,
          "Dungeon Tile147 Mercutio": 180,
          "Dungeon Tile159 Bogie": 0,
          "Dungeon Tile162 Bogie": 90
        },
        "t1234":         {
          "Dungeon Tile 08": 270,
          "Dungeon Tile 12": 270,
          "Dungeon Tile 20": 270,
          "Dungeon Tile 55": 180,
          "Dungeon Tile144 Mercutio": 270,
          "Dungeon Tile145 Mercutio": 270,
          "Dungeon Tile146 Mercutio": 270,
          "Dungeon Tile148 Mercutio": 270,
          "Dungeon Tile149 Mercutio": 270,
          "Dungeon Tile152 Mercutio": 270,
          "Dungeon Tile153 Mercutio": 270,
          "Dungeon Tile154 Mercutio": 270,
          "Dungeon Tile155 Mercutio": 270,
          "Dungeon Tile156 Mercutio": 270
        }
      },
      "w42.bot.fg.GroupSettings": "bot.fg.Transportation=1;btnbot.fg.Transportation=ShowOverview;bot.fg.EventTokenArea=1;bot.fg.UtilityMove=1;bot.fg.UtilityGeneral=1;bot.fg.Tables=1;bot.fg.Animations=1;bot.fg.MapCreation=1;bot.fg.VBL=1;bot.fg.Other=1;bot.fg.Functions=1",
      "w42.bot.lastTime": "",
      "w42.bot.lastTime1": 1589668038817,
      "w42.bot.lastTime2": 1398346576813,
      "w42.bot.lastTime3": 1460041044128,
      "w42.bot.lastTime4": 1406800597244,
      "w42.bot.pauseTime": 0,
      "w42.bot.pausedTime": 0,
      "w42.bot.processOrder.degrees": 90,
      "w42.bot.startTime": 1418380706138,
      "w42.bot.subTime": 1418380706138,
      "w42.bot.timeIsPaused": 0,
      "w42.bot.w42.bot.timeIsPaused": 0,
      "w42.bot.whisperPanel.languages": "Common, Dwarfish, Elfish",
      "w42.bot.whisperPanel.lastSettings":       {
        "italic": 0,
        "bold": 0,
        "underline": 0,
        "allPlayers": 0,
        "impersonate": 0,
        "currLanguage": "Dwarfish",
        "whisperText": "test",
        "color": "black",
        "Whisper": "Send Message"
      },
      "w42.bot.whisperPanel.playerChoices":       {
        "RolphLAN": "Common, Dwarfish, Elfish",
        "RolphTOK": "Eagle",
        "The Mighty JohnLAN": "",
        "The Mighty JohnTOK": "Tiny Dragon with Man on Top",
        "TomLAN": "",
        "TomTOK": "wEagle 9",
        "WolphLAN": "Common, Dwarfish, Elfish",
        "WolphTOK": "Eagle 1"
      },
      "w42.bot.whisperPanel.script":       {
        "Dwarfish": "script_dwarvish",
        "Elfish": "script_elvish"
      },
      "width": "",
      "width1": ""
    },
    "macros":     [
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 33,
        "label": "@skip this one",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "you never know for which its usefull, but macros whos name start with @ will be skipped in the benchmark.",
        "maxWidth": "",
        "tooltip": "an example benchmark macro. macro starting with @ are skipped in the benchmark",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "53ac9769-65ae-4f5e-b856-8a400f78862c",
          "commandChecksum": "7e8d415285f97162961c727a511fc6b6",
          "propsChecksum": "8881b2dc0c25354b7b14f4b512530f63"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 35,
        "label": "w42",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:var = '{\"Light\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Light\"},\"Mage Hand\":{\"level\":0,\"damage\":\"2d4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mage Hand\"},\"Expeditious Retreat\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Expeditious Retreat\"},\"Vanish\":{\"level\":\"1st\",\"damage\":\"2d5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Vanish\"},\"Read Magic\":{\"level\":0,\"damage\":\"2d10\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Read Magic\"},\"Resistance\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Resistance\"},\"Saving Finale\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Saving Finale\"},\"Feather Fall\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Feather Fall\"},\"Cure Light Wounds\":{\"level\":\"1st\",\"damage\":\"1d8+4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Light Wounds\"},\"Cacophonous Call\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cacophonous Call\",\"numMem\":2},\"Grease\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Reflex Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Grease\"},\"Timely Inspiration\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Timely Inspiration\"},\"Liberating Command\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Liberating Command\"},\"Charm Person\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Person\"},\"Invisibility\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Invisibility\"},\"Tongues\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Tongues\"},\"Charm Monster\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Monster\",\"numMem\":1},\"Hold Person\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Hold Person\"},\"Cure Serious Wounds\":{\"level\":\"3rd\",\"damage\":\"3d8+8\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Serious Wounds\"},\"Gallant Inspiration\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Gallant Inspiration\",\"numMem\":1},\"Cure Moderate Wounds\":{\"level\":\"2nd\",\"damage\":\"2d8+5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Moderate Wounds\"},\"Shatter\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Shatter\"},\"Dispel Magic\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dispel Magic\",\"numMem\":2},\"Silence\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Silence\"},\"See Invisibility\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"See Invisibility\"},\"Dimension Door\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dimension Door\"},\"Song of Kyonin\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Song of Kyonin\"},\"Mirror Image\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mirror Image\"},\"Terrible Remorse\":{\"level\":\"3rd\",\"damage\":\"3d6\",\"toHit\":\"No\",\"toHitBonus\":1,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":1,\"spell name\":\"Terrible Remorse\"},\"Virtuoso Performance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Virtuoso Performance\"},\"Primal Scream\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Primal Scream\"},\"Displacement\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Displacement\"},\"Cure Critical Wounds\":{\"level\":\"4th\",\"damage\":\"4d8+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Critical Wounds\"},\"Break Enchantment\":{\"level\":\"4th\",\"damage\":\"d20+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Break Enchantment\"},\"Freedom of Movement\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Freedom of Movement\",\"numMem\":1},\"Ki Shout\":{\"level\":\"5th\",\"damage\":\"13d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Fort Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ki Shout\"},\"Bards Escape\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bards Escape\",\"numMem\":1},\"Acid Fog\":{\"level\":\"5th\",\"damage\":\"2d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Acid Fog\",\"numMem\":0},\"Unadulterated Loathing\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Unadulterated Loathing\"},\"Wish\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Wish\"},\"Youthful Appearance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Youthful Appearance\"},\"Fire Breath\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fire Breath\"},\"Fireball\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fireball\"},\"Ablative Barrier\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ablative Barrier\"},\"Cackling Skull\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cackling Skull\"},\"Badgers Ferocity\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Badgers Ferocity\"},\"Daemon Ward\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Daemon Ward\"},\"Fabricate\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate\"},\"Fabricate Bullets\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate Bullets\"},\"Bears Endurance\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bears Endurance\"}}']\n[h:var = replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[^\"]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[^\"]+\"),', '\\$1:{')]\n[r:var = \"{\"+substring(var, 1, length(var)-1)+\"}\"]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e82ca724-e976-413a-994c-12a66b23eb97",
          "commandChecksum": "9a45782f17df74d031a6d48353a3bfd3",
          "propsChecksum": "9ca23919831e2dbae966987619579ce7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 3,
        "label": "Limit Sight",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n\n[h:triggerType\t\t\t= arg(5)]\n\n\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n\n[h:\t\t\t\t\t\tsightLevel = getProperty(\"w42.bot.sightLevel\")]\n[h,if(sightLevel == \"\"):\tsightLevel = 0]\n\n\n[h:sightType = getSightType()]\n[h,if(!startsWith(sightType, \"Limited \")):setProperty(\"w42.bot.oldSightType\", sightType)]\n\n\n\n[h,if(event == \"movedOn\"):\tsightLevel = min(4,sightLevel + 1)]\n[h,if(event == \"movedOff\"):\tsightLevel = max(0,sightLevel - 1)]\n\n\n[h:setProperty(\"w42.bot.sightLevel\", sightLevel)]\n[h, if(sightLevel):setSightType(\"Limited \"+sightLevel); setSightType(getProperty(\"w42.bot.oldSightType\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "39ac376d-42d8-4aa5-92c1-520279544a55",
          "commandChecksum": "ec2a5675309960643c4432dfea69598f",
          "propsChecksum": "35209277de07718b9107eb41604746f0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 36,
        "label": "am",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:var = '{\"Light\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Light\"},\"Mage Hand\":{\"level\":0,\"damage\":\"2d4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mage Hand\"},\"Expeditious Retreat\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Expeditious Retreat\"},\"Vanish\":{\"level\":\"1st\",\"damage\":\"2d5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Vanish\"},\"Read Magic\":{\"level\":0,\"damage\":\"2d10\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Read Magic\"},\"Resistance\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Resistance\"},\"Saving Finale\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Saving Finale\"},\"Feather Fall\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Feather Fall\"},\"Cure Light Wounds\":{\"level\":\"1st\",\"damage\":\"1d8+4\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Light Wounds\"},\"Cacophonous Call\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cacophonous Call\",\"numMem\":2},\"Grease\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Reflex Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Grease\"},\"Timely Inspiration\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Timely Inspiration\"},\"Liberating Command\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Liberating Command\"},\"Charm Person\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Person\"},\"Invisibility\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Invisibility\"},\"Tongues\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Tongues\"},\"Charm Monster\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Charm Monster\",\"numMem\":1},\"Hold Person\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Hold Person\"},\"Cure Serious Wounds\":{\"level\":\"3rd\",\"damage\":\"3d8+8\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Serious Wounds\"},\"Gallant Inspiration\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Gallant Inspiration\",\"numMem\":1},\"Cure Moderate Wounds\":{\"level\":\"2nd\",\"damage\":\"2d8+5\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Moderate Wounds\"},\"Shatter\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Shatter\"},\"Dispel Magic\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dispel Magic\",\"numMem\":2},\"Silence\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Silence\"},\"See Invisibility\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"See Invisibility\"},\"Dimension Door\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Dimension Door\"},\"Song of Kyonin\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Song of Kyonin\"},\"Mirror Image\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Mirror Image\"},\"Terrible Remorse\":{\"level\":\"3rd\",\"damage\":\"3d6\",\"toHit\":\"No\",\"toHitBonus\":1,\"saveAllowed\":\"Will Save\",\"casterStat\":\"Cha\",\"dcBonus\":1,\"spell name\":\"Terrible Remorse\"},\"Virtuoso Performance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Virtuoso Performance\"},\"Primal Scream\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Primal Scream\"},\"Displacement\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Displacement\"},\"Cure Critical Wounds\":{\"level\":\"4th\",\"damage\":\"4d8+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cure Critical Wounds\"},\"Break Enchantment\":{\"level\":\"4th\",\"damage\":\"d20+13\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Break Enchantment\"},\"Freedom of Movement\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Freedom of Movement\",\"numMem\":1},\"Ki Shout\":{\"level\":\"5th\",\"damage\":\"13d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"Fort Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ki Shout\"},\"Bards Escape\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bards Escape\",\"numMem\":1},\"Acid Fog\":{\"level\":\"5th\",\"damage\":\"2d6\",\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Acid Fog\",\"numMem\":0},\"Unadulterated Loathing\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Unadulterated Loathing\"},\"Wish\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Wish\"},\"Youthful Appearance\":{\"level\":\"4th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Youthful Appearance\"},\"Fire Breath\":{\"level\":\"5th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fire Breath\"},\"Fireball\":{\"level\":\"3rd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fireball\"},\"Ablative Barrier\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Ablative Barrier\"},\"Cackling Skull\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Cackling Skull\"},\"Badgers Ferocity\":{\"level\":\"1st\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Badgers Ferocity\"},\"Daemon Ward\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Daemon Ward\"},\"Fabricate\":{\"level\":\"6th\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate\"},\"Fabricate Bullets\":{\"level\":0,\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Fabricate Bullets\"},\"Bears Endurance\":{\"level\":\"2nd\",\"damage\":0,\"toHit\":\"No\",\"toHitBonus\":0,\"saveAllowed\":\"No Save\",\"casterStat\":\"Cha\",\"dcBonus\":0,\"spell name\":\"Bears Endurance\"}}']\n[r:var = \"{\"+substring(replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[\\\\w\\\\s]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[\\\\w\\\\s]+\"),', '\\$1:{'), 1, length(replace(json.sort(replace(\"[\"+substring(var, 1, length(var)-1)+\"]\", '(\"[\\\\w\\\\s]+\")\\\\:\\\\{', '{\"tmpJonsSortName\":\\$1,'), \"a\", \"level\"), '\\\\{\"tmpJonsSortName\"\\\\:(\"[\\\\w\\\\s]+\"),', '\\$1:{'))-1)+\"}\"]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8960b21f-ba59-477a-aeb4-044bb57107d7",
          "commandChecksum": "d62f8256ddc3f9a7d8c4c689dc2db610",
          "propsChecksum": "17650fa3ad09133c50221b326ceecd44"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "CORE",
        "includeLabel": false,
        "sortBy": "1",
        "index": 5,
        "label": "onCampaignLoad",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H:'\n\n\n']\n\n[H: '']\n\n[h:prefix = \"bot_\"]\n\n[h:defineFunction(prefix+\"limitMovement\", \"Limit Movement@this\" ,1,0) ]\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a97ea905-66cb-40d7-af3e-4bd99541879b",
          "commandChecksum": "e35b1a8514fe3d3a0f18113b3759229c",
          "propsChecksum": "b4e78d78b4e8752905ed9f4b700fcc94"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "CORE",
        "includeLabel": false,
        "sortBy": "",
        "index": 37,
        "label": "Limit Movement",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"toggles) is set to a number other then 0. The below macro handles movement \n\tlimitation in a very basic form. You can choose to change this to handle more advanced movement limitations. \n\n\tIt uses the same scope as the onTokenMove macro, which means that you have certain variables at your disposal:\n\t- limitMovement:\tis the max amount the token is allowed to move.\n\t- lastPath:\t\t\tan array of coordinates of the path over which the token has moved\n\t- startingLocation:\tthe coordinates where the token started (in the form of an array)\n\t- currentLocation:\tthe coordinates where the token ended (in the form of an array)\n\t- usedMove:\t\t\tthe amount of units (distance per cell, e.g. feet or meters) moved (getMoveCount())\n\t\n\tNote that the actual movement limitation kicks in when:\n\t1. the initiative panel is active and the token is part of it\n\t2. a PLAYER moves the token\n\t3. the space the token is moved is more then its property 'movement' (edit token to change it)\n\t4. \n\t\n\tAn example:\n\tLets say that all the tokens have a characteristic: Dexterity and the max amount of units a token is allowed to move is 4 x Dexterity. \n\tIn addition if a token is Dead or Incapacitated, it cannot move. Lets say that these conditions are set with states in your framework.\n\tThen you could add this piece of code in front of the if() in the macro. \n\t\n\t[h,if(getState('Dead') || getState('Incapacitated'), CODE:{\t\n\t\t[limitMovement = 0]\t\n\t\t[message\t= '%{tok} is incapacitated and cannot move.<br>']\n\t}; {\t\n\t\t[limitMovement = getProperty('Speed')]\n\t}]\n-->\"]\n\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)] \n\n\n[h:tok \t\t\t= getSelectedNames()]\n\n[h,if(getState('Dead')), CODE:{\t\n\t\t[limitMovement\t= 0]\t\n\t\t[message\t\t= strformat(\"%{tok} is incapacitated and cannot move.<br>\")]\n\t}; {\n\t\t[message\t\t= \"\"]\n\t\t\n\t\t[if(!isNumber(limitMovement)): limitMovement\t= getProperty(limitMovement)]\n\t\t\n\t\t[if(limitMovement == \"\"): limitMovement = 0]\n}]\n\n\n[if(listCount(tok) > 1), CODE:{\n\t\n\t\n\t[tok = listGet(tok, 0)]\n\t[switchToken(tok)]\n\t\n\t[initInUse\t= !json.isEmpty(json.get(getInitiativeList(),\"tokens\"))]\n\t\n\t[singleMove = 0]\n}; {\n\t\n\t\n\t[initInUse\t\t= if(getInitiative() != \"The token is not in the initiative list.\", 1, 0)]\n\t[singleMove = 1]\n}]\n\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map+\".W42.Limit\")), CODE:{\n\t[thisMapLimits\t\t\t= json.get(linkedAreas, map+\".W42.Limit\")]\n\t[ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n\n\t[output = strformat(\n\t\t\"<b><u>MOVE ACTION OF %{token.name}<\/u><\/b><br>\n\t\tMax allowed move is: \"+limitMovement+\"<br>\n\t\tAreas Checked: %s<br>\n\t\tStart coord: %{startingLocation}, Current coord: %{currentLocation}<br>\n\t\tYou moved: %{usedMove}<br><br>\", json.fields(thisMapLimits)\n\t)]\n\n\t[foreach(areaName, thisMapLimits,\"<br>\"), CODE:{\n\t\t[h:areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n\t\t[h:intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n\t\t[h:eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n\t\t[h:diffCount\t\t\t= json.length(intersectPath)*DpC]\n\t\t[h:modifier\t\t\t\t= if(areaName == \"Very Difficult Terrain\", 2, 1)]\n\t\t[h:totalDiff\t\t\t\t= diffCount*modifier]\n\t\t[h:usedMove\t\t\t\t= usedMove + totalDiff]\n\t\t\n\t\t[h:output = output + strformat(\n\t\t\t\"<b>Area: %{areaName}<\/b>\n\t\t\toverlap with last path: %{intersectPath}<br>\n\t\t\tTrigger Type: %s<br>\n\t\t\tYou moved %{diffCount} (+%{totalDiff} move) over %{areaName}<br>\", bot_getEventType()\n\t\t)]\n\t}]\n\n\t[output = output + strformat(\"In total you moved: %{usedMove}\")]\n\t[broadcast(output)]\n}]\n\n[h:'pause(\"initInUse\", \"tmp\", \"usedMove\" , \"usedMove\" ,\"limitMovement\")']\n[h,if( !isGM() && initInUse && usedMove && usedMove > limitMovement), CODE:{\n\t\n\t[broadcast(strformat(\"%{message}You moved <i>%{tok}<\/i> <b>%{usedMove}<\/b> units. The maximum allowed movement is <b>%{limitMovement}<\/b> units.\"))]\n\t\n\t[tokens.denyMove\t= 1]\n\t[doAbort\t\t\t= 1]\n\t[resetMove\t\t\t= 1]\n\t[lastPath\t\t\t= \"[]\"]\n\t[if(singleMove): currentLocation\t= startingLocation]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b2accfa2-9338-4a48-b357-5090f1b14642",
          "commandChecksum": "ee376969b649c808f897a4a3a4e53f62",
          "propsChecksum": "2bb156e53c8be13585c7fd04c7b50560"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 38,
        "label": "test",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n[h:'']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "26b25929-8452-4290-b202-1ba4417f2426",
          "commandChecksum": "6d452ecf8151c26cf27012a6a3ee1bea",
          "propsChecksum": "7bb531172e9a4adb01f19f10cd4c2330"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 39,
        "label": "Standard Trap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:me = arg(0)]\n[h:event = arg(1)]\n[h:triggerType = arg(5)]\n\n\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:attackRoll = d20]\n[h:roll=1d6]\n[h,if(attackRoll > Dexterity):HP=HP-roll]\n[h,if(attackRoll > Dexterity):broadcast(\"You have triggered a trap and sustained \"+roll+\" hits.<br>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "91294cc7-e5dc-45a2-8775-22c564801a22",
          "commandChecksum": "7cd474a588e38765825e3720b3f32078",
          "propsChecksum": "e2a46f61e6f31716aeed0d9da5be2ae2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 40,
        "label": "Standard Net Trap",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n[h:netTrapPad\t\t\t= \"net trap 1\"]\n\n\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(netTrapPad): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've triggered a net trap<br>\")]\n\t[h: AgTest = \"Failed\"]\n\t[h: setState('Trapped', 1, me)]\n}; {\n\t[h:'']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly triggered a trip wire, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\t[h: setState('Trapped', 0, me)]\n\n\t[h:'']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "1ea8793c-405a-4152-b079-b71994b0ea21",
          "commandChecksum": "f5c6b11d3915b7305aeb3baab187ea62",
          "propsChecksum": "acca3b877f8d1e737dc60dfa0cf4921f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Door Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 9,
        "label": "Typical Door",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h:'']\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:thisPlayer\t\t\t= arg(1)]\n[h:tokList\t\t\t\t= arg(2)]\n[h:byStanders\t\t\t= arg(3)]\n[h:door\t\t\t\t\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n[h:doorIsOpened\t\t\t= arg(6)]\n[h:isLocked\t\t\t\t= arg(7)]\n\n\n[h:assert(triggerType == \"door\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to door: \"+door, 0)]\n\n\n[h:switchToken(me)]\n\n\n\n[h, if(isLocked), CODE:{\n\t\n\n\t\n\t[broadcast(\"You try to open the door but it won't budge, perhaps its locked?\",thisPlayer)]\n\n\t\n\t[broadcast(me+\" tries to open the door but it appears to be locked\",byStanders)]\n\t\n\t\n\t[abort(0)]\n}; {\n\t\n\t\n\t[if(doorIsOpened): broadcast(\"The door makes a loud 'SQUEEEEEK' noise when you open the door\", thisPlayer); broadcast(\"You close the door with an audible 'CLICK' \", thisPlayer)]\n\t\n\t[if(doorIsOpened): broadcast(\"With a loud 'SQUEEEEEK' the door opens\", byStanders); broadcast(\"The door closes with an audible 'CLICK' \", byStanders)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "124bd189-a1c9-4667-92dc-006539c1cb78",
          "commandChecksum": "566b3253c9a29f627f17a8d5fc2948b2",
          "propsChecksum": "9616bed12e61a8616d65af61560b512e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 10,
        "label": "Teleport All",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "1c075abc-4f1a-445a-afc8-014a272c57ae",
          "commandChecksum": "0ce027f6e2e7211a2d44b5e2727d2b52",
          "propsChecksum": "65273f789758e107503646002efdbbf2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 11,
        "label": "Red Team Teleport",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1, 'Red')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "a0230933-d170-4880-8745-cd73b9dc1354",
          "commandChecksum": "fea45a2bd165cedd8929fccbbc0c688a",
          "propsChecksum": "7db33fe8edfb830652e1e6fe7cc8874f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 12,
        "label": "Green Team Teleport",
        "fontSize": "0.90em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads(1, 'Green')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "a56356a8-e105-4f8e-abbf-e4fccc080892",
          "commandChecksum": "05930631de42a9183f36c8417e915665",
          "propsChecksum": "ca6e06317d09a9e07a9ac0e83029cf3d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 13,
        "label": "Teleport Message",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"Message for you sir \"+tok, \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "83a5aa3d-a9a7-4514-806a-faff53bec851",
          "commandChecksum": "ccc46eb2321136f0f4e161663914ef8a",
          "propsChecksum": "afef034ce32ce633426e955873c30dbd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 14,
        "label": "Tel Pre Message",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[broadcast(macro.args)]\n[h:bot_animateText(\"Teleporting in 5,     4,     3,     2,    1     \", \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "ae019f0a-0236-4ebd-8c02-b2ad5e97e58c",
          "commandChecksum": "5eabfb146f952fea016972685c3bf35b",
          "propsChecksum": "1999d1fdf8ffba22f9660f800c1716f7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 15,
        "label": "InterTel Msg",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(tok+\" is being teleported from \"+oldMap+\" to \"+newMap,\"Inter map teleport\", 0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "77b2314a-88c4-4e95-a724-e089a11631ab",
          "commandChecksum": "81e2fbdc7b2a7ab444c70a4213bae822",
          "propsChecksum": "2dfe97858d7241bea264d5ea9ca625a5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 16,
        "label": "onTokenMoveTrigger",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:broadcast(arg(0)+\" moved!\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "ab222fde-ea8d-41cd-b599-869ec8a8341e",
          "commandChecksum": "4accc44e4f2065b6f0d389483e9949f3",
          "propsChecksum": "1578dc9c2aed4aed6bf869010aff29e9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Button macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 20,
        "label": "Switch To Map",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n\n\n[message = \"Click Ok to switch to map: \"+getStrProp(arg(0),\"mapName\")]\n[pause(\"message\")]\n\n[h:bot_switchMap(mapName, 1)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "d0a24cc5-67ff-4656-8224-7502d257e39c",
          "commandChecksum": "5900bb53f8df31e8717f123f7d79177b",
          "propsChecksum": "5de845fa5e7d62aec73fb3635408f53d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Button macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 22,
        "label": "Test Event Button",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:varsFromStrProp(arg(0))]\n[h:bot_animateText(\"The following button was selected: \"+getSelectedNames()+\"<br>The following arguments were passed: \"+arg(0), \"Test message\",0,\"default\",\"300\",\"50\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "81c05ba0-5668-4758-b834-f9f80374ef3c",
          "commandChecksum": "794c90157c1a26080fc384c082faf925",
          "propsChecksum": "43d8f983eaf4e0087bb87a0c30efdbdc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 23,
        "label": "HillTopVBL",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n\n\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(padName)]\n[h:onHill\t\t\t\t= if(event==\"movedON\",1,0)]\n[h:offHill\t\t\t\t= if(event==\"movedOFF\",1,0)]\n\n[h:preHillCount\t\t\t= 0+getProperty(\"w42.bot.hillCount\")]\n[h:postHillCount\t\t= max(0,preHillCount+onHill-offHill)]\n[h:setProperty(\"w42.bot.hillCount\", postHillCount)]\n\n[h,if(!preHillCount && postHillCount), CODE:{ \n\t[vbl\t= getTokenVBL()]\n\t[setProperty(\"w42.bot.hillVBL\", vbl)]\n\t[setTokenVBL(\"{'shape':'none'}\")]\n}]\n[h,if(preHillCount && !postHillCount), CODE:{ \n\t[vbl\t= getProperty(\"w42.bot.hillVBL\")]\n\t[setTokenVBL(vbl)]\n}]\n\n\n[h:broadcast(\"there are \"+postHillCount+\" token on the hill\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "4116afce-146a-4e70-810c-143aeb106c19",
          "commandChecksum": "893eb1a1ed7fdd93e838a96d3aa0b5b2",
          "propsChecksum": "e80504afb0302f8e438c28a230c5ee85"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 26,
        "label": "Standard Pit",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n[h:me\t\t\t\t\t= arg(0)]\n[h:event\t\t\t\t= arg(1)]\n[h:padName\t\t\t\t= arg(2)]\n[h:lastPath \t\t\t= arg(3)]\n[h:eventPadTriggered\t= arg(4)]\n[h:triggerType\t\t\t= arg(5)]\n\n\n[h:assert(triggerType == \"pad\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n[h:trapped = if(event==\"movedOff\" || event==\"movedReturn\",1,0)]\n\n[h:attackRoll = 1d20]\n[h,if(attackRoll > Dexterity), CODE:{\n\t[h:'']\n\t[h:entryPoint = json.get(eventPadTriggered, 0)]\n\t[h:x = json.get(entryPoint, \"x\")]\n\t[h:y = json.get(entryPoint, \"y\")]\n\t[h:iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[h:lastPath = if(trapped, json.get(lastPath, 0, 0), json.get(lastPath, 0, iEntryPoint-1) )]\n\n\t[h, token(padName): setTokenImage(getTokenHandout())]\n\t[h: moveToken(x, y)]\n\t[h: txtOut = if(trapped,\"You failed to climb out<br>\",\"you've fallen into a pit<br>\")]\n\t[h: AgTest = \"Failed\"]\n}; {\n\t[h:'']\n\t[h: txtOut = if(trapped,\"You succeed to climb out<br>\", \"You nearly fell into a pit, but succeeded your Ag test. Rethink your next move!!<br>\")]\n\t[h: AgTest = \"Success\"]\n\n\t[h:'']\n\t[h, if(event == \"movedOn\"), CODE: {\n\t\t[entryPoint\t\t= json.get(eventPadTriggered, 0)]\n\t\t[iEntryPoint\t= json.indexOf (lastPath, entryPoint)]\n\t\t[edgePoint\t\t=  json.get(lastPath, iEntryPoint-1)]\n\t\t[lastPath\t\t=  json.get(lastPath, 0, iEntryPoint-1)]\n\t\t\n\t\t[x\t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t[moveToken(x, y)]\n\t}]\n}]\n[h:broadcast(txtOut)]\n[h:macro.return = lastPath]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "28d4767f-46bb-4af9-8913-2452fba0990a",
          "commandChecksum": "e38bd298dba75a16127625a72a5a3653",
          "propsChecksum": "005c01dd25cbd2a7d0dc69e23ef610f0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event Pad Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 27,
        "label": "Night Vision",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n[h:triggerType\t= arg(5)]\n\n\n[h:assert(triggerType == \"pad\" || triggerType == \"area\", \"The GM has assigned a wrong trigger type: <i>\"+triggerType+\"<\/i> to this pad\", 0)]\n\n[h:switchToken(me)]\n\n[h,if(event == \"movedOn\"):\tsetSightType(\"Lowlight\")]\n[h,if(event == \"movedOff\"):\tsetSightType(\"Normal\")]\n\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0c5a0b7c-356c-44bc-b8d2-680ced9ef64e",
          "commandChecksum": "4739ea4d98d46b873f2f5100ccd4bc7c",
          "propsChecksum": "7042ab207bf1611608a32f8cb1a011af"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Event list macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 28,
        "label": "Excl FoW Maps",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[h:'']\n\n[h, if(listContains(\"BASE\", getCurrentMapName())): doResetFoW = 0]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "d76dfc33-7a01-4d63-bc43-cd923dc857f6",
          "commandChecksum": "98d15388ea40b6a0ae9bd10cf56f42e2",
          "propsChecksum": "68dc7460d24b9ca5cf43a28108178a59"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Benchmark Macros",
        "includeLabel": false,
        "sortBy": "",
        "index": 29,
        "label": "Default",
        "fontSize": "1.00em",
        "minWidth": "90",
        "playerEditable": false,
        "command": "",
        "maxWidth": "",
        "tooltip": "<html><b>DO NOT DELETE<\/b><br>This macro is used as reference to check how much time it takes<br>(during the benchmark) to run an empty macro.<br>The resulted value is deducted from the time of the benchmark macros",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d1256e18-115e-4683-8bf3-bbf15f7e8f77",
          "commandChecksum": "d41d8cd98f00b204e9800998ecf8427e",
          "propsChecksum": "f2585b27c5a0d81a5b40c180a41ccd7a"
        }
      }
    ]
  }},
  "Lib:AutoOCL": {".01a":   {
    "mtversion": "1.8.5",
    "timestamp": "2021-05-06T10:05:04.8803184-07:00",
    "notes": "Proof of concept to automatically run OCL.",
    "gmnotes": "",
    "properties":     {
      "AC": "",
      "Charisma": "",
      "Constitution": "",
      "Defense": "",
      "Description": "",
      "Dexterity": "",
      "Elevation": "",
      "HP": "",
      "Intelligence": "",
      "Movement": "",
      "Strength": "",
      "Wisdom": "",
      "libVersion": ".01a"
    },
    "macros":     [
            {
        "autoExecute": true,
        "color": "#a0ffa0",
        "fontColor": "black",
        "group": "",
        "includeLabel": false,
        "sortBy": "",
        "index": 1,
        "label": "Test",
        "fontSize": "1.20em",
        "minWidth": "85px",
        "playerEditable": false,
        "command": "[h, if(!isFunctionDefined(\"OCL.TheDoors\")):\t\n\texecLink( macroLinkText(\"onCampaignLoad@\" + getMacroLocation()) )]\n\n[h: LibOutput()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4ac8184-ee2a-49db-84df-09866a3d73b8",
          "commandChecksum": "91bab046f35b91b4809d9e98333e2883",
          "propsChecksum": "a812b4e52326422a9e827a9516032f6d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1.0 Under the hood",
        "includeLabel": false,
        "sortBy": "",
        "index": 2,
        "label": "onCampaignLoad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: defineFunction(\"OCL.\" + getLibProperty(\"libOCL\"), \"onCampaignLoad@\" + getMacroLocation())]\n[h: defineFunction(\"LibOutput\", \"output@\" + getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a2618687-056a-4c36-be18-311d25714475",
          "commandChecksum": "dfcecee60d59eaadca85896c5e24c9a7",
          "propsChecksum": "ca7fc93725da4b23dd94c36eea704505"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1.0 Under the hood",
        "includeLabel": false,
        "sortBy": "",
        "index": 4,
        "label": "output",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: broadcast(\"<b style='color:green'>This macro was called with the following functions defined:<\/b><pre>\" + json.indent(json.get(getInfo(\"client\"), \"user defined functions\"), 2) + \"<\/pre>\")] ",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "720ea64f-8a8b-4d9c-a3c7-8d6decba3874",
          "commandChecksum": "14603eff09c8cbc9f2e5b793f7101728",
          "propsChecksum": "1a78185abe320cd79e09c75b4969aafe"
        }
      }
    ]
  }},
  "lib:OnTokenMove": {"48":   {
    "mtversion": "1.8.5",
    "timestamp": "2021-05-06T10:05:12.8303181-07:00",
    "notes": "\n\n",
    "gmnotes": "Click \"onCampaignLoad\" to activate automatic stair and doors transitions! \n(Teleports, InterTeleports and the one way teleports)\nThe onCampaignLoad button can be found on the 'selection panel'\n\nWhen the animation of the doors stop working and start to create all kinds of duplicates, then the autoexec on the other clients doesn't work anymore. This usually happens when the ownership of this tokens has been assigned to someone not online. Make sure NO OWNERS ARE SET FOR THIS LIB:TOKEN",
    "properties":     {
      "---------INSTALLED FEATURES-----": "",
      "--------FEATURES-------": "",
      "--diagnose--": "",
      "--menu--": "",
      "____Library_Basic_Data____": "",
      "____Library_Meta_Data____": "",
      "am.bot.disguiseMacro":       {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "includeLabel": false,
        "sortBy": "81",
        "label": "Use Disguise",
        "fontSize": "11pt",
        "minWidth": "90",
        "playerEditable": false,
        "command": "[H: bot_useDisguise()]",
        "maxWith": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "toolapplyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1e79f6ba-9681-499d-b231-c97cdcbf358a",
          "commandChecksum": "0ce1dac741989645cee926b9ff11ef4e",
          "propsChecksum": "b6fd6357814530597380f5d611697495"
        }
      },
      "bot.fg.Animations":       [
                {
          "Group_Name": "Animations",
          "Function": "Animated Doors",
          "Type": "Menu Macro",
          "Dependencies": "State: Locked; Token: DoorLeverToken",
          "Macro_Group": "Door Animation",
          "Description": "Full functionality to setup animated doors, both single and double, both rotating and sliding. Including support to activate them in at least 5 different ways. "
        },
                {
          "Group_Name": "Animations",
          "Function": "VBL on Doors",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Door Animation",
          "Description": "Toggling (open or close) an animated door will give the following options: look through key-hole, look through window, crack door open, open door half way, open door fully. The VBL will be adjusted accordingly"
        },
                {
          "Group_Name": "Animations",
          "Function": "Token door switches (with proximity check)",
          "Type": "Menu Macro",
          "Dependencies": "State: isButton",
          "Macro_Group": "Door Button",
          "Description": "Set up a door with a switch token that corresponds with that door when you click on the switch. Option for the gm to 'Lock' the door, so players can't open it. You can also set a proximity check, that checks whether a token of the player is close enough to open the door."
        },
                {
          "Group_Name": "Animations",
          "Function": "Animate Token Movement Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "A macro and macro button with which you can animate the movement of one or more tokens. See video"
        },
                {
          "Group_Name": "Animations",
          "Function": "Animate Token Movement Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "Same as the macro only in the form of a macro function that you can call inside your own macros."
        },
                {
          "Group_Name": "Animations",
          "Function": "Animated text Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "A macro that generates an input screen where you can setup the animated text. This will pop up a frame on every client pc showing a frame where a delayed text is printed in"
        },
                {
          "Group_Name": "Animations",
          "Function": "Animated text Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Animate Move",
          "Description": "Same as the macro only in the form of a macro function that you can call inside your own macros."
        },
                {
          "Group_Name": "Animations",
          "Function": "Set View Animation",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Use lastpath of selected token to run a screen animation"
        },
                {
          "Group_Name": "Animations",
          "Function": "Link View Animations",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Link the view animation of selected tokens and store it on one token"
        },
                {
          "Group_Name": "Animations",
          "Function": "Run View Animation",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "Run view animation created for selected token"
        }
      ],
      "bot.fg.EventTokenArea":       [
                {
          "Group_Name": "Event token and area support",
          "Function": "Transparent Roofs",
          "Type": "Token",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Roof) When a token moves onto a building (with a roof) the roof automatically turns transparent (with a red halo) and return opague again when the token moves away from it. For this to work you will need to install the tabel into your framework inside the attached zip file."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Roof VBL Swap",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "in addition to existing Roof swap function, an option is added where you can store the VBL currently on a building and swap it with a VBL cross shape. Hence from the outside players can see the partially and as soon as they enter the building the VBL of the roof is swapped with the VBL of the building."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Warded Roofs",
          "Type": "Token/Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Roof) Roofs have now a corresponding 'set roof' macro with which you can assign doors to the roof. If doors are assigned, the Roof automatically becomes a 'warded' area, which you can ONLY enter through the OPEN door. Thus if the door is closed, there is no way a player can move her token onto the roof. If the door is open, a player can ONLY move in the building when it moves her token OVER the door token first."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Foliage",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Foliage) Tokens with these names work exactly as roofs, except there will be NO red halo outline for the transparent version AND you can choose to use a different picture to swap with when you move over it. (on default when you move over them their image is swapped with an transparent image from the tables)."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Canopy",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Canopy) Tokens with these names are automatically given an treetrunk as alternative image when a token moves over them."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Warded Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros",
          "Description": "(Ward) Tokens that move onto this area are moved back to their original position. They cannot enter the area."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Event Pads",
          "Type": "Token/Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Event Macros",
          "Description": "(EventPad) These tokens are triggered on certain event e.g. when a token move onto the pad. These events can be set through a 'set event pad' macro. These pads replace the former Pit and Trap pads and allow for a much more versatile use. When the pad is triggered then a macro that you linked to it will run. Extra example is added: trip wire in combination with a net trap (thnx Pinkrose)"
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Canopy, Foliage, Roof) Linked tokens are special pads that are activated simultaneously. If you have two or more tokens that are linked by the same link identifier, e.g. 'Linked 1 Roof 5' and 'Linked 1 Canopy 3' (here the link identifier is '1'), then when one of the tokens is activated (by moving a token on top of it) the other is activated as well."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Bridge Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(i.c.w. Canopy, Foliage, Roof) Bridges are pads that you link with Canopy, Foliage or Roof pads. When you move over a Bridge and then onto a Roof (in one move) then the roof does NOT dissapear (See vid. tutorial for more info)."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Linked Tunnel Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(i.c.w. Canopy, Foliage, Roof) Tunnels work exactly the same as Bridges albeith the opposite effect. So when moving over a tunnel token the roofs disappear, while moving directly onto a roof they won't."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Shadow Pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; ShadowPads",
          "Description": "(ShadowPads ) This allows to watch token movement on map A from map B. Typical use is a 2 story building where you can watch the ground floor from the first floor through a gap in the floor (and vice versa). See vid tutorial for more details."
        },
                {
          "Group_Name": "Event token and area support",
          "Function": "Event Areas",
          "Type": "Area",
          "Dependencies": "State: Special Area; Token: Area Marker",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof; Event Area Macros",
          "Description": "These are Areas you can define (and these can take ANY form, with a resolution of the grid) and depending whether a token moves onto, over, off, etc. it will trigger an event (macro). The best use for these are to define difficult terrain areas which impede the movement of a token. For which the 'Limit Movement' macro in the lib:EventMacros lib is now adapted.<br>Finally one other good thing of these areas: they're FAST! A lot faster then the token method currently in use."
        }
      ],
      "bot.fg.Functions": [      {
        "Group_Name": "Function Macros",
        "Function": "Function Macros",
        "Type": "Function Macro",
        "Dependencies": "None",
        "Macro_Group": "Geofunctions Support; Geofunctions; Util - Math; Message; Util - General; Util - Documented",
        "Description": "<a href='macro://manFunctionsTxt@Lib:OnTokenMove/none/Impersonated?'>Bot Function Manual (for overview)<\/a>"
      }],
      "bot.fg.GroupList": "bot.fg.Transportation,bot.fg.EventTokenArea,bot.fg.UtilityMove,bot.fg.UtilityGeneral,bot.fg.Tables,bot.fg.Animations,bot.fg.MapCreation,bot.fg.VBL,bot.fg.Other,bot.fg.Functions",
      "bot.fg.MapCreation":       [
                {
          "Group_Name": "Map Creation macros",
          "Function": "Scatter",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "Select one or more tokens, set an area and a number and copies of the tokens will be randomly scattered accross the preset area. Ideal for e.g. rocks, trees, or a chaos warband."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Building A Forest",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "A macro to build a big forest FAST and have it ready for the Canopy 'Trick'. This is a specialized macro based on the 'Scatter' macro"
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Summon tokens",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Summon",
          "Description": "A macro with which you can summon tokens from the 'BASE' map onto the current.map . The location you can set by hand or you can summon it onto a selected token."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Fill Area",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "A macro that with which you can quickly fill an area with tokens (also useful for creating special areas)."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Draw Order Edit Panel",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Order",
          "Description": "With this panel you can edit the draw order of the selected tokens, rotate them individually, random or as a group. It also contains layer and shape dropdown list."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Crowd Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Scatter",
          "Description": "An new set of macros that allows you to fill a e.g. Town square with tokens (forming a crowd), which can then 'flee in panic' when the fight goes down."
        },
                {
          "Group_Name": "Map Creation macros",
          "Function": "Map Editor",
          "Type": "Menu Macro/Area",
          "Dependencies": "State: editFieldMarker; Token: GridCoordMarker",
          "Macro_Group": "Scatter",
          "Description": "Two new macro to create a field on the map where its VERY easy to place token, used for map creation. Try it out for more info."
        }
      ],
      "bot.fg.MenuButtons": "Manual=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+pops+up+a+user+manual+of+this+tool%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmanualText%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EManual%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Settings=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EHere+you+can+set+stuff+as+a+different+name+for+BASE+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fsettings%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3ESettings%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; BoTFeatures=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Chtml%3EChange+the+installed+BoT+features.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfeatureTable%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EBoT+Features%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; InitializePads=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+cycles+through+all+maps+in+the+campaign+file%3Cbr%3Elooking+for+special+pads.+It+will+initialize+any+special+pad+it%3Cbr%3Eencounters+and+report+any+errors++on+the+way%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FinitializePads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EInitialize+Pads%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AltInitPads=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Apurple%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EIn+contrast+to+initialize+Pads%2C+this+macro+does+ONLY+initialize+the+CURRENT+map.%3Cbr%3E+It+uses+a+completely+different+and+more+time+consuming+method+for+this.%3Cbr%3EResulting+in+a+map+where+the+movement+of+tokens+is+less+snappy+in+general%3Cbr%3E+But+will+be+%28a+lot%29+faster+when+there+are+a+lot+%28%3E100%29+special+tokens+on+a+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FaltInitMap%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EAlt.+Init.+Pads%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ActivateSwitches=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23FFA500%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+activates+a+frame.+As+long+as+that+frame+is+open+the+following+functions+are+active%3A%3Cbr%3E-+Door+Switches+%28user+can+click+them+to+open+doors%29+%3Cbr%3E-+Event+Buttons+%28user+can+click+them+to+activate+linked+macro%29+%3Cbr%3E-+Full+screen+mode+%28if+turned+on+in+the+settings%2C+frames+are+automatically+turned+into+Dialogs%29+%3Cbr%3E-+Group+select+tokens+%28user+can+select+one+token+and+the+rest+is+auto-selected%29%3Cbr%3E-+Force+token+selection+%28token+that+gm+selects+on+his+client+is+also+selected+on+a+player+client%29%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FopenFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EActivate+Switches%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetSound=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ETo+setup+sound+pads%3C%2Fi%3E+macro%2C+select+one+SoundPad+token+and+click+this+button+to+set+it+up%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetupSound%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESetup+Sound+Pad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ClearSound=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+stop+ALL+sounds+currently+streaming%2Fplaying+AND+removes+them+from+memory%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearSound%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EClear+all+sounds%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ReplaceSoundURL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+search+and+replaces+all+URLs+for+ALL+soundpads+in+the+campaign+file%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchangeAdress%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ES%26R+all+sound+URL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetDoor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ETo+use+the+%3Ci%3EToggle+Door%28s%29%3C%2Fi%3E+macro%2C+select+one+or+more+doors+and+click+this+button+to+set+it+up%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetDoor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Door%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetRoof=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EHere+you+can+give+a+list+of+%3Ci%3Eentry+doors%3C%2Fi%3E+through+which+a+token+can%3Cbr%3Eenter+the+building.+Note+that+these+doors+MUST+be+on+the+edge+of+the%3Cbr%3Eroof+%28like+real+doors%29.+If+you+leave+this+list+empty%2C+a+token+can+move%3Cbr%3Eanywhere+on+or+over+the+%3Ci%3Eroof%3C%2Fi%3E+token%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetRoof%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Roof%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; BuildForest=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+one+ore+more+images+of+a+Tree+top+%28Canopy%29+and+click+this+button+to+randomly+spread+them+over+an+area%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FbuildForest%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EBuild+Forest%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ChooseTrunks=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+form+where+you+can+select+or+deselect+tree+trunk+images%3Cbr%3Ewhich+are+on+the+BASE+map.+The+checked+images+will+be+%28randomly%29+used+for+the+%3Ci%3ECanopy%3C%2Fi%3E+pads%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchooseTrunks%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChoose+Trunks%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EUse+this+macro+to+create+a+square+filled+with+tokens+%28a+crowd%29%2C%3Cbr%3Ethat+can+later+be+dispersed+by+using+the+%3Ci%3Emove+crowd%3C%2Fi%3E+macro%3C%2Fhtml%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcreateCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ChooseCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+form+where+you+can+select+or+deselect+crowd+tokens+images%3Cbr%3Ewhich+are+on+the+BASE+map.+The+checked+images+will+be+%28randomly%29+used+for%3Cbr%3Ethe+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchooseCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChoose+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ScatterTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+will+%3Ci%3Escatter%3C%2Fi%3E+selected+tokens+over+the+map%2C+according+to+the+set+parameters%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fscatter%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EScatter+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MassVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+draws+VBL+crosses+on+all+tokens+that+match+a+search+string%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMass+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DrawArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+fills+up+an+area+with+tokens.+You+can+either+select+ONE+token+and+run+it%2C+or+run+it+without+selection.%3Cbr%3EIf+you+select+one+token+before+you+run+this+then+that+token+will+be+added+to+the+dropdown.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleAreaDraw%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E0.+Draw+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetEventPad=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+can+be+used+to+link+an+Event+Macro+to+an+EventPad%3Cbr%3E%3Cbr%3E1.+Create+a+macro+on+the+lib%3AEventMacros+token+in+the+group%3A%3Cbr%3E%26%2339%26semi%3BEvent+Pad+Macros%26%2339%26semi%3B%2C+containing+the+code+that+is+activated+when+the%3Cbr%3EEvent+is+triggered.+For+example+%26%2339%26semi%3BSpear+Trap%3Cbr%3E2.+Select+an+%26%2339%26semi%3BEvent+token%26%2339%26semi%3B.+This+is+a+token+which+name+starts+with%3Cbr%3E%26%2339%26semi%3BEventPad+%26%2339%26semi%3B+e.g.+%26%2339%26semi%3BEventPad+1%26%2339%26semi%3B+or+%26%2339%26semi%3BEventPad+Pit+Trap%26%2339%26semi%3B.%3Cbr%3EThis+token+can+be+placed+on+any+layer%3Cbr%3E3.+Run+the+macro+%26%2339%26semi%3BSet+Event+Pad%26%2339%26semi%3B%3Cbr%3E4.+Pick+an+Event+macro+from+the+list%2C+e.g.+%26%2339%26semi%3BStandard+Pit%26%2339%26semi%3B%3Cbr%3E5.+Then+select+the+events+on+which+this+macro+is+triggered%3Cbr%3E7.+Click+OK+%3Cbr%3E8.+Run+%26%2339%26semi%3BInitialize+Maps%26%2339%26semi%3B%3Cbr%3E%3Cbr%3EThe+Event+Pad+is+now+set%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetEventPad%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Event+Pad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FillArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+fills+a+predefined+area+with+tokens%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfillArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E1.+Fill+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ResetPit=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+pop-up+with+all+the+initialized+doors.+Here+you+can+select+which+to+open%2Fclose%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FresetPit%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EReset+Pit%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DefineArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+define+an+Event+Area+which+you+then+can+link+to+an+event+macro%2C+to+be+triggered+when+a+token+moves+over+this+area.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdefineArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E2.+Define+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetEventButton=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+can+be+used+to+link+an+Event+Macro+to+a+Event+Button.%3Cbr%3E%3Cbr%3E1.+Create+a+macro+on+the+lib%3AEventMacros+token+in+the+group%3A+%26%2339%26semi%3BEvent+Button+Macros%26%2339%26semi%3B%2C+containing+the%3Cbr%3Ecode+that+is+activated+when+the+button%2C+e.g.+%26%2339%26semi%3BSwitch+To+Map%26%2339%26semi%3B%3Cbr%3E2.+Select+the+button+%28any+token+will+do%29+to+which+that+macro+should+apply+e.g.+%26%2339%26semi%3BSwitch+to+Fair+Haven%26%2339%26semi%3B%3Cbr%3E3.+Run+this+macro%3Cbr%3E4.+Select+%26%2339%26semi%3BSwitch+Map%26%2339%26semi%3B+from+the+list%3Cbr%3E5.+In+the+%26%2339%26semi%3BGive+Arguments%26%2339%26semi%3B+box+enter+the+arguments+as+a+stringproperty%2C+e.g.%26%2339%26semi%3BtoMap%09%09%09%3D+Fair+Haven%26%2339%26semi%3B%3Cbr%3E%3Cbr%3EHere+it+is+important+that+both+the+the+arguments+name+%28toMap%29+and+the+arguments+%28Fair+Haven%29%3Cbr%3Econtains+ONLY+alphanumeric++characters%21%3Cbr%3ENote+that+you+can+give+multiple+arguments%21+Just+seperate+them+with+a+%26semi%3B.%3Cbr%3EE.g.+toMap%09%09%09%3D+Fair+Haven%26semi%3Bmessage%09%09%09%3D+Going+to+Fair+Haven.%3Cbr%3E%3Cbr%3E6.+Click+OK.+Now+everything+is+set+up%3Cbr%3E%3Cbr%3ETo+use+the+buttons+you+need+to+run+the+macro+%26%2339%26semi%3BActivate+Switches%26%2339%26semi%3B.+This+is+used+for+door+switches%3Cbr%3Ebut+it+will+also+work+for+the+Event+Buttons.+Now+when+thats+done+you+will+notice+a+pop-up.+You+can%3Cbr%3Emake+this+pop-up+small%2C+but+you+cannot+close+it+%28else+the+buttons+will+not+work%29.%3Cbr%3E%3Cbr%3EIf+you+now+click+on+the+button+%26%2339%26semi%3BSwitch+to+Fair+Haven%26%2339%26semi%3B+the+macro+%26%2339%26semi%3BSwitch+Map%26%2339%26semi%3B+is+activated.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetEventButton%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Event+Button%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AssignArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+link+predefined+Areas+to+Event+Macros+and+to+the+Limit+Movement+macro%3Cbr%3EThe+Event+Macro+will+be+triggered+when+a+token+moves+over+the+Area.+The+handling+of+this+is+left%3Cbr%3Eto+the+macro+itself%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FassignArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E3.+Assign+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UnShowArea=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+predefined+areas+by+putting+token+in+the+cells+that+are+part+of+the+Area.%3Cbr%3EWhen+you+run+this+macro+again+the+tokens+are+removed+again.%3Cbr%3E%3Cbr%3EHence+this+macro+can+be+used+to+change+pre+defined+area.+To+do+this+first+run+this+macro%3Cbr%3Efor+the+area+you+wish+to+change.+The+map+will+then+be+filled+with+tokens.+Then+move+these%3Cbr%3Etokens+around%2C+delete+them%2C+copy+them+until+youre+happy.+Then+run+%3Ci%3EDefine+Area%3C%2Fi%3E+and%3Cbr%3Eenter+a+name+for+the+new+Area+%28can+be+the+same+as+the+original+in+which+case+it+will+be%3Cbr%3Eoverwritten%29+and+click+ok.+A+new+Area+is+now+defined.+Finally+you+can+run+Show+Area+again%3Cbr%3Eto+remove+the+tokens.+Note+that+is+you+created+new+tokens+that+these+will+NOT+be+removed+by%3Cbr%3Ethis+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E4.+%28Un%29Show+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UnShowAreaUtil=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+predefined+areas+by+putting+token+in+the+cells+that+are+part+of+the+Area.%3Cbr%3EWhen+you+run+this+macro+again+the+tokens+are+removed+again.%3Cbr%3E%3Cbr%3EHence+this+macro+can+be+used+to+change+pre+defined+area.+To+do+this+first+run+this+macro%3Cbr%3Efor+the+area+you+wish+to+change.+The+map+will+then+be+filled+with+tokens.+Then+move+these%3Cbr%3Etokens+around%2C+delete+them%2C+copy+them+until+youre+happy.+Then+run+%3Ci%3EDefine+Area%3C%2Fi%3E+and%3Cbr%3Eenter+a+name+for+the+new+Area+%28can+be+the+same+as+the+original+in+which+case+it+will+be%3Cbr%3Eoverwritten%29+and+click+ok.+A+new+Area+is+now+defined.+Finally+you+can+run+Show+Area+again%3Cbr%3Eto+remove+the+tokens.+Note+that+is+you+created+new+tokens+that+these+will+NOT+be+removed+by%3Cbr%3Ethis+macro.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowArea%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%28Un%29Show+Area%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AssignTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+assign+token+that+are+on+the+TOKEN+or+HIDDEN+layer+to+Assignpads.%3Cbr%3ETokens+assigned+to+Assignpads+will+be+moved+onto+their+assigned+pad+when+you+run+Execute%3Cbr%3EAssignpads%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FassignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAssign+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Execute=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBefore+you+can+use+this+macro+you+first+need+to+assign+token+to+the+special+Assignpads.%3Cbr%3EOnce+that+is+done%2C+you+can+run+this+macro+and+pick+the+Assignpads+to+be+executed.%3Cbr%3EOn+execution+the+linked+token+will+be+moved+to+its+assigned+pad.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecAssignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExecute%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+create+a+new+BoT+table+by+copy+pasting+a+table+from+e.g.+excel%3Cbr%3Einto+the+text+box.+You+can+use+bot_table%28tableName%2C+optional%3A+column%2C+row%29+to+retrieve%3Cbr%3Ean+entry+from+that+table.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcreateTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+a+list+of+all+available+BoT+tables.+The+one+you+pick+can+be+edited.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EShow+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DeleteTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+a+list+of+all+available+BoT+tables.+The+one+you+pick+will+be+deleted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdeleteTable%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDelete+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CreateMTTable=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+create+a+new+MAPTOOL+table+by+copy+pasting+a+table+from+e.g.+excel%3Cbr%3Einto+the+text+box.+Pasted+entries+should+be+seperated+by+tabs+and+newlines+%28which+happens%29%3Cbr%3Eautomatically+if+you+paste+it+from+excel.+Next+to+that+you+can+use+either+1%2C+2+or+3+entries%3Cbr%3EWhere+the+first+entry+is+the+start+of+the+roll%2C+the+2nd+is+the+end+of+the+roll+range%3Cbr%3Ethe+third+is+the+value+so+either%3A%3Cbr%3E%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E2%26nbsp%26semi%3B%26nbsp%26semi%3B%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E2%26nbsp%26semi%3B%26nbsp%26semi%3B5%26nbsp%26semi%3B%26nbsp%26semi%3B%3Ci%3EYou+summon+a+dragon%3C%2Fi%3E%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fxls2Table%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECreate+MT+Table%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MapEditor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ECreates+a+filed+where+creating+a+token+map+becomes+really+easy.+Hit+this+button+for+more+info.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmapEditor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMap+Editor%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; QuitMapEditor=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStops+the+Map+editor+%28and+removes+the+editor+field%29%3Chtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FquitEditor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EQuit+Map+Editor%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MovetoHidden=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBelongs+to+the+map+editor.+Moves+all+pasted+tokens+to+the+HIDDEN+layer+so+theyre+no+longer+visible.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveToHidden%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+to+Hidden%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MovetoToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBelongs+to+the+map+editor.+Moves+all+hidden+tokens+back+to+the+TOKEN+layer.%3Chtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveToToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+to+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SeekToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+searches+ALL+maps+and+ALL+tokens+and%3Cbr%3Ereturn+those+tokens+of+which+the+first+part+of+%3Cbr%3Etheir+name+matches+with+the+entered+search+string%3Cbr%3E%3Cb%3EPop-ups+on+first+use.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FseekToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESeek+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetLightSource=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThe+power+of+this+button+is+that+you+can+apply+it+to+multiple+tokens+at+once.%3Cbr%3ESelect+all+tokens+you+want+to+set+the+light+for+before+you+hit+this+button.%3Cbr%3EYou+can+set+light+sources+to+exclude+in+the+settings.%3Cbr%3E%3Cb%3EMake+sure+that+no+lightsource+in+the+campaign+setting+contains+a+comma%3A+%2C+%3C%2Fb%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetLightSource%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Light+Source%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetReference=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+is+used+to+setup+the+%3Cb%3EShadow+pads.%3C%2Fb%3E%3Cbr%3E+To+sync+the+movement+of+the+shadow+token+to+the+real+token+two+reference+tokens+are+required.%3Cbr%3E+%3Cbr%3E+To+set+this+up+do+the+following%3A%3Cbr%3E+1.+create+two+tokens+with+the+same+name+where+one+has+the+suffix+%26%2339%26semi%3B+Ground%26%2339%26semi%3B+and+the+other+%26%2339%26semi%3B+Floor%26%2339%26semi%3B%3Cbr%3E+2.+Make+sure+that+the+reference+tokens+are+snapped+to+grid+and+medium+sized.%3Cbr%3E+3.+Place+one+of+the+tokens+on+the+ground+floor+map+and+one+on+the+first+floor+map.%3Cbr%3E+4.+Then+select+one+of+the+reference+tokens+and+hit+this+macro.+Select+the+shadow+pads+to+which+it%3Cbr%3E+should+be+linked+and+hit+ok.%3Cbr%3E+%3Cbr%3E+Read+the+manual+for+more+detailed+instructions.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetReference%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Reference%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Remove20=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+replaces+%2520+with+spaces+%3E+%3C+in+the+selected+token+names%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FremoveP20%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERemove+%2520%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetDrawOrder=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+is+just+a+handy+macro+where+you+can+manually+set+the+draw+order+of+the+token.+%3Cbr%3EA+high+number+means+on+top+of+all+a+low+number+means+below+all.%3Cbr%3EThen+current+number+%28draw+order%29+is+shown+when+you+run+this+macro+on+a+token%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetDrawOrder%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Draw+Order%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; RenumberTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+you+have+used+the+scatter+function%3Cbr%3E+%28especially+icw+Spread%29+then+can%3Cbr%3Erenumber+the+scattered+tokens+before+you+%3Cbr%3Ehit+the+initialize+pads.+Assuming+that+you+%3Cbr%3Ehave+scattered+special+tokens+onto+the+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FrenumberToks%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERenumber+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ToggleSpecial=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+toggles+Canopy%2C+%3Cbr%3EFoliage+or+Roofs+on+or+off.+%3Cbr%3EThis+also+resets+the+tokens.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleSpecial%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Special%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetTokenSize=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+is+usefull+if+you+want+to+use+Alt+Init+Pads+macro+to+initialize+a+map.%3Cbr%3EWith+this+macro+you+can+pre-set+the+size+of+a+token.+So+you+wont+be+asked+%3Cbr%3Efor+it+when+you+run+alt.+init.+maps.%3Cbr%3ENote+that+you+only+need+to+do+this+for+free+size+tokens%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetTokSize%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Token+Size%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CopyDelMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+This+macro+allows+you+to+select+macros+on+the+selected+token.+The+selected+macros+you+can+copy+or+delete.%3Cbr%3E+%3Cbr%3E+In+case+of+%3Cb%3Ecopy%3C%2Fb%3E%2C+they+will+be+stored+in+a+property+on+lib%3AEventMacros.+When+you+select+another+token+you+can+%3Cbr%3E+click+%3Ci%3EPaste+Macros%3C%2Fi%3E.+This+will+open+a+similar+frame+where+you+can+select+the+macros+to+paste+on+the+selected%3Cbr%3E+token.%3Cbr%3E+In+case+of+%3Cb%3Edelete%3C%2Fb%3E+you+have+the+option+to+%3Ci%3Eallow+undo%3C%2Fi%3E.+The+selected+macros+will+be+deleted+from+the+token%3Cbr%3E+and+if+allow+undo+is+turned+on%2C+they+will+be+stored+in+a+property+on+that+token.+So+you+can+later+choose+to+undo+the%3Cbr%3E+process.+%3C%2Fhtml%3E++%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcpyDelMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ECopy%2FDel+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PasteMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+This+button+you+can+use+to+paste+macro+on+the+selected+token.+Before+you+do+this%2C+you+first+need+to+run+the+%3Cbr%3E+Copy%2FDel+Macros+button+on+another+token.+%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpasteMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPaste+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UndoDelMacros=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+If+you+deleted+macros+on+the+selected+token+using+the+Copy%2FDel+Macros+function%3Cbr%3E+AND+you+had+%3Ci%3Eallow+undo%3C%2Fi%3E+turned+on%2C+then+you+can+use+this+function+to+undo%3Cbr%3E+that+process+%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FundoDelMacros%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUndo+Del.+Macros%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FindDuplicates=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EGive+a+list+of+all+tokens+of+all+layers+on+current+map+that+have+the+same+name%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FfindDuplicates%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFind+Duplicates%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PadExplorer=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+shows+all+special+pads+on+the+current+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FinitializeMap%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPad+Explorer%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AutoDisguiseBttn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+you+click+this%2C+a+text+box+will+appear+with%3Cbr%3Ea+token+property+you+can+add+to+your+Campaign%3Cbr%3EProperty+token+properties+to+automatically%3Cbr%3Eadd+the+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+to+tokens.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FautoDisguiseButton%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAuto+Disguise+Bttn%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SetVBLStamp=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+applies+a+VBL+%28Vision+Blocking+Layer%29+upon+a+token.%3Cbr%3EThe+VBL+will+move+with+the+token+as+you+move+it.%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetVBLStamp%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+VBL+Stamp%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MassVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+function+draws+VBL+crosses+on+all+tokens+that+match+a+search+string%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMass+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ToggleVBL=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+function+you+can+toggle+saved+mass+VBL+structures+%28set+with+Mass+VBL+macro%29+on+and+off%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleMassVBL%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+VBL%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Deleteprops=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+resets+ALL+properties+currently+on+the+token.+Effectively+deleting+all+properties.+Use+carefully%21%21%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FdeleteProps%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDELETE+props%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Benchmark=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Apurple%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+runs+each+macro+that+is+in+the+%26%2339%26semi%3BBenchmark+Macros%26%2339%26semi%3B+group+on+lib%3AOntokenmove%3Cbr%3Eand+compares+their+individual+times.+It+uses+an+empty+loop+%28Default+in+that+group%29+as%3Cbr%3E+reference+as+deducts+that+resulting+time+from+the+added+macros.+%3Cbr%3E%3Cbr%3ETo+make+use+of+this%2C+create+one+or+more+macros+in+that+group+with+ONLY+the+code+that+you%3Cbr%3Ewish+to+test.+Then+run+this+macro+and+give+the+number+of+times+%281%2C10%2C100+or+1000%29+you+wish%3Cbr%3Eto+test.+The+higer+the+number+the+more+accurate+the+result%2C+but+obviously+it+will+take+more%3Cbr%3Etime+to+run%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fbenchmark%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EBenchmark%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DiagnoseMaps=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMap+Error+Checks.+This+function+checks+ALL+maps+and+ALL+%28lib%29tokens+for+potential+issues.%3Cbr%3EIt+checks+whether+token+names+contain+non-alphanumerical+characters+and+checks+the+libs+for+the%3Cbr%3Esame+and+owner+ship+and+visibility.+Any+errors+are+rendered+in+a+frame+with+hyperlinks+that+lead%3Cbr%3Eyou+to+the+token.+%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fdiagnose%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EDiagnose+Maps%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; CleanTokNames=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThere+are+certain+characters+e.g.+%40+%23+%26+that%2C+when+used+in+a+token+name%2C%3Cbr%3Ecan+potentially+break+a+macro+IF+that+macro+uses+that+token+name.+An+obvious%3Cbr%3Eexample+is+getTokenNames%28%2C%29+which+returns+a+%2C+seperated+list.+Should+one+of%3Cbr%3Ethe+tokens+in+that+list+be+called+e.g.+%3Ci%3EFire+Elemental%2C+Giant%3C%2Fi%3E+than+the+list%3Cbr%3Ewould+thus+consist+out+of+%3Ci%3EFire+Elemental%3C%2Fi%3E+and+%3Ci%3EGiant%3C%2Fi%3E.+%3Cbr%3E%3Cbr%3EThis+macro+tracks+these+tokens+down+and+reports+them+in+the+chat.+You+then+have%3Cbr%3Ethe+choice+to+either+fix+them+automatically+or+not.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FcleanTokNames%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EClean+Tok+Names%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Door=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+door+%28that+has+been+initialized%29+and+click+this+button+to+open+or+close+it%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleDoor%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%27%3EToggle+Door%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Doors=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+show+a+pop-up+with+all+the+initialized+doors%3Cbr%3Eon+the+OBJECT+LAYER.+Here+you+can+select+which+to+open%2Fclose%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleDoors%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Door%3Cb%3Es%3C%2Fb%3E%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Lock=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3ABlue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+toggle+the+Lock+State+of+a+door.+Select+the+door+first.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Lock%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveCrowd=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EDisperses+a+crowd+created+by+the+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3Cbr%3EMake+sure+the+antagonist+is+on+the+map.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveCrowd%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Crowd%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveCrowdP=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Chtml%3EDisperses+a+crowd+created+by+the+%3Ci%3ECreate+Crowd%3C%2Fi%3E+macro.%3Cbr%3E+Make+sure+the+antagonist+is+on+the+map.%3Cbr%3E+%3Cbr%3E+This+macro+uses+more+intelligence+however+and+is+more+realistic%3Cbr%3E+but+MUCH+slower+%28roughly+1+second+per+10+tokens%29%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmoveCrowdPlus%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Crowd%2B%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3ABlue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+will+animate+the+movement+of+the+selected+token.+An+options+panel+will+be+shown+first.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanimateMove%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMove+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnimateText=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+open+an+input+screen+where+you+can+set-up+animated+text.%3Cbr%3EThis+text+will+be+send+and+animated+within+a+frame+to+every+attached%3Cbr%3Eclient+pc.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanimateTextInput%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnimate+Text%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ExecuteEvent=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+generates+a+list+of+macros+per+group+from+the+lib%3AEvent+token.%3Cbr%3EYou+can+select+one+or+more+macros+which+then+will+be+executed%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecuteEvent%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExecute+Event%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ExecAssignpad=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EBefore+you+can+use+this+macro+you+first+need+to+assign+token+to+the+special+Assignpads.%3Cbr%3EOnce+that+is+done%2C+you+can+run+this+macro+and+pick+the+Assignpads+to+be+executed.%3Cbr%3EOn+execution+the+linked+token+will+be+moved+to+its+assigned+pad.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FexecAssignPads%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EExec+Assignpad%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; DiceBox=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EOpens+a+form+with+dices+where+you+can+set+a+group+of+dice+to+roll%3Cbr%3EThe+workings+of+the+Dice+box+are+pretty+obvious.+What+might+not+be%3Cbr%3Eobvious+is+that+it+supports+10+different+dice+boxes.+You+can+click+the%3Cbr%3Emacro+10+times+and+set+each+frame+individually.%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FLaunch+Dice+Box%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EDice+Box%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SwitchMap=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aorange%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+Forces+ALL+clients+to+chosen+map+AND+centres+view+on+the+token+%3Ci%3EcentreOnMePad%3C%2Fi%3E+%3Cbr%3E%3Cbr%3EIf+you+select+tokens+before+you+use+this+macro%2C+then+the+option+will+be+added+to+move%3Cbr%3Ethe+selected+tokens+to+the+new+map+as+well.+These+tokens+will+be+placed+near+the+%3Ci%3EcentreOnMePad%3C%2Fi%3E%3Cbr%3E%3Cbr%3EIf+there+is+no+%3Ci%3EcentreOnMePad%3C%2Fi%3E+then+the+coords+%28X%2CY%29+0%2C0+will+be+used+instead.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FswitchMap%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%27%3ESwitch+Map%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UseDisguise=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+-+Clicking+the+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+will+add+the+current+token+image+to+your+disguise+list.%3Cbr%3E+-+Changing+your+image+and+clicking+the+button+again+will+add+a+new+image+to+list.%3Cbr%3E+OR%3Cbr%3E+-+Selecting+%3Ci%3Eimage%3Atokens%3C%2Fi%3E+together+with+the+token+will+add+those+images+to+the+disguise%3Cbr%3Elist+of+the+token%3Cbr%3E%3Cbr%3E-+A+list+will+be+shown+for+all+the+possible+images+you+have+loaded.%3Cbr%3E+-+You+have+the+option+to+Change+or+Delete+an+image+from+your+list.%3Cbr%3E+-+On+the+lib+file%2C+if+you+click+%3Ci%3EautoDisguiseButton%3C%2Fi%3E+a+text+box+will+appear+with+a+token%3Cbr%3Eproperty+you+can+add+to+your+Campaign+Property+token+properties+to+automatically+add+the%3Cbr%3E+%3Ci%3EUse+Disguise%3C%2Fi%3E+button+to+tokens.%3C%2Fhtml%3E+%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FuseDisguise%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUse+Disguise%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowHandout=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E+Pops+up+a+dialog+showing+the+handout+of+the+selected+token+on+all+selected+clients.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FshowHandout%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EShow+Handout%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; WhisperFrame=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+opens+a+frame+where+you+can+send+formatted+text+to+specific+players.%3Cbr%3E+%3Cu%3EAlternatively%3C%2Fu%3E+you+can+send+a+message+to+%3Cu%3Eall%3C%2Fu%3E+players+as+if+you%3Cbr%3E+impersonate+the+selected+token%2C+without+actually+needing+to+impersonate+it.%3Cbr%3E+%3Cbr%3E+%3Cb%3ENotes%3C%2Fb%3E+%3Cbr%3E+-+you+must+either+be+the+gm+or+own+the+selected+token+to+do+this.%3Cbr%3E+-+the+impersonation+ONLY+works+with+%3Ci%3Eall+players%3C%2Fi%3E+check+box+%3Cbr%3E+++selected.+%28So+not+when+some+or+all+the+individual+player+checkboxes+are%3Cbr%3E+++selected%21%21%29.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FwhisperFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EWhisper+Frame%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MessageMngr=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+allows+you+to+store+prepared+messages+and+manage+these.%3Cbr%3EFor+GMs+these+will+be+store+on+lib%3AEventMacros%2C+for+players+these+will+%3Cbr%3Ebe+stored+on+the+token+that+they+own+%28and+is+selected%29.+%3Cbr%3ETo+add+a+picture+to+a+message%3A+%3Cbr%3E-+create+the+message+%28and+save+it%29.+%3Cbr%3E-+select+the+token+that+contains+the+image+%28can+be+token%2Cportrait+or+handout%29.%3Cbr%3E-+click+add+selected+image+for+that+message.+The+rest+should+be+simple.%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fnotes%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EMessage+Mngr%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; GroupMove=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+a+group+of+tokens+to+group+them+for+group+move.%3Cbr%3ENote+that+any+previous+set+groups+for+any+of+the+tokens+will+be%3Cbr%3Ecleared+if+you+run+this+macro.%3Cbr%3EAlso+note+that+this+macro+makes+use+of+the+label+field+of+the%3Cbr%3Etoken+and+any+current+value+will+get+overwritten%21%21.+Changing%3Cbr%3Ethis+value+after+a+group+has+been+set+will+de-activate+group-%3Cbr%3Emovement+when+you+move+THAT+token.+The+token+will+still+be%3Cbr%3Epart+of+the+group+and+will+be+moved+if+another+token+of+the%3Cbr%3Egroup+is+moved%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EGroup+%28Move%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UngroupMove=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+one+token+from+a+%3Ci%3Emove%3C%2Fi%3E+group+and+use+this+macro+to+clear+the+ENTIRE+group%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUngroup+%28Move%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; Formations=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Amaroon%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EOpen+the+group+move+macro+frame.%3Cbr%3ENote+that+it+can+appear+behind+this+panel.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FMacroButtonsGroupMove%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFormations%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SummonTokens=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+summon+any+token+from+the+BASE+map+that+is+on+the+TOKEN+layer.%3Cbr%3EIf+you+select+a+token+first+before+you+click+this+button+then+the+to-summon-token%28s%29+will+be%3Cbr%3Eplaced+on+the+selected+token.+Else+you+can+enter+x+and+y+coordinates+of+where+you+want+to+summon%3Cbr%3Ethe+token.+The+types+of+tokens+listed+in+the+Dialog+can+be+specified+through+the+settings.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsummonToken%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESummon+Tokens%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ActivateGroup=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+opens+a+%3Ci%3Egroup+select%3C%2Fi%3E+frame+which+is+required+for+the+%3Ci%3ESelect+Group%3C%2Fi%3E+to+function.%3Cbr%3EWhen+this+panel+is+closed+you+can+still+group+and+ungroup%2C+but+the+%3Ci%3Eauto+select%3C%2Fi%3E+will+only%3Cbr%3Ework+when+this+frame+is+active.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FopenGroupFrame%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EActivate+Group%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; GroupSelect=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+macro+creates+a+%3Ci%3Eselect+group%3C%2Fi%3E+of+all+currently+selected+tokens.%3Cbr%3EAfter+a+group+is+set+%28and+the+group+select+frame+is+active%29+when+you%3Cbr%3Eselect+one+token+of+the+group%2C+all+the+other+tokens+of+the+group+will+be%3Cbr%3Eautomatically+selected+as+well.+This+is+particularly+usefull+when+drawing%3Cbr%3Emaps+and+you+want+to+group+a+set+of+tokens+into+one+object.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetSelectGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EGroup+%28Select%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; UngroupSelect=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Aaqua%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+ungroups+a+%3Ci%3ESelect+Group%3C%2Fi%3E.+You+only+need+to+select+one+token+of+the+group+to+ungroup+the+entire+group+%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ablack%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FclearSelectGroup%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EUngroup+%28Select%29%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; VBLGrenade=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablack%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESelect+one+or+more+tokens%2C+run+macro%2C+set+radius+%28in+grid+cells%29+and+ALL+VBL+in+that+radius+around+the+selected+tokens+will+be+cleared.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FVBLGrenade%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EVBL+Grenade%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; LockMovement=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+this+is+turned+ON%2C+no+PLAYER+can+move+a+token%2C+only+the+GM+can.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ared%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FmovementLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELock+Movement%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; LockToken=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ayellow%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+this+is+turned+ON%2C+no+one+%28gm+included%29+can+move+the+selected+token%28s%29.%3Cbr%3EFor+this+to+work+the+toggle+in+the+settings%3A+%3Ci%3ELock+Movement+for+Locked+Tokens%3C%2Fi%3E+needs+to+be+turned+on%21%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ared%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtokenLock%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELock+Token%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveEventOn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+disable%2Fenable+the+onTokenMoveEvent+macros.%3Cbr%3EThe+onTokenMoveEvent+can+be+demanding+for+every+move%3Cbr%3Ea+token+makes%2C+especially+when+creating+a+map+this+can+be%3Cbr%3Eannoying.+By+clicking+on+this+button+you+can+temporarily%3Cbr%3Edisable+the+event.+Clicking+it+again+will+turn+it+on+again.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleOnTokenMove%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EMove+Event+is%3Cbr%3ETurned+ON%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; MoveEventOff=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EThis+will+disable%2Fenable+the+onTokenMoveEvent+macros.%3Cbr%3EThe+onTokenMoveEvent+can+be+demanding+for+every+move%3Cbr%3Ea+token+makes%2C+especially+when+creating+a+map+this+can+be%3Cbr%3Eannoying.+By+clicking+on+this+button+you+can+temporarily%3Cbr%3Edisable+the+event.+Clicking+it+again+will+turn+it+on+again.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Adark+gray%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleOnTokenMove%40lib%3AOnTokenMove%2Fall%2FImpersonated%3F%27%3EMove+Event+is%3Cbr%3Eturned+OFF+%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FullScreenModeOn=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ared%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+toggled%2C+the+frames+will+be+changed+into+dialogs%2C%3Cbr%3E+which+ARE+allowed+in+full+screen.+This+way+when+you%3Cbr%3E+toggle+this+button+you+can+have+acces+to+chat+and+macros%3Cbr%3E+in+the+form+of+dialogs.%3Cbr%3E+In+addition%2C+when+you+have+turned+on+the+%3Ci%3Eredefine+broadcast%3C%2Fi%3E%3Cbr%3E+setting+in+the+settings%2C+then+when+using+the+broadcast%28%29+function%3Cbr%3E+a+dialog+will+pop+up+showing+the+last+message+broadcasted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleFullScreen%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFull+Screen%3Cbr%3EMode+is+ON%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; FullScreenModeOff=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agray%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWhen+toggled%2C+the+frames+will+be+changed+into+dialogs%2C%3Cbr%3E+which+ARE+allowed+in+full+screen.+This+way+when+you%3Cbr%3E+toggle+this+button+you+can+have+acces+to+chat+and+macros%3Cbr%3E+in+the+form+of+dialogs.%3Cbr%3E+In+addition%2C+when+you+have+turned+on+the+%3Ci%3Eredefine+broadcast%3C%2Fi%3E%3Cbr%3E+setting+in+the+settings%2C+then+when+using+the+broadcast%28%29+function%3Cbr%3E+a+dialog+will+pop+up+showing+the+last+message+broadcasted.%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Adark+gray%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleFullScreen%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EFull+Screen%3Cgr%3EMode+is+OFF%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; ShowDescription=%3Ctd+width%3D%2750%25%27%3E%0A%09%09%3Ctable+bgcolor%3D%27gray%27%3E%0A%09%09%09%3Ctd+align%3D%27center%27+style%3D%22background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+%22+%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+Button%3C%2Fb%3E%3Cbr%3ESelect+a+%3Ci%3ERoom+Description%3C%2Fi%3E+token+and+hit+this+button+%3Cbr%3E%28See+Manual+for+more+info%29%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%3Ca+href%3D%27macro%3A%2F%2FshowDescription%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%3Cimg+src%3D%27asset%3A%2F%2F3fcd87c798fedd3ade1bd9ed272550e0%27+border%3D%270%27+height%3D%2730%27+width%3D%2730%27+alt%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+Button%3C%2Fb%3E%3Cbr%3ESelect+a+%3Ci%3ERoom+Description%3C%2Fi%3E+token+and+hit+this+button+%3Cbr%3E%28See+Manual+for+more+info%29%3C%2Fhtml%3E%27%2F%3E%3C%2Fa%3E%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; roomDescrHelp=%3Ctd+width%3D%2750%25%27%3E%0A%09%09%3Ctable+bgcolor%3D%27gray%27%3E%0A%09%09%09%3Ctd+align%3D%27center%27+style%3D%22background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+%22+%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+HELP%3C%2Fb%3E%3Cbr%3EA+reference+overview+of+the+tags+for+Nildiks+Room+Descriptor%3Cbr%3E%3C%2Fhtml%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%3Ca+href%3D%27macro%3A%2F%2FroomDescrHelp%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3E%3Cimg+src%3D%27asset%3A%2F%2F1badb8f7d4e390d6c9c058f49c90c744%27+border%3D%270%27+height%3D%2730%27+width%3D%2730%27+alt%3D%27%3Chtml%3E%3Cbgcolor%3Dred+color%3Dyellow%3E%3Cb%3ENildiks+Room+Description+HELP%3C%2Fb%3E%3Cbr%3EA+reference+overview+of+the+tags+for+Nildiks+Room+Descriptor%3Cbr%3E%3C%2Fhtml%3E%27%2F%3E%3C%2Fa%3E%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; StartInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMakes+a+token+invisible%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FStart+Invisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EStart+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; EndInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EMakes+a+token+visible%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FendInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EEnd+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SeeInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EToken+can+see+invisible+tokens+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FseeInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESee+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; SawInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+seeing+invisible+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsawInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESaw+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PurgeInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ENegates+invisibility+for+tokens+as+longs+as+they+are+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpurgeInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPurge+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; PurgedInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+negating+invisibility%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FpurgedInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EPurged+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnulInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EPermanently+destroys+invisibility+on+tokens+in+range%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanulInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnul+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; AnulledInvis=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EStop+destroying+invisibility%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FanulledInvisibility%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EAnulled+Invisibility%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; resetRanges=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23006000%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EResets+invisibility+related+ranges+on+selected+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FresetRanges%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EReset+Ranges%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; changeElevation=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3A%23006000%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ESet+the+elevation+for+the+selected+tokens%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Awhite%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FchangeElevation%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EChange+Elevation%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; setAnimateView=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EUse+lastpath+of+selected+token+to+run+a+screen+animation%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FsetAnimateView%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ESet+Animate+View%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; runAnimateView=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ELink+the+view+animation+of+selected+tokens+and+store+it+on+one+token%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FrunAnimateView%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ERun+Animate+View%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; linkViewAnim=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Agreen%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3ERun+view+animation+created+for+selected+token%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FlinkViewAnimations%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3ELink+View+Animations%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; embarkation=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EWith+this+macro+you+can+move+%28N%29PC+tokens+inside+a+vehicle.%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2Fembarkation%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EEmbarkation%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E ; toggleEmbark=%3Ctd+width%3D%2750%25%27%3E%0A%09%3Ctable+width%3D%27100%25%27+cellpadding%3D%270%27+cellspacing%3D%270%27%3E%0A%09%09%3Ctr%3E%0A%09%09%09%3Ctd+style%3D%27padding%3A0px%26semi%3B+border-width%3A1pt%26semi%3B+border-style%3Asolid%26semi%3B+border-color%3Ablack%26semi%3B+text-align%3Acenter%26semi%3B+white-space%3Anowrap%26semi%3B+background-image%3Aurl%28asset%3A%2F%2Ff6c8b56a3aa735a7b12ad57de21e6240%29%26semi%3B+background-color%3Ablue%26semi%3B%27%3E%0A%09%09%09%09%3Cspan+title%3D%27%3Chtml%3EIF+PCs+are+embarked+on+a+vehicle+you+can+quickly+%28dis%29embark+them%3Cbr%3E%27+style%3D%27text-decoration%3Anone%26semi%3B+color%3Ayellow%27%3E%0A%09%09%09%09%09%3Ca+href%3D%27macro%3A%2F%2FtoggleEmbark%40lib%3AOnTokenMove%2Fnone%2FImpersonated%3F%255B%255D%27%3EToggle+Embark%3C%2Fa%3E%0A%09%09%09%09%3C%2Fspan%3E%0A%09%09%09%3C%2Ftd%3E%0A%09%09%3C%2Ftr%3E%0A%09%3C%2Ftable%3E%0A%3C%2Ftd%3E",
      "bot.fg.Other":       [
                {
          "Group_Name": "Other",
          "Function": "Force Selection",
          "Type": "Other",
          "Dependencies": "None",
          "Macro_Group": "Door Button",
          "Description": "To use with 'Always on Top' application. With this feature you can force a client slave to have the same button selected as you have on the master. Read the manual for more info. Usefull for those that like to use Full Screen Mode but still have a chat window and macros available. (and working)"
        },
                {
          "Group_Name": "Other",
          "Function": "Load Map and Coordinates on Start Up",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "This feature can be found in the settings, where you can set the map to load on start-up and the coordinates (or token name) on that map to go to."
        },
                {
          "Group_Name": "Other",
          "Function": "AssignedPads Macro",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Assigned Pads",
          "Description": "Teleport pads that are linked to a specific token, can be used for a mass invasion!"
        },
                {
          "Group_Name": "Other",
          "Function": "AssignedPads Function",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Assigned Pads",
          "Description": "Same as the macro menu but now on the fly."
        }
      ],
      "bot.fg.Tables":       [
                {
          "Group_Name": "BoT Tables",
          "Function": "Create Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "Show Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "Delete Table",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "This macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros"
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_table()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "With this function you can retrieve a value from the stored BoT Tables. Usage: bot_table('name of table', optional: 'column', 'row', ). Both 'column' and 'row' can either be an index number or the name of the row/column. Leaving them empty will result in a random choice."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_listBoTtables()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns a list with the stored BoT Tables."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_listMTtables()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns a list with the stored Maptool Tables."
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_getRows('table name')",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns the row names of the given BoT table"
        },
                {
          "Group_Name": "BoT Tables",
          "Function": "bot_getColumns('table name')",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Tables",
          "Description": "Returns the column names of the given BoT table"
        }
      ],
      "bot.fg.Transportation":       [
                {
          "Group_Name": "Transportation",
          "Function": "On Map Teleport pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadStart, PadEnd) every teleport consists out of a starting pad and ending pad (paired pads), if you drop a token on one it will end on the other. You can resize or place them anyway you want, as long as its on the same map."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Between Map Teleport pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(Interpad) Any Interpad is automatically paired with the Interpad with the SAME identifier (e.g. '1') on a DIFFERENT map. Again, size and place are completely free, as long as its on two different maps."
        },
                {
          "Group_Name": "Transportation",
          "Function": "One way teleports",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadJump, PadDrop, InterJump and InterDrop) Moving onto a 'Jump' token will transport you its paired 'drop' token. And NOT the other way round. The 'Inter' version can be used for transport between maps."
        },
                {
          "Group_Name": "Transportation",
          "Function": "One Way Teleport Border pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder) As with the one way teleports The big difference with the 'normal one way teleports' is that the 'border teleport' tokens will teleport a token that moves onto OR OVER the special pad. I've added 8 new tokens to the zip file (4 horizontal and 4 vertical as you must NOT rotate the tokens, because the footprint of the token does NOT rotate). <br>The inter versions can ideally be used for e.g. large maps where you can build seperate sections on seperate MT maps. This will keep the memory use per map low and will give an easy transfer between to sections. <br>The map versions can be used for creating e.g. a closed loop map where the edges of the map are connected. Moving over the edge will automatically transport you to the opposite edge."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Two Way Teleport Border pads",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(InterPadBorder, PadStartBorder, PadEndBorder) Same as the above one way, but now also two ways teleports."
        },
                {
          "Group_Name": "Transportation",
          "Function": "Mapped Teleports",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Pad Macros; Teleport &Roof",
          "Description": "(MappedPad) These pads work similar to the teleport pads, although of these there is only one type of pad and not two like the start and end pad with the 'normal' teleports. When initializing them you'll get a pop-up per map where they exist and here you can set the destination pad. The 'destination' must be a number, so you can if you like also put in forumulas or dice rolls, as long as the result is a number (and as long as a destination pad with that number actually exist)."
        }
      ],
      "bot.fg.UtilityGeneral":       [
                {
          "Group_Name": "Utility macros",
          "Function": "Set Light",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro whith which you can easily set lights sources on tokens"
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Rumbles Dice Box",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Rumbles Dice Box",
          "Description": "A frame where you can set a pool of dice that you can roll in one click. I have used Rumbles code and layout as a basis and rewrote most of it. Noteably I've added 'options' so you can fully customize the frame."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Show Token Handout",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that forces a pop-up on ALL clients showing a token handout (gm only)."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Switch Map",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A macro that forces ALL clients and selected tokens to the chosen map AND forces all views to the centreOnMePad (if its on the map)(gm only)."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Seek token",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A utility that scans ALL maps and ALL tokens returning a list of all tokens that match the search string. Updated with a wide variety of options, biggest change is showing the results as macro links which allows you to either Copy, Move or Select the token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "bot_debugInfo()",
          "Type": "Function Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - Documented",
          "Description": "A macro that shows all kinds of debug info (primarily for tracking variable values), with several optional settings."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Aliasmasks Disguise macro",
          "Type": "Menu Macro",
          "Dependencies": "Table: Polymorph",
          "Macro_Group": "Aliasmak Usedisguise",
          "Description": "A macro that allows you to add extra token images to a token, so you can e.g. 'polymorph' during gameplay into something else."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "LMarkus Whisper Frame",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "LMarkus Whispers",
          "Description": "A frame where you can whisper (with some text formats) to one or more players without needing to use the /w option. It also includes an impersonation feature so you can speak as another token, without needing to actually impersonate it."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Rumbles Delete Macros utility",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Rumbles Delete Macros utility",
          "Description": "A macro that allows you to copy/paste/delete macros from/on a selected token onto another token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Plothos Message Manager uttility",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Plothos Message Manager",
          "Description": "A macro that allows you to create and store messages for players."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Event Buttons",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Event Macros",
          "Description": "A macro that links an lib:EventMacro macro to a token. When the token is selected, the macro is activated. Usefull for e.g. switching maps."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Benchmark",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro specially developed for macro developers. It can be used to discern the execution time for a certain macro."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Map Diagnosis",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that checks ALL maps and ALL (lib)tokens for potential issues. It checks whether token names contain non-alphanumerical characters and checks the libs for the same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead you to the token."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Token Name Cleaner",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Util - General",
          "Description": "A macro that detects and cleans up characters in token names that are incompatible with the macro system in maptool."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Bubblobills Input String Builder",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Bubblobills Input String Builder",
          "Description": "A macro with which you can easily create the code for a complex input string."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Nildiks Fancy Frames",
          "Type": "Menu Macro",
          "Dependencies": "Table: frames",
          "Macro_Group": "Nildiks Frames",
          "Description": "Two macro functions that allow you to show fancy frames around the 'frames' you usually show to the players."
        },
                {
          "Group_Name": "Utility macros",
          "Function": "Nildiks Room Description Token",
          "Type": "Menu Macro",
          "Dependencies": "Table: encounters, tbl_Image",
          "Macro_Group": "Nildiks Room Description",
          "Description": "The Room Description token allows you to easily access a description of the area where the players are AND to easily share texts (e.g. pieces or parchments, treasure etc) and images (of e.g. encounters) with them in one overview"
        }
      ],
      "bot.fg.UtilityMove":       [
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group (Select)",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Group Move; Group Select",
          "Description": "Create groups of tokens. When you select one token of the group, all the tokens are automatically selected."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove; Group Move; Group Select",
          "Description": "You can combine tokens into one group. When you move ONE token of that group then the whole group moves accordingly."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Rotation",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Group Move; Group Select",
          "Description": "When the group is defined you can use the CW or CCW rotation buttons to rotate the group. For snapped tokens the increment is 90, for unsnapped its 45 and its also possible to select a token from the group and set its facing and then click either CW or CCW, after which the group will be rotated to that direction (unsnapped only)."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Group Formations",
          "Type": "Menu Macro",
          "Dependencies": "Table: tbl_Image",
          "Macro_Group": "Group Move; Group Select",
          "Description": "For defined groups (or a group of selected tokens) you can set different formation like, square, wedge, line, echelon, spread and compact."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Centre on token",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "A toggle in the settings where you can turn on continuous centre on token. This will force a centre on map for every token moved. (only works for single token move)."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Restore FoW (Fog of War)",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "When a player moves a token all the FoW will be restored and only the PC visible areas will be cleared. This function has the extra advantage that the VBL lag bug (game gets very laggy after a while when there is a lot of VBL on the map) is ommitted."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "VBL (Vision Blocking Layer) move check",
          "Type": "Setting",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This function is created by Aliasmask. It can also be found on his lib:Players. However to make both libs compatible I've added it to the BoT so it can be turned off on lib:Players. This function checks EVERY step of the just-moved-token and checks whether it can see into gridcell its moving into. If not then the movement is halted. This function too has the extra advantage that the VBL lag bug is ommitted."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Path Tracking",
          "Type": "Setting",
          "Dependencies": "State: pathFeet; Token: red feet, blue feet",
          "Macro_Group": "OnTokenMove",
          "Description": "Added toggle to the settings where you can turn on path tracking. This will show small feet in the grid cells where the last token moved. Red for NPCs and blue for PCs."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Lock Movement",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This is a toggle on the macro panel that will lock down the movement of ALL tokens. Only the gm can move the tokens now. To use simply hit the macro button and hit it again to allow movement again."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Lock Token",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "Similar to lock movement, only this works on the individual token. It prevents the token from being moved. Both by player and gm! To use: select one or more token. Click the 'lock token' macro. There is a general toggle in the settings to turn this feature on and off."
        },
                {
          "Group_Name": "Move related utily macros",
          "Function": "Invisibility Purge",
          "Type": "Token",
          "Dependencies": "None",
          "Macro_Group": "OnTokenMove",
          "Description": "This functions can be turned of or on the in the settings-->toggle tab. It uses <i>visible to owner only function<\/i>. When a token is invisible this setting is (automatically) turned on. Any token that has <i>Purge invisibility<\/i> turned on will be added as owner to the invisible when the invisible token is in range. See manual for full instructions.<\/i>"
        }
      ],
      "bot.fg.VBL":       [
                {
          "Group_Name": "VBL macros",
          "Function": "VBL Stamps on tokens",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "With this macro you can add a VBL layer upon a token that 'moves' with the token. (Its not really ON the token, but erased and redrawn as you move the token). Possible VBL are Square, Rectangle, Line, Regular Polygon. With a bunch of extra options (like offset, scale, fill, etc.)."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Drawable Polygon Stamps",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "In addition to the 'normal' stamps, you can now also save ANY VBL currently over the token as a stamp. So you can draw VBL over a token as you normally draw VBL and the store that VBL as a stamp onto the token. This is particularly usefull for dungeon tiles where you can store the VBL data onto the tile and then copy paste the tile over the map."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Mass VBL",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function will draw VBL on ALL tokens that match a (partial) search string. Its mainly intended for roofs and canopy but options (selection, all, layers) have been added to use it for other purposes. This macro also contains 2 different scaling techniques to apply the VBL onto the token. Finally you can also store the ENTIRE VBL structure and you can use Toggle VBL to turn that on or off"
        },
                {
          "Group_Name": "VBL macros",
          "Function": "Toggle VBL",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function corresponds with Mass VBL. In Mass VBL you can store all the added VBL and with this function you can turn it on or off instantly."
        },
                {
          "Group_Name": "VBL macros",
          "Function": "VBL Grenade",
          "Type": "Menu Macro",
          "Dependencies": "None",
          "Macro_Group": "Vision Blocking Layer",
          "Description": "This function will erase ALL VBL in a given radius (in grid cells) around one or more selected tokens."
        }
      ],
      "bot.fg.diagArrays": "diagStateArray=[\"isButton\",\"Locked\",\"pathFeet\",\"Special Area\",\"Prone\",\"editFieldMarker\"] ; diagTokenArray=[\"DoorLeverToken\",\"blue feet\",\"red feet\",\"Area Marker\",\"GridCoordMarker\",\"VPCU\"] ; diagTableArray=[\"tbl_Image\",\"Polymorph\",\"encounters\",\"frames\"]",
      "bot.fg.diagLists": "diagStateList=the switch buttons to operate doors, doors so the gm can lock them (doors will NOT work without this state), path tracking (blue and red feet), creating special areas (like movement limitation), used for the Crowd utility, used for Map Editor Utility ; diagTokenList=the switch buttons to operate doors, path tracking (the PC track), path tracking (the NPC track), creating special areas (like movement limitation), the transparent field tokens required for the Map Editor, a token required as placeholder when using the Embarkation macros (vehicles) ; diagTableList=Roofs - Formations - Dicebox - Room Descriptions, Aliasmask Polymorph (table is only necessary if you want to access images from that table), Nildiks Room Description  (table is only necessary if you want to access images from that table), Nildiks Fancy Frames and Room Description",
      "bot.fg.menuMacroList": "utilAnimationList=Door, Doors, Lock, ClearSound, MoveCrowd, MoveCrowdP, MoveToken, AnimateText, runAnimateView, ResetPit, UnShowAreaUtil, ExecuteEvent, ExecAssignpad ; utilUtilList=DiceBox, SwitchMap, SeekToken, SetLightSource, UseDisguise, ToggleSpecial, ShowHandout, WhisperFrame, MessageMngr, SetDrawOrder, GroupMove, UngroupMove, Formations, ActivateGroup, GroupSelect, UngroupSelect, toggleEmbark, SummonTokens, ToggleVBL, VBLGrenade, LockMovement, LockToken, moveEventToggle, ShowDescription ; utilInvisList=StartInvis, EndInvis, SeeInvis, SawInvis, PurgeInvis, PurgedInvis, AnulInvis, AnulledInvis, resetRanges, changeElevation ; basicsList=Settings, BoTFeatures, InitializePads, AltInitPads, Manual ; animationList=SetDoor, SetRoof, setAnimateView, linkViewAnim, ActivateSwitches ; soundList=ClearSound, ReplaceSoundURL, SetSound ; scatterList=BuildForest, ChooseTrunks, CreateCrowd, ChooseCrowd, ScatterTokens, MassVBL ; eventList=DrawArea, SetEventPad, FillArea, ResetPit, DefineArea, SetEventButton, AssignArea, UnShowArea ; assignList=AssignTokens, Execute ; tablesList=CreateTable, ShowTable, DeleteTable, CreateMTTable ; mapList=MapEditor, QuitMapEditor, MovetoHidden, MovetoToken ; utilsList=SeekToken, SetLightSource, SetReference, Remove20, SetDrawOrder, RenumberTokens, ToggleSpecial, SetTokenSize, CopyDelMacros, PasteMacros, UndoDelMacros, FindDuplicates, embarkation, PadExplorer, AutoDisguiseBttn, SetVBLStamp, MassVBL, ToggleVBL, Deleteprops, Benchmark, DiagnoseMaps, CleanTokNames, roomDescrHelp",
      "gmNames": "",
      "libAuthor": "",
      "libAuthorURL": "",
      "libMap": "",
      "libName": "",
      "libTitle": "",
      "libURL": "",
      "libUpdateURL": "https://raw.githubusercontent.com/melek/mtplugins-API-test/main/bot_updates.json",
      "libVersion": 48,
      "onTokenMoveEvent": 1,
      "w42.bot.soundSettings": "uri=http://wolph42.ddns.net:4242/sounds/Bot_Inn/musician.mp3 ; startVolume=0.1 ; distStart=60 ; maxVolume=1 ; distMaxVolume=15"
    },
    "macros":     [
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 1,
        "label": "onCampaignLoad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H:'\n\n\n']\n\n[h: thisLib\t\t= getMacroLocation()]\n\n[h:'']\n[h,if(getLibProperty('maxGroupSelect','lib:EventMacros') == \"\"):\tsetLibProperty(\"maxGroupSelect\", 500,\"lib:EventMacros\")]\n[h,if(getLibProperty('maxOrderSelect','lib:EventMacros') == \"\"):\tsetLibProperty(\"maxOrderSelect\", 300,\"lib:EventMacros\")]\n[h,if(getLibProperty('linkedMappedPads','lib:EventMacros') == \"\"):\tsetLibProperty(\"linkedMappedPads\", '{}',\"lib:EventMacros\")]\n[h,if(getLibProperty('libCoordSize','lib:EventMacros') == \"\"):\t\tsetLibProperty(\"libCoordSize\", 30,\"lib:EventMacros\")]\n[h,if(getLibProperty('padNameList','lib:EventMacros') == \"\"):\t\tsetLibProperty(\"padNameList\", \"Ward, Linked, EventPad , ShadowPad, PadStart , PadEnd , InterPad , PadStartBorder , PadEndBorder , InterPadBorder , PadJump , PadDrop , InterJump , InterDrop , PadJumpBorder , PadDropBorder , InterJumpBorder , InterDropBorder , MappedPad , Roof, Foliage , Canopy\",\"lib:EventMacros\")]\n\n[h:'']\n[h:prefix = \"bot_\"]\n\n[h:'']\n\n[h:defineFunction(prefix+\"followMe\", \"followMe@\"+thisLib) ]\n\n[h:defineFunction(prefix+\"MacroButtonsOTMSetup\", \"MacroButtonsOTMSetup@\"+thisLib) ]\n[h:defineFunction(prefix+\"MacroButtonsOTMUtils\", \"MacroButtonsOTMUtils@\"+thisLib) ]\n[h:defineFunction(prefix+\"createMacroButtonsOTMSetup\", \"createMacroButtonsOTMSetup@\"+thisLib ) ]\n[h:defineFunction(prefix+\"createMacroButtonsOTMUtils\", \"createMacroButtonsOTMUtils@\"+thisLib ) ]\n[h:defineFunction(prefix+\"MacroButtonsGroupMove\", \"MacroButtonsGroupMove@\"+thisLib) ]\n[h:defineFunction(prefix+\"createMacroButtonsGroupMove\", \"createMacroButtonsGroupMove@\"+thisLib) ]\n[h:defineFunction(prefix+\"HTMLMacroButton\", \"HTMLMacroButton@\"+thisLib) ]\n[h:defineFunction(prefix+\"HTMLMacroImageButton\", \"HTMLMacroImageButton@\"+thisLib) ]\n[h:defineFunction(prefix+\"updateVirtualMenu\", \"updateVirtualMenu@\"+thisLib) ]\n\n[h:'']\n[h:defineFunction(prefix+\"initializePads\", \"initializePads@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"initializeMap\", \"initializeMap@\"+thisLib, 0, 0) ]\n[h:defineFunction(prefix+\"checkInterPads\", \"checkInterPads@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"altInitMap\", \"altInitMap@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"path2pads\", \"path2pads@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"chkMoveStop\", \"chkMoveStop@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"determineTokSize\", \"determineTokSize@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"moveVBLToken\", \"moveVBLToken@\"+thisLib, 1, 0 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"Canopy\", \"Canopy@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadStart\", \"PadStart@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadEnd\", \"PadEnd@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadStartBorder\", \"PadStartBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadEndBorder\", \"PadEndBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadJump\", \"PadJump@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"PadJumpBorder\", \"PadJumpBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterPad\", \"InterPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterPadBorder\", \"InterPadBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterJump\", \"InterJump@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"InterJumpBorder\", \"InterJumpBorder@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"MappedPad\", \"MappedPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Ward\", \"Ward@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Roof\", \"Roof@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"Foliage\", \"Foliage@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"EventPad\", \"EventPad@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"EventArea\", \"EventArea@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"ShadowPad\", \"ShadowPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"SoundPad\", \"SoundPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"Linked\", \"Linked@\"+thisLib, 1, 0 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"doShadowPad\", \"doShadowPad@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"setReference\", \"setReference@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"shadowCoords\", \"shadowCoords@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"removeShadow\", \"removeShadow@\"+thisLib, 1, 0 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"chkSounds\", \"chkSounds@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"setupSound\", \"setupSound@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"playPadSound\", \"playPadSound@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"isOnDrawing\", \"isOnDrawing@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"roofSwap\", \"roofSwap@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"teleport\", \"teleport@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"mapTeleport\", \"mapTeleport@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"setRoof\", \"setRoof@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"setVBLRoof\", \"setVBLRoof@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"operateLever\", \"operateLever@\"+thisLib, 0, 0 ) ]\n[h:defineFunction(prefix+\"toggleLock\", \"toggleLock@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"setDoor\", \"setDoor@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"toggleDoor\", \"toggleDoor@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toggleDoors\", \"toggleDoors@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"isDoorClosed\", \"isDoorClosed@\"+thisLib)] \n[h:'defineFunction(prefix+\"setVBLDoor\", \"setVBLDoor@\"+thisLib,1,0)'] \n\n[h:'']\n[h:'']\n[h:defineFunction(prefix+\"getEventType\", \"getEventType@\"+thisLib, 1,0) ]\n[h:defineFunction(prefix+\"convertTrapPit\", \"convertTrapPit@\"+thisLib, 0,1) ]\n[h:defineFunction(prefix+\"setEventPad\", \"setEventPad@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"setEventButton\", \"setEventButton@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"resetPit\", \"resetPit@\"+thisLib, 0, 1 ) ]\n[h:defineFunction(prefix+\"executeEvent\", \"executeEvent@\"+thisLib, 0, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"rotateGroup\", \"rotateGroup@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"setGroup\", \"setGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"clearGroup\", \"clearGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"rotateCW\", \"rotateCW@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"rotateCCW\", \"rotateCCW@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"spreadGroup\", \"spreadGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"contractGroup\", \"contractGroup@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationSquare\", \"formationSquare@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationWedge\", \"formationWedge@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationPWedge\", \"formationPWedge@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationLine\", \"formationLine@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationEchelon\", \"formationEchelon@\"+thisLib, 1, 0) ]\n[h:defineFunction(prefix+\"formationStagger\", \"formationStagger@\"+thisLib, 1, 0) ]\n\n[h:'']\n[h:defineFunction(prefix+\"assignPads\", \"assignPads@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"execAssignPads\", \"execAssignPads@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"groupFrame\", \"groupFrame@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"orderFrame\", \"orderFrame@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"reOrderTokens\", \"reOrderTokens@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"orderWarning\", \"orderWarning@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[defineFunction(prefix+\"pointInTriangle\", \"pointInTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointInCone\", \"pointInCone@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"showTriangle\", \"showTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showCone\", \"showCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showLine\", \"showLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showSquare\", \"showSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"showCircle\", \"showCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"getTriangleCoords\", \"getTriangleCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getConeCoords\", \"getConeCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getLineCoords\", \"getLineCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getSquareCoords\", \"getSquareCoords@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"getCircleCoords\", \"getCircleCoords@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"pointOnTriangle\", \"pointOnTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnCone\", \"pointOnCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnLine\", \"pointOnLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnSquare\", \"pointOnSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"pointOnCircle\", \"pointOnCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"selectOnTriangle\", \"selectOnTriangle@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnCone\", \"selectOnCone@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnLine\", \"selectOnLine@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnSquare\", \"selectOnSquare@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"selectOnCircle\", \"selectOnCircle@\"+thisLib, 1, 1)]\n\n[defineFunction(prefix+\"getNeighbourXY\", \"getNeighbourXY@\"+thisLib, 1, 1)]\n[defineFunction(prefix+\"isClockWise\", \"isClockWise@\"+thisLib, 1, 1)]\n\n[h:'']\n[defineFunction(prefix+\"createTable\", \"createTable@\"+thisLib,1,1)]\n\n[defineFunction(prefix+\"getRows\", \"getRows@\"+thisLib,1,1)]\n[defineFunction(prefix+\"getColumns\", \"getColumns@\"+thisLib,1,1)]\n[defineFunction(prefix+\"table\", \"table@\"+thisLib,1,1)]\n[defineFunction(prefix+\"deleteTable\", \"deleteTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"showTable\", \"showTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"setTable\", \"setTable@\"+thisLib,1,1)]\n[defineFunction(prefix+\"searchRow\", \"searchRow@\"+thisLib,0,0)]\n\n[defineFunction(prefix+\"listMTTables\", \"listMTTables@\"+thisLib,1,1)]\n[defineFunction(prefix+\"listBoTTables\", \"listBoTTables@\"+thisLib,1,1)]\n\n[defineFunction(\"json.paths\", \"json.paths@\"+thisLib,1,1)]\n[defineFunction(\"json.pget\", \"json.pget@\"+thisLib,1,1)]\n[defineFunction(\"json.pset\", \"json.pset@\"+thisLib,1,1)]\n[defineFunction(\"json.pappend\", \"json.pappend@\"+thisLib,1,1)]\n\n[h:'']\n[h:defineFunction(prefix+\"scatter\", \"scatter@\"+thisLib)]\n[h:defineFunction(prefix+\"buildForest\", \"buildForest@\"+thisLib)]\n[h:defineFunction(prefix+\"chooseTrunks\", \"chooseTrunks@\"+thisLib)]\n[h:defineFunction(prefix+\"getValidTrunks\", \"getValidTrunks@\"+thisLib, 0, 0)]\n[h:defineFunction(prefix+\"createCrowd\", \"createCrowd@\"+thisLib)]\n[h:defineFunction(prefix+\"moveCrowd\", \"moveCrowd@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"moveCrowdPlus\", \"moveCrowdPlus@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"chooseCrowd\", \"chooseCrowd@\"+thisLib)]\n[h:defineFunction(prefix+\"getValidCrowd\", \"getValidCrowd@\"+thisLib, 0, 0)]\n[h:defineFunction(prefix+\"mapEditor\", \"mapEditor@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"fieldEditDialog\", \"fieldEditDialog@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"quitEditor\", \"quitEditor@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"moveToHidden\", \"moveToHidden@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"moveToToken\", \"moveToToken@\"+thisLib, 1, 1)]\n\n[h:'']\n[h:defineFunction(prefix+\"embarkation\", \"embarkation@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"toggleEmbark\", \"toggleEmbark@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"summonToken\", \"summonToken@\"+thisLib, 0, 1) ]\n[h:defineFunction(prefix+\"getValidTokens\", \"getValidTokens@\"+thisLib, 0, 0) ]\n\n[h:'']\n[h:defineFunction(prefix+\"animateMove\", \"animateMove@\"+thisLib, 1,0 ) ]\n[h:defineFunction(prefix+\"animateText\", \"animateText@\"+thisLib, 1,1 ) ]\n[h:defineFunction(prefix+\"delay\", \"delay@\"+thisLib, 1,1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"message\", \"message@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"self\", \"self@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nself\", \"nself@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"all\", \"all@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"gm\", \"gm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ngm\", \"ngm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"selfgm\", \"selfgm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nselfgm\", \"nselfgm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ownergm\", \"ownergm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nownergm\", \"nownergm@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"owner\", \"owner@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"nowner\", \"nowner@\"+thisLib,1,1)]\n\n\n[h:'']\n[h:defineFunction(prefix+\"startInvisibility\", \"startInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"endInvisibility\", \"endInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"seeInvisibility\", \"seeInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"sawInvisibility\", \"sawInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"purgeInvisibility\", \"purgeInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"purgedInvisibility\", \"purgedInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"anulInvisibility\", \"anulInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"anulledInvisibility\", \"anulledInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"checkInvisibility\", \"checkInvisibility@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"resetRanges\", \"resetRanges@\"+thisLib ,1,1) ]\n\n[h:'']\n[h:defineFunction(prefix+\"setAnimateView\", \"setAnimateView@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"runAnimateView\", \"runAnimateView@\"+thisLib ,1,1) ]\n[h:defineFunction(prefix+\"linkViewAnimations\", \"linkViewAnimations@\"+thisLib ,1,1) ]\n\n[h:'']\n[H: defineFunction(\"bot_useDisguise\",\"useDisguise@\"+thisLib,1,1)]\n\n[h:'']\n[h:defineFunction(prefix+\"buildInputString\",\"buildInputString@\"+thisLib)]\n\n[h:'']\n[H:defineFunction(prefix+\"outputTo\", \"outputTo@this\" )]\n[H:defineFunction(prefix+\"whisperFrame\", \"whisperFrame@this\" )]\n[H:defineFunction(prefix+\"textToScript\", \"textToScript@this\", 1,1)]\n[h:defineFunction(prefix+\"scrambleText\", \"scrambleText@\"+thisLib,1,1)]\n\n\n[h:'']\n[h:defineFunction(prefix+\"frameOpen\", \"frameOpen@\"+thisLib,1,1) ]\n[h:defineFunction(prefix+\"frameClose\", \"frameClose@\"+thisLib,1,1) ]\n[h:defineFunction(prefix+\"frameOverview\", \"frameOverview@\"+thisLib,1,1) ]\n\n[h:'']\n\n[h:'']\n\n[h:'']\n[h:defineFunction(prefix+\"cpyDelMacros\",\"cpyDelMacros@\"+thisLib)]\n[h:defineFunction(prefix+\"undoDelMacros\",\"undoDelMacros@\"+thisLib)]\n[h:defineFunction(prefix+\"pasteMacros\",\"pasteMacros@\"+thisLib)]\n\n[h:'']\n[h:defineFunction(\"dbxOutputTo\",\"dbxOutputTo@\"+thisLib)]\n[h:defineFunction(\"dbxLaunch\", \"Launch Dice Box@\"+thisLib)]\n\n[h:'']\n[h:defineFunction(prefix+\"createSplices\", \"createSplices@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getPath\", \"getPath@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getTokensPath\", \"getTokensPath@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"ids2Names\", \"ids2Names@\"+thisLib)]\n[h:defineFunction(prefix+\"ids2NamesArray\", \"ids2NamesArray@\"+thisLib)]\n[h:defineFunction(prefix+\"showHTML\", \"showHTML@\"+thisLib)]\n[h:defineFunction(\"pause\", \"pause@\"+thisLib, 1,0 ) ]\n[h:defineFunction(prefix+\"inStr\", \"inStr@\"+thisLib)] \n[h:defineFunction(prefix+\"getGridSize\", \"getGridSize@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"round2Grid\", \"round2Grid@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"ppc2GridCoord\", \"ppc2GridCoord@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"snapAngle\", \"snapAngle@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"snapToGrid\", \"snapToGrid@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"travelAngle\", \"travelAngle@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"seekToken\", \"seekToken@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"getNewImage\", \"getNewImage@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"execAllPlayers\", \"execAllPlayers@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"sortTokByProp\", \"sortTokByProp@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"debugInfo\", \"debugInfo@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"CoMScan\", \"CoMScan@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"switchMap\", \"switchMap@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"findDuplicates\", \"findDuplicates@\"+thisLib,1,0)]\n[h:defineFunction(prefix+\"getTokCDistance\", \"getTokCDistance@\"+thisLib,1,1)]\n\n[h:'']\n[h:defineFunction(prefix+\"cleanTokNames\", \"cleanTokNames@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"abortProcess\", \"abortProcess@\"+thisLib)]\n[h:defineFunction(prefix+\"setDrawOrder\", \"setDrawOrder@\"+thisLib)]\n[h:defineFunction(prefix+\"removeP20\", \"removeP20@\"+thisLib)]\n\n[h:defineFunction(prefix+\"setLightSource\", \"setLightSource@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"applyLightSource\", \"applyLightSource@\"+thisLib,1,0)]\n\n[h:defineFunction(prefix+\"movementLock\", \"movementLock@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"tokenLock\", \"tokenLock@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"showHandout\", \"showHandout@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"benchmark\", \"benchmark@\"+thisLib, 0, 1 ) ]\n\n[h:defineFunction(prefix+\"isFullScreen\", \"isFullScreen@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toggleFullScreen\", \"toggleFullScreen@\"+thisLib, 1, 1 ) ]\n\n[h:defineFunction(prefix+\"renumberToks\", \"renumberToks@\"+thisLib)]\n[h:defineFunction(prefix+\"toggleSpecial\", \"toggleSpecial@\"+thisLib)]\n[h:defineFunction(prefix+\"removeTokens\", \"removeTokens@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"getRangedDistance\", \"getRangedDistance@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"changeElevation\", \"changeElevation@\"+thisLib,1,1)]\n\n[h:defineFunction(prefix+\"changeElevation\", \"changeElevation@\"+thisLib,1,1)]\n\n[h:'']\n[h:defineFunction(prefix+\"pi\", \"pi@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"cos\", \"cos@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"sin\", \"sin@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"tan\", \"tan@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"toRadians\", \"toRadians@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(\"odd\", \"odd@\"+thisLib)]\n[h:defineFunction(\"mod\", \"mod@\"+thisLib,1,1)]\n[h:defineFunction(prefix+\"facingToCoord\", \"facingToCoord@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"facingToCoordX\", \"facingToCoordX@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"facingToCoordY\", \"facingToCoordY@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"getTokenFacing\", \"getTokenFacing@\"+thisLib,1,1)] \n[h:defineFunction(prefix+\"setTokenFacing\", \"setTokenFacing@\"+thisLib,1,1)] \n\n[h:'']\n[h:defineFunction(prefix+\"diagnose\", \"diagnose@\"+thisLib, 1, 0 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"resetTimer\", \"resetTimer@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"timeOut\", \"timeOut@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"startTime\", \"startTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"pauseTime\", \"pauseTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"resumeTime\", \"resumeTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"subTime\", \"subTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"totalTime\", \"totalTime@\"+thisLib, 1, 1)]\n[h:defineFunction(prefix+\"formatTime\", \"formatTime@\"+thisLib, 1, 1)]\n\n[h:'']\n[h:defineFunction(prefix+\"createVBL\", \"createVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"removeVBL\", \"removeVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"VBLGrenade\", \"VBLGrenade@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"moveStamp\", \"moveStamp@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"setVBL\", \"setVBL@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"extendPoint\", \"extendPoint@\"+thisLib, 1, 0 ) ]\n[h:defineFunction(prefix+\"drawFgVBL\", \"drawFgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"saveFgVBL\", \"saveFgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"drawBgVBL\", \"drawBgVBL@\"+thisLib, 1, 1 ) ]\n[h:defineFunction(prefix+\"saveBgVBL\", \"saveBgVBL@\"+thisLib, 1, 1 ) ]\n\n[h:'']\n[h:defineFunction(prefix+\"manualText\", \"manualText@\"+thisLib)]\n[h:defineFunction(prefix+\"optionTable\", \"optionTable@\"+thisLib)]\n[h:defineFunction(prefix+\"manFunctionsTxt\", \"manFunctionsTxt@\"+thisLib)]\n[h:defineFunction(prefix+\"videoTutorials\", \"videoTutorials@\"+thisLib)]\n[h:defineFunction(prefix+\"settings\", \"settings@\"+thisLib)]\n\n[h:'']\n\n[h:'']\n\n[h,if(getLibProperty('fullScreenBroadcast','lib:EventMacros') == 1 && isFunctionDefined(\"broadcast\") == 2):defineFunction(\"broadcast\", \"bot_broadcast@\"+thisLib, 1, 1 ) ]\n\n[H: '']\n[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:mapList\t\t= getAllMapNames(\"json\")]\n[h,if(!json.contains(mapList, baseMap)), CODE:{\n\t\n\t[firstTimeUse\t= 1]\n\t[macro(\"welcomeInit@lib:OnTokenMove\"):\"\"]\n\t[botTok\t= findToken(\"lib:OnTokenMove\")]\n\t[emTok\t= findToken(\"lib:EventMacros\")]\n\t[assert(botTok != \"\", \"BASE map name is not set up correctly. Please run Settings and set up the correct BASE map, when done run onCampaignLoad macro on the lib:OnTokenMove token\",0)]\n\t[assert(emTok != \"\", \"Make sure that there is a lib:EventMacros on the same map as lib:OnTokenMove and that you have run the settings (and set up the BASE map correctly in the settings)\",0)]\n\t[setLibProperty(\"baseMapName\", getCurrentMapName(), \"lib:EventMacros\")]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n};{\n\t[firstTimeUse\t= 0]\n}]\n\n[H: '']\n[h:newGmNames = getLibProperty(\"gmNames\", \"lib:EventMacros\")]\n[h,if(json.type(newGmNames)!=\"ARRAY\"):newGmNames\t= \"[]\"]\n[h:oldgmNames = newGmNames]\n[H:playerName = json.fromList(getPlayerName())]\n[h:tmpAllPlayers = getAllPlayerNames(\"json\")]\n[H,if(isGM()), CODE:{\n\t[newGmNames\t= json.union(newGmNames,playerName)]\n\t[intersect\t= '[]']\n}; { \n\t[intersect\t= json.intersection(newGmNames,playerName)]\n\t[if(!json.isEmpty(intersect)): newGmNames = json.difference(newGmNames,playerName)]\n}]\n[H: newGmNames = json.intersection(tmpAllPlayers,newGmNames)]\n\n[H: '']\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h,if(!json.equals(oldgmNames,newGmNames)), CODE:{\n\t[if(!firstTimeUse):setCurrentMap(baseMap)]\n \t[setLibProperty(\"gmNames\",newGmNames, \"lib:EventMacros\")]\n}; {}]\n\n[h:noGM = json.isEmpty(getLibProperty(\"gmNames\", \"lib:EventMacros\"))]\n[h,if(noGM), CODE:{\n\t[abort(input(\n\t\t\"junk|<html><b>The system has no GMs registered.<br>If you started the game without a gm restart it and correct it.<br>Else pick the gm from the list below<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"gmNames|\"+getAllPlayerNames()+\"|Select the gm|LIST|SELECT=0 VALUE=STRING\"\n\t))]\n\t[setLibProperty(\"gmNames\", json.fromList(gmNames), \"lib:EventMacros\")]\n}]\n\n[H: '']\n\n[h:'']\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"Lib:EventMacros\") ]\n[h, if(json.type(linkedAreas)==\"UNKNOWN\"): setLibProperty(\"linkedAreas\", \"{}\", \"Lib:EventMacros\")]\n\n[h:'']\n[h:oldMapsPads\t\t= getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n[h:initialized\t\t= 1]\n[h:chckMapsOCL\t\t= getLibProperty(\"checkMapsOCL\", \"lib:EventMacros\")]\n[h:macroLocation\t= getMacroLocation()]\n\n[h, if(json.type(oldMapsPads)=='OBJECT' && chckMapsOCL), CODE:{\n\t[excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n\t[toCheckMaps\t= json.difference(mapList, excludedMaps)]\n\t[foreach(currentMap, mapList,\"\"), CODE:{\n\t\t[setCurrentMap(currentMap)]\n\t\t\n\t\t[if(findToken(macroLocation) != \"\"): macroMap = currentMap]\n\t\t\n\t\t[if(!json.contains(oldMapsPads, currentMap) && json.contains(toCheckMaps, currentMap)):initialized = 0]<br>\n\t}]\n}; {}]\n\n[h, if(json.type(oldMapsPads)!='OBJECT' && chckMapsOCL), CODE:{\n\t[initialized\t= 0]\n\t[foreach(currentMap, mapList,\"\"), CODE:{\n\t\t[setCurrentMap(currentMap)]\n\t\t[if(findToken(macroLocation) != \"\"): macroMap = currentMap]\n\t}]\n}; {}]\n\n[r,if(!initialized && chckMapsOCL), CODE:{\n\t[r:bot_initializePads(1)]\n\t[h:newMapsPads = macro.return]\n\t[h:setCurrentMap(macroMap)]\n\t[h:setLibProperty(\"allMapsPads\",newMapsPads,\"lib:EventMacros\")]\n}; {}]\n\n[h,if(getLibProperty('runSwitchForm','lib:EventMacros')==1), CODE:{\n\t[macro(\"SwitchFrame@Lib:OnTokenMove\"):\"\"]\n}; {}]\n\n\n[H: disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\")]\n[H, if(json.isEmpty(disguiseMacro)), CODE: {\n\t[macroName\t= \"Use Disguise\"]\n\t[index\t\t= getMacroIndexes(macroName)]\n\t[command\t= getMacroCommand(index)]\n\t[props\t\t= json.set(getMacroProps(index,\"json\"),\"command\",command)]\n\t[props\t\t= json.removeAll(props,json.set(\"{}\",\"index\",\"\",\"group\",\"\"))]\n\t[setLibProperty(\"am.bot.disguiseMacro\",props)]\n};{}]\n\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n[h,if(disableOCLCheck != 1), CODE:{\n\t[h:'']\n\t\n\t[h: info\t\t= getInfo(\"client\")]\n\t[h: assert(json.type(info)== \"OBJECT\", \"MAKE SURE THAT THE LIB TOKENS ARE ON THE TOKEN LAYER. After that, save and reload the campaign file.\",0)]\n\t[h: libs\t\t= json.get(info, \"library tokens\")]\n\t[h: botVersion\t= json.get(libs, \"lib:OnTokenMove\")]\n\t[h: assert(listContains(json.fields(libs), \"Lib:EventMacros\"), \"Lib:EventMacros not found! Make sure that its in the campaign file, and then save and reload the campaign file\",0)]\n\t[h: mtVersion\t= json.get(info, \"version\")]\n\t[h,if(indexOf(mtVersion, \"b\") != -1): \n\t\tmtVersionNr\t= substring(mtVersion, indexOf(mtVersion,\"b\")+1,indexOf(mtVersion,\"b\")+3)\n\t;\n\t\tmtVersionNr\t= substring(mtVersion, 2,3)\n\t]\n\n\n[mtVersionNr = 4]\n\n\t\n\t[h, if(!firstTimeUse):bot_diagnose(1)]\n\t[vblSupport\t\t= if(bot_inStr(lower(mtVersion), \"nerps\") || mtVersionNr > 89 || mtVersionNr == 4, 1, 0)]\n\t[vblSupport = if(bot_inStr(lower(mtVersion), \"nerps\") || mtVersionNr > 89 || mtVersionNr >= 4, 1, 0)]\n\t[vblOutput\t\t= if(vblSupport, \"v This Maptool version <b>supports<\/b> automatic vision blocking manipulation, this functionality will be <b>enabled<\/b>\", \"x This Maptool version <b>does <u><font color='red'>not<\/font><\/u> support<\/b> automatic vision blocking manipulation, this functionality will be <b>disabled<\/b>\"))]\n\t[setLibProperty('vblSupport',vblSupport,'lib:EventMacros')]\n\t[message\t\t= \"v Current online GM's are: <b>\"+json.toList(newGmNames) + \"<\/b>\"]\n\t[message\t\t= listAppend(message, \"v This campaign runs in Maptool version <b>\"+mtVersion+\"<\/b>\",\"<br>\")]\n\t[message\t\t= listAppend(message, \"v This campaign is powered by version <b>\"+botVersion+\"<\/b> of the <b>Bag of Tricks<\/b> (<font color='blue'><a href='https://forums.rptools.net/viewtopic.php?f=46&t=28409&p=274496#p274496'>check for updates<\/a><\/font>)\",\"<br>\")]\n\t[message\t\t= listAppend(message, vblOutput,\"<br>\")]\n\t[h, if(!firstTimeUse), CODE:{\n\t\t[message\t\t= listAppend(message, stateOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, invisOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, tokOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, tableOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, libOwnerOutput,\"<br>\")]\n\t\t[message\t\t= listAppend(message, togglesOutput,\"<br>\")]\n\t};{\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t}]\n\t\n\t[if(right != \"\"): message = replace(message, \"v \", right+\"\")]\n\t[if(wrong != \"\"): message = replace(message, \"x \", wrong+\"\")]\n\n\t\n\t[bot_message(message, \"<b>Bag of Tricks - OnCampaignLoad checks<\/b>\", \"maroon-yellow\", bot_self())]\n\n\t[broadcast(\"\n\t\t<table  cellpadding='5' cellspacing='0'  bgcolor='blue'>\n\t\t\t<tr>\n\t\t\t\t<td cellpadding='10' >\n\t\t\t\t\t<span title='This open TWO manuals of the BoT' style='text-decoration:none; color:yellow;'>\n\t\t\t\t\t\t\" + \n\t\t\t\t\t\tmacroLink('Open BoT Manual', 'manualText@lib:OnTokenMove','self')\n\t\t\t\t\t\t+ \"\n\t\t\t\t\t<\/span>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\",\"self\")] \n};{}]\n\n\n[h,if(getLibProperty('useStartUpMap','lib:EventMacros')==1), CODE:{\n\t[if(!firstTimeUse):setCurrentMap(getLibProperty('startUpMap','lib:EventMacros'))]\n\t[gotoCoord\t= getLibProperty('startUpCoords','lib:EventMacros')]\n\t[h,if(findToken(\"centreOnMePad\") != \"\" && getLibProperty('useCentreOnMePad','lib:EventMacros')==1), CODE:{\n\t\t\n\t\t[goto(getTokenX(0,\"centreOnMePad\"),getTokenY(0,\"centreOnMePad\"))]\n\t}; {\n\t\t\n\t\t\n\t\t[if(listCount(gotoCoord)==2): goto(listGet(gotoCoord, 0),listGet(gotoCoord, 1)) ; goto(gotoCoord)]\n\t}]\n}; {\n\t[setCurrentMap(oldMap)]\n}]\n\n\n[abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e9e5dc31-054d-4a1e-b3ac-f3febf2887e2",
          "commandChecksum": "48873f8cbcddbe9949dc5b86d8b35144",
          "propsChecksum": "d92149fe7140aa66b93e17ffa2714e84"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "43",
        "includeLabel": false,
        "sortBy": "43",
        "index": 2,
        "label": "(Un)Show Area",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"showArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "562638b8-abef-4ce6-af55-c96f1ed21379",
          "commandChecksum": "87637f02f5c62d991a7cdd709aacc471",
          "propsChecksum": "6d6e5df56bf4d62decb04e522b1d8c70"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 3,
        "label": "<i>Animate Text",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"animateTextInput@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "00364fa0-3d9c-4f81-955a-666fb19d47d9",
          "commandChecksum": "9210aaa35848d75e6f6885bcd21c3e36",
          "propsChecksum": "ed22d03f31822be61e10fe2382b600d0"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "112",
        "includeLabel": false,
        "sortBy": "112",
        "index": 5,
        "label": "Activate Group",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, macro(\"openGroupFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d4adab1d-d4ae-4f2f-99db-ee8675dbe81f",
          "commandChecksum": "698d0f7773ef7c22c2aff7c3badcf82a",
          "propsChecksum": "dc16d85f8334db70d6fa21d547299714"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 6,
        "label": "Activate Switches",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, macro(\"openFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0da64303-49e3-4b5c-bb6c-0e487573f17d",
          "commandChecksum": "550ba1684efb6ee5d43a1fafb7db562d",
          "propsChecksum": "43f14e0897d1a87e47b625d732ee478b"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 7,
        "label": "Alt. Init. Pads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_altInitMap()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b748910e-8b86-4268-8654-d66df173b519",
          "commandChecksum": "4c22110367b59eb069b9995a14b1f5e9",
          "propsChecksum": "582f6190c930284c4d5f2ac13e984bfb"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 8,
        "label": "Animate Move",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_animateMove()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "32853d68-c0b5-4dce-9cca-45a18ca1824a",
          "commandChecksum": "c679df278e1c0d7bf44583d62147276a",
          "propsChecksum": "7d8c8ffdb17cdb704144e46820a55130"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 9,
        "label": "Assign Areas",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"assignArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ab984c4a-986e-4188-aac3-b7c691d09b29",
          "commandChecksum": "75d4c8c7c6ef11b5fa592d81d7cad025",
          "propsChecksum": "84a98d72161120d99eb67c2c144a6a77"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "51",
        "includeLabel": false,
        "sortBy": "51",
        "index": 10,
        "label": "Assign Tokens to Pads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_assignPads()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "972cde22-69de-434a-bb9e-d0baeba8840e",
          "commandChecksum": "3fdb98347dd75bba4770b0a8f078cbd4",
          "propsChecksum": "43178b5926917c0bd0fdf5caa39ced61"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "white",
        "group": "81a",
        "includeLabel": false,
        "sortBy": "81a",
        "index": 11,
        "label": "Auto Disguise Btn",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[H, if(json.isEmpty(macro.args)), CODE: {\n\t[propText\t\t= '*autoDisguiseButton:[macro(\"autoDisguiseButton@lib:disguise\"): currentToken()]']\n\t[input(\n\t\t\"label|<html><b>Copy text in to Token Property to auto load Disguise Button:<\/b><br><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50\")\n\t)]\n};{\n\t[id\t\t\t\t= json.get(macro.args,0)]\n\t[switchToken(id)]\n\t[disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\",getMacroLocation())]\n\t[setProperty(\"autoDisguiseButton\",\"\")]\n\t[if(!hasMacro(\"Use Disguise\")): createMacro(disguiseMacro)]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ac63fa80-e3d6-43d3-b36c-f645eb4d19b0",
          "commandChecksum": "284855b405a69e88505ee3e647124f6c",
          "propsChecksum": "57684520f2126a0dcd04a04f7506c1d1"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 12,
        "label": "Bag of Tricks Macros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_MacroButtonsOTMSetup()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f030810a-11c6-4ccf-8cc4-9752278e776d",
          "commandChecksum": "d61d7e64b79d870a4c67e4b51088af33",
          "propsChecksum": "11e02cd4fcca04cba796f51910fe0cae"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 13,
        "label": "Build Forest",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_buildForest()]",
        "maxWidth": "",
        "tooltip": "<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ee485703-6386-45be-a526-100a866fff62",
          "commandChecksum": "3ef3403868168bea93a7e593c6a4e1c3",
          "propsChecksum": "b5f9ec02a25684844359eecdf5db751d"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "24",
        "includeLabel": false,
        "sortBy": "24",
        "index": 14,
        "label": "Choose Crowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_chooseCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eaa9e51c-0399-45bb-9436-bf0764bc78e5",
          "commandChecksum": "79c389e75f13defc9d44851f652b962e",
          "propsChecksum": "89a136f9ab1f246e3cd524136835ed27"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 15,
        "label": "Choose Trunks",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_chooseTrunks()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6bfb27d0-1bfe-4480-9f7f-40cb8f82d2a6",
          "commandChecksum": "b8d1a87eb8525fe1afdd9dd8a1e57813",
          "propsChecksum": "a004c907004d39e595e2925c0714adf9"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "82a",
        "includeLabel": false,
        "sortBy": "82a",
        "index": 16,
        "label": "Clean Tok Names",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_cleanTokNames()]",
        "maxWidth": "",
        "tooltip": "<html>There are certain characters e.g. @ # & that, when used in a token name,<br> can potentially break a macro IF that macro uses that token name. An obvious<br> example is getTokenNames(\",\") which returns a , seperated list. Should one of<br> the tokens in that list be called e.g. \"Fire Elemental, Giant\" than the list<br> would thus consist out of \"Fire Elemental\" and \"Giant\". <br><br> This macro tracks these tokens down and reports them in the chat. You then have<br> the choice to either fix them automatically or not.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9e93e3ab-1eaf-4c34-9b3d-cc38fb45ef4a",
          "commandChecksum": "86f7083fee699963b43bcd744dc73510",
          "propsChecksum": "6f1ffb9cbfea5331898d63e011ada329"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "94",
        "includeLabel": false,
        "sortBy": "94",
        "index": 17,
        "label": "Contract Group",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_contractGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "846b4d44-17ee-46f7-8e93-1211fd8835c0",
          "commandChecksum": "e11e3aa9e04b7db1aab15be4b9505cb2",
          "propsChecksum": "04349b0fc05be1c6335c622a0ca18c03"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "11a",
        "includeLabel": false,
        "sortBy": "11a",
        "index": 18,
        "label": "Convert Trap/Pits",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_convertTrapPit()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e4c45eda-2555-46b0-a9b1-5203aa0c2e8b",
          "commandChecksum": "b4a3c354a9a7ee9449ca9bb1b2473598",
          "propsChecksum": "0530474de62926d0d5637474d78bd975"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "87",
        "includeLabel": false,
        "sortBy": "87",
        "index": 19,
        "label": "Copy / Del. Macro",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_cpyDelMacros()]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8ba7e0ac-54f0-45b0-87c7-1e6a86dbab42",
          "commandChecksum": "0b99299b932ae8bc90701a5f38d65a22",
          "propsChecksum": "c00eb1c2548df7a3aa58fd4d5537eb32"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "25",
        "includeLabel": false,
        "sortBy": "25",
        "index": 20,
        "label": "Create Crowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_createCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>Same as choose trunks. Creates a list of tokens which 'Create Crowd' uses.<br> Based on tokens on BASE map starting name with 'Crowd '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "528e26d3-1612-4ceb-84e7-5eb0331cb825",
          "commandChecksum": "5ab40c6fd2414a4cd276f942fe808860",
          "propsChecksum": "fa007f710092aec7b5be334ccbc72af7"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "41",
        "includeLabel": false,
        "sortBy": "41",
        "index": 21,
        "label": "Define Area",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"defineArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cae4596d-0bad-4350-b60d-785fd1316a71",
          "commandChecksum": "6196ea54d7d931c6dac2373a62120f45",
          "propsChecksum": "e5f5b59a871602afd970f9dc4abd3969"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "82",
        "includeLabel": false,
        "sortBy": "82",
        "index": 22,
        "label": "Diagnose Maps",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_diagnose()]",
        "maxWidth": "",
        "tooltip": "<html>Map diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5ddaedf0-9924-449a-acc4-b67d4ecee9f0",
          "commandChecksum": "e6fd1665aa70ce92d77b1ab660cee406",
          "propsChecksum": "ff7478b8f1ab231d1fe8349fd4322a48"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "43",
        "includeLabel": false,
        "sortBy": "43",
        "index": 23,
        "label": "Draw Area",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"toggleAreaDraw@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e792c6b6-461d-4ec4-9b08-106970ca1ea1",
          "commandChecksum": "32dc95e55faba469d392cca0a8a9c590",
          "propsChecksum": "6f3d595afc8d3262ad4aa3ec106afc1b"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "red",
        "group": "111",
        "includeLabel": false,
        "sortBy": "111",
        "index": 24,
        "label": "Draw Order",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, macro(\"openOrderFrame@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f7270837-d6ea-417e-898b-2307789d2b4f",
          "commandChecksum": "6ece77298c7dbb4c7772f5e493c92291",
          "propsChecksum": "631fa4403b783580ae1b1fdeb820249f"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "98",
        "includeLabel": false,
        "sortBy": "98",
        "index": 25,
        "label": "Echelon Formation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationEchelon()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5e7bc46f-f58b-4e42-aac2-b44c0a403c6e",
          "commandChecksum": "26bf3841c04019223ae1e6cd6d2a656c",
          "propsChecksum": "5f994c8087f9c679fe9e67584c2b4a98"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "52",
        "includeLabel": false,
        "sortBy": "52",
        "index": 26,
        "label": "Execute AssignPads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_execAssignPads()]",
        "maxWidth": "",
        "tooltip": "<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1a72b001-8a3f-4758-b789-5859926d4c2e",
          "commandChecksum": "e2799c4cab011449075570f5ecd119da",
          "propsChecksum": "9a8e4b681d52bf7547b702c0a9b73266"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 27,
        "label": "Execute Event",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_executeEvent()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7a8b95fe-226d-4c54-8df1-7b162281eb6a",
          "commandChecksum": "d77e1b8aa2c48447bde9177b5eec4f8d",
          "propsChecksum": "3d388a9b268fa76b195b7c107ca04243"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "33",
        "includeLabel": false,
        "sortBy": "33",
        "index": 28,
        "label": "Execute event",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_executeEvent()]",
        "maxWidth": "",
        "tooltip": "<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d1893b7a-d47d-47ad-9843-df42e01a8ddc",
          "commandChecksum": "d77e1b8aa2c48447bde9177b5eec4f8d",
          "propsChecksum": "88eed2b03260bde69c192bc7b632246b"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "43",
        "includeLabel": false,
        "sortBy": "43",
        "index": 29,
        "label": "Fill Area",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"fillArea@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills a predefined area with tokens<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "67fac60c-afee-4c7e-93c8-6ebf53cf85a5",
          "commandChecksum": "d48898d75c5eebb035d6ce456c2d816d",
          "propsChecksum": "26ee7bc88d0de6014288573bd62cd3d4"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "77",
        "includeLabel": false,
        "sortBy": "77",
        "index": 30,
        "label": "Find Duplicates",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_findDuplicates()]",
        "maxWidth": "",
        "tooltip": "Give a list of all tokens of all layers on current map that have the same name",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "02606097-1570-4238-ae77-1521f99d040c",
          "commandChecksum": "b307f44d4f2a580d533f8d4de1a833d3",
          "propsChecksum": "c9c3368c0703de036ebdcba90d74d587"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "91",
        "includeLabel": false,
        "sortBy": "91",
        "index": 31,
        "label": "Formation Buttons",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_MacroButtonsGroupMove()]",
        "maxWidth": "",
        "tooltip": "<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e19128dc-9baa-4fd7-aba5-7a3740a37d45",
          "commandChecksum": "9170337ffe76a9de6f3a696b9b309936",
          "propsChecksum": "6cb4bd73113f6e133904488332a3c666"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "81b",
        "includeLabel": false,
        "sortBy": "81b",
        "index": 32,
        "label": "Frame Overview",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_frameOverview()]",
        "maxWidth": "",
        "tooltip": "<html>This macro toggles shows an <br>overview of all Nildiks frames.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "135aee2d-d111-4b15-bf2c-32cc60107d17",
          "commandChecksum": "befa94d1d806f0d740f61945e73cd328",
          "propsChecksum": "91709a5daae9ade03362da5b6efafc64"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "101",
        "includeLabel": false,
        "sortBy": "101",
        "index": 33,
        "label": "Group (Move)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_setGroup()]",
        "maxWidth": "",
        "tooltip": "<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c5964d68-458a-4bd8-be53-0f4bfbbdd782",
          "commandChecksum": "70e4630276c69afb862e09d5f566daf2",
          "propsChecksum": "e888432b74e66b4d9299dd66d065f29f"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "113",
        "includeLabel": false,
        "sortBy": "113",
        "index": 34,
        "label": "Group (Select)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, macro(\"setSelectGroup@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f0b1da83-05f2-4706-acc1-56327075d951",
          "commandChecksum": "960d83e50284677ed9e2f6dd768c720e",
          "propsChecksum": "9e286ba04ad357184a89a503d8b8d794"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 35,
        "label": "Initialize Pads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_initializePads()]",
        "maxWidth": "",
        "tooltip": "<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1868ad0e-8c5e-4262-8c4f-a6a0b7dcbd3c",
          "commandChecksum": "a57b6e5605628f6f7937c29a22a60157",
          "propsChecksum": "c023f67bc76c4c1fc0e1c841629f18c6"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "97",
        "includeLabel": false,
        "sortBy": "97",
        "index": 36,
        "label": "Line Formation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationLine()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "616d23ff-87b1-425c-b34a-8561eaea5fa1",
          "commandChecksum": "64a5d4d524a28211787c32587df0d87a",
          "propsChecksum": "bfebf0599f1a9c125608fbde5ec0d5d1"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "121",
        "includeLabel": false,
        "sortBy": "121",
        "index": 37,
        "label": "Lock Movement",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_movementLock()]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no PLAYER can move a token, only the GM can.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b3048e38-88f7-4f1c-ab4d-a33c46895206",
          "commandChecksum": "2caa8cae1f33e38e3de1cb105fa83e2e",
          "propsChecksum": "b80c134afc66f473312feb5bb7edc92a"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "121",
        "includeLabel": false,
        "sortBy": "121",
        "index": 38,
        "label": "Lock Token",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_tokenLock()]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "21368fea-9b18-4bf3-b9ab-21a929135bcf",
          "commandChecksum": "9a27f2f23492faef260c042f2f89cd81",
          "propsChecksum": "ac20a230a8576c8bca0704395be13013"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 39,
        "label": "Manual",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_manualText()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5b048255-80b6-4282-8e5d-3c53a99eda33",
          "commandChecksum": "47c186c062ecc9f674c3b539fce662a2",
          "propsChecksum": "26aadf704dc6fe2f649abcce97d298f7"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "28",
        "includeLabel": false,
        "sortBy": "28",
        "index": 40,
        "label": "Map Editor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_mapEditor()]",
        "maxWidth": "",
        "tooltip": "Creates an overlay on the token layer where you can quickly create a new map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c88288f9-5518-4725-b6b9-d5573987842c",
          "commandChecksum": "fd927fa63aaee6deb57c3d744a8fe218",
          "propsChecksum": "19cd04aef7f998752fd8f176061c7d37"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "122",
        "includeLabel": false,
        "sortBy": "122",
        "index": 41,
        "label": "Mass VBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"MassVBL@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This function draws VBL crosses on all tokens that match a search string",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "668701cb-02f0-4e18-a9a3-78e4e774c527",
          "commandChecksum": "480d9c67818e81d1a545995daa5c2a91",
          "propsChecksum": "7d934e0b0710728f087816d420e36132"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "85",
        "includeLabel": false,
        "sortBy": "85",
        "index": 42,
        "label": "Setup Sound Pad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"setupSound@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa7bbc70-c7fb-4863-b543-172ffc18f74a",
          "commandChecksum": "be08577caaa75f040551223898d6fb5a",
          "propsChecksum": "5604253db428356212fd71663e56aa57"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "26",
        "includeLabel": false,
        "sortBy": "26",
        "index": 43,
        "label": "Move Crowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_moveCrowd()]",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5a193a32-500d-4583-836b-17c2d3f1fac4",
          "commandChecksum": "7bbdd88c1943c5493946b6bbdd719c7f",
          "propsChecksum": "6135f585ecf89dd9633879a622256331"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "white",
        "group": "27",
        "includeLabel": false,
        "sortBy": "27",
        "index": 44,
        "label": "Move Crowd +",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_moveCrowdPlus()]",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "64689fc7-3a90-4b3b-a1af-186850428b05",
          "commandChecksum": "fe1dd0880bc5963dcac01ca0279a6356",
          "propsChecksum": "a9bfc2187db5eb0e994c1b7352133ea0"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 45,
        "label": "Move Token",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_animateMove()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will animate the movement of the selected token. An options panel will be shown first.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8ea78ee6-6ad0-464a-8dc3-a1cdb0fe650f",
          "commandChecksum": "c679df278e1c0d7bf44583d62147276a",
          "propsChecksum": "68ba7c5dcf374201983824fff2c40f48"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 46,
        "label": "Move to hidden",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_moveToHidden()]",
        "maxWidth": "",
        "tooltip": "Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so they're no longer visible",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "93d32577-e279-4e08-99d2-32f952b6176c",
          "commandChecksum": "173d07393304d1858e996a4a1f60bde2",
          "propsChecksum": "6b933939187e32fae9a17ca4ac430d2e"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "30a",
        "includeLabel": false,
        "sortBy": "30a",
        "index": 47,
        "label": "Move to token",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_moveToToken()]",
        "maxWidth": "",
        "tooltip": "Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "81e6b94e-02dd-4364-834a-c031ad3751f4",
          "commandChecksum": "6953081459002d0de80335ac1cb69386",
          "propsChecksum": "f838eda53cd8799c7ad2d8c25cd70b39"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "96",
        "includeLabel": false,
        "sortBy": "96",
        "index": 48,
        "label": "Packed-Wedge",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationPWedge()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a2aa5093-ae74-4fea-8e9d-03e2b45e192d",
          "commandChecksum": "085e6fbb098820999d088318f1c145f8",
          "propsChecksum": "53e9cbb5af02fd9b03a84b4c6afa4765"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "81",
        "includeLabel": false,
        "sortBy": "81",
        "index": 49,
        "label": "Pads Explorer",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_initializeMap()]",
        "maxWidth": "",
        "tooltip": "Show overview of special pads on map",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9f161d97-c01b-41d5-a874-fa8a13367817",
          "commandChecksum": "b504782766fb4c8641f7a1d641be0175",
          "propsChecksum": "f4ca64e55e4907d1b423355b1204bdb0"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "88",
        "includeLabel": false,
        "sortBy": "88",
        "index": 50,
        "label": "Paste Macros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_pasteMacros()]",
        "maxWidth": "",
        "tooltip": "<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "25290149-4961-4dcb-aff0-0e7318269a38",
          "commandChecksum": "4c44e43dbdb9a59736d03c779bc761fc",
          "propsChecksum": "93c5e4f45506af0f9646fc7c53a067d2"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "29",
        "includeLabel": false,
        "sortBy": "29",
        "index": 51,
        "label": "Quit Editor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_quitEditor()]",
        "maxWidth": "",
        "tooltip": "removes the overlay and the states of the pasted tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "544c5b0a-0773-4ce0-a6c5-ed894f1a223e",
          "commandChecksum": "bafb9b993041933ef9339fa89719b1df",
          "propsChecksum": "43b32599c58c2553de21505f07648f5f"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "74",
        "includeLabel": false,
        "sortBy": "74",
        "index": 52,
        "label": "Remove %20",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_removeP20()]",
        "maxWidth": "",
        "tooltip": "This macro replaces %20 with spaces \" \" in the selected token names",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "680eee7b-20c9-4b44-91fc-08b5295cc1f0",
          "commandChecksum": "b0e5812a822ff2d1f45d8eb0370aa5fb",
          "propsChecksum": "8f56c817879c613773614c5a944cce56"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "72",
        "includeLabel": false,
        "sortBy": "72",
        "index": 53,
        "label": "Renumber Tokens",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_renumberToks()]",
        "maxWidth": "",
        "tooltip": "<html>When you have used the scatter function<br> (especially icw Spread) then you need to <br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2b51939a-803e-40ef-88a5-f010cb8ee9d6",
          "commandChecksum": "df271719bd8f0ad8e52277365a2e455b",
          "propsChecksum": "95133e098e2edf515260053fbc4e2088"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "31",
        "includeLabel": false,
        "sortBy": "31",
        "index": 54,
        "label": "Reset Pit",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:setTokenImage(getTokenPortrait())]",
        "maxWidth": "",
        "tooltip": "<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6f8db39c-dbe1-49f3-b2a4-f0e1d6ea3e28",
          "commandChecksum": "2af7e2d3fa1a35fd6b2ee6dff372acc1",
          "propsChecksum": "23f08fd82630941c359ef1d7bd06b81a"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "92",
        "includeLabel": false,
        "sortBy": "92",
        "index": 55,
        "label": "Rotate CCW",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_rotateCCW()]",
        "maxWidth": "",
        "tooltip": "Select a 'group' token and rotate the other corresponding group tokens around it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2f54de9c-8564-4d3f-939a-42ffee8e5b09",
          "commandChecksum": "2e7654c26f1d5e33b7804c7aa7048404",
          "propsChecksum": "b355de8840289583c1f00c13a96e9045"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "91",
        "includeLabel": false,
        "sortBy": "91",
        "index": 56,
        "label": "Rotate CW",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_rotateCW()]",
        "maxWidth": "",
        "tooltip": "Select a 'group' token and rotate the other corresponding group tokens around it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9bb464ba-6067-4ab1-b3d5-68e87353e5d7",
          "commandChecksum": "edc5b4323bac218a914584e67505e9cd",
          "propsChecksum": "a77d15515f04a73e4297f673404c9812"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "79",
        "includeLabel": false,
        "sortBy": "79",
        "index": 57,
        "label": "DiceBox",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:dbxLaunch()]",
        "maxWidth": "",
        "tooltip": "<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c0470cf3-f1f6-475e-acb6-9a976a1266dc",
          "commandChecksum": "98658570b3e0cc0d011110d7fd677e59",
          "propsChecksum": "ab51b30d9ee1b383a3ecd0d86fd96920"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 58,
        "label": "Scatter Tokens",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_scatter()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad9907c5-2e22-469e-a732-17710a5f87cc",
          "commandChecksum": "ebe58c929e2a71d578013c23c785dd41",
          "propsChecksum": "f55f0cc2aaa32994be453628220a866d"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "77",
        "includeLabel": false,
        "sortBy": "77",
        "index": 59,
        "label": "Seek Token",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"seekToken@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f3ebdada-c22e-454b-b0be-692a75712e47",
          "commandChecksum": "24e7210d58a6dd40342186b96a788881",
          "propsChecksum": "41dca203049cde08cc1cd29b8698b5be"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 60,
        "label": "Set Door",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_setDoor()]",
        "maxWidth": "",
        "tooltip": "<html>To use the <i>Toggle Door(s)<\/i> macro, select one or more doors and click this button to set it up<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1492340d-aed3-43c4-ae6f-94596b7abfce",
          "commandChecksum": "3bdb9c147f31ce3156425981ef4987ba",
          "propsChecksum": "8139c54022fad639b0f1a78a1537cb7e"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "71",
        "includeLabel": false,
        "sortBy": "71",
        "index": 61,
        "label": "Set Draw Order",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_setDrawOrder()]",
        "maxWidth": "",
        "tooltip": "<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6c22f698-58cb-492e-9301-058f28575742",
          "commandChecksum": "a315463a2ac633698ce1cca4f34c8f05",
          "propsChecksum": "a1a3ae236d61eca25a2a67ae724538cb"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 62,
        "label": "Set Event Button",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_setEventButton()]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. \"Switch to Fair Haven\"<br>3. Run this macro<br>4. Select \"Switch Map\" from the list<br>5. In the \"Give Arguments\" box enter the arguments as a stringproperty, e.g.\"toMap=Fair Haven\"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "765f79e7-37ec-41d5-90f7-a730fd4b5aeb",
          "commandChecksum": "e210641deddb97cf68d75404e6f08013",
          "propsChecksum": "dc64a26bdfa8d21b4aae9ac9956067ac"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 63,
        "label": "Set Event Pad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_setEventPad()]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5d459c85-f10d-40bb-bfa4-2d5f0350bad4",
          "commandChecksum": "0a90ca893a35b04199cdb2da390a19dd",
          "propsChecksum": "86844f8ed2c10df06baa8d6d15a9f668"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "75",
        "includeLabel": false,
        "sortBy": "75",
        "index": 64,
        "label": "Set Light Source",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_setLightSource()]",
        "maxWidth": "",
        "tooltip": "<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , <\/b><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3be1efc5-2969-4080-a924-e3334d3c90e7",
          "commandChecksum": "e3d74fe4743c91be13b1f5e32565a23d",
          "propsChecksum": "8a7a89702f25f87c305861641e8f3dd5"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "75",
        "includeLabel": false,
        "sortBy": "75",
        "index": 65,
        "label": "Set Reference",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_setReference()]",
        "maxWidth": "",
        "tooltip": "<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5c2cbd3f-aebf-4e1e-8556-eff3e6c546dc",
          "commandChecksum": "c0e2d29509cd6818216d39b5e29750e0",
          "propsChecksum": "c89dc72babbccbce1aa0239e3a87b690"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "80",
        "includeLabel": false,
        "sortBy": "80",
        "index": 66,
        "label": "Set Roof",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_setRoof()]",
        "maxWidth": "",
        "tooltip": "<html>Here you can give a list of 'entry doors' through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the 'roof' token<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ec537b04-dfa1-4db5-9af4-526a904563fd",
          "commandChecksum": "a7c55c27518cfb86b67ceb512ddc4d83",
          "propsChecksum": "a1df4cdd868139ae94320293c69de011"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "76",
        "includeLabel": false,
        "sortBy": "76",
        "index": 67,
        "label": "Set Token Size",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"setTokSize@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This macro is usufull is you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "49122581-8ce4-4489-83af-2cf74707ed93",
          "commandChecksum": "727a43a8750be4cc56db4fcb0950986f",
          "propsChecksum": "123c2cee3f43a295a363b593546f17c7"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "122",
        "includeLabel": false,
        "sortBy": "122",
        "index": 68,
        "label": "Set VBL Stamp",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"setVBLStamp@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "396dbb6f-7a39-4055-9e0a-9e5aec1597a7",
          "commandChecksum": "194b429ed7ca6aa72c497d386e923704",
          "propsChecksum": "5a19c63252adcce418a3f7faf726eb88"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 69,
        "label": "Settings",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_settings()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ba830772-f2fc-4a31-953f-6790a883df0d",
          "commandChecksum": "a7f60807d315bffb2902ca216b1d6f70",
          "propsChecksum": "cd672ddcaf122a0bd87a031b91cbf5d8"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "79",
        "includeLabel": false,
        "sortBy": "79",
        "index": 70,
        "label": "Show Handout",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"showHandout@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> Pops up a dialog showing the handout of the selected token on all selected clients",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "28adfa0a-b6ac-497a-a25d-3c93f6450105",
          "commandChecksum": "f81cb6d9c06206cade8492f93675f5c9",
          "propsChecksum": "19187e97ced82b4c4c1d5d8f59ddb9f2"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "93",
        "includeLabel": false,
        "sortBy": "93",
        "index": 71,
        "label": "Spread Group",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_spreadGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and spread the other tokens with an offset of X=1 and Y=1",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d5509f44-126a-4846-a459-b4b2bf2a03dd",
          "commandChecksum": "26b0472b5fba3f1bb98eb5c17933c284",
          "propsChecksum": "efff4ac7ea549fb908f7215612e02e38"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "100",
        "includeLabel": false,
        "sortBy": "100",
        "index": 72,
        "label": "Square Formation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationSquare()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "efe8298c-a789-4287-9ecd-fb438fa80f06",
          "commandChecksum": "df9fdb4d3b7bd275572e48e895c1aaf3",
          "propsChecksum": "7f52f65305755fcd1550b28832a46d0a"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 73,
        "label": "StaggerFormation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationStagger()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bada75af-67ec-4f84-8667-b0e7f9b6be8d",
          "commandChecksum": "88ca77e4565e342ba7da88f8fe75992a",
          "propsChecksum": "12d319025542d9ffc495ce4897a811a1"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "23a",
        "includeLabel": false,
        "sortBy": "23a",
        "index": 74,
        "label": "Summon Token",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_summonToken()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "153eb7f6-5148-4bce-8209-ea58a36a9140",
          "commandChecksum": "16de006f2845af74a302952fa3e4c514",
          "propsChecksum": "ac79e2ca4a835a19ddd9f374e97be375"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "78",
        "includeLabel": false,
        "sortBy": "78",
        "index": 75,
        "label": "Switch Map",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"switchMap@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b60c3b6e-5a4b-41f7-b162-e4f24a32ca1a",
          "commandChecksum": "2ac22dcecfb5dc6141d924445f9122b5",
          "propsChecksum": "2a6f46ab12e267e6e5786f86e87da939"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 76,
        "label": "Toggle Door",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_toggleDoor()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f8eceaa5-77ee-4443-9fae-8a906fcd69a2",
          "commandChecksum": "553ea12602db01fdffcdd1de8e86364d",
          "propsChecksum": "cc47ebd6679eafc1d9a0e26acb0993bd"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 77,
        "label": "Toggle Door<b>s<\/b>",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_toggleDoors()]",
        "maxWidth": "",
        "tooltip": "<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "525d43fd-ecf1-44af-98a4-43425b3d9994",
          "commandChecksum": "87d28c4f13b7d99c44239e9cbacd1fa2",
          "propsChecksum": "0d0865e09450fc1aea512958e42d1de8"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "900",
        "includeLabel": false,
        "sortBy": "900",
        "index": 78,
        "label": "Toggle EventMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r,macro(\"toggleOnTokenMove@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0c603cfe-83ab-4cb9-ac7d-29cc4f58ea03",
          "commandChecksum": "d7080583572deafb30d89f25be6cbe2e",
          "propsChecksum": "9095ca50daa546d81e011b16fb667313"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "901",
        "includeLabel": false,
        "sortBy": "901",
        "index": 79,
        "label": "Toggle Full Screen",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"toggleFullScreen@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "61e78a7c-a999-4d89-8bb1-870d51effe27",
          "commandChecksum": "81a3d7023f4b0bc580e0054900c9320e",
          "propsChecksum": "2f80a39d3f2bb922ffbd1778d2581490"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 80,
        "label": "Toggle Lock",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_toggleLock()]",
        "maxWidth": "",
        "tooltip": "Select a door (that has been initialized) and click this button to open or close it",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8d984154-99cb-46a1-80cb-143af1cdd8a2",
          "commandChecksum": "a11beea7b7489d13014f236be59522c8",
          "propsChecksum": "4fb755932cc0f81fd8ee5c2f294340ee"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "122",
        "includeLabel": false,
        "sortBy": "122",
        "index": 81,
        "label": "Toggle Mass VBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"toggleMassVBL@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3a3f3c5e-e05f-4553-8216-66be605ee80d",
          "commandChecksum": "c8d416441dfe192bd6f9800829a3f0b8",
          "propsChecksum": "f52d29e34edecea5adc89b287fc55292"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "73",
        "includeLabel": false,
        "sortBy": "73",
        "index": 82,
        "label": "Toggle Special",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_toggleSpecial()]",
        "maxWidth": "",
        "tooltip": "<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c330191c-f093-492a-bb1e-93164476216a",
          "commandChecksum": "18218b015026daefceae150ab36b12ea",
          "propsChecksum": "51ae8f8a48ac5664f3db84d870c425be"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "89",
        "includeLabel": false,
        "sortBy": "89",
        "index": 83,
        "label": "Undo Del. Macros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_undoDelMacros()]",
        "maxWidth": "",
        "tooltip": "<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f0b466a1-6059-4cd6-af1b-13e1718e8b12",
          "commandChecksum": "b43e8910224907e2b908af0042b57dee",
          "propsChecksum": "a02e4b54ffbae7fa6fffda465a84d3af"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "102",
        "includeLabel": false,
        "sortBy": "102",
        "index": 84,
        "label": "Ungroup (Move)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_clearGroup()]",
        "maxWidth": "",
        "tooltip": "Select one token from a group and use this macro to clear the ENTIRE group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "db116064-98d6-4554-a8b0-0ae5a2784eef",
          "commandChecksum": "1bb17d2afe33e84292d78c4ce3dbd479",
          "propsChecksum": "e7701b958e2209d2fecce89571c32989"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "114",
        "includeLabel": false,
        "sortBy": "114",
        "index": 85,
        "label": "Ungroup (Select)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, macro(\"clearSelectGroup@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a545f420-cf47-4b51-8568-f0a986949729",
          "commandChecksum": "7eb16e507a1d1003865f81691cf30025",
          "propsChecksum": "c53cdfa53bf80cb0e0f5b769bf7ac025"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "81",
        "includeLabel": false,
        "sortBy": "81",
        "index": 86,
        "label": "Use Disguise",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_useDisguise()]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9045297c-a397-41d7-9bc8-bcb28d67b0da",
          "commandChecksum": "0ce1dac741989645cee926b9ff11ef4e",
          "propsChecksum": "5f4717033005cc3c2790b5ed4255c2f3"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "122",
        "includeLabel": false,
        "sortBy": "122",
        "index": 87,
        "label": "VBL Grenade",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"VBLGrenade@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a1b17fd0-c999-44d8-bd67-37a63bb0640f",
          "commandChecksum": "5380fe2b4ab15642f3b7311c6c466a2a",
          "propsChecksum": "b4d843a1539c395bc6c0c9aec06475ae"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "95",
        "includeLabel": false,
        "sortBy": "95",
        "index": 88,
        "label": "Wedge Formation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_formationWedge()]",
        "maxWidth": "",
        "tooltip": "Select one token of a group and put them in formation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8e52926c-8598-4549-93d7-bf2340ed468d",
          "commandChecksum": "ebbe25fe137a2163d4530c0454722117",
          "propsChecksum": "97594ebf585db98354127f8d9d5ec33d"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "80a",
        "includeLabel": false,
        "sortBy": "80a",
        "index": 89,
        "label": "Whisper Frame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_whisperFrame()]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "98b95861-f299-41e4-b8a8-642bd6faff78",
          "commandChecksum": "9f0cc18eb4cc5d22341926831e4f0080",
          "propsChecksum": "28c929119cc9d81be4eb9fa6c99397ae"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "901",
        "includeLabel": false,
        "sortBy": "901",
        "index": 91,
        "label": "reset ALL props",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r,macro(\"deleteProps@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "(copy to Campaign panel)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e6434d27-5d08-4c9f-91c5-c89206756366",
          "commandChecksum": "474d2d430fad812ab096a7e848a01751",
          "propsChecksum": "7c5481889f4e026764ef8e1e2a8ecd1a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 92,
        "label": "Canopy",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:canopyTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(canopyTriggered,startingLocation) || json.contains(canopyTriggered,currentLocation)), CODE:{\n\t[switchToken(padName)]\n\t[inHouse = if(json.contains(canopyTriggered,currentLocation), 1, 0)]\n['pause(\"inHouse\",\"canopyTriggered\",\"currentLocation\",\"padName\", \"lastPath\")']\n\t[r,macro(\"roofSwap@this\"): json.append(\"\", inHouse, tok, padName, 0)]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ec5cd5ff-8ef2-4a72-917c-e3690fba4d7c",
          "commandChecksum": "b44dd1c32c075049347386b384e9b4b6",
          "propsChecksum": "b5d0274ffe6073d62863c7738ef67af2"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 93,
        "label": "EventArea",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n[areaCoords\t\t\t= json.get(thisMapAreas, areaName)]\n[intersectPath\t\t= json.intersection(ignoreStartPath,areaCoords)]\n[eventPadTriggered\t= json.intersection(lastPath,areaCoords)]\n[diffCount\t\t\t= json.length(intersectPath)*DpC]\n[if(!json.isEmpty(eventPadTriggered)), CODE:{ \n\n\t[if(json.contains(thisMapLinks, areaName)):\t\tstrPropVars = json.get(thisMapLinks, areaName); strPropVars = \"\"]\n\t\n\t[if(strPropVars != \"\"), CODE: {\n\t\t[varsFromStrProp(strPropVars)]\n\t}; {\n\t\t[eventMacro = \"\"]\n\t\t[eventTriggerList = \"\"]\n\t}]\n\n\t[eventType\t\t= bot_getEventType()]\n\t[triggered\t\t= listContains(eventTriggerList, eventType)]\n\t[if(triggered),CODE:{\n\t\t[args\t\t\t= json.append(\"\", tok, eventType, areaName, lastPath, eventPadTriggered, 'area' , diffCount)]\n\t\t[macro(eventMacro+\"@Lib:EventMacros\"): args]\n\t}; {\n\t\t[macro.return = \"\"]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eb62f8bf-669d-44c3-8bbb-e0d338e47894",
          "commandChecksum": "023d19e4505dd85e7b51c47826fbbfde",
          "propsChecksum": "3b742c1ec2f2ebcb59892c5400f08d1a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 94,
        "label": "EventPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h: eventPadTriggered = movedOverToken(padName,lastPath)]\n[h, if(!json.isEmpty(eventPadTriggered)), CODE:{\n\t\n\t[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", padName)]\n\t[h:eventType\t\t= bot_getEventType()]\n\t[h:triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[h,if(triggered),CODE:{\n\t\t[h:macroName = getProperty(\"w42.bot.macroName\", padName)]\n\t\t[h:args = json.append(\"\", tok, eventType, padName, lastPath, eventPadTriggered, 'pad')]\n\t\t[h,macro(macroName+\"@Lib:EventMacros\"): args]\n\t\t[bot_playPadSound(padName, tok)]\t\n\t}; {\n\t\t[h:macro.return=\"\"]\n\t}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0657ba21-71b5-4801-ae63-76eb55f76d9e",
          "commandChecksum": "0c2db2f4a6f96b5d82ec55954325aff0",
          "propsChecksum": "4aeccd32ef511a4ff8dac606a7dbf030"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9b",
        "includeLabel": false,
        "sortBy": "9b",
        "index": 95,
        "label": "Foliage",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:foliageTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(foliageTriggered)), CODE:{\n\t[switchToken(padName)]\n\t[inHouse = if(json.contains(foliageTriggered,currentLocation), 1, 0)]\n\t['foliageSwap(inHouse, tok, padName)']\n\n\t[args = json.append(\"\", inHouse, tok, padName, 0)]\n\t[macro(\"roofSwap@this\"): args]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e1e0bef2-8895-45ba-9e6d-881d19a819ef",
          "commandChecksum": "1a87605ad375ad74665e1d874023fb7d",
          "propsChecksum": "49011003ed1cfc1b4648956d9c295627"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 96,
        "label": "InterJump",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\n\t\t\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"\n\t))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3f43760d-3e37-42ac-b49f-24eddd7fed30",
          "commandChecksum": "2a22c973262533392da12c3520136e6f",
          "propsChecksum": "498119d1655f5e41282bbb9a93a22ae2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 97,
        "label": "InterJumpBorder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4406fcfd-7465-42f6-9d8c-1cc43a078903",
          "commandChecksum": "9cbb860dbdd2cff9713aeaeb9d4aa3c1",
          "propsChecksum": "db4094e9d1ec4169edfc326f37e6f781"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 98,
        "label": "InterPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6148b524-4f58-4757-9e19-1b11a1ea7f35",
          "commandChecksum": "305b5c2925af1c060d4cf764e677e430",
          "propsChecksum": "0780a8e060fe7bedc48a486e9170f48f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 99,
        "label": "InterPadBorder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOn\t= json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOn): bot_mapTeleport(strPropFromVars(\"tok, padName, doAbort, eventMacroPreInterTeleport, eventMacroPostInterTeleport,doScaleTeleport,doSwitchInterMap,pathPadList\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "296abcfb-d32e-44d9-8aa6-9ac4fc40990b",
          "commandChecksum": "b145990cf1d2d05ec82032e13d61a361",
          "propsChecksum": "5aeaee45575d3b1bb50fbf909b5c7d2d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 100,
        "label": "Linked",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[linkedTriggered\t= movedOverToken(padName,lastPath)]\n[h:startOnPad\t\t= if(json.contains(linkedTriggered,startingLocation), 1, 0)]\n[h:endOnPad\t\t\t= if(json.contains(linkedTriggered,currentLocation),  1, 0)]\n\n[h:linkId\t\t\t= getGroup(strfind(padName, \"[^\\\\s]+\"), 2, 0)]\n[h:startLinkId\t\t= if(startOnPad, linkId, startLinkId)]\n[h:endLinkId\t\t= if(endOnPad, linkId, endLinkId)]\n\n['pause(\"linkedTriggered\",\"startOnPad\",\"endOnPad\",\"linkId\",\"lastLinkId\",\"startLinkId\",\"endLinkId\")']\n\n[h,if(!json.isEmpty(linkedTriggered) && startOnPad != endOnPad), CODE:{\n\t\n\t\n\t[if(startOnPad && endLinkId == \"\"), CODE:{\n\t\t[linkedAll\t\t= getProperty(\"w42.bot.linked\", padName)]\n\t\t[foreach(pad, linkedAll), CODE:{\n\t\t\t[tlinkedTriggered\t= movedOverToken(pad,lastPath)]\n\t\t\t[endLinkId\t\t\t= if(json.contains(tlinkedTriggered,currentLocation),  linkId, endLinkId)]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t\n\t[if(endLinkID != lastLinkId), CODE:{\n\t\t[switchToken(padName)]\n\t\t[linkedBridge\t= getProperty(\"w42.bot.linkedBridge\")]\n\t\t[linkedTunnel\t= getProperty(\"w42.bot.linkedTunnel\")]\n\t\t[linkedSpecial\t= lower(getProperty(\"w42.bot.linkedSpecial\"))]\n\t\t\n\t\t[overBridge\t= 0]\n\t\t[foreach(pad, linkedBridge):overBridge\t= max(overBridge, !json.isEmpty(movedOverToken(pad,lastPath)))]\n\n\t\t\n\t\t[overTunnel\t= if(listCount(linkedTunnel), 0, 1)]\n\t\t[foreach(pad, linkedTunnel):overTunnel\t= max(overTunnel, !json.isEmpty(movedOverToken(pad,lastPath)))]\n\t\t\n\t\t\n\t\t['activated\t= max(   eval(\"activated\"+linkId),min(!overBridge, overTunnel, endOnPad )   )']\n\t\t['set(\"activated\"+linkId, activated)']\n\n\t\t[activate\t= min(!overBridge, overTunnel, endOnPad)]\n\n\t\t\n\t\t[foreach(pad, linkedSpecial):bot_roofSwap(activate, tok, pad, if(bot_inStr(pad, \"roof\"),1,0), roofHaloColor)]\n\t\t\n\t\t['pause(\"linkedTriggered\",\"startOnPad\",\"endOnPad\",\"linkId\",\"lastLinkId\",\"startLinkId\",\"endLinkId\",\"lastPath\",\"padName\",\"tok\",\"pathPadList\",\"linkedAll\",\"linkedPads\", \"overBridge\",\"overTunnel\")']\n\t\t[switchToken(tok)]\n\t}]\n\t\n''\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "59daf36c-70ee-4e73-8c17-f8b55e85a66f",
          "commandChecksum": "e5a131ba71a40e35c8c399c6414f525d",
          "propsChecksum": "16d9753cbef5f3591ed8fb649c842b89"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 101,
        "label": "MappedPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[iMapped = eval(string(getProperty(\"w42.bot.MappedPad\", padName)))]\n\t[teleportEndName = \"MappedPad \" + iMapped)]\n\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "62c7c378-2fd5-4071-891c-9fb416c94d98",
          "commandChecksum": "c23f2ec307c977297277ca9bfbde5684",
          "propsChecksum": "d35b959628ce271d737a9d4312fa564f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 102,
        "label": "PadEnd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"End\", \"Start\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6abb6f7c-e469-4e99-aee3-f704ebc69b42",
          "commandChecksum": "308a0c11d85b7d0094fdbbeb3003601b",
          "propsChecksum": "fc6c699a8e3e101e5424083004a476d1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 103,
        "label": "PadEndBorder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOff\t= !json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOff): return(0,\"\")] \n\t[teleportEndName = replace(padName, \"End\", \"Start\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c22bffe6-87e5-486e-81ed-6f95f74cf26e",
          "commandChecksum": "40df9774c2aac51063c0f2c2a0936c88",
          "propsChecksum": "6c491476d89e20b66d7c0a19d479c0f1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 104,
        "label": "PadJump",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"Jump\", \"Drop\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "06d20095-304b-4a02-b2a1-37fa7b19a08f",
          "commandChecksum": "9154a7254cf26b9a756b94aba19ae6ca",
          "propsChecksum": "0b12ad24cce39308f35cf1ce71b1df44"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 105,
        "label": "PadJumpBorder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\t[teleportEndName = replace(padName, \"Jump\", \"Drop\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f6ad69ae-b96a-49ae-85fc-83167a35471a",
          "commandChecksum": "ce8d1127995fe91f9f7ac9abac8206ab",
          "propsChecksum": "571d26ad77df704768c2db002f43b890"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 106,
        "label": "PadStart",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(json.contains(teleporterTriggered,currentLocation)), CODE:{\n\t[teleportEndName = replace(padName, \"Start\", \"End\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ea7f75e6-18cf-4361-8b34-e1f2396ae37b",
          "commandChecksum": "02247af6bc8d24204cb305b1082f674a",
          "propsChecksum": "815a5090066ff91862586210e955e683"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 107,
        "label": "PadStartBorder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:teleporterTriggered = movedOverToken(padName,lastPath)]\n[h,if(!json.isEmpty(teleporterTriggered)), CODE:{\n\n\t[t\t\t\t= json.get(lastPath,0,0)]\n\t[movedOff\t= !json.isEmpty(movedOverToken(padName,t))]\n\t[if(movedOff): return(0,\"\")] \n\n\t\n\t[teleportEndName = replace(padName, \"Start\", \"End\")]\n\t[Token(padName): \t\t\tstartCentreX\t= getTokenX(1)]\n\t[Token(padName): \t\t\tstartCentreY\t= getTokenY(1)]\n\n\t[Token(teleportEndName): \tendCentreX\t\t= getTokenX(1)]\n\t[Token(teleportEndName): \tendCentreY\t\t= getTokenY(1)]\n\n\t[bot_teleport(strPropFromVars(\"tok, padName, teleportEndName, startCentreX,startCentreY,endCentreX,endCentreY, eventPreMacroTeleport, eventPostMacroTeleport,doScaleTeleport\", \"UNSUFFIXED\"))]\n\t[goto(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52f3b779-5e0b-4c90-9a18-9aa04fd71821",
          "commandChecksum": "c9ab4d07d7b12855e3b8d0809c265c01",
          "propsChecksum": "960b2ceb69f262a46542c83be0d16d75"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 108,
        "label": "Roof",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:roofTriggered = movedOverToken(padName,lastPath)]\n\n[h: startInHouse\t= if(json.contains(roofTriggered,startingLocation), 1, 0)]\n[h: endInHouse\t\t= if(json.contains(roofTriggered,currentLocation),  1, 0)]\n[h: continue\t\t= if(startInHouse == endInHouse, 0, 1)]\n\n[h,if(!json.isEmpty(roofTriggered) && continue), CODE:{\n\t\n\t[Doors = getProperty(\"w42.bot.Doors\", padName)]\n\t[wentThroughDoor = if(listCount(Doors), 0,1)]\n\t[doorClosed = 0]\n\t[foreach(door, Doors), CODE:{\n\t\t\t[doorTriggered\t= movedOverToken(door,lastPath)]\n\t\t\t[if(!json.isEmpty(doorTriggered)): wentThroughDoor = 1]\n\t\t\t[isClosed = if(getProperty(\"closedAngle\", door) == bot_getTokenFacing(door), 1, 0)]\n\t\t\t[if(isClosed && wentThroughDoor): doorClosed = 1]\n\t}]\n\t[switchToken(padName)]\n\t['pause(\"Doors\",\"wentThroughDoor\",\"doorTriggered\",\"lastPath\",\"roofTriggered\", \"startInHouse\", \"continue\")']\n\t[if(!isGM() && (!wentThroughDoor || doorClosed)),CODE:{\n\t\t[if(startInHouse)\t: iEntryPoint = json.length(roofTriggered)-1; iEntryPoint = json.indexOf (lastPath, json.get(roofTriggered, 0))-1]\n\t\t[edgePoint\t\t= json.get(lastPath, iEntryPoint)]\n\t\t[lastPath\t\t= json.get(lastPath, 0, iEntryPoint)]\n\t\t[x \t\t\t\t= json.get(edgePoint, \"x\")]\n\t\t[y\t\t\t\t= json.get(edgePoint, \"y\")]\n\t\t['pause(\"roofTriggered\", \"doorTriggered\", \"lastPath\", \"entryMod\", \"iEntryPoint\",\"edgePoint\",\"x\",\"y\", \"startInHouse\")']\n\t\t[moveToken(x, y, 1, tok)]\n\t\t[if(doorClosed):\n\t\t\tbroadcast(\"You need to open the door first, before you can \"+if(startInHouse,\"exit\",\"enter\")+\" the building\")\n\t\t; \n\t\t\tbroadcast(\"You can only \"+if(startInHouse,\"exit\",\"enter\")+\" this building through (one of) the door(s)\")\n\t\t]\n\t\t[continue = 0]\n\t}; {}]\t\t\n\t\n\t\n\t[if(continue): bot_roofSwap(endInHouse, tok, padName, 1, roofHaloColor)]\n\t[switchToken(tok)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "58c659d0-9bb5-4067-98ca-3f4095f9ef2b",
          "commandChecksum": "e7b7d690943a2afea3ae9a26191e42d2",
          "propsChecksum": "23807aae23205822447b5f10406bc72d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 109,
        "label": "ShadowPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:eventPadTriggered = movedOverToken(padName,lastPath)]\n[h:tok = getName(currentToken())]\n[h,if(!json.isEmpty(eventPadTriggered)), CODE:{\n\t[event\t= \tbot_getEventType()]\n\t[bot_doShadowPad(tok, event, padName)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "41481129-eb55-4a0e-92c9-17cf0a19cce3",
          "commandChecksum": "c66208739420e06cd19b9992a7ab3334",
          "propsChecksum": "ec9bd47185fbf49a4872b1c9c06aa080"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 110,
        "label": "Ward",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:wardedPadTriggered = movedOverToken(padName,lastPath)]\n[h, if(!json.isEmpty(wardedPadTriggered)), CODE:{\n\t[entryPoint = json.get(wardedPadTriggered, 0)]\n\t[iEntryPoint = json.indexOf (lastPath, entryPoint)]\n\t[edgePoint =  json.get(lastPath, iEntryPoint-1)]\n\t[lastPath =  json.get(lastPath, 0, iEntryPoint-1)]\n\t\n\t[x = json.get(edgePoint, \"x\")]\n\t[y = json.get(edgePoint, \"y\")]\n\t[moveToken(x, y)]\n\n\t[broadcast(\"This area is warded, you are not allowed to move there\")]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ed504306-10e8-4bdf-8c73-9d4c6d97ba10",
          "commandChecksum": "8965ee31229882ce8c0a993760563ddc",
          "propsChecksum": "9c74d08f10c515ed722cf0a7d1bb0ea0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 111,
        "label": "Clear Messages",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:abort(input(\n\t\"junkvar|Make sure you want to do this.|This action will erase ALL messages you have readied|label\",\n\t\"checkvar|No, Yes|Proceed?|radio|\"\n))]\n[h:abort(checkvar)]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",\"{}\",target); setProperty(\"Messages\",\"{}\",target)]\n\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1c8d6c8e-75f9-4f89-9f93-16da90e229ee",
          "commandChecksum": "4eefdf3580fa555d0de893903dfe460b",
          "propsChecksum": "cab171f7e211b9358cb8bf65162d10aa"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 112,
        "label": "Create New Message",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:abort(input(\n\t\"label|Msg1|Enter a label (no spaces) for this message data|text|width=20\",\n\t\"title|Important Info|Enter the title of the message (for the player to see)|text|width=20\",\n\t\"text|You are not illiterate|Enter the message text here|text|width=50\",\n\t\"italic|0|<html><i>Italic|CHECK\",\n\t\"bold|0|<html><b>Bold|CHECK\",\n\t\"underline|0|<html><u>Underline|CHECK\",\n\t\"color|black, gray, maroon, red, yellow, green, blue, navy, purple|Color|LIST\"\n))]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t\t= \"Lib:EventMacros\"\t\t\t\t; target\t\t= currentToken()]\n[h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target)\t; messages\t= getProperty(\"Messages\",target)]\n\n[h,if(json.type(messages)==\"UNKNOWN\"): messages\t= \"{}\"]\n[h:usedlabels\t\t= json.fields(messages)]\n[h:overwritecheck\t= 0]\n[h:done\t\t\t\t= 0]\n[h,while(!done),CODE:{\n\t[if(listFind(usedlabels,label) == -1),CODE:{\n\t\t[done\t\t= 1]\n\t}; {\n\t\t[abort(input(\n\t\t\t\"junkvar|Proceed How?|The label \"+label+\" already exists|label\",\n\t\t\t\"msglabel2|\"+label+\"(2)|Enter another name|text|width=20\",\n\t\t\t\"overwritecheck|0|Or check here to overwrite the previous message|check\"\n\t\t))]\n\t\t[if(overwritecheck==1): done = 1; label = msglabel2]\n\t}]\n}]\n\n\n[h:picID\t\t= \"\"]\n[h:picSize\t\t= 0]\n[h:picPos\t\t= -1]\n\n[h:messageinfo\t= json.fromStrProp(strPropFromVars(\"title, text, italic, bold, underline, color, picID, picSize, picPos\",\"UNSUFFIXED\"))]\n[h:messages\t\t= json.set(messages,label,messageinfo)]\n\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6587ccae-5045-44a8-bbad-07d6e812a65e",
          "commandChecksum": "da50b7bd85ef62d27d3f4e9ab72af36f",
          "propsChecksum": "f57781b6c43deba5d0f95e14ef063be4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 113,
        "label": "Delete Message",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:msglabel\t= macro.args]\n\n[h:abort(input(\t\"confpick|No, Yes|Confirm that you wish to delete \"+msglabel+\"|radio|\" ))]\n\n[h,if(confpick == 1), CODE:{\n\t [h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n\t [h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n\t [h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n\t [h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target); messages\t= getProperty(\"Messages\",target)]\n\t [h:messages\t= json.remove(messages,msglabel)]\n\t [h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n}; {}]\n\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9f1deb68-8ecb-404d-974e-6d2304dfd362",
          "commandChecksum": "344510013c8883ed2b57d977f3bc0025",
          "propsChecksum": "7fe22cf5a032b9f0b211379118f52d9f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 114,
        "label": "Edit Message",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:debug=0]\n[h:varsFromStrProp(macro.args)]\n[h:msglabelbefore\t= msglabel]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messages\t= getLibProperty(\"plothos.bot.messages\",target); messages\t= getProperty(\"Messages\",target)]\n[h:colors\t\t\t= \"black, gray, maroon, red, yellow, green, blue, navy, purple\"]\n\n[h:messageinfo\t\t= json.get(messages,msglabel)]\n[h:varsFromStrProp(json.toStrProp(messageinfo))]\n[h,if(addPic):\tpicID\t= bot_showHandout(1)]\n\n[h,if(picID != \"\"), CODE:{\n\t[toFind\t\t= strfind(picID, \"(.*)-(.*)\")]\n\t[tmp\t= getFindCount(toFind)]\n\t[if(getFindCount(toFind)), CODE:{\n\t\t[picID\t\t= getGroup(toFind,1,1)]\n\t\t[picSize\t= getGroup(toFind,1,2)]\n\t}]\n\n\t[imageStr\t= \"<html><table><tr><td>Yes<\/td><td height='100'><img width=90 height=90 src='\"+picID+\"'><\/img>\t<\/td><\/tr><\/table><\/html>\"]\n\t[showPic\t= \"picHide|\"+imageStr+\", No, Remove|Show picture|RADIO|ORIENT=H SELECT=0\"]\n\t[showSize\t= \"picSize|\"+picSize+\"|Size of picture (px)\"]\n\t[showPos\t= \"picPos|below text, above text|Where to show the picture|RADIO|ORIENT=H SELECT=0\"]\n};{\n\t[picID\t\t= \"\"]\n\t[picSize\t= 0]\n\t[picPos\t\t= -1]\n\t[picHide\t= 0]\n\t[showPic\t= \"\"]\n\t[showSize\t= \"\"]\n\t[showPos\t= \"\"]\n}]\n\n[h:abort(input(\n\t\"msglabel|\"+msglabel+\"|Label used to find this in the manager|text|width\t= 20\",\n\t\"title|\"+title+\"|Title shown in the text frame the player will see|text|width\t= 20\",\n\t\"text|\"+text+\"|Text of the message|text|width\t= 100\",\n\t\"italic|\"+italic+\"|<html><i>Italic|CHECK|\",\n\t\"bold|\"+bold+\"|<html><b>Bold|CHECK\",\n\t\"underline|\"+underline+\"|<html><u>Underline|CHECK\",\n\t\"color|black, gray, maroon, red, yellow, green, blue, navy, purple|<html><font color='\"+listGet(colors,color)+\"'><b>Color<\/b><\/font><\/html>|LIST|SELECT=\"+color,\n\tshowPic,\n\tshowSize,\n\tshowPos\n))]\n[h,if(debug): bot_debugInfo(\"addPic, picID, msglabel, picHide\")]\n\n[h,if(picHide), CODE:{\n\t[picPos\t= -1]\n\t[if(picHide\t== 2): picID = \"\"]\n};{}]\n\n[h:messageinfo\t= json.fromStrProp(strPropFromVars(\"title, text, italic, bold, underline, color, picID, picSize, picPos\",\"UNSUFFIXED\"))]\n\n[h,if(msglabel != msglabelbefore), CODE:{\n\t[abort(input(\n\t\t\"junkvar|You may copy or delete the original one|You have changed the label and will create a new msg|label\",\n\t\t\"copypick|Delete Original, Keep Original|Do which?|radio|\"\n\t))]\n\t[if(copypick == 0): messageinfo\t= json.remove(messageinfo,msglabelbefore)]\n}; {}]\n\n[h:usedlabels\t= json.fields(messageinfo)]\n[h:done\t\t\t= 0]\n\n[h,while(!done), CODE:{\n\t[if(listFind(usedlabels,msglabel)==-1),CODE:{\n\t\t[done\t= 1]\n\t}; {\n\t\t[abort(input(\n\t\t\t\"junkvar|Proceed How?|The label \"+msglabel+\" already exists|label\",\n\t\t\t\"msglabel2|\"+msglabel+\"(2)|Enter another name|text|width=20\",\n\t\t\t\"overwritecheck|0|Or check here to overwrite the previous message|check\"\n\t\t))]\n\t\t[if(overwritecheck==1): done = 1; msglabel = msglabel2]\n\t}]\n}]\n\n[h:messages\t= json.set(messages,msglabel,messageinfo)]\n\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",messages,target); setProperty(\"Messages\",messages,target)]\n[macro(\"notes@this\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "794a83a7-4075-45cb-8c1c-d0148193e5fa",
          "commandChecksum": "043b12c248121f45ce0cad26dd56805d",
          "propsChecksum": "d31f416d4947db64c447505ee216be6c"
        }
      },
            {
        "autoExecute": false,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 115,
        "label": "Open Text Frame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:msgpass\t= macro.args]\n[h:varsFromStrProp(json.toStrProp(msgpass))]\n[h:colors\t= \"black, gray, maroon, red, yellow, green, blue, navy, purple\"]\n\n[frame(title):{\n\t<font size='+2'><b>[r:title]<\/b><\/font><br><br>\n\t[r,if(picPos == 1)\t: strformat(\"<img width=%{picSize} height=%{picSize} src='%{picID}'><\/img><br>\")]\n\t[r,if(italic)\t: \"<i>\"]\n\t[r,if(bold)\t\t: \"<b>\"]\n\t[r,if(underline): \"<u>\"]\n\t[r,if(color)\t: \"<font color=\"+listGet(colors, color)+\">\"]\n\t[r:text]\n\t[r,if(italic)\t: \"<\/i>\"]\n\t[r,if(bold)\t\t: \"<\/b>\"]\n\t[r,if(underline): \"<\/u>\"]\n\t[r,if(color)\t: \"<\/font>\"]\n\t[r,if(picPos == 0)\t: strformat(\"<br><img width=%{picSize} height=%{picSize} src='%{picID}'><\/img>\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4cc77a07-5558-4b58-b8c2-c4dad6c56b84",
          "commandChecksum": "a034e9293de77b685fa05ce3c78526a0",
          "propsChecksum": "315653835b8a8090bd624eb65f04242a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 116,
        "label": "Reset Messages",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): setLibProperty(\"plothos.bot.messages\",\"{}\",target); setProperty(\"Messages\",\"{}\",target)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d3aaee45-69c3-4401-806c-c6e2b5530a4b",
          "commandChecksum": "3d839e98ac50459d2aa9828cbf7f11d4",
          "propsChecksum": "54aaded0ac4842c902dcfdc464bc6022"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 117,
        "label": "Send Prepped Text Starter",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:playernames=listSort(getAllPlayerNames(),\"A\")]\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h,if(string(messageinfo)==\"\"): messageinfo\t= \"{}\"]\n[h:usedlabels\t= json.fields(messageinfo)]\n\n[h:inptext=\"junkvar|Send text frame to whom?|Text can be sent to any player|label\"]\n[h,foreach(playername,playernames),CODE:{\n\t[inptext\t= listAppend(inptext, \"Player\"+roll.count+\"|0|\"+playername+\"|check\", \"##\")]\n\t[num\t\t= roll.count]\n}]\n\n[h:abort(input(\n\tinptext,\n\t\"msgpick|\"+usedlabels+\"|Which message do you want to send?|list|select=0 value=string\"\n))]\n\n[h:varvar=0]\n[c(num+1,\"\"), CODE: {\n\t[if(eval(\"Player\"+varvar) == 1),CODE:{\n\t\t[h:playername\t= listGet(playernames,varvar)]\n\t\t[macro(\"Send Prepped Text Wrap@this\"):playername+\",\"+msgpick]\n\t}; {}]\n\t[h:varvar\t= varvar + 1]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5c947d8a-4efc-4992-b1b3-80ed077269ae",
          "commandChecksum": "f50c73c22fd9b8dda59ff01e31d54b03",
          "propsChecksum": "690fe997bfe37cc063e6fa67f2f01ee6"
        }
      },
            {
        "autoExecute": false,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 118,
        "label": "Send Prepped Text Wrap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:passed\t\t= macro.args]\n[h:playername\t= listGet(passed,0)]\n[h:msgpick\t\t= listGet(passed,1)]\n\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h:indivmsginfo\t= json.get(messageinfo,msgpick)]\n\n[r,w(playername): \"The GM has info for you. Click \"+macroLink(\"here\",\"Open Text Frame@this\",\"none\",indivmsginfo,target)+\" to review it.\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d9a80b21-9d6f-458a-b39f-afb69e1c7947",
          "commandChecksum": "35e0904fac1013dc1d9fe8f4107c944b",
          "propsChecksum": "18dec4ab4ca69134029cfb7a11acc141"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 119,
        "label": "View Messages Text",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:fullview\t= macro.args]\n[h,if(currentToken() == \"\" && getSelected() != \"\"): switchToken(getSelected())]\n[h,if(currentToken() == \"\"): isNPC\t= 1; isNPC\t= isNPC()]\n[h,if(isGM() && isNPC): target\t= \"Lib:EventMacros\"; target\t= currentToken()]\n[h,if(isGM() && isNPC): messageinfo\t= getLibProperty(\"plothos.bot.messages\",target); messageinfo\t= getProperty(\"Messages\",target)]\n[h,if(target == currentToken()): tokenImg\t= getTokenImage(); tokenImg\t= getImage(target)]\n[h:output\t= strformat(\n\t\"<table><tr valign=top><td><img src='%{tokenImg}-50' /><\/td><td><font size='+2'><b>Message Manager<\/b><\/font><br>%s -- %s<\/td><\/tr><\/table><br>\",\n\t macroLink(\"Add Message\",\"Create New Message@this\",\"none\",\"\",target),\n\t macroLink(\"Delete All\",\"Clear Messages@this\",\"none\",\"\",target)\n)]\n\n[h,if(string(messageinfo) == \"\"): messageinfo\t= \"{}\"]\n[h:messagelabels\t= json.fields(messageinfo)]\n[h,if(messagelabels == \"\"): output\t= output + \"(No messages saved)\"]\n[h:messagelabels\t= listSort(messagelabels, \"A\")]\n\n[h:messages\t= \"\"]\n[h,foreach(label,messagelabels),CODE:{\n\t [indivmsginfo\t= json.get(messageinfo,label)]\n\t [msgtext\t\t= json.get(indivmsginfo, \"text\")]\n\t [messages\t\t= listAppend(messages,\n\t\t\t\"<b>(\"+label+\"):<\/b><font size='-2'> -- \"\n\t\t\t+macrolink(\"Send This\",\"Send Prepped Text From Menu@this\",\"all\",label,target)\t\t\t\t\t\t+\" -- \"\n\t\t\t+macroLink(\"Edit This\", \"Edit Message@this\",\"none\",strformat(\"msglabel=%{label};addPic=0\"),target)\t+\" -- \"\n\t\t\t+macroLink(\"Delete This\",\"Delete Message@this\",\"none\",label,target)\t\t\t\t\t\t\t\t\t+\" -- \"\n\t\t\t+macroLink(\"Add Selected Picture\",\"Edit Message@this\",\"none\",strformat(\"msglabel=%{label};addPic=1\"),target)\t+\"<\/font><br>\"\n\t\t\t+\"<b>\"+json.get(indivmsginfo, \"title\")+\":<\/b> \",\"<br><br>\")\n\t]\n\t[if(label != fullview), CODE: { \n\t\t\t[h,if(length(msgtext) >150): \n\t\t\t\tmessages\t= messages + substring(msgtext,0,100)+\"... <font size='-2'>\"+macroLink(\"View Full\",\"notes@this\",\"none\",label,target)+\"<\/font>\"\n\t\t\t; \n\t\t\t\tmessages\t= messages + msgtext\n\t\t\t]\n\t }; {\n\t\t\t[h:messages\t\t= messages + msgtext + \"<font size='-2'>\" + macroLink(\"Shorten\",\"notes@this\",\"none\",\"\",target) + \"<\/font>\"]\n\t }]\n}]\n[R: output + messages]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "623c291f-422a-4503-bd4b-83ee9d0f7249",
          "commandChecksum": "0240edb066d74efde73961a6d6e74b6f",
          "propsChecksum": "bc8be1e5f26cf7cb0d7b40ffe30b1a82"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "0",
        "includeLabel": false,
        "sortBy": "0",
        "index": 120,
        "label": "notes",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:fullview\t= macro.args]\n\n[frame(\"Messages\"):{\n\t[macro(\"View Messages Text@this\"):fullview]\n}]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68c09ae2-3dcc-4549-a0eb-f067c6864b12",
          "commandChecksum": "7b9c7c434db0506b3fbacfd621c379fe",
          "propsChecksum": "e3764f8568f47dcd707d4693c5e9c8dd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 121,
        "label": "HTMLMacroButton",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bgColor\t= arg(1)]\n[h,if(argCount() > 5): shadow = arg(5); shadow = \"\")]\n[h,if(argCount() > 6): toolTip = arg(6); toolTip = \"\")]\n[h,if(argCount() > 7): args = arg(7); args = \"[]\")]\n[h,if(argCount() > 8): libType = arg(8); libType = \"@this\")]\n[h,if(argCount() > 9): output = arg(9); output = \"none\")]\n\n[h:btnformat\t= strformat(\"padding:0px; border-width:1pt; border-style:solid; border-color:black; text-align:center; white-space:nowrap; background-image:url(%{shadow}); background-color:%{bgColor};\")]\n \n<td width='[r:arg(0)]%'>\n\t<table width='100%' cellpadding='0' cellspacing='0'>\n\t\t<tr>\n\t\t\t<td style='[r:btnformat]'>\n\t\t\t\t<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>\n\t\t\t\t\t[r:macroLink(arg(3),arg(4)+libType,output,args)]\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/table>\n<\/td>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aa92c368-36e7-460f-b7f5-7b94e472fa16",
          "commandChecksum": "37eadc2016ed58aadd18f2155ce97b5d",
          "propsChecksum": "5db6b5f0b8759f6c0473c436dd39eeb7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 123,
        "label": "HTMLMacroImageButton",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount() > 5): shadow = arg(5); shadow = \"\")]\n[h,if(argCount() > 6): toolTip = arg(6); toolTip = \"\")]\n[h,if(argCount() > 7): args = arg(7); args = \"[]\")]\n[h,if(argCount() > 8): libType = arg(8); libType = \"@this\")]\n[h,if(argCount() > 9): output = arg(9); output = \"none\")]\n[h:shownImage = strformat(\"<img src='%s' border='0' height='30' width='30' alt='%{toolTip}'/>\",arg(3))]\n\n<td width='[r:arg(0)]%'>\n\t\t<table bgcolor='[r:arg(1)]'>\n\t\t\t<td align='center' style=\"background-image:url([r:shadow]); \" >\n\t\t\t\t<span title='[r:toolTip]' style='text-decoration:none; color:[r:arg(2)]'>[r:macroLink(shownImage,arg(4)+libType,output,args)]<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n<\/td>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b6cadc1a-0a92-46b4-93e5-9fde268b4d77",
          "commandChecksum": "ade3df5634b5084782b1729ad0b192c6",
          "propsChecksum": "56b228e876b5862e8576076f5c5c3d19"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "yellow",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 124,
        "label": "MacroButtonsGroupMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Group Move Macros\", \"width=100; height=310; temporary=1; input=1\"): {\n\t\t[r:bot_createMacroButtonsGroupMove()]\n\t}]\n};{\n\t[frame(\"Group Move Macros\", \"width=100; height=310; temporary=1\"): {\n\t\t[r:bot_createMacroButtonsGroupMove()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c6bb8785-a88b-4294-9225-c1d1604b3ea6",
          "commandChecksum": "fb0941f4992e4e09d6cf119f3d403ed6",
          "propsChecksum": "34fbad36aac03b236894bcf109d319ab"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "0",
        "includeLabel": false,
        "sortBy": "0",
        "index": 125,
        "label": "MacroButtonsOTMSetup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b4f94cbe-be02-48db-83d2-b889f735582f",
          "commandChecksum": "efe1abe859049b22c53835c3542856ee",
          "propsChecksum": "d312a4ca5c7e0fe4e53b66a38c2f5866"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "yellow",
        "group": "0",
        "includeLabel": false,
        "sortBy": "0",
        "index": 126,
        "label": "MacroButtonsOTMUtils",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMUtils()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMUtils()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6f436bd7-44af-4868-bf1c-54ef86b03aa2",
          "commandChecksum": "a6b8560e63824829855527e4045e3596",
          "propsChecksum": "2e737a5980def86dec4cdb7a46061766"
        }
      },
            {
        "autoExecute": true,
        "color": "maroon",
        "fontColor": "white",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 127,
        "label": "createMacroButtonsGroupMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:'']\n\n[h:bColor\t\t='#e5e5cc']\n\n[h: out \t\t= '#BDBDFF']\n[h: in \t\t\t= '#9595FF']\n[h: inner \t\t= '#0000FF']\n[h: innerOFF\t= '#8888FF']\n[h: font \t\t= 'Yellow']\n\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n[h: shadow = tblImage(\"tbl_Image\",2)]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='0' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=1 cellspacing='0' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadding=2 cellspacing='0' bgcolor='%{bColor}'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine  = \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd = \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor='[r:bColor]' style='font-size:8.5px; text-align:center'>\n<table width='100%' cellpadding='1' cellspacing='0'><tr><td>\n\n[h:groupTitle = \"Group Move\"]\n[r:strformat(macroGroup)]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",3), \"rotateCW\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Rotate Group Clockwise<\/b>Select a <i>group<\/i> token and rotate the other corresponding group tokens around it<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",4), \"rotateCCW\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Rotate Group Counter Clockwise<\/b>Select a <i>group<\/i> token and rotate the other corresponding group tokens around it<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",5), \"spreadGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Spread Group<\/b>Select one token of a group and spread the other tokens with an offset of X=1 and Y=1<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",6), \"contractGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Contract Group<\/b>Select one token of a group and contract the other tokens with an offset of X=-1 and Y=-1<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",7), \"formationWedge\", \tshadow, \"<html><bgcolor=red color=yellow><b>Wedge formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",8), \"formationPWedge\",\tshadow, \"<html><bgcolor=red color=yellow><b>Packed Wedge formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",9), \"formationLine\",\tshadow, \"<html><bgcolor=red color=yellow><b>Line formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",10), \"formationEchelon\",shadow, \"<html><bgcolor=red color=yellow><b>Echelon formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",11), \"formationStagger\",shadow, \"<html><bgcolor=red color=yellow><b>Stagger formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",12), \"formationSquare\",shadow, \"<html><bgcolor=red color=yellow><b>Square formation<\/b> Select one token of a group and put them in this formation<\/html>\")]\n\t[r:macroNewLine]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",13), \"setGroup\", \t\tshadow, \"<html><bgcolor=red color=yellow><b>Set Group<\/b> Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved<\/html>\")]\n\t\t[r:bot_HTMLMacroImageButton(50,\"maroon\",\"white\",tblImage(\"tbl_Image\",14), \"clearGroup\", \tshadow, \"<html><bgcolor=red color=yellow><b>Clear Group<\/b> Select one token from a group and use this macro to clear the ENTIRE group<\/html>\")]\n[r:macroGroupEnd]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e5539a70-ad8d-4f90-92ec-74574eb64a55",
          "commandChecksum": "cdb1ded09c23ec7b6445200a6c57ec1b",
          "propsChecksum": "0bfb2005094b34942bc72aa89d55544e"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "orange",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 128,
        "label": "createbuttonDB",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h:'']\n[h:Manual\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Manual\"\t\t\t\t, \"manualText\"\t\t\t, shadow, \"<html>This pops up a user manual of this tool<\/html>\"))]\n[h:Settings\t\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Settings\"\t\t\t\t, \"settings\"\t\t\t, shadow, \"<html>Here you can set stuff as a different name for BASE map.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:BoTFeatures\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"BoT Features\"\t\t\t, \"featureTable\"\t\t, shadow, \"<html><html>Change the installed BoT features.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:InitializePads\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Initialize Pads\"\t\t, \"initializePads\"\t\t, shadow, \"<html>This macro cycles through all maps in the campaign file<br>looking for special pads. It will initialize any special pad it<br>encounters and report any errors  on the way<\/html>\"))]\n[h:AltInitPads\t\t= encode(bot_HTMLMacroButton(50,\"purple\",\"yellow\",\"Alt. Init. Pads\"\t\t, \"altInitMap\"\t\t\t, shadow, \"<html>In contrast to initialize Pads, this macro does ONLY initialize the CURRENT map.<br> It uses a completely different and more time consuming method for this.<br>Resulting in a map where the movement of tokens is less snappy in general<br> But will be (a lot) faster when there are a lot (>100) special tokens on a map.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:ActivateSwitches\t= encode(bot_HTMLMacroButton(50,\"#FFA500\",\"black\",\"Activate Switches\"\t\t, \"openFrame\"\t\t\t, shadow, \"<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br>- Force token selection (token that gm selects on his client is also selected on a player client)<br><\/html>\"))]\n[h:ClearSound\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Clear all sounds\"\t\t, \"clearSound\"\t\t\t, shadow, \"<html>This stop ALL sounds currently streaming/playing AND removes them from memory<\/html>\"))]\n[h:SetSound\t\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"Setup Sound Pad\"\t\t, \"setupSound\"\t\t\t, shadow, \"<html>To setup sound pads<\/i> macro, select one SoundPad token and click this button to set it up<\/html>\"))]\n[h:ReplaceSoundURL\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"black\",\"S&R all sound URL\"\t\t, \"changeAdress\"\t\t, shadow, \"<html>This search and replaces all URLs for ALL soundpads in the campaign file<\/html>\"))]\n[h:SetDoor\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Door\"\t\t\t\t, \"setDoor\"\t\t\t\t, shadow, \"<html>To use the <i>Toggle Door(s)<\/i> macro, select one or more doors and click this button to set it up<\/html>\"))]\n[h:SetRoof\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Roof\"\t\t\t\t, \"setRoof\"\t\t\t\t, shadow, \"<html>Here you can give a list of <i>entry doors<\/i> through which a token can<br>enter the building. Note that these doors MUST be on the edge of the<br>roof (like real doors). If you leave this list empty, a token can move<br>anywhere on or over the <i>roof<\/i> token<\/html>\"))]\n[h:BuildForest\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Build Forest\"\t\t\t, \"buildForest\"\t\t\t, shadow, \"<html>Select a one ore more images of a Tree top (Canopy) and click this button to randomly spread them over an area<\/html>\"))]\n[h:ChooseTrunks\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Choose Trunks\"\t\t\t, \"chooseTrunks\"\t\t, shadow, \"<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>\"))]\n[h:CreateCrowd\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Create Crowd\"\t\t\t, \"createCrowd\"\t\t\t, shadow, \"<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the <i>move crowd<\/i> macro<\/html><\/html>\"))]\n[h:ChooseCrowd\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Choose Crowd\"\t\t\t, \"chooseCrowd\"\t\t\t, shadow, \"<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>\"))]\n[h:ScatterTokens\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Scatter Tokens\"\t\t, \"scatter\"\t\t\t\t, shadow, \"<html>This macro will <i>scatter<\/i> selected tokens over the map, according to the set parameters<\/html>\"))]\n[h:MassVBL\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Mass VBL\"\t\t\t\t, \"MassVBL\"\t\t\t\t, shadow, \"<html>This function draws VBL crosses on all tokens that match a search string\"))]\n[h:DrawArea\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"0. Draw Area\"\t\t\t, \"toggleAreaDraw\"\t\t, shadow, \"<html>This macro fills up an area with tokens. You can either select ONE token and run it, or run it without selection.<br>If you select one token before you run this then that token will be added to the dropdown.<\/html>\"))]\n[h:SetEventPad\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Event Pad\"\t\t\t, \"setEventPad\"\t\t\t, shadow, \"<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set\"))]\n[h:FillArea\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"1. Fill Area\"\t\t\t, \"fillArea\"\t\t\t, shadow, \"<html>This macro fills a predefined area with tokens<\/html>\"))]\n[h:ResetPit\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Reset Pit\"\t\t\t\t, \"resetPit\"\t\t\t, shadow, \"<html>This will show a pop-up with all the initialized doors. Here you can select which to open/close<\/html>\"))]\n[h:DefineArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"2. Define Area\"\t\t, \"defineArea\"\t\t\t, shadow, \"<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.<\/html>\"))]\n[h:SetEventButton\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Event Button\"\t\t, \"setEventButton\"\t\t, shadow, \"<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. 'Switch to Fair Haven'<br>3. Run this macro<br>4. Select 'Switch Map' from the list<br>5. In the 'Give Arguments' box enter the arguments as a stringproperty, e.g.'toMap\t\t\t= Fair Haven'<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap\t\t\t= Fair Haven;message\t\t\t= Going to Fair Haven.<br><br>6. Click OK. Now everything is set up<br><br>To use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>but it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>make this pop-up small, but you cannot close it (else the buttons will not work).<br><br>If you now click on the button 'Switch to Fair Haven' the macro 'Switch Map' is activated.<\/html>\"))]\n[h:AssignArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"3. Assign Area\"\t\t, \"assignArea\"\t\t\t, shadow, \"<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself<\/html>\"))]\n[h:UnShowArea\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"4. (Un)Show Area\"\t\t, \"showArea\"\t\t\t, shadow, \"<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.<\/html>\"))]\n[h:UnShowAreaUtil\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"(Un)Show Area\"\t\t, \"showArea\"\t\t\t, shadow, \"<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.<\/html>\"))]\n[h:AssignTokens\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Assign Tokens\"\t\t\t, \"assignPads\"\t\t\t, shadow, \"<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br><\/html>\"))]\n[h:Execute\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Execute\"\t\t\t\t, \"execAssignPads\"\t\t, shadow, \"<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br><\/html>\"))]\n[h:CreateTable\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Create Table\"\t\t\t, \"createTable\"\t\t\t, shadow, \"<html>With this macro you can create a new BoT table by copy pasting a table from e.g. excel<br>into the text box. You can use bot_table(tableName, optional: column, row) to retrieve<br>an entry from that table.<\/html>\"))]\n[h:ShowTable\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Show Table\"\t\t\t, \"showTable\"\t\t\t, shadow, \"<html>This macro shows a list of all available BoT tables. The one you pick can be edited.<\/html>\"))]\n[h:DeleteTable\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Delete Table\"\t\t\t, \"deleteTable\"\t\t\t, shadow, \"<html>This macro shows a list of all available BoT tables. The one you pick will be deleted.<\/html>\"))]\n[h:CreateMTTable\t= encode(bot_HTMLMacroButton(50,\"blue\",\"white\",\"Create MT Table\"\t\t, \"xls2Table\"\t\t\t, shadow, \"<html>With this macro you can create a new MAPTOOL table by copy pasting a table from e.g. excel<br>into the text box. Pasted entries should be seperated by tabs and newlines (which happens)<br>automatically if you paste it from excel. Next to that you can use either 1, 2 or 3 entries<br>Where the first entry is the start of the roll, the 2nd is the end of the roll range<br>the third is the value so either:<br><i>You summon a dragon<\/i><br>2<i>You summon a dragon<\/i><br>25<i>You summon a dragon<\/i><br><\/html>\"))]\n[h:MapEditor\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Map Editor\"\t\t\t, \"mapEditor\"\t\t\t, shadow, \"<html>Creates a filed where creating a token map becomes really easy. Hit this button for more info.<\/html>\"))]\n[h:QuitMapEditor\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Quit Map Editor\"\t\t, \"quitEditor\"\t\t\t, shadow, \"<html>Stops the Map editor (and removes the editor field)<html>\"))]\n[h:MovetoHidden\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Move to Hidden\"\t\t, \"moveToHidden\"\t\t, shadow, \"<html>Belongs to the map editor. Moves all pasted tokens to the HIDDEN layer so theyre no longer visible.<\/html>\"))]\n[h:MovetoToken\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Move to Token\"\t\t, \"moveToToken\"\t\t\t, shadow, \"<html>Belongs to the map editor. Moves all hidden tokens back to the TOKEN layer.<html>\"))]\n[h:SeekToken\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Seek Token\"\t\t\t, \"seekToken\"\t\t\t, shadow, \"<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use.<\/html>\"))]\n[h:SetLightSource\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Light Source\"\t\t, \"setLightSource\"\t\t, shadow, \"<html>The power of this button is that you can apply it to multiple tokens at once.<br>Select all tokens you want to set the light for before you hit this button.<br>You can set light sources to exclude in the settings.<br><b>Make sure that no lightsource in the campaign setting contains a comma: , <\/b><\/html>\"))]\n[h:SetReference\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Reference\"\t\t\t, \"setReference\"\t\t, shadow, \"<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br> 2. Make sure that the reference tokens are snapped to grid and medium sized.<br> 3. Place one of the tokens on the ground floor map and one on the first floor map.<br> 4. Then select one of the reference tokens and hit this macro. Select the shadow pads to which it<br> should be linked and hit ok.<br> <br> Read the manual for more detailed instructions.<\/html>\"))]\n[h:Remove20\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Remove %20\"\t\t\t, \"removeP20\"\t\t\t, shadow, \"<html>This macro replaces %20 with spaces > < in the selected token names<\/html>\"))]\n[h:SetDrawOrder\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Draw Order\"\t\t, \"setDrawOrder\"\t\t, shadow, \"<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token<\/html>\"))]\n[h:RenumberTokens\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Renumber Tokens\"\t\t, \"renumberToks\"\t\t, shadow, \"<html>When you have used the scatter function<br> (especially icw Spread) then can<br>renumber the scattered tokens before you <br>hit the initialize pads. Assuming that you <br>have scattered special tokens onto the map.<\/html>\"))]\n[h:ToggleSpecial\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Toggle Special\"\t\t, \"toggleSpecial\"\t\t, shadow, \"<html>This macro toggles Canopy, <br>Foliage or Roofs on or off. <br>This also resets the tokens.<\/html>\"))]\n[h:SetTokenSize\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Set Token Size\"\t\t, \"setTokSize\"\t\t\t, shadow, \"<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you wont be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens\"))]\n[h:CopyDelMacros\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Copy/Del Macros\"\t\t, \"cpyDelMacros\"\t\t, shadow, \"<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>  \"))]\n[h:PasteMacros\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Paste Macros\"\t\t\t, \"pasteMacros\"\t\t\t, shadow, \"<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>\"))]\n[h:UndoDelMacros\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Undo Del. Macros\"\t\t, \"undoDelMacros\"\t\t, shadow, \"<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html> \"))]\n[h:FindDuplicates\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Find Duplicates\"\t\t, \"findDuplicates\"\t\t, shadow, \"<html>Give a list of all tokens of all layers on current map that have the same name<\/html>\"))]\n[h:PadExplorer\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Pad Explorer\"\t\t\t, \"initializeMap\"\t\t, shadow, \"<html>This macro shows all special pads on the current map.<\/html>\"))]\n[h:AutoDisguiseBttn\t= encode(bot_HTMLMacroButton(50,\"gray\",\"white\",\"Auto Disguise Bttn\"\t\t, \"autoDisguiseButton\"\t, shadow, \"<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>\"))]\n[h:SetVBLStamp\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Set VBL Stamp\"\t\t\t, \"setVBLStamp\"\t\t\t, shadow, \"<html>This function applies a VBL (Vision Blocking Layer) upon a token.<br>The VBL will move with the token as you move it.\"))]\n[h:MassVBL\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Mass VBL\"\t\t\t\t, \"MassVBL\"\t\t\t\t, shadow, \"<html>This function draws VBL crosses on all tokens that match a search string\"))]\n[h:ToggleVBL\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"Toggle VBL\"\t\t\t, \"toggleMassVBL\"\t\t, shadow, \"<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off\"))]\n[h:Deleteprops\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"DELETE props\"\t\t\t, \"deleteProps\"\t\t\t, shadow, \"<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!!\"))]\n[h:Benchmark\t\t= encode(bot_HTMLMacroButton(50,\"purple\",\"white\",\"Benchmark\"\t\t\t, \"benchmark\"\t\t\t, shadow, \"<html>This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br>and compares their individual times. It uses an empty loop (Default in that group) as<br> reference as deducts that resulting time from the added macros. <br><br>To make use of this, create one or more macros in that group with ONLY the code that you<br>wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br>to test. The higer the number the more accurate the result, but obviously it will take more<br>time to run\", \"\", \"@this\", \"all\"))]\n[h:DiagnoseMaps\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Diagnose Maps\"\t\t\t, \"diagnose\"\t\t\t, shadow, \"<html>Map Error Checks. This function checks ALL maps and ALL (lib)tokens for potential issues.<br>It checks whether token names contain non-alphanumerical characters and checks the libs for the<br>same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br>you to the token. <\/html> \", \"\", \"@this\", \"all\"))]\n[h:CleanTokNames\t= encode(bot_HTMLMacroButton(50,\"red\",\"white\",\"Clean Tok Names\"\t\t\t, \"cleanTokNames\"\t\t, shadow, \"<html>There are certain characters e.g. @ # & that, when used in a token name,<br>can potentially break a macro IF that macro uses that token name. An obvious<br>example is getTokenNames(,) which returns a , seperated list. Should one of<br>the tokens in that list be called e.g. <i>Fire Elemental, Giant<\/i> than the list<br>would thus consist out of <i>Fire Elemental<\/i> and <i>Giant<\/i>. <br><br>This macro tracks these tokens down and reports them in the chat. You then have<br>the choice to either fix them automatically or not.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:Door\t\t\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Toggle Door\"\t\t\t, \"toggleDoor\"\t\t\t, shadow, \"<html>Select a door (that has been initialized) and click this button to open or close it<\/html>\",\"\"))]\n[h:Doors\t\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"yellow\",\"Toggle Door<b>s<\/b>\"\t, \"toggleDoors\"\t\t\t, shadow, \"<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close<\/html>\"))]\n[h:Lock\t\t\t\t= encode(bot_HTMLMacroButton(50,\"Blue\",\"yellow\",\"Toggle Lock\"\t\t\t, \"toggleLock\"\t\t\t, shadow, \"<html>This will toggle the Lock State of a door. Select the door first.<\/html>\"))]\n[h:MoveCrowd\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Move Crowd\"\t\t\t, \"moveCrowd\"\t\t\t, shadow, \"<html>Disperses a crowd created by the <i>Create Crowd<\/i> macro.<br>Make sure the antagonist is on the map.<\/html>\"))]\n[h:MoveCrowdP\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Move Crowd+\"\t\t\t, \"moveCrowdPlus\"\t\t, shadow, \"<html><html>Disperses a crowd created by the <i>Create Crowd<\/i> macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)<\/html>\"))]\n[h:MoveToken\t\t= encode(bot_HTMLMacroButton(50,\"Blue\",\"yellow\",\"Move Token\"\t\t\t, \"animateMove\"\t\t\t, shadow, \"<html>This macro will animate the movement of the selected token. An options panel will be shown first.<\/html>\"))]\n[h:AnimateText\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Animate Text\"\t\t\t, \"animateTextInput\"\t, shadow, \"<html>This will open an input screen where you can set-up animated text.<br>This text will be send and animated within a frame to every attached<br>client pc.<\/html>\"))]\n[h:ExecuteEvent\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Execute Event\"\t\t\t, \"executeEvent\"\t\t, shadow, \"<html>This macro generates a list of macros per group from the lib:Event token.<br>You can select one or more macros which then will be executed<\/html>\"))]\n[h:ExecAssignpad\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Exec Assignpad\"\t\t, \"execAssignPads\"\t\t, shadow, \"<html>Before you can use this macro you first need to assign token to the special Assignpads.<br>Once that is done, you can run this macro and pick the Assignpads to be executed.<br>On execution the linked token will be moved to its assigned pad.<br><\/html>\"))]\n[h:DiceBox\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Dice Box\"\t\t\t\t, \"Launch Dice Box\"\t\t, shadow, \"<html>Opens a form with dices where you can set a group of dice to roll<br>The workings of the Dice box are pretty obvious. What might not be<br>obvious is that it supports 10 different dice boxes. You can click the<br>macro 10 times and set each frame individually.\"))]\n[h:SwitchMap\t\t= encode(bot_HTMLMacroButton(50,\"orange\",\"black\",\"Switch Map\"\t\t\t, \"switchMap\"\t\t\t, shadow, \"<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br><br>If you select tokens before you use this macro, then the option will be added to move<br>the selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br><br>If there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.<\/html>\",\"\"))]\n[h:UseDisguise\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Use Disguise\"\t\t\t, \"useDisguise\"\t\t\t, shadow, \"<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html> \"))]\n[h:ShowHandout\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Show Handout\"\t\t\t, \"showHandout\"\t\t\t, shadow, \"<html> Pops up a dialog showing the handout of the selected token on all selected clients.<\/html>\"))]\n[h:WhisperFrame\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Whisper Frame\"\t\t\t, \"whisperFrame\"\t\t, shadow, \"<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!).<\/html>\"))]\n[h:MessageMngr\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Message Mngr\"\t\t\t, \"notes\"\t\t\t\t, shadow, \"<html>This macro allows you to store prepared messages and manage these.<br>For GMs these will be store on lib:EventMacros, for players these will <br>be stored on the token that they own (and is selected). <br>To add a picture to a message: <br>- create the message (and save it). <br>- select the token that contains the image (can be token,portrait or handout).<br>- click add selected image for that message. The rest should be simple.<br><\/html>\"))]\n[h:GroupMove\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Group (Move)\"\t\t\t, \"setGroup\"\t\t\t, shadow, \"<html>Select a group of tokens to group them for group move.<br>Note that any previous set groups for any of the tokens will be<br>cleared if you run this macro.<br>Also note that this macro makes use of the label field of the<br>token and any current value will get overwritten!!. Changing<br>this value after a group has been set will de-activate group-<br>movement when you move THAT token. The token will still be<br>part of the group and will be moved if another token of the<br>group is moved<\/html>\"))]\n[h:UngroupMove\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Ungroup (Move)\"\t\t, \"clearGroup\"\t\t\t, shadow, \"<html>Select one token from a <i>move<\/i> group and use this macro to clear the ENTIRE group<\/html>\"))]\n[h:Formations\t\t= encode(bot_HTMLMacroButton(50,\"maroon\",\"white\",\"Formations\"\t\t\t, \"MacroButtonsGroupMove\",shadow, \"<html>Open the group move macro frame.<br>Note that it can appear behind this panel.<\/html>\"))]\n[h:SummonTokens\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Summon Tokens\"\t\t\t, \"summonToken\"\t\t\t, shadow, \"<html>With this macro you can summon any token from the BASE map that is on the TOKEN layer.<br>If you select a token first before you click this button then the to-summon-token(s) will be<br>placed on the selected token. Else you can enter x and y coordinates of where you want to summon<br>the token. The types of tokens listed in the Dialog can be specified through the settings.<\/html>\"))]\n[h:ActivateGroup\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Activate Group\"\t\t\t, \"openGroupFrame\"\t\t, shadow, \"<html>This opens a <i>group select<\/i> frame which is required for the <i>Select Group<\/i> to function.<br>When this panel is closed you can still group and ungroup, but the <i>auto select<\/i> will only<br>work when this frame is active.<\/html>\"))]\n[h:GroupSelect\t\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Group (Select)\"\t\t\t, \"setSelectGroup\"\t\t, shadow, \"<html>This macro creates a <i>select group<\/i> of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.<\/html>\"))]\n[h:UngroupSelect\t= encode(bot_HTMLMacroButton(50,\"aqua\",\"black\",\"Ungroup (Select)\"\t\t, \"clearSelectGroup\"\t, shadow, \"<html>This ungroups a <i>Select Group<\/i>. You only need to select one token of the group to ungroup the entire group <\/html>\"))]\n[h:VBLGrenade\t\t= encode(bot_HTMLMacroButton(50,\"black\",\"white\",\"VBL Grenade\"\t\t\t, \"VBLGrenade\"\t\t\t, shadow, \"<html>Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.<\/html>\"))]\n[h:LockMovement\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"red\",\"Lock Movement\"\t\t\t, \"movementLock\"\t\t, shadow, \"<html>When this is turned ON, no PLAYER can move a token, only the GM can.<\/html>\"))]\n[h:LockToken\t\t= encode(bot_HTMLMacroButton(50,\"yellow\",\"red\",\"Lock Token\"\t\t\t\t, \"tokenLock\"\t\t\t, shadow, \"<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: <i>Lock Movement for Locked Tokens<\/i> needs to be turned on!<\/html>\"))]\n[h:MoveEventOn\t\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Move Event is<br>Turned ON\"\t\t\t, \"toggleOnTokenMove\"\t, shadow, \"<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:MoveEventOff\t\t= encode(bot_HTMLMacroButton(50,\"gray\",\"dark gray\",\"Move Event is<br>turned OFF \"\t, \"toggleOnTokenMove\"\t, shadow, \"<html>This will disable/enable the onTokenMoveEvent macros.<br>The onTokenMoveEvent can be demanding for every move<br>a token makes, especially when creating a map this can be<br>annoying. By clicking on this button you can temporarily<br>disable the event. Clicking it again will turn it on again.<\/html>\", \"\", \"@this\", \"all\"))]\n[h:FullScreenModeOn\t= encode(bot_HTMLMacroButton(50,\"red\",\"yellow\",\"Full Screen<br>Mode is ON\"\t\t\t, \"toggleFullScreen\"\t, shadow, \"<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.<\/html>\"))]\n[h:FullScreenModeOff= encode(bot_HTMLMacroButton(50,\"gray\",\"dark gray\",\"Full Screen<gr>Mode is OFF\"\t\t, \"toggleFullScreen\"\t, shadow, \"<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.<\/html>\"))]\n[h:ShowDescription\t= encode(bot_HTMLMacroImageButton(50,\"gray\",\"white\",tblImage(\"tbl_Image\",26)\t\t, \"showDescription\"\t\t, shadow, \"<html><bgcolor=red color=yellow><b>Nildiks Room Description Button<\/b><br>Select a <i>Room Description<\/i> token and hit this button <br>(See Manual for more info)<\/html>\"))]\n[h:roomDescrHelp\t= encode(bot_HTMLMacroImageButton(50,\"gray\",\"white\",tblImage(\"tbl_Image\",31)\t\t, \"roomDescrHelp\"\t\t, shadow, \"<html><bgcolor=red color=yellow><b>Nildiks Room Description HELP<\/b><br>A reference overview of the tags for Nildiks Room Descriptor<br><\/html>\"))]\n[h:StartInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Start Invisibility\"\t, \"Start Invisibility\"\t, shadow, \"<html>Makes a token invisible<br>\"))]\n[h:EndInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"End Invisibility\"\t\t, \"endInvisibility\"\t\t, shadow, \"<html>Makes a token visible<br>\"))]\n[h:SeeInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"See Invisibility\"\t\t, \"seeInvisibility\"\t\t, shadow, \"<html>Token can see invisible tokens in range<br>\"))]\n[h:SawInvis\t\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Saw Invisibility\"\t\t, \"sawInvisibility\"\t\t, shadow, \"<html>Stop seeing invisible tokens<br>\"))]\n[h:PurgeInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Purge Invisibility\"\t, \"purgeInvisibility\"\t, shadow, \"<html>Negates invisibility for tokens as longs as they are in range<br>\"))]\n[h:PurgedInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Purged Invisibility\"\t, \"purgedInvisibility\"\t, shadow, \"<html>Stop negating invisibility<br>\"))]\n[h:AnulInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Anul Invisibility\"\t\t, \"anulInvisibility\"\t, shadow, \"<html>Permanently destroys invisibility on tokens in range<br>\"))]\n[h:AnulledInvis\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"white\",\"Anulled Invisibility\"\t, \"anulledInvisibility\"\t, shadow, \"<html>Stop destroying invisibility<br>\"))]\n[h:resetRanges\t\t= encode(bot_HTMLMacroButton(50,\"#006000\",\"white\",\"Reset Ranges\"\t\t, \"resetRanges\"\t\t\t, shadow, \"<html>Resets invisibility related ranges on selected tokens<br>\"))]\n[h:changeElevation\t= encode(bot_HTMLMacroButton(50,\"#006000\",\"white\",\"Change Elevation\"\t, \"changeElevation\"\t\t, shadow, \"<html>Set the elevation for the selected tokens<br>\"))]\n[h:setAnimateView\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Set Animate View\"\t\t, \"setAnimateView\"\t\t, shadow, \"<html>Use lastpath of selected token to run a screen animation<br>\"))]\n[h:linkViewAnim\t\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Link View Animations\"\t, \"linkViewAnimations\"\t, shadow, \"<html>Run view animation created for selected token<br>\"))]\n[h:runAnimateView\t= encode(bot_HTMLMacroButton(50,\"green\",\"yellow\",\"Run Animate View\"\t\t, \"runAnimateView\"\t\t, shadow, \"<html>Link the view animation of selected tokens and store it on one token<br>\"))]\n[h:embarkation\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Embarkation\"\t\t\t, \"embarkation\"\t\t\t, shadow, \"<html>With this macro you can move (N)PC tokens inside a vehicle.<br>\"))]\n[h:toggleEmbark\t\t= encode(bot_HTMLMacroButton(50,\"blue\",\"yellow\",\"Toggle Embark\"\t\t\t, \"toggleEmbark\"\t\t, shadow, \"<html>IF PCs are embarked on a vehicle you can quickly (dis)embark them<br>\"))]\n\n[h:'']\n\n[h:menuButtons\t\t= strPropFromvars(\"Manual,Settings,BoTFeatures,InitializePads,AltInitPads,ActivateSwitches,SetSound,ClearSound,ReplaceSoundURL,SetDoor,SetRoof,BuildForest,ChooseTrunks,CreateCrowd,ChooseCrowd,ScatterTokens,MassVBL,DrawArea,SetEventPad,FillArea,ResetPit,DefineArea,SetEventButton,AssignArea,UnShowArea,UnShowAreaUtil,AssignTokens,Execute,CreateTable,ShowTable,DeleteTable,CreateMTTable,MapEditor,QuitMapEditor,MovetoHidden,MovetoToken,SeekToken,SetLightSource,SetReference,Remove20,SetDrawOrder,RenumberTokens,ToggleSpecial,SetTokenSize,CopyDelMacros,PasteMacros,UndoDelMacros,FindDuplicates,PadExplorer,AutoDisguiseBttn,SetVBLStamp,MassVBL,ToggleVBL,Deleteprops,Benchmark,DiagnoseMaps,CleanTokNames,Door,Doors,Lock,MoveCrowd,MoveCrowdP,MoveToken,AnimateText,ExecuteEvent,ExecAssignpad,DiceBox,SwitchMap,UseDisguise,ShowHandout,WhisperFrame,MessageMngr,GroupMove,UngroupMove,Formations,SummonTokens,ActivateGroup,GroupSelect,UngroupSelect,VBLGrenade,LockMovement,LockToken,MoveEventOn,MoveEventOff,FullScreenModeOn,FullScreenModeOff,ShowDescription,roomDescrHelp,StartInvis,EndInvis,SeeInvis,SawInvis,PurgeInvis,PurgedInvis,AnulInvis,AnulledInvis,resetRanges, changeElevation, setAnimateView,runAnimateView,linkViewAnim,embarkation,toggleEmbark\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"bot.fg.MenuButtons\", menuButtons, \"lib:OnTokenMove\")]\n\nMenu button database updated",
        "maxWidth": "",
        "tooltip": "creates a DB of all html necessary to create the macro buttons",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a713b146-d5f7-434a-9df6-6c98f0f3118b",
          "commandChecksum": "9881681c0541165fef12fa7dc960315b",
          "propsChecksum": "a665eb14d42159dc18176560e2ed50ee"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 129,
        "label": "createMacroButtonsOTMUtils",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h, if(argCount() > 0): txtOutput\t= arg(0) ; txtOutput\t= \"\"]\n\n[h:'']\n[h:menuButtons\t= getLibProperty(\"bot.fg.MenuButtons\", \"lib:OnTokenMove\")]\n[h:varsFromStrProp(menuButtons)]\n\n[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadinvisding=0 cellspacing='1' bgcolor='#e5e5cc'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine\t= \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd\t= \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor=\"#e5e5cc\" style=\"font-size:8.5px; text-align:center\">\n<table width=\"100%\" cellpadding=\"0\" cellspacing=\"1\"><tr><td>\n\t<table width=\"100%\"><tr><td bgColor = \"#c5c5ac\" align=\"center\">\n\t\t<span color=\"gray\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Setup<\/b>\" ,\"MacroButtonsOTMSetup@this\",\"none\")]<\/span>\n\t\t<\/td><td bgColor = \"#e5e5cc\" align=\"center\">\n\t\t<span color=\"black\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Utils<\/b>\" ,\"MacroButtonsOTMUtils@this\",\"none\")]<\/span>\n\t<\/td><\/tr><\/table>\n\t<\/td><\/tr><tr><td>\n\n\n[h: moveEventToggle\t\t\t= if(getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')==1,  MoveEventOn, MoveEventOff)]\n\n\n\n\n[h:varsFromStrProp(getLibProperty('bot.fg.menuMacroList',  'lib:OnTokenMove'))]\n\n[r, if(listCount(utilAnimationList)), CODE:{\n\t[h:groupTitle\t= \"Animation & Events\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilAnimationList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilAnimationList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilUtilList)), CODE:{\n\t[h:groupTitle\t= \"Utils\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilUtilList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilUtilList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilInvisList)), CODE:{\n\t[h:groupTitle\t= \"Invisibility\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilInvisList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilInvisList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[h:'']\n\n[r,if(txtOutput != \"\"), CODE:{\n\t[h:'']\n\t[r:txtOutput]\n};{}]\n\n<\/td><\/tr><\/table><\/body><\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5c263a48-f7e9-4d37-8f9a-cf95f7951359",
          "commandChecksum": "48812e7ef91cc2ba3a79547d903f6078",
          "propsChecksum": "a49a44fbddbdf813cb515f8477e3c87d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 130,
        "label": "toggleOnTokenMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:assert(isGM(),\"GM Only!!,0\")]\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:baseMapName\t\t= getLibProperty('baseMapName', 'lib:EventMacros')]\n[h:onTokenMoveEvent\t= getLibProperty('onTokenMoveEvent', 'lib:onTokenMove')]\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n\n[h:macroList = getMacros(\",\",\"lib:OnTokenMove\")]\n\n[r,g,if(listContains(macroList, \"onTokenMove\")), CODE:{\n\t[h:setMacroProps(\"onTokenMove\", \"label=#onTokenMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setMacroProps(\"onMultipleTokensMove\", \"label=#onMultipleTokensMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setLibProperty('onTokenMoveEvent', 0, 'lib:onTokenMove')]\n\tThe on token move event is turned <font color=\"red\"><b>off\n}; {\n\t[h:setMacroProps(\"#onTokenMove\", \"label=onTokenMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setMacroProps(\"#onMultipleTokensMove\", \"label=onMultipleTokensMove\", \"; \", \"lib:OnTokenMove\")]\n\t[h:setLibProperty('onTokenMoveEvent', 1, 'lib:onTokenMove')]\n\tThe on token move event is turned <font color=\"red\"><b>on\n}]\n\n[h, if(oldMap != baseMapName):setCurrentMap(oldMap)]\n[h, if(isFrameVisible(\"Bag Of Tricks Macros\")): bot_MacroButtonsOTMUtils()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c413b5f8-5616-4237-8080-04745bf62e33",
          "commandChecksum": "cc7c9a23c4de0fdead14c398e2359e8f",
          "propsChecksum": "19578c7bb13cb2f273c38560a9a36359"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 131,
        "label": "setAnimateView",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me\t\t\t= getSelectedNames()]\n[h:assert(listCount(me)==1,\"Make sure (only) one token is selected before you run this macro\",0)]\n[h:switchToken(me)]\n\n\n[h:\t\t\t\t\t\tsettings\t\t= getProperty(\"w42.animatedViewSettings\")]\n\n[h,if(settings == \"\"):\tsettings\t\t= getLibProperty(\"w42.animatedViewSettings\", \"lib:EventMacros\")]\n\n[h,if(settings == \"\"):\tsettings\t\t= \"delay=0;stepSize=50;width=100;height=50;width1=100;height1=50;useStoredPath=0\"]\n\n[h:varsFromStrProp(settings)]\n\n[h:coords\t\t= getLastPath(0)]\n[h:previousPath\t= getProperty(\"w42.storedPathCoords\")] \n[h,if(json.type(previousPath)!=\"UNKNOWN\"):pCoords = previousPath ; pCoords = \"[]\"]\n\n[h:numCoords\t= json.length(coords)]\n[h:numPCoords\t= json.length(pCoords)]\n[h:assert(numCoords > 1 || numPCoords > 1, \"The 'lastpath' of this token does not exist or is too short (at least 2 coordinates), drag it on the map first and then try again\",0)]\n\n[h:gs\t\t\t= bot_getGridSize()]\n\n[h,if(!isNumber(stepSize)): stepSize = gs]\n\n\n[h:pixelStep\t=\tif(mod(stepSize,gs)==0, 0,1)]\n[h,if(pixelStep), CODE:{\n\t[if(isNumber(width)):\twidth\t= round(width/gs,0)\t\t; width\t\t= 80]\n\t[if(isNumber(height)):\theight\t= round(height/gs,0)\t; height\t= 50]\n\t[if(isNumber(width1)):\twidth1\t= round(width1/gs,0)\t; width1\t= 80]\n\t[if(isNumber(height1)):\theight1\t= round(height1/gs,0)\t; height1\t= 50]\n}]\n\n[h, if(!numCoords): useStoredPath = numPCoords]\n[h, if(!numPCoords): useStoredPath = 0]\n[h:abort(input(\n\tif(!numCoords, \"junk|<html>There is no lastpath for this token, only a stored path <\/html>|-|LABEL|SPAN=TRUE\",\"\"),\n\t\"junk|<html>\nThis function will animate the viewing area for all clients.  The path you see is the lastpath\t\t\t\t\t\t\t\t<br>\nof the currently selected token or the path that is store on the selected token (see below).                        \t\t<br>\nThe <b>width<\/b> and <b>height<\/b> are the number of cells that the view area shows each frame (a <b>frame<\/b> is the       <br>\nmoment the current view area is actually shown on all screens). The <b>delay<\/b> is the delay between                   \t<br>\neach frame shown The <b>pixel shift or step size<\/b> is the amount of pixels the view area moves each                    \t<br>\nframe. To have it move in number of cells use a multiple of the <b>gridsize (<font color='red'>\"+gs+\"<\/font color>)<\/b>.\t<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<br>\n<b>Example<\/b> (horizontal move, so we ignore the y coordinate and height):                                           \t\t<br>\nDragging a token from the origin (x=0) 3 cells to the right creates the path (0)(1)(2)(3).                          \t\t<br>\nLets assume a gridsize of 100. Then that same path in pixel coordinates is (0)(100)(200)(300).                      \t\t<br>\nIf you set the pixel shift to 50 that means that the view area shifts 50 pixels every                               \t\t<br>\nframe. The animated path in pixels will thus be (0)(50)(100)(150)(200)(250)(300). Every coordinate                  \t\t<br>\nis one frame shown as fast as your PC can handle it OR using the delay if its not 0. Here                           \t\t<br>\ndelay=1000 is 1 second between every frame. Lets assume a (view) width of 10 cells, That means                      \t\t<br>\nthat the most left cell you can see on your screen is -5 and the most right one you can see is                      \t\t<br>\n+5 or in pixels: -500 and 500. The view area per frame (xLeft, xRight)thus becomes:                                 \t\t<br>\n(-500,500)(-450,550)(-400,600)(-350,650)(-300,700)(-250,750)(-200,800).                                             \t\t<br>\n\t\n\t<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"stepSize|\"+stepSize+\"|pixel shift per frame (in # pixels)\",\n\t\"delay|\"+delay+\"|Delay per frame (ms)\",\n\t\"width|\"+width+\"|starting width of the viewarea (in # cells)\",\n\t\"height|\"+height+\"|starting height of the viewarea (in # cells)\",\n\t\"width1|\"+width1+\"|final width of the viewarea (in # cells)\",\n\t\"height1|\"+height1+\"|final height of the viewarea (in # cells)\",\n\tif(numCoords && numPCoords, \"useStoredPath|\"+useStoredPath+\"|Use stored path on the token instead of the lastpath?|CHECK\", \"\"),\n\tif(numCoords, \"storePath|0|store 'lastpath' on the token?|CHECK\", \"\"),\n\t\"\"\n))]\n\n[h:stepCount\t= ceil(gs/stepSize*(json.length(coords)-1))]\n[h:minStepSize\t= ceil(gs*json.length(coords)/999)]\n\n\n[h,if(mod(stepSize,gs)!=0 && stepSize > gs):stepSize = round(stepSize/gs,0)*gs]\n\n[h:pixelStep\t= if(mod(stepSize,gs)==0, 0,1)]\n[h,if(pixelStep), CODE:{\n\t[width\t\t= round(width*gs,0)]\n\t[height\t\t= round(height*gs,0)]\n\t[width1\t\t= round(width1*gs,0)]\n\t[height1\t= round(height1*gs,0)]\n}]\n\n[h:settings\t= strPropFromVars(\"delay,stepSize,width,height,width1,height1,useStoredPath\",\"UNSUFFIXED\")]\n[h:setProperty(\"w42.animatedViewSettings\", settings)]\n[h:setLibProperty(\"w42.animatedViewSettings\", settings, \"lib:EventMacros\")]\n[h,if(storePath):setProperty(\"w42.storedPathCoords\", coords)]\n[h,if(useStoredPath): coords\t= pCoords]\n\n[h:assert(stepCount < 999, \"Your path counts a total of :\"+stepCount+\" steps. It cannot be longer than 1000, pls increase the stepsize to at least: \" + minStepSize,0)]\n\n\n[h:newCoords\t= \"[]\"]\n[h:pS\t\t\t= pixelStep]\n[h:d\t\t\t= delay]\n\n\n[h,if(pixelStep), CODE:{\n\t[stepDiv\t= round(gs/stepSize,0)]\n\t[lessCoords\t= json.get(coords, 0,-2)] \n\t[totalSteps\t= json.length(lessCoords)*stepDiv] \n\t[currentStep= 0]\n['pause(\"stepDiv\", \"gs\", \"stepSize\")']\n\t\n\t[dW\t\t\t= width1 - width]\n\t[dH\t\t\t= height1 - height]\n\t[foreach(coord, lessCoords), CODE:{\n\t\t[nextCoord\t= json.get(coords,roll.count+1)]\n\t\t[x\t\t\t= json.get(coord, \"x\")\t\t*gs]\n\t\t[nx\t\t\t= json.get(nextCoord, \"x\")\t*gs]\n\t\t[y\t\t\t= json.get(coord, \"y\")\t\t*gs]\n\t\t[ny\t\t\t= json.get(nextCoord, \"y\")\t*gs]\n\t\t[dX\t\t\t= nx - x]\n\t\t[dY\t\t\t= ny - y]\n\t\t[divX\t\t= floor(dX/stepDiv)]\n\t\t[divY\t\t= floor(dY/stepDiv)]\n\t\t[count(stepDiv), CODE:{\n\t\t\t\t\n\t\t\t\t[nwidth\t\t= width + round(dW*currentStep/totalSteps, 0)]\n\t\t\t\t[nheight\t= height + round(dH*currentStep/totalSteps, 0)]\n\t\t\t\t\n\t\t\t\t[x1\t\t\t= x - round(nwidth/2,0)]\n\t\t\t\t[y1\t\t\t= y - round(nheight/2,0)]\n\t\t\t\t[x2\t\t\t= x + round(nwidth/2,0)]\n\t\t\t\t[y2\t\t\t= y + round(nheight/2,0)]\n\n\t\t\t\t[newCoords\t= json.append(newCoords, strPropFromVars(\"x1, y1, x2, y2, pS, d\",\"UNSUFFIXED\"))]\n\t\t\t\t[currentStep= currentStep + 1]\n\t\t\t\t\n\t\t\t\t[x\t\t\t= x + divX]\n\t\t\t\t[y\t\t\t= y + divY]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t[stepDiv=0]\n''\n};{\n\t[coordsDiv\t\t= stepSize/gs] \n\t[stepCount\t\t= ceil(json.length(coords)/coordsDiv) - 1] \n\t[dW\t\t\t\t= (width1 - width) / stepCount]\n\t[dH\t\t\t\t= (height1 - height) / stepCount]\n\n\t[newCoords\t\t= \"[]\"]\n\t[foreach(coord, Coords), CODE:{\n\t\t[if(!mod(roll.count,coordsDiv)), CODE:{\n\t\t\t[x\t\t\t= json.get(coord, \"x\")]\n\t\t\t[y\t\t\t= json.get(coord, \"y\")]\n\t\t\t[x1\t\t\t= x - round(width/2,0)]\n\t\t\t[y1\t\t\t= y - round(height/2,0)]\n\t\t\t[x2\t\t\t= x + round(width/2,0)]\n\t\t\t[y2\t\t\t= y + round(height/2,0)]\n\n\t\t\t[newCoords\t= json.append(newCoords, strPropFromVars(\"x1, y1, x2, y2, pS, d\",\"UNSUFFIXED\"))]\n\t\t\t\n\t\t\t[width\t\t= width + dW]\n\t\t\t[height\t\t= height + dH]\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n}]\n\n[h:setProperty(\"w42.viewAnimationCoords\", newCoords)] \n\n[h:'broadcast(replace(newCoords, \",\", \"<br>\"))']\n[h:ncoords=json.length(newCoords)]\n[h:'pause(\"width\",\"height\",\"dW\",\"dH\",\"stepDiv\",\"stepSize\",\"coords\",\"newCoords\",\"stepCount\",\"ncoords\",\"height\",\"y1\",\"y2\")']\n\n[h:'']\n[h:bot_execAllPlayers(\"deferHover@Lib:OnTokenMove\", newCoords)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "254f172f-9317-48b1-a9db-c60e84a6cd19",
          "commandChecksum": "6c0191258b9c243e14ef098acf01c4e2",
          "propsChecksum": "d9ce359382c8bfeb3859d19d358abf6a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 133,
        "label": "abortProcess",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[setLibProperty(\"abortProcess\", arg(0), \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4eb89e22-93c6-4e5d-8e41-966c1d29b7ce",
          "commandChecksum": "dfc853ce9dcb37a6ba1696d5defa3fca",
          "propsChecksum": "924342bf51b5b8413f3985ad9509065e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "17",
        "includeLabel": false,
        "sortBy": "17",
        "index": 134,
        "label": "applyLightSource",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h: switchToken(tok)]\n[h: setLight(lightSet,light,eval(\"Lamp\"+i+\"S\"+j))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "71963dcd-ed83-4cca-a6f6-a8acdee06ac0",
          "commandChecksum": "10c9b3243a2da41ea3f5d9ecf26f1883",
          "propsChecksum": "6ed6fd1956cbf2cde8f382cb4ac95506"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "35",
        "includeLabel": false,
        "sortBy": "35",
        "index": 135,
        "label": "benchmark",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:macroIDList\t\t= getMacroGroup(\"Benchmark Macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"\"]\n[h,foreach(id, macroIDList), CODE:{\n\t[macroName\t\t= getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\")]\n\t[if(macroName != \"Default\" && !startsWith(macroName, \"@\")):macroNameList\t= listAppend(macroNameList, macroName)]\n}]\n\n\n[h:timeResults\t= \"\"]\n[h:bot_startTime()]\n[h,foreach(mac, macroNameList,\"\"), CODE:{ [macro(mac+\"@lib:EventMacros\"):\"\"] }]\n[h:time\t= bot_totalTime()]\n\n[h:timeChoices\t= \"1,10,100,1000\"]\n[h:abort(input(\n\t\"junk|<html><b>The following macros will be tested: <\/b><i><br>\"+macroNameList+\"<\/i><br>Choose the number of times you wish to run each macro.<br>The higer the number, the more accurate the result, but<br>that will take more time<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"choice|1 (~\"+bot_formatTime(time,0)+\"),10 (~\"+bot_formatTime(time*10,0)+\"),100 (~\"+bot_formatTime(time*100,0)+\"),1000 (~\"+bot_formatTime(time*1000,0)+\")|Run how many times?|RADIO|SELECT=2\"\n))]\n[h:numTimes\t\t= listGet(timeChoices,choice)]\n\n\n[h:bot_startTime()]\n[h,count(numTimes), CODE:{\n\t[macro(\"Default@lib:EventMacros\"):\"\"]\n}]\n[h:defaultTime\t= bot_totalTime()]\n\n[h:timeResults\t= \"\"]\n<b>BENCHMARK RESULTS:<\/b><br><br>\n<table>\n\t<tr><td><b><u>Macro Name<\/u><\/b><\/td><td><b><u>Execution Time<\/u><\/b><\/td><\/tr><tr><td>\n\t\t[r,foreach(mac, macroNameList,\"<\/td><\/tr><tr><td>\"), CODE:{\n\t\t\t[h:bot_startTime()]\n\t\t\t[h,count(numTimes), CODE:{\n\t\t\t\t[macro(mac+\"@lib:EventMacros\"):\"\"]\n\t\t\t}]\n\t\t\t[h:resultTime\t= max(0,(bot_totalTime() - defaultTime))/numTimes]\n\t\t\t<i>{mac}<\/i><\/td><td>{resultTime}ms (= {bot_formatTime(resultTime)})\n\t\t\t[h:timeResults\t= listAppend(timeResults, resultTime)]\n\t\t}]\n\t<\/td><\/tr>\n<\/table>\n\n[r,if(listCount(macroNameList) > 1), CODE:{\n\t[h:sortedResults\t= listSort(timeResults,\"N-\")]\n\t[h:slowestTime\t\t= listGet(sortedResults, 0)]\n\t[h:fastestTime\t\t= listGet(sortedResults, listCount(timeResults)-1)]\n\t[h:slowestName\t\t= listGet(macroNameList, listFind(timeResults, slowestTime))]\n\t[h:fastestName\t\t= listGet(macroNameList, listFind(timeResults, fastestTime))]\n\t<br>\n\t<b><u>Conclusions:<\/u><\/b><br>\n\t<table>\n\t\t<tr><td>The <b>slowest<\/b> macro is:<\/td><td><b>{slowestName}<\/b> ({slowestTime} ms)<\/td><\/tr>\n\t\t<tr><td>The <b>fastest<\/b> macro is:<\/td><td><b>{fastestName}<\/b> ({fastestTime} ms)<\/td><\/tr>\n\t<\/table>\n\t<br>\n\t<b>Normalized<\/b> results using the fastest ({fastestName}) as base:<br>\n\n\t<table>\n\t\t<tr><td><b><u>Macro Name<\/u><\/b><\/td><td colspan='2'><b><u>Execution Time<\/u><\/b><\/td><\/tr><tr><td>\n\t\t\t[r,foreach(time,sortedResults,\"<\/td><\/tr><tr><td>\"), CODE:{\n\t\t\t\t[h:macroName\t= listGet(macroNameList, listFind(timeResults, time))]\n\t\t\t\t[h,if(fastestTime != 0):normTime\t\t= round(time/fastestTime,1)+\"x\" ; normTime = \"infinate\"]\n\t\t\t\t<i>[r:macroName]<\/i><\/td><td><b>[r:normTime]<\/b><\/td><td>slower then <i>[r:fastestName]<\/i>\n\t\t\t}]\n\t\t<\/td><\/tr>\n\t<\/table>\n};{}]\n<br>\n<b>Remarks:<\/b><br>\nThe resulting execution times are the ACTUAL times it takes to execute the given macro once. Some time is lost by running the macro in a loop and the macro is also looped {numTimes}x.<br>\nSo the resulting times of these tests are processed as follows:<br>\n- first the time it takes to run 'Default' (which is empty) is deducted from the total time. This takes care of the loop time.<br>\n- that result is divided by {numTimes} (number of iterations).<br>\nThe result is thus a close approximation of the actual execution time.<br>\n<br>\nHowever its usually still usefull to run this test 2 or 3 times. There is usually quite some difference between the 1st and 2nd benchmark (probly a caching thing) which can be eliminated by running the benchmark  2 or three times.<br>",
        "maxWidth": "",
        "tooltip": "<html> This macro runs each macro that is in the 'Benchmark Macros' group on lib:Ontokenmove<br> and compares their individual times. It uses an empty loop (Default in that group) as<br>  reference as deducts that resulting time from the added macros. <br> <br> To make use of this, create one or more macros in that group with ONLY the code that you<br> wish to test. Then run this macro and give the number of times (1,10,100 or 1000) you wish<br> to test. The higer the number the more accurate the result, but obviously it will take more<br> time to run",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3a7ec6e4-b88f-42cb-a8d6-c1891dbc9200",
          "commandChecksum": "67e2ae426f246257c0f645d273507194",
          "propsChecksum": "197c6ce5eec062ca8925736ec5e9c971"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 136,
        "label": "bot_broadcast",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h,if(argCount()>1): arg1\t\t= arg(1); arg1\t= bot_all()]\n[h,if(argCount()>2): oldFunc\t= arg(2); oldFunc\t= 0]\n\n\n[h,if(json.isEmpty(arg1)):arg1 = \"['']\"]\n\n[h,if(getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\") && !oldFunc), CODE:{\n\t[oldFunction(arg(0),arg1)]\n\t[bot_execAllPlayers (\"deferBroadcast@this\", arg(0), arg1)]\n};{\n\t[oldFunction(arg(0),arg1)]\n}]\n\n[macro.return = arg(0)]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2a905ff1-f433-47aa-bda7-b29a5d760f1f",
          "commandChecksum": "af7443fa2880579eed8b856c2904e045",
          "propsChecksum": "94b1ae14f1bad162adac4e3b84c8817b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1a",
        "includeLabel": false,
        "sortBy": "1a",
        "index": 137,
        "label": "cleanTokNames",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[h:varsFromStrProp(\"charComma=1 ; charColon=1 ; charApostrophe=1 ; charGrave=0 ; charAcute=0 ; charAmpersand=1 ; charQuestion=1 ; charAt=1 ; charSpace=1 ; charPlus=0 ; charDash=0 ; charEqual=0 ; charHash=0 ; charBar=0 ; charLesser=0 ; charGreater=0 ; charPeriod=0 ; charDollar=1 ; lyrBackGround=1 ; lyrHidden=1 ; lyrObject=1 ; lyrToken=1 ; \"))]\n[h:varsFromStrProp(getLibProperty(\"w42.bot.cleanSettings\", \"Lib:EventMacros\"))]\n\n\n[H: abort(input(\n\t\"tab0 | Choose Character to check for || TAB\", \n\t\"junk|<html>Select which characters to check in tokens<\/html>|<html>\tThe below characters *might* cause an issue<br>\tin token names. This all depends on how you<br>\twill use them. This check allows you to find<br>\tand fix them.<\/html>|LABEL|SPAN=TRUE\",\n\n\t\"junk|<html><br><b>Really bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charComma|\"+charComma+\"|<html>, (comma)<\/html>|CHECK\",\n\t\"charSemicolon|\"+charSemicolon+\"|<html>; (Semicolon)<\/html>|CHECK\",\n\t\"charColon|\"+charColon+\"|<html>: (colon)<\/html>|CHECK\",\n\t\"charApostrophe|\"+charApostrophe+\"|<html>' (apostrophe)<\/html>|CHECK\",\n\t  \n\t\"junk|<html><br><b>Potentially bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charAmpersand|\"+charAmpersand+\"|<html>& (ampersand)<\/html>|CHECK\",\n\t\"charDollar|\"+charDollar+\"|<html>\\$(dollar sign)<\/html>|CHECK\",\n\t\"charQuestion|\"+charQuestion+\"|<html>? (question mark)<\/html>|CHECK\",\n\t\"charAt|\"+charAt+\"|<html>@ (at)<\/html>|CHECK\",\n\t\"charSpace|\"+charSpace+\"|<html><i>Trailing & Leading Spaces<\/i><\/html>|CHECK\",\n\t\n\t\"junk|<html><br><b>Might be bad<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charPlus|\"+charPlus+\"|<html>+ (plus)<\/html>|CHECK\",\n\t\"charDash|\"+charDash+\"|<html>- (dash)<\/html>|CHECK\",\n\t\"charEqual|\"+charEqual+\"|<html>= (equals)<\/html>|CHECK\",\n\t\"charHash|\"+charHash+\"|<html># (hash)<\/html>|CHECK\",\n\t\"charBar|\"+charBar+\"|<html><i>Bar character (=shift backslash)|CHECK\",\n\t\"charLesser|\"+charLesser+\"|<html>< (lesser than)<\/html>|CHECK\",\n\t\"charGreater|\"+charGreater+\"|<html>> (greater then)<\/html>|CHECK\",\n\t\"charPeriod|\"+charPeriod+\"|<html><b>.<\/b> (period)<\/html>|CHECK\",\n\t\"junk|<html><br><b>Pick your own<\/b><br>\tAt your own risk. This uses rather complicated<br>\tregex method and as its unkown to me what you<br>\tenter here, things might blow up.<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"charChosen||<html>Leave 0 to ignore this field<\/html>\",\n\t\n\t\"tab0 | Choose Replacement || TAB\", \n\t\"junk|<html><br><b>\n\tWhen an illegal character is found,<br>\tit will be replaced with another character.<br>\tPls enter this here<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"replacementChar|_|Enter Character\",\n\t\"junk|<html><br><b>\tSuggestions:<\/b><br>\tNothing ('')<br>\tUnderscore ('_')<br>\tSpace (' ')<br><br>Note that when you use Space, you might need<br>\tto run diagnose\tagain as this might result in<br>\ttrailing or leading spaces.\t<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\n\t\"tab0 | Choose Layers || TAB\", \n\t\"junk|<html><br><b>\tOn wich layers should the token<br>names be checked??<\/html>|<html><\/html>|LABEL|SPAN=TRUE\",\n\t\"lyrToken|\"+lyrToken+\"|<html>Token<\/html>|CHECK\",\n\t\"lyrObject|\"+lyrObject+\"|<html>Object<\/html>|CHECK\",\n\t\"lyrHidden|\"+lyrHidden+\"|<html>Hidden<\/html>|CHECK\",\n\t\"lyrBackGround|\"+lyrBackGround+\"|<html>Background<\/html>|CHECK\"\n))]\n[h:varList = \"\ncharComma,charSemicolon,charColon,charApostrophe,charGrave,charAcute,charAmpersand,charQuestion,\ncharAt,charSpace,charPlus,charDash,charEqual,charHash,charBar,charLesser,charGreater,\ncharPeriod,charDollar,lyrBackGround,lyrHidden,lyrObject,lyrToken\n\"]\n\n[h:setLibProperty(\"w42.bot.cleanSettings\", strPropFromVars(varList,\"UNSUFFIXED\"),\"Lib:EventMacros\"))]\n\n\n\n[h:regStr\t\t=\tif(charDollar,\"\\\\\\$\",\"\")]\n\n[h:replaceStr\t= \tif(charColon,\":\",\"\")+\n\t\t\t\t\tif(charSemicolon,\";\",\"\")+\n\t\t\t\t\tif(charApostrophe,\"'\",\"\")+\n\n\t\t\t\t\tif(charAmpersand,\"&\",\"\")+\n\t\t\t\t\tif(charQuestion,\"?\",\"\")+\n\t\t\t\t\tif(charAt,\"@\",\"\")+\n\t\t\t\t\t\n\t\t\t\t\tif(charPlus,\"+\",\"\")+\n\t\t\t\t\tif(charEqual,\"=\",\"\")+\n\t\t\t\t\tif(charHash,\"#\",\"\")+\n\t\t\t\t\tif(charBar,\"|\",\"\")+\n\t\t\t\t\tif(charLesser,\"<\",\"\")+\n\t\t\t\t\tif(charGreater,\">\",\"\")+\n\t\t\t\t\tif(charPeriod,\".\",\"\")+\n\t\t\t\t\tif(charChosen!=0,charChosen,\"\")+\n\t\t\t\t\tif(charDash,\"-\",\"\")\n]\n[h:regStr\t\t= regStr + replaceStr]\n\n[h:layerJson\t\t= \"[]\"]\n[h, if(lyrToken):\t\tlayerJson\t= json.append(layerJson, \"TOKEN\")]\n[h, if(lyrObject):\t\tlayerJson\t= json.append(layerJson, \"OBJECT\")]\n[h, if(lyrHidden):\t\tlayerJson\t= json.append(layerJson, \"HIDDEN\")]\n[h, if(lyrBackGround):\tlayerJson\t= json.append(layerJson, \"BACKGROUND\")]\n\n\n[H:commaTokList\t= getTokenNames(\"%\", json.set(\"{}\", \"layer\", layerJson))]\n[h:tokJson\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", layerJson))]\n\n\n[h:regResult\t\t= strfind(commaTokList,\"[^%]*(,+)[^%]*\")]\n[h:numWrong\t\t\t= min(1000,getFindCount(regResult))]\n[h:commaTokJson\t= \"[]\"]\n[h,if(numWrong), CODE:{\n\t[count(numWrong): commaTokJson = json.append(commaTokJson, getGroup(regResult, roll.count+1,0))]\n}]\n\t\t\n[h,if(charComma):\n\tbroadcast(strformat(\"<b><font color='red'>The following tokens have a comma (,) in their name:<\/b><\/font><br>%{commaTokJson}\"))\n;\n\tcommaTokJson\t= \"[]\"\n]\n\n\n[h:cleanTokList\t= json.toList(json.difference(tokJson, commaTokJson))]\n\n[h:jsonTokIllCharList\t= \"[]\"]\n[h,if(regStr != \"\"), CODE:{\n\t\n\t\n\t[regResult\t= strfind(cleanTokList,\"[^,]*([&+:;=?@#|'<>.-]+)[^,]*\")]\n\t[regResult\t= strfind(cleanTokList,\"[^,]*([\"+regStr+\"]+)[^,]*\")]\n\t[numWrong\t= min(1000,getFindCount(regResult))]\n\t[if(numWrong), CODE:{\n\t\t[count(numWrong): jsonTokIllCharList = json.append(jsonTokIllCharList, getGroup(regResult, roll.count+1,0))]\n\t}]\n\t\n\t[cleanTokList\t= json.difference(cleanTokList, jsonTokIllCharList)]\n\t[broadcast(\"<b><font color='red'>The following tokens have erronous characters in their name:<\/b><\/font>\")]\n\t[broadcast(jsonTokIllCharList)]\n};{}]\n\n[h:jsonTokSpaceList\t= \"[]\"]\n[h, if(charSpace), CODE:{\n\t\n\t[regResult\t= strfind(cleanTokList,\"(?<=,)\\\\s[^,]*|[^,]*\\\\s(?=,)\")]\n\t[numWrong\t= min(1000,getFindCount(regResult))]\n\n\t[if(numWrong), CODE:{\n\t\t[count(numWrong): jsonTokSpaceList = json.append(jsonTokSpaceList, getGroup(regResult, roll.count+1,0))]\n\t}]\n\t[broadcast(strformat(\"<b><font color='red'>The following tokens have trailing and/or leading spaces in their name:<\/b><\/font><br>%{jsonTokSpaceList}\"))]\n};{}]\n\n\n\n[h:hasWrongIdName\t= \"[]\"]\n[h:idList\t= getTokens(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n[h:splices\t= bot_createSplices(idList)]\n[h,foreach(splice, splices), CODE:{\n\t[foreach(id, splice), if(length(id) != 32): hasWrongIdName = json.append(hasWrongIdName, id)]\n\t\n}]\n\n[h:txtOutputL\t= \"\"]\n[h,foreach(id, hasWrongIdName), CODE:{\n\t[txtOutputL\t= listAppend(txtOutputL, getName(strformat(\"%032d\",id)))]\n\t[copyToken(strformat(\"%032d\",id),1,\"\",json.set(\"{}\",\"name\",getName(strformat(\"%032d\",id)),\"delta\",1,\"x\",0,\"y\",0)) ]\n\t[removeToken(strformat(\"%032d\",id)) ]\n}]\n[h:broadcast(strformat(\"<b><font color='red'>The following tokens had an erronous ID tag. This is now fixed:<\/b><\/font><br>%{hasWrongIdName}\"))]\n\n\n[h:message\t= \"In the chat you can see the lists of tokens that will be fixed if you continue.<br>Click <b>OK<\/b> to continue<br>Click <b>CANCEL<\/b> to discontinue\"]\n[h:pause(\"message\")]\n\n\n\n[h,foreach(tok, commaTokJson), CODE:{\n\t[token(tok):token.name = replace(token.name, \",\", replacementChar)]\n}]\n\n\n[h,foreach(tok, jsonTokSpaceList), CODE:{\n\t[token(tok):token.name = trim(token.name)]\n}]\n\n\n[h,foreach(tok, jsonTokIllCharList), CODE:{\n\t[foreach(char, replaceStr,\"\",\"\"), CODE:{\n\t\t[token(tok):token.name = replace(token.name, \"\\\\\"+char, replacementChar)]\n\t}]\n}]\n\n[h:chkDollar\t= getFindCount(strfind(cleanTokList,\"\\\\\\$\"))]\n[h,if(chkDollar):broadcast(\"All tokens have been fixed, except the ones with dollar signs in their name. This cannot be fixed automatically. You will need to mannually change these tokens. You can run this macro again to get a list.\")]",
        "maxWidth": "",
        "tooltip": "<html>There are certain characters e.g. @ # & that, when used in a token name,<br> can potentially break a macro IF that macro uses that token name. An obvious<br> example is getTokenNames(\",\") which returns a , seperated list. Should one of<br> the tokens in that list be called e.g. \"Fire Elemental, Giant\" than the list<br> would thus consist out of \"Fire Elemental\" and \"Giant\". <br><br> This macro tracks these tokens down and reports them in the chat. You then have<br> the choice to either fix them automatically or not.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d5ffaaa4-cc74-4c77-8956-c610aee836cd",
          "commandChecksum": "54ad58c362b6df21bff66d5159a6183c",
          "propsChecksum": "68bc0ae746984cc34b64add65a27271a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 138,
        "label": "deferBroadcast",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[dialog(\"Chat Window\", \"input=1\"):{[r:arg(0)]}]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5514038a-a0ad-4a62-8441-ac5b4c996627",
          "commandChecksum": "b90db030e5945092a58fee3d691cbaeb",
          "propsChecksum": "9cb3518296ebc210e5ccc1127f318105"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "51",
        "includeLabel": false,
        "sortBy": "51",
        "index": 140,
        "label": "deferMessage",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: link = macroLinkText(\"deferMessageLink@Lib:OnTokenMove\", \"self\", arg(0))]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8fa2c131-2f4b-4654-99f6-d3f60645507d",
          "commandChecksum": "02c02f900c45bd1b49516ee178e1036f",
          "propsChecksum": "5912c5cb220cddb0cd97de1e79032a70"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "51",
        "includeLabel": false,
        "sortBy": "51",
        "index": 141,
        "label": "deferMessageLink",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:broadcast(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4261c61e-1690-434b-b96f-c21b22765514",
          "commandChecksum": "f870cb37bd044b5e59287d1fa3f1ec9a",
          "propsChecksum": "75d19c671d87ddeb6982bfec07590b1d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "31",
        "includeLabel": false,
        "sortBy": "31",
        "index": 142,
        "label": "deleteProps",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:allAtOnce\t= 0]\n\n[h:abort(input(\n\t\"junk|<html><b><font color='red'>THIS WILL DELETE TOKEN PROPERTIES OF THE FOLLOWING SELECTED TOKENS<\/font><br><font color='blue'>\"+toks+\"<\/font><\/b><br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"sure|Quit, Choose properties to delete (NONE preselected), Choose properties to delete (ALL preselected), Delete all properties|Pre-select properties?|RADIO|SELECT=0\",\n\tif(listCount(toks) > 1, \"allAtOnce|Choose properties to delete per token, Choose once and delete for all selected tokens|All tokens at once?|RADIO|SELECT=1\",\"\")\n))]\n\n[h:assert(isGm()&&sure, \"Reset ABORTED. Either you're not the GM or you're not sure\",0)]\n\n\n[h,if(allAtOnce && sure!=3): tmpToks = listGet(toks, 0) ; tmpToks = toks]\n\n[r, foreach(tok, tmpToks,\"<br><br>\"), CODE:{\n\t[h:switchToken(tok)]\n\t[h:allProps = getPropertyNamesRaw()]\n\tThe following properties of <b>[r:token.name]<\/b> have been deleted:\n\n\t[r,switch(sure),CODE:\n\t\tcase 1: {\n\t\t\t[h:inputStr = \"[]\"]\n\t\t\t[h:inputStr = json.append(inputStr,\"junk|<html><b>CHECK those properties you wish TO DELETE<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t[h,foreach(prop, allProps): inputStr = json.append(inputStr, \"prop\"+roll.count+\"|0|\"+prop+\"|CHECK\")]\n\t\t\t[h:abort(input(json.toList(json.evaluate(inputStr),\"##\")))]\n\t\t\t\n\t\t\t[h:'']\n\t\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t\t};\n\t\tcase 2: {\n\t\t\t[h:inputStr = \"[]\"]\n\t\t\t[h:inputStr = json.append(inputStr,\"junk|<html><b>CHECK those properties you wish TO DELETE<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t[h,foreach(prop, allProps): inputStr = json.append(inputStr, \"prop\"+roll.count+\"|1|\"+prop+\"|CHECK\")]\n\t\t\t[h:abort(input(json.toList(json.evaluate(inputStr),\"##\")))]\n\t\t\t\n\t\t\t[h:'']\n\t\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t\t};\n\t\tcase 3: {\n\t\t\t[h,foreach(prop, allProps):resetProperty(prop)]\n\t\t\t[r:allProps]\n\t\t\t[h:allAtOnce = 0]\n\t\t};\n\t\tdefault: {[assert(\"0,\"You made an impossible choice\",0\")]}\n\t]\n}]\n\n[r,if(allAtOnce), CODE:{\n\t[h:remToks\t= listDelete(toks, 0)]\n\t<br><br>\n\t[r, foreach(tok, remToks,\"<br><br>\"), CODE:{\n\t\t[h:switchToken(tok)]\n\t\t[h,foreach(prop, allProps), if(eval(\"prop\"+roll.count)):resetProperty(prop)]\n\t\tThe following properties of <b>[r:token.name]<\/b> have been deleted:\n\t\t[r,foreach(prop, allProps, \"\"), if(eval(\"prop\"+roll.count)):\"<br>\"+prop]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>This macro resets ALL properties currently on the token. Effectively deleting all properties. Use carefully!!",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9a1a2955-21f4-4acf-b716-f749f2bcf443",
          "commandChecksum": "a15f7ef57965f5e0483ebafe1ff070b8",
          "propsChecksum": "cddba7253d872e130ed6a406d5f3f910"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "41",
        "includeLabel": false,
        "sortBy": "41",
        "index": 144,
        "label": "isFullScreen",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:FSM = getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")]\n[h:macro.return = if(!isNumber(FSM), 0, FSM)]",
        "maxWidth": "",
        "tooltip": "returns 1 when its toggled else 0",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ac232df1-4103-48df-8a07-31f72969d733",
          "commandChecksum": "7767276ee8ffa69b86f4deac15e5c9ed",
          "propsChecksum": "4c81eca5aaa6ad3685d6c1465fddf436"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 145,
        "label": "manFunctionsTxt",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:output =  \"<font color=red><b><u>BOT FUNCTION DOCUMENTATION<\/u><\/b><br><\/font>\n<p>\nThis function manual exists out of three sections:<br>\n\t\t<b>- GENERAL MACROS<\/b><br>\n\t\t<b>- MESSAGE MACROS<\/b><br>\n\t\t<b>- GEOMETRIC MACROS<\/b><br>\n<\/p>\n\n\t<p>\n\t\t<br>\n\t\t<u><b>GENERAL MACROS<\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_animateText<\/b><\/font><i>(text[, title, position, html-header, width, height, delay, upper])<\/i><br />\n\t\tThese are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the 'Bag of Tricks macro panel'. When the text animation is activated a frame will pop-up on every attached client pc printing the text.<br />\n\t\t<b>- text<\/b>: The text you enter here will be animated in a frame<br />\n\t\t<b>- title<\/b>: The title of the frame<br />\n\t\t<b>- position<\/b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won't be animated<br />\n\t\t<b>- html-header<\/b>: Here you can set some basic make up for the frame itself. If you enter 'Default' it will show a black-green frame with courier font<br />\n\t\t<b>- width & height<\/b>: The dimensions of the Frame<br />\n\t\t<b>- delay<\/b>: Amount of delay per character printed in ms.<br />\n\t\t<b>- upper<\/b>: Print the animated text in UPPER CASE<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_animateMove<\/b><\/font><i>(0. tokenID, 1. x, 2. y [, 3. relative, 4. onImpact(-1:bounce; 0=continue; 1=stop), 5. layer(json.object), 6. vbl(1; 0), 7 delay(ms),  8. distance, 9. macro (to run after 1 move), 10. rotation, 11. rotation step size])<\/i><br />\n\t\tWith this function you can choose to use the input panel by selecting a token and clicking 'Animate Move' in the 'Animation' window. However this is a bit cumbersome for e.g. casting a fireball. The 'better' way is by calling the macro directly.If you give at least the token Id and the x and y coordinates then this function will run automatically with the following 'default' settings: relative=0, onImpact=0, layer='[]', vbl=0, delay=0.<br />\n\t\t<b>- X (#cells)<\/b>: The destination X coord of the token, either absolute or relative to its current position<br />\n\t\t<b>- Y (#cells)<\/b>: Dito X, but then Y<br />\n\t\t<b>- Relative (1/0)<\/b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br />\n\t\t<b>- onImpact - Bounce (-1)<\/b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An 'obstacle' is defined by the below settings.<br />\n\t\t<b>- onImpact - Continue (0)<\/b>: the token is moved to its destination no matter what<br />\n\t\t<b>- onImpact - Stop (1)<\/b>: the animation stop as soon as it meets an obstacle<br />\n\t\t<b>- Token (and the other) layer(s)<\/b>: 'The 'checked' layers will be searched for obstacles' where the token can run into while its moving<br />\n\t\t<b>- Vision Blocking Layer<\/b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc.<br />\n\t\t<b>- Delay (ms)<\/b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br />\n\t\t<b>- Distance (#cells)<\/b>: Distance in cells to travel, regardless of end position<br />\n\t\t<b>- Macro <\/b>: A macro that will be run after every iteration/step/move (e.g. '[runme()]'), set to 0 or '' if unused<br />\n\t\t<b>- R (#degrees)<\/b>: How many degrees the token rotates<br />\n\t\t<b>- R-Stepsize (#degrees)<\/b>: The amount of degrees per step. The higher the number, the faster the rotation<br />\n\t\t<br />\n\t\tNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.\t<br />\n\t\t<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\t[bot_animateMove('Dragon', 12, 12, 1, -1, '["token","object"]', 1, 0, 0, '[broadcast("One step for this Dragon...")]', 360, 10)]<\/i>\n\t\t<\/p>\n\n\t<p>\n\t\t<font color=red><b>bot_createSplices<\/b><\/font><i>(list or array)<\/i><br />\n\t\tThis function can be used for foreach() loops where the entered list contains (potentially) more then 1000 items. This will normally create an error as maximum 1000 items are allowed. This function will return an array with lists, eacht list consisting out of exactly 1000 items so: "1,2,..,1099" will return ["1,2,..1000", "1001, 1002,..1099"]. Then you can use two foreach loops to cycle through the list.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_delay<\/b><\/font>(time)<br />\n\t\tdelays the function with 'time' ms<br />\n\t\t<b>- time: <\/b>milli seconds, so 1second is 1000.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_debugInfo<\/b><\/font><i>(vars [, oneLine, showTok, pause, macroName, macroLocation])<\/i><br />\n\t\tbroadcasts all the listed variables and their current values either on one line (1) or beneath eachother (0)<br />\n\t\t<b>- vars<\/b>:\t\t\tlist of variables you want to track while debuggin<br />\n\t\t<b><i>Optional Arguments<\/i><\/b><br />\n\t\t<b>- oneLine<\/b>:\t\t(0) all variables in one column; (1) (default) all variables on one line<br />\n\t\t<b>- showTok<\/b>:\t\t(0) show nothing; (1) (default) show current token and impersonated token<br />\n\t\t<b>- pause<\/b>:\t\t\t(0) dont pause on debug line; (1) pause on debug line AND show a frame with the debug results<br />\n\t\t<b>- macroName<\/b>:\t\tto make use of this you need to enter <i>getMacroName()<\/i> as argument<br />\n\t\t<b>- macroLocation<\/b>: to make use of this you need to enter <i>getMacroLocation()<\/i> as argument<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\t[bot_debugInfo( 'X, Y, Name, Strength', 0, 1, 1, getMacroName(), getMacroLocation() )]<\/i>\n\t\t\n\t<p>\n\t\t<font color=red><b>bot_execAllPlayers <\/b><\/font><i>(macroNname, arguments[, players, output to])<\/i><br />\n\t\tThis macro executes the macro 'macroName' on ALL SELECTED clients.<br />\n\t\t<b>- macroName<\/b>: name of the macro to execute: e.g. runThisMacro@lib:token<br />\n\t\t<b>- arguments<\/b>: the arguments to pass on to that macro (in the form of an json array)<br />\n\t\t<b>- players<\/b>: a list of PLAYER names where to execute on (so not their token names). Defaults to 'all'<br />\n\t\t<b>- output to<\/b>: Send resulting output of macro to whom (self, gm, all, none, gm-self, list). Defaults to 'none'\n\t\t<\/p>\n\t\t\n\t<p>\n\t\t<font color=red><b>bot_findDuplicates<\/b><\/font>()<br />\n\t\treturns ALL duplicate token (names) from ALL layers on the current map.<\/p>\n\n\t<p>\n\t\t<font color=red><b>bot_frameOpen, bot_frameClose<\/b><\/font>()<br />\n\t\tBy Nildik.\n\t\tThese functions can be used to create a frame around a piece of text, with the sole purpose of making it neater.<br>\n\t\tTo use them you have to decide which frame you wish to use. To get an overview of all available frames run the macro 'Frame Overview'<br>\n\t\t<i><b>Example use:<\/b><br>\n\t\t[R: bot_frameOpen(1,'This is the Title','WHITE')]<br>\n\t\t\tall the html text that is placed between these two functions is shown in a nice frame, in this case Frame Type: 1. <br>\n\t\t\tThe tile of the frame will be : 'This is the Title' and the color of the title will be WHITE. <br>\n\t\t[R: bot_frameClose(1)]\n\t\t<\/i>\t\t\n\t\t<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getCTokDistance<\/b><\/font>(<i>[token1, corner1, token2, corner2, units]<\/i>)<br/>\n\t\t<b>- token1:<\/b> name or id of first token.<br />\n\t\t<b>- corner1:<\/b> distance FROM corner of token1: <i>top_right, top_left, bottom_left or bottom_right<\/i>.<br />\n\t\t<b>- token2:<\/b> name or id of second token.<br />\n\t\t<b>- corner2:<\/b> distance TO corner of token2 <i>top_right, top_left, bottom_left or bottom_right<\/i>.<br />\n\t\t<b>- units:<\/b> units of distance to returns, either: 0 - distance in cells ; 1 - distance in pixels ; 2 - distance in 'distance per cell'.<br />\n\t\treturns a json object e.g.: {'dx':12,'dy':15}.<br />\n\t\t<i><b>Example use:<\/b><br />\n\t\tassume: token1 on 0,0 and token 2 on 10,0 (cell coordinates); pixels per cell: 50; distance per cell 5<br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'top_left', 'Elf', 'bottom_Right', 0)]<br>\n\t\treturns: {'dx':11,'dy':1} <br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'top_left', 'Elf', 'top_left', 1)]<br>\n\t\treturns: {'dx':50,'dy':0} <br />\n\t\t[R: bot_getTokenCornerDistance('Dragon', 'bottom_right', 'Elf', 'top_left', 2)]<br>\n\t\treturns: {'dx':45,'dy':5} <br />\n\t\t<\/i>\t\t\n\t\t<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getGridSize<\/b><\/font>()<br />\n\t\treturns current size of grid in pixels per cell.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getTokenFacing<\/b><\/font>(<i>[token, type]<\/i>)<br />\n\t\tall settings are optional<br />\n\t\t<b>- token:<\/b> name or id of token. Leave blank for currentToken<br />\n\t\t<b>- type:<\/b> <br />\n\t\t(0=default) convert angle from (-180 to 180) to (0-360) So 0=EAST;90=NORTH; 180=WEST and 270=SOUTH. This results in an angle according to mathematical polar coordinates convention (also used in Java) <br />\n\t\t(1) Does the same as the above but also inverts rotation to CW and gives an offset of +90 so 'no token facing' ends up to be 0 instead of 270. An 'unrotated' or 'facing cleared' token faces SOUTH. With the default option this would thus result in 270. With this option it results in 0. In this case thus: 0=SOUTH; 90=EAST;180=NORTH and 270=WEST.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_getPath<\/b><\/font>(<i>[showPath, units, id]<\/i>)<br />\n\t\tall settings are optional<br />\n\t\tThis function returns ALL points where the direction of the tokens' path changed. For an unsnapped token these are the way points, for a snapped token also the points will be added for non 45 degree angle diagonal movement. This function can also be used to show the entire path including the facing direction. In addition it can *show* the path by placing feet tokens on it path.<br />\n\t\t<b>- showPath: <\/b> (0) (default):do not show the path (just return the waypoint); (1) show the path (with feet token) and REMOVE the last shown path , (2)  show the path (with feet token) and DO NOT REMOVE the last shown path, (3) REMOVE the last path shown on the map<\/b> <br />\n\t\t<b>- units: <\/b> (0) return the coordinates in cells ; (1) (default) return the coordinates in pixels<br />\n\t\t<b>- id: <\/b>token id or name<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_getTokensPath<\/b><\/font>(<i>token1, token2[, staircasing, units]<\/i>)<br />\n\t\tThis function returns an json array containing the coordinates of all the cells (including the tokens positions) between the two given tokens.<br />\n\t\t<b>- token1: <\/b>starting token name or Id, its coordinates will be the first coord in the array<br />\n\t\t<b>- token2: <\/b>ending token name or Id, its coordinates will be the last coord in the array<br />\n\t\t<b>- staircasing:<\/b>(1) (default) no diagonal connection between cells so the 'next' cell will always be n/s/e/w of the current cell. (0) diagonal connection allowed, so ne/nw/se/sw are allowed as well. <br />\n\t\t<b>- units: <\/b>(1) return coordinates in pixels; (0) (default) return coordinates in cells<br /><\/p>\n\t<p>\n\t\t<font color=red><b>bot_getValidTokens<\/b><\/font><i>(useCurrentMap, conditions, use_none, startsWithTxt)<\/i><br />\n\t\tALL arguments are optional<br />\n\t\tThis function does not return anything but operates in the same scope and will create several types of lists of tokens from the BASE map. For every list there is also a 'graphic' list accompanyin it giving it the option to use for the input LIST function. Have a look at 'summonToken' function to better understand its workings.<br />\n\t\t<b>- useCurrentMap<\/b>: (0) use BASE map ; (1) use CURRENT map<br />\n\t\t<b>- conditions<\/b>: read the wiki conditions for getTokenNames(), defaults to '{}'<br />\n\t\t<b>- use_None<\/b>: will add 'None' as first option for all lists, defaults to 1<br />\n\t\t<b>- startsWithTxt<\/b>: allows for a partial search string to return. Defaults to ""<\/p>\n\t<p>\n\t\t<font color=red><b>bot_ids2Names<\/b><\/font><i>(tokList)<\/i><br />\n\t\tThis function returns a list of token names.<br />\n\t\t- <b>tokList<\/b>: a list of token ID's.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_inStr<\/b><\/font><i>(string, searchStr)<\/i><br />\n\t\tThis function returns 0 when searchStr is NOT found within string, ELSE it will return a number not 0.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_startInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_endInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_seeInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_sawInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_purgeInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_purgedInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_anullInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\t<font color=red><b>bot_annuledInvisibility<\/b><\/font><i>([tokList])<\/i><br />\n\t\tThese functions can be used as direct macro or made part of your own custom macro. A full explanation can be found in the (other) Manual.\n\t\t- OPTIONAL: <b>tokList<\/b>: a list of token ID's or names. If no argument is given it applies on all selected tokens. <\/p>\n\t<p>\n\t\t<font color=red><b>bot_rotateGroup<\/b><\/font><i>(degrees [, tokens])<\/i><br />\n\t\tthis rotates a group of tokens in respect of eachother, regardless of size. The one condition is that the tokens must NOT be set tofreesize.<\/p>\n\t\t<b>- degrees<\/b>: multiples of +/-90 degrees, where + is CCW and - CW<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- tokens<\/b>: List of tokens to rotate. Defaults to currently selected tokens<\/p>\n\t<p>\n\t\t<font color=red><b>bot_round2Grid<\/b><\/font><i>(coordinate [, gridsize])<\/i><br />\n\t\tthis rounds a coordinate exactly to the current gridsize. E.g. in a 50 size grid, the argument 55, will return 50. 122 will return 100 etc.<\/p>\n\t\t<b>- coordinate<\/b>: any number, usually a coordinate to which a function is applied<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- gridsize<\/b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_round2Grid(70)] - will return 50 for a 50 gridsize map, 75 for a 25 gridsize map and 100 for a 100 gridsize map.<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_ppc2GridCoord<\/b><\/font><i>(coordinate [, gridsize])<\/i><br />\n\t\tThis will translate a 'pixel per cell' coordinate in a 'grid cell' coordinate. E.g. on a 50 pixel per grid size map (so ppC is 50) the coordinate 150 will return 3 (third grid cell)<\/p>\n\t\t<b>- coordinate<\/b>: a coordinate in pixels per cell, usually a multiple of the gridsize<br />\n\t\t<b><i>Optional Argument<\/i><\/b><br />\n\t\t<b>- gridsize<\/b>: this is the number it will be rounded to. If no argument is given the gridsize of the current map is taken.<br />\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_ppc2GridCoord(100)] - will return 2 for a 50 gridsize map, 4 for a 25 gridsize map and 1 for a 100 gridsize map.<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_seekToken<\/b><\/font><i> ([returnArg(0/1), findStr(string), layers(json object), maps(list), libTokens(0/1), jsonOutput(0/1)])<\/i><br />\n\t\tThis macro searches ALL maps and ALL tokens and returns a list of those tokens of which their name (partially) matches with the entered search string.<br />\n\t\tALL arguments are optional. IF only one map then this function returns a list of found tokens, IF multiple maps, then this function will return a json object with the map as key.<br />\n\t\t- <b>returnArg<\/b>: (1) the given arguments are used and NO input screen will pop-up. Basically if you want to use this as a function you need to start it with '1'<br />\n\t\t- <b>findstr<\/b>: the string to look for in the token, default is ""<br />\n\t\t- <b>layers<\/b>: to look in, default is ["TOKEN", "HIDDEN", "OBJECT", "BACKGROUND"],<br />\n\t\t- <b>maps<\/b>: the maps to look into, default is current map<br />\n\t\t- <b>libTok<\/b>: (0) (default) is do NOT return any found lib tokens; 1 is DO return any libtokens.<\/p>\n\t\t- <b>jsonOutput<\/b>: (0) (default) is only 1 map is listed the output will be a list. If multiple maps are listed the output is a json construct. Setting this to 1 will force a json output regardless of the number of maps listed.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_setTokenFacing<\/b><\/font>(angle [, token,type])<br />\n\t\tThis function sets the token facing according to the 'normal' polar coordinate system, instead of the rather convoluted MT system.<br />\n\t\t<b>- angle:<\/b> angle in degrees<br />\n\t\t<b>- token:<\/b> token id<br />\n\t\t<b>- type<\/b>: <br />\n\t\t\t(0=default) 0=EAST;90=NORTH; 180=WEST and 270=SOUTH. This results in an angle according to mathematical polar coordinates convention (also used in Java) <br />\n\t\t\t(1) inverts rotation to CW and gives an offset of +90 so 'no token facing' ends up to be 0 instead of 270. An 'unrotated' or 'facing cleared' token faces SOUTH. With the default (0) option you would thus use 270. With this alternative (1) option you use 0. In this case thus: 0=SOUTH; 90=EAST;180=NORTH and 270=WEST.<\/p>\n\t<p>\n\t\t<font color=red><b>bot_showHTML<\/b><\/font><i>(string)<\/i><br />\n\t\tThis function will pop-up two forms, one with the <html> code and the other with the result. This is purely for debug purposes and works best when followed by a pause().<\/p>\n\t<p>\n\t\t<font color=red><b>bot_snapAngle<\/b><\/font><i>(token [,divider, align])<\/i><br />\n\t\tThis function aligns the facing of a token to the closest angle given along a divider and returns the new angle<br />\n\t\te.g a divider of 4 will face a token to either -90 0 90 or 180 depending on where its closest at<br />\n\t\tyou can also turn off the align and just return the closest angle<br />\n\t\ttoken: id of the token<br />\n\t\tdivider: the number of allowed facing angles<br />\n\t\talign: 1 is set the token facing to the closest divider angle, 0 is just return the closest angle. Defaults to 1<\/p>\n\t<p>\n\t\t<font color=red><b>bot_sortTokByProp<\/b><\/font><i>(propertyName[,sortOder, tokenList)<\/i><br />\n\t\tReturns an array token Ids or Names of given or selected tokens, sorted by given property.<br />\n\t\t<b>- propertyName:<\/b> name of the property, e.g. 'Strength'<br />\n\t\t<b>- sortOrder:<\/b> 'asc' or 'desc' (defaults to asc)<br />\n\t\t<b>- tokenList:<\/b> list or array of token names or ids (defaults to selected tokens)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_switchMap<\/b><\/font><i>([mapName [,playerNames]])<\/i><br />\n\t\tSwitches the users listed in playerNames to the map mapName.<br />\n\t\t<b>- mapName:<\/b> name of the map to switch to<br />\n\t\t<b>- playerNames<\/b> EITHER: a list of users that are logged in OR 1. The latter switches ALL connected users to the new map.\n\t\t<i><b>Example Use:<\/b><br>\n\t\t[bot_switchMap()] - gives pop-up where you can select map and the user(s) to switch<br>\n\t\t[bot_switchMap('Fair Haven')] - gives pop-up where you can select map ('Fair Haven' is pre selected) and the user(s) to switch<br>\n\t\t[bot_switchMap('Fair Haven', 'Carry, Tom, Burt')] - moves Carry, Tom and Burt to the new map<br>\n\t\t[bot_switchMap('Fair Haven', 1)] - moves ALL players to the new map<br>\n\t\t<\/i><\/p>\n\t<p>\n\t\t<font color=red><b>bot_travelAngle<\/b><\/font><i>(x1,y1,x2,y2)<\/i><br />\n\t\tReturns the angle (within a resolution of 45 degrees) in which the token is travelling.<br />\n\t\t<b>- x1,y1:<\/b> coordinate where the token starts<br />\n\t\t<b>- x2,y2:<\/b> coordinate where the token ends<\/p>\n\t<p>\n\t\t<font color=red><b>mod<\/b><\/font>(<i>number, modNumber<\/i>)<br />\n\t\treturn the modNumber modulus of number<\/p>\n\t<p>\n\t\t<font color=red><b>odd<\/b><\/font><i>(number)<\/i><br />\n\t\treturns 1 is the number is odd else 0.<\/p>\n\t<p>\n\t\t<font color=red><b>pause<\/b><\/font><i>(variable1, variable2, etc.)<\/i><br />\n\t\tthis stops the running code and shows the current value of the variable. Note the "quotes" which are required!<\/p>\n\t\t<br>\n\t\t<br>\n\t\t<u><b>MESSAGE MACROS<\/b><\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_message<\/b><\/font><i>(0:message [, 1:headertxt, 2:color (bgcolor-txtcolor), 3:userList, 4:token, 5:target, 6:broadcast, 7:width])<\/i><br>\n\t\tBroadcasts a preformatted message to all users (default). The message consists out of a black (bg) and white (txt) header (default) and a delimited textbox below it, containing the message. When the message is left empty ('') only the header will be displayed. bot_message contains the following optional parameters (only message is required):<br />\n\t\t<b>- message:<\/b> The message displayed<br />\n\t\t<b>- headerText:<\/b> This defaults to: ''. The text in the header, note that the 'token' parameter is set in the header as well on the left side. E.g. when token='Wolf' and headerTxt='Attacks' the header will read 'Wolf Attacks'.<br/>As an extra option you can add ':width=150px' (where 150 obviously is arbitrary) at the end of the header string. This will get filtered out from the header text and used to set the width of the entire message box (which defaults to 100%). Note that if argument 7 (width) is used that argument 7 will overwrite the width you set here. <br>\n\t\t<b>- color:<\/b> This defaults to 'black-white'. Here you can set the backgroundcolor-textcolor of the header. You can choose also to only set the backgroundcolor. Some examples: 'red', 'black-yellow', yellow-red'.<br />\n\t\t<b>- userlist:<\/b> Defaults to all(). Here you can set to whom the message should be send. You can either fill in a user name yourself (NOT TOKEN NAME!) e.g. 'Frank' or you can make use of one of the user functions defined here below, e.g. all(), gm(), ownergm().<br />\n\t\t<b>- token:<\/b> Defaults to ''. Here you can give the name of the token to which the message reflects. The effect is that the image and name of the token appears left in the header<br />\n\t\t<b>- target:<\/b> Defaults to ''. Here you can give the name of another token to which the message reflects. The effect is that the image of tha token appears right in the header<br />\n\t\t<b>- broadcast:<\/b>: (0) the message is NOT broadcasted but the entire structure is returned. This is usefull is you want to e.g. embed the result in another message; (1) (default) the message is immediately broadcasted<br>\n\t\t<b>- width:<\/b>: defaults to 100%. The message is actually an html table. This parameter sets the width of that table. <br>\n\t\t<i><b>Examples Use:<\/b><br>\n\t\t[resultMsg = bot_message('Hello world', 'Header', 'black-white', bot_all(), 'Wolf', 'Wolf', '', 0, '150px')]<br>\n\t\t[bot_message("Hallow word")]<br>\n\t\t[bot_message("this message is shown to gm only", "GM Only:width=110px", "red-yellow", bot_gm())]<br>\n\t\t[bot_message("this message is shown to all but gm", "The rest", "yellow-red", bot_ngm())]<br>\n\t\t[bot_message(token.name+" Takes damage", "is attacked", "black", all(), 'Harmless Bunny', 'Tim The Enchanter')]<br>\n\t\t<\/i><\/p>\n\t\t<br>\n\t\tThe following functions can be used in conjunction with bot_message() and return a JSON ARRAY (e.g. ["Frank","Jim","Suzy"])<br>\n\t\t<b>- <font color=red>bot_all<\/font>():<\/b> all users<br />\n\t\t<b>- <font color=red>bot_gm<\/font>():<\/b> gm(s) only<br />\n\t\t<b>- <font color=red>bot_ngm<\/font>():<\/b> all but NOT gm(s)<br />\n\t\t<b>- <font color=red>bot_self<\/font>():<\/b> initiator of the macro<br />\n\t\t<b>- <font color=red>bot_nself<\/font>():<\/b> all but NOT initiator of the macro<br />\n\t\t<b>- <font color=red>bot_selfgm<\/font>():<\/b> gm(s) and initiator of the macro<br />\n\t\t<b>- <font color=red>bot_nselfgm<\/font>():<\/b> all but NOT gm(s) and initiator of the macro<br />\n\t\t<b>- <font color=red>bot_ownergm<\/font>():<\/b> gm(s) and owners of the currentToken. So NOT the token that you might give as a parameter to the bot_message() function but the token that is currentToken() at that moment.<br />\n\t\t<b>- <font color=red>bot_nownergm<\/font>():<\/b> all but NOT gm(s) and owners of the current token<\/p>\n\t\t<br>\n\t\t<br>\n\t\tThe 'bot_' prefixes in all these function are added as a precaution to make sure that there are no conflicts with a framework in which you use the BoT. If you however want to use these 'retrieve user' functions but without the 'bot_' prefix you need to create your own set of user defined functions. To do this paste the following piece of code in any onCampaignLoad macro in your framework:<br>\n\t\t<br><i>\n\t\t[H: '<!-- ONTOKENMOVE MACROS -->']<br>\n\t\t[defineFunction("self", "self@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nself", "nself@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("all", "all@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("gm", "gm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("ngm", "ngm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("selfgm", "selfgm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nselfgm", "nselfgm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("ownergm", "ownergm@lib:OnTokenMove",1,1)]<br>\n\t\t[defineFunction("nownergm", "nownergm@lib:OnTokenMove",1,1)]<br>\n\t<\/i><\/p>\n\t\n\t<p>\n\t\t<br>\n\t\t<u><b>GEOMETRIC MACROS<\/b><\/u><\/p>\n\t<p>\n\t\tThe Geometric functions allow you to:<br>\n\t\t- create shapes on the map (<b>bot_show...<\/b>), <br>\n\t\t- check whether a point or token is on the shape (<b>bot_pointOn...<\/b>) and <br>\n\t\t- select all tokens within the shape (<b>bot_selectOn...<\/b>). <br>\n\t\t<br>\n\t\tfor different types of shapes:<br>\n\t\t- <b>Circle<\/b>,<br>\n\t\t- <b>Cone<\/b>, <br>\n\t\t- <b>Triangle<\/b>, <br>\n\t\t- <b>Square<\/b> and<br>\n\t\t- <b>Line<\/b><br>\n\t\t<br>\n\t\tSome of these functions can be passed on different types of parameter, depending on what you want. For example bot_pointOnCircle can be passed a point (xp,yp) as parameter or a token (tok). The function checks in this case the number of parameters passed on and from that number derives which type of parameters you submitted. <br>\n\t\t<br>\n\t\tThe following parameters are used<br>\n\t\t- <b>xp,yp<\/b>: these are GRID coordinates e.g. 0,0 is the origin of the map. These are coordinates that are checked whether they are on the shape. The function will thus return true (1) or false (0)<br>\n\t\t- <b>x1,y1,x2,y2,x3,y3<\/b>: these are also GRID coordinates e.g. 3,5 or 2,6. These form the edge or the shape. E.g. for a line x1,y1 is the beginning of the line and x2,y2 the end. x3,y3 is only used to define the triangle.<br>\n\t\t- <b>me<\/b>: this is the centre token, e.g. when drawing a circle, then the circle will be centered around me. When checking whether tok is on the circle, then me is again the centre of that circle<br>\n\t\t- <b>range<\/b>: this is the distance from the centre of the shape (e.g. me) to the edge. The distance is in CELLS (so not in distance per cell)<br>\n\t\t- <b>arc=angle<\/b>: this is the angle of the arc of the triangle or cone in degrees. Typical numbers are 30, 45, 60 and 90 degrees. Here 90 degrees is a quarter of a circle. <br>\n\t\t- <b>drawToken<\/b>: when the shapes are drawn on the map a token is used to draw the shape. This token is copied on the background and the ids of the copied token are returned (so you can easily delete them later on). drawToken is the NAME of the token. Note that this token has to be on the BASE map. E.g. 'Boom'.<br>\n\t\t<br>\n\t\t\t\n\t\t<font color=red><b>bot_pointOnCircle<\/b><\/font><i> (xp,yp, me, range)<\/i> OR <font color=red><b>bot_pointOnCircle<\/b><\/font><i> (tok, me, range) <\/i><br>\n\t\tChecks if a point (p) or token (tok) is on a circle centered on me with range r<br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnCircle<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showCircle<\/b><\/font><i> (me, range, arc=angle, drawToken)  <\/i><br>\n\t\tThis is a completely redundant functions as everything is done by bot_getCircleCoords, but for function name consistancy this is added. Returns coordinates of the circle and does NOT draw it when drawToken=='' ;  returns the ids of the copied tokens and DOES draw it, when drawToken !='' <br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnCone<\/b><\/font><i> (xp,yp, me, range, arc=angle)  <\/i> OR <font color=red><b>bot_pointOnCone<\/b><\/font><i> (tok, me, range, arc=angle)  <\/i><br>\n\t\tChecks if a point is on a cone, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnCone<\/b><\/font><i> (me, range, arc=angle)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showCone<\/b><\/font><i> (tok, range, arc=angle, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the cone. Draws the cone on grid if option set true<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnSquare<\/b><\/font><i> (xp,yp, me, range)  <\/i> OR <font color=red><b>bot_pointOnSquare<\/b><\/font><i> (tok, me, range)  <\/i><br>\n\t\tChecks if a point (p) is within range of me, assuming a square area with range (me, edge square) <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnSquare<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showSquare<\/b><\/font><i> (me, range, drawToken)  <\/i> OR <font color=red><b>bot_showSquare<\/b><\/font><i> (x1,y1, x2,y2, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the square draws the square on grid (if option set true)<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnLine<\/b><\/font><i> (xp,yp, x1,y1, x2,y2)  <\/i> OR <font color=red><b>bot_pointOnLine<\/b><\/font><i> (xp,yp, me, range)  <\/i> OR <font color=red><b>bot_pointOnLine<\/b><\/font><i> (tok, me, range)  <\/i><br>\n\t\tChecks if a point (p) or token (tok) is on a line between 2 points (1 and 2) or on a line casted from me, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnLine<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showLine<\/b><\/font><i> (x1,y1, x2,y2, drawToken)  <\/i> OR <font color=red><b>bot_showLine<\/b><\/font><i> (me, range, drawToken)  <\/i><br>\n\t\tReturns an array with all coords of the line. Draws the line on grid (if option set true)<br>\n\t\t<br>\n\t\t<font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (xp,yp, x1,y1, x2,y2, x3,y3)  <\/i> OR <font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (xp,yp, me, range, arc=angle)  <\/i> OR <font color=red><b>bot_pointOnTriangle<\/b><\/font><i> (tok, me, range, arc=angle)  <\/i><br>\n\t\t<br>\n\t\tChecks if a point is between three points, DOES include boundary <br>\n\t\t<br>\n\t\t<font color=red><b>bot_selectOnTriangle<\/b><\/font><i> (me, range)  <\/i><br>\n\t\tSelects all tokens inside of the shape <br>\n\t\t<br>\n\t\t<font color=red><b>bot_showTriangle<\/b><\/font><i> (x1,y1, x2,y2, x3,y3, drawToken)  <\/i> OR <font color=red><b>bot_showTriangle<\/b><\/font><i> (me, range, arc=angle, drawToken)  <\/i><br>\n\t\tReturns coordinates of the triangle and draws it on grid if options set true <br>\n\t<\/p>\n\t\n\t<p>\n\t\t<u><b>Some functions that are not of my hand but as there was a need for them I implemented them into the BoT<\/b><\/u><\/p>\n\t<p>\n\t\t<font color=red><b>bot_pi<\/b><\/font>()<\/p>\n\t<p>\n\t\t<font color=red><b>bot_cos<\/b><\/font>(radians)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_sin<\/b><\/font>(radians)<\/p>\n\t<p>\n\t\t<font color=red><b>bot_toRadians<\/b><\/font>(degrees)<\/p>\n\n\t\"]\n\n\t[r, if(bot_isFullScreen()), CODE:{\n\t\t[r,dialog(\"BoT Functions Manual\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n\t};{\n\t\t[r,frame(\"BoT Functions Manual\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n\t}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "61b04afe-4906-4061-bef8-973e979142aa",
          "commandChecksum": "2c162b9c1a4379c7a7681cadec57591d",
          "propsChecksum": "9b842d8cf0d9e41f5c8cf3bf2c32070b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 147,
        "label": "movementLock",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:assert(isGM(),\"This macro may only be executed by the GM\",0)]\n\n[h:toggles\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[H: movementLock = 1 - movementLock]\n\n[h:toggles = setStrProp(toggles, \"movementLock\", movementLock)]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\n\t\n[H: broadcast(\"<b>Server Movement Lock is <font color=blue>\"+if(movementLock,\"ON\",\"OFF\")+\"<\/font><\/b>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3735b3f8-c424-4500-9cad-79a4db1b8afb",
          "commandChecksum": "41d4419b5f5bc4c86e21d93024c8b318",
          "propsChecksum": "6908d940340e88ecf93f7fa5dccaac3a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "23",
        "includeLabel": false,
        "sortBy": "23",
        "index": 148,
        "label": "popUpHandout",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[id\t= arg(0)]\n[w\t= arg(1) + 40]\n[h\t= w]\n[text\t= arg(2)]\n\n[dialog(\"Token Handout\", \"width=\"+w+\"; height=\"+h+\"; temporary=1; input=0; noframe=1\"): {\n\t<table align='center' valign='center'>\n\t\t<tr><td>\n\t\t\t<img src='[r:id]'><\/img>\n\t\t<\/td><\/tr><tr><td>\n\t\t\t[r:text]\n\t\t<\/td><\/tr>\n\t<\/table>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "07872527-3ddf-4660-8d05-b5ca87d4c818",
          "commandChecksum": "dc187d33beb93dbe754bf6f901abce74",
          "propsChecksum": "4493d51337dcc452e0583fd05891502f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "16",
        "includeLabel": false,
        "sortBy": "16",
        "index": 149,
        "label": "remTrunkImages",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:tokenList = getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n[h:canopyList = \"\"]\n[h: allTokensJson = json.fromList(tokenList)]\n[h: maxCount = json.length(allTokensJson)]\n\n[h:'']\n[h: splices = \"\"]\n[h: from = 0]\n[h: to = from + 499]\n[h, while(to >= 0), code: {\n    [if(to >= maxCount): to = -1]\n    [thisSplice = json.get(allTokensJson, from, to)]\n    [splices = json.append(splices, thisSplice)]\n    [from = from + 500]\n    [if(to != -1):to = from + 499]\n}]\n\n[h:'']\n[h: cleanTokenList = \"\"]\n[h, foreach(splice, splices, \"\"), code: {\n    [foreach(tok, splice, \"\"):  cleanTokenList = if(startsWith(tok, \"Canopy\"), listAppend(cleanTokenList, tok), cleanTokenList)]\n    }]\n}]\n\n[h:'pause(\"cleanTokenList\",\"numTokens\",\"mainCount\",\"restCount\")']\n[h:tokenList = cleanTokenList]\n\n[h,foreach(token,tokenList,\"\"): setTokenHandout()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d9c36d3-0b42-4ca1-a999-0cc08865f283",
          "commandChecksum": "ec65af3415349dff1b21cb6a1e4dc18a",
          "propsChecksum": "006cad9b47853ee3e369c7903e5cb81d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "15",
        "includeLabel": false,
        "sortBy": "15",
        "index": 150,
        "label": "removeP20",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:tokList = getSelected()]\n[h, foreach(tok,tokList), CODE:{\n\t[token(tok): token.name = replace(token.name,\"%20\", \" \")]\n}]",
        "maxWidth": "",
        "tooltip": "This macro replaces %20 with spaces \" \" in the selected token names",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b89dd142-d259-411a-bfe9-1bebf3d622d7",
          "commandChecksum": "5ccb309be665429aea6293d3cc71d2c8",
          "propsChecksum": "621feaddf4c516db434dda23126d0430"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "63",
        "includeLabel": false,
        "sortBy": "63",
        "index": 151,
        "label": "removeTokens",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(argCount() < 1): toks\t= \"\"\t; toks = arg(0)]\n[splices\t= bot_createSplices(toks)]\n\n[foreach(splice, splices, \"\"), code: {\n\t[foreach(tok, splice, \"\"):  removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1f0e14a0-909a-4c6d-b878-026ef5398f11",
          "commandChecksum": "d3052e4567c0eb83f5b299c7676e92f7",
          "propsChecksum": "656961b1d379ed310c236a4d1dccf2fd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "61",
        "includeLabel": false,
        "sortBy": "61",
        "index": 152,
        "label": "renumberToks",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n[h,if(argCount()>0): tokenName = arg(0); tokenName = \"\"]\n[h,if(argCount()>1): allToks = arg(1); allToks = \"\"]\n\n[h:specNameList = \"Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop\"]\n\n[h, if(tokenName == \"\"): abort(input(\"tokenName|\"+specNameList+\"|Choose the special tokens on this map to renumber?|LIST|VALUE=STRING\"))]\n[h, if(allToks == \"\"): allToks = json.toList(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\"))))]\n\nold Names<br>\n[r:allToks]\n[h:allToks = listSort(allToks, \"N-\")]\n\n[h:'']\n[h:splices = bot_createSplices(allToks)]\n[h:i=1]\n[h, foreach(splice, splices, \"\"), CODE:{\n\t[foreach(tok, splice, \"\"), CODE:{\n\t\t[if(startsWith(tok, tokenName + \" \")), CODE:{\n\t\t\t[token(tok):token.name = tokenName + \" \" + i]\n\t\t\t[i = i + 1]\n\t\t''\n\t\t}; {}]\n\t''\n\t}]\n''\n}]\n\n[h:allToks = json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\"))))]\n\n<br><br>\nNew Names<br>\n[r:allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d0773776-2e9e-4eba-8ccf-4ce14f2f88cb",
          "commandChecksum": "39f1d9d75f7f4c28a2f9ac97b48461b2",
          "propsChecksum": "8cd72b816205282c1380bbe4363db18e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 153,
        "label": "setDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:assert(listCount(getSelected()), \"make sure (only) one token is selected\",0)]\n[h:switchToken(getSelected())]\n[h:drawOrder = getTokenDrawOrder()]\n[h:input(\"drawOrder|\"+drawOrder+\"|Set Draw Order\")]\n[h:setTokenDrawOrder(DrawOrder)]",
        "maxWidth": "",
        "tooltip": "<html>This is just a handy macro where you can manually set the draw order of the token. <br>A high number means on top of all a low number means below all.<br>Then current number (draw order) is shown when you run this macro on a token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d66b11b9-b210-471d-833d-8b365b6c266e",
          "commandChecksum": "7dad47b02cabad6b675db5cf39d0b4b8",
          "propsChecksum": "a04e761a3cad8d1eb88330e383c20068"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "16",
        "includeLabel": false,
        "sortBy": "16",
        "index": 154,
        "label": "setLightSource",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h: selToks\t\t\t\t= getSelectedNames()]\n[h: assert(listCount(selToks),\"Please make sure at least one token is selected\",0)]\n[h: me\t\t\t\t\t= listGet(selToks, 0)]\n[h: switchToken(me)]\n\n\n[h:source\t\t\t\t= getInfo(\"campaign\")]\n[h:lightSource\t\t\t= json.get(source, \"light sources\")]\n[h:lightTypeList\t\t= listSort(json.fields(lightSource),\"A+\")]\n\n\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes', 'lib:EventMacros')]\n[h,foreach(light,excludeLightTypes): lightTypeList = listDelete(lightTypeList, listFind(lightTypeList, light))]\n\n\n[h:i\t\t\t\t\t= 0]\n[h:inputStr\t\t\t\t= \"\"]\n\n[h, foreach(lightType, lightTypeList), CODE:{\n\t[inputStr\t\t\t= listAppend(inputStr,\"tab\"+i+\" | \"+lightType+\" || TAB\")]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"divider | | <html><b>The Wolph42 Light Editor<\/b><\/html>| LABEL | text=none\")]\n\t[lights\t\t\t\t= json.get(lightSource,lightType)]\n\t[lightSet\t\t\t= lightType]\n\t[lightList\t\t\t= \"\"]\t\t\n\t[foreach(light, lights):lightList\t= listappend(lightList, json.get(light, \"name\"))]\n\t[lightSetList\t\t= listSort(lightList,\"N+\")]\n\t[nlightSetList\t\t= listCount(lightSetList)]\n\t[h,count(nlightSetList),CODE:{\n\t\t[light\t\t\t= listGet(lightSetList,roll.count)]\n\t\t[newStr\t\t\t= \"Lamp\"+i+\"S\"+roll.count+\"|\"+hasLightSource(lightSet, light)+\"| \"+light+\" | CHECK\"]\n\t\t[inputStr\t\t= listAppend(inputStr, newStr)]\n\t}]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"divider2 | ------ | ------------------------------ | LABEL\")]\n\t[H, if(!i): inputStr = listAppend(inputStr, \"removeAll | 0 | REMOVE ALL LIGHTS? | CHECK\")]\n\t[i\t\t\t\t\t= i + 1]\n}]\n\n\n[H: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\")]\n\n\n[H: status\t\t\t\t= eval(inputStr)]\n[H: abort(status)]\n\n\n[h: i\t\t\t\t\t= 0]\n[h, foreach(lightType, lightTypeList), CODE:{\n\t[lights\t\t\t\t= json.get(lightSource,lightType)]\n\t[lightSet\t\t\t= lightType]\n\t[lightList\t\t\t= \"\"]\t\t\n\t[foreach(light, lights):lightList\t= listappend(lightList, json.get(light, \"name\"))]\n\t[lightSetList\t\t= listSort(lightList,\"N+\")]\n\t[nlightSetList\t\t= listCount(lightSetList)]\n\t[h,COUNT(nlightSetList),CODE:{\n\t\t[j\t\t\t\t= roll.count]\n\t\t[light\t\t\t= listGet(lightSetList,j)]\n\t\t[foreach(tok, selToks): bot_applyLightSource()]\n\t}]\n\t[i\t\t\t\t\t= i + 1]\n}]\n\n\n[H, if(removeAll), CODE:{\n\t\t\t[foreach(tok, selToks), CODE:{[token(tok): clearLights()]}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2e35111b-c076-48e4-9d0f-519d099e5ffe",
          "commandChecksum": "2ce1ec46a909f5f8f0f4130130593c8e",
          "propsChecksum": "f43c3eaad1b55d439668d86da872813a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 155,
        "label": "setTokSize",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:tok = getSelectedNames()]\n[h:assert(listCount(tok)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(tok)]\n[h:bot_determineTokSize()]",
        "maxWidth": "",
        "tooltip": "<html>This macro is usefull if you want to use Alt Init Pads macro to initialize a map.<br>With this macro you can pre-set the size of a token. So you won't be asked <br>for it when you run alt. init. maps.<br>Note that you only need to do this for free size tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8e03af2b-09a5-48ca-a271-da5b55f90d0a",
          "commandChecksum": "f0ab7c6d654bff88e055861a9a32c9b8",
          "propsChecksum": "d419637fdf4d276bd73ac64de02e8c4a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "23",
        "includeLabel": false,
        "sortBy": "23",
        "index": 157,
        "label": "showHandout",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h,if(argCount() > 0): returnID\t= arg(0) ; returnID = 0]\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:me\t\t\t= getSelected()]\n[h:assert(listCount(me)==1, \"Make sure (only) one token is selected\",0)]\n[h:userList\t\t= if(returnID, \"\", getAllPlayerNames())]\n\n[h, token(me),CODE:{\n\t[image\t\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenImage()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Image<\/td>\t<\/tr><\/table><\/html>\"]\n\t[portrait\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenPortrait()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Portrait<\/td>\t<\/tr><\/table><\/html>\"]\n\t[handout\t= \"<html><table><tr><td height='100'><img width=90 height=90 src='\"+getTokenHandout()+\"'><\/img>\t<\/td><\/tr><tr><td align='center'>Handout<\/td>\t<\/tr><\/table><\/html>\"]\n}] \n\n[H: inputStr\t= \"[]\"]\n[H: inputStr\t= json.append(inputStr,\"junk|<html><b>Choose picture to show to players:<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[H: inputStr\t= json.append(inputStr,\"picChoice|\"+image+\",\"+portrait+\",\"+handout+\"|Which picture|RADIO|ORIENT=H SELECT=2\")]\n[H: inputStr\t= json.append(inputStr,\"picSize|500|Size of picture (px)\")]\n[h,if(!returnID), CODE:{\n\t[H: inputStr\t= json.append(inputStr,\"text|<enter handout-text here>|Handout text (html)\")]\n\t[H: inputStr\t= json.append(inputStr,\"junk|<html><b>Select Players<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[H,FOREACH(player, userList): inputStr = json.append(inputStr,\"player\"+roll.count+\"|1|\"+player+\"|CHECK\")]\n};{}]\n\n[H: inputStr\t= json.evaluate(inputStr)]\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n[h:playerList = \"\"]\n[H,FOREACH(player, userList), CODE:{\t\n\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n}]\n\n[h,token(me), if(picChoice == 0): handoutID = getTokenImage(picSize)]\n[h,token(me), if(picChoice == 1): handoutID = getTokenPortrait(picSize)]\n[h,token(me), if(picChoice == 2): handoutID = getTokenHandout(picSize)]\n\n[h,if(returnID):\n\tmacro.return = handoutID\n;\n\tbot_execAllPlayers(\"popUpHandout@lib:OnTokenMove\",json.append(\"\",handoutID,picSize,text), playerList)\n]",
        "maxWidth": "",
        "tooltip": "<html> Pops up a dialog showing the handout of the selected token on all selected clients",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "21e12f53-c656-47af-a66d-587c8a8a759a",
          "commandChecksum": "0a7f9337061d617966a78b99cf46ecd3",
          "propsChecksum": "758944974cf659c89ab3d1dd378ca38e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 158,
        "label": "toggleFullScreen",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[FSM = getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")]\n\n\n[if(FSM == \"\"): FSM = 1]\n\n[FSM = 1- FSM]\n\n\n[h:setLibProperty(\"fullScreenMode\", FSM , \"Lib:EventMacros\") ]\n\n\n[h:message = if(FSM, \"Full Screen Mode is now turned ON\", \"Full Screen Mode is now turned OFF\")]\n[h:bot_message(\"\",message)]\n\n\n[closeDialog(\"Bag Of Tricks Macros\")]\n[closeFrame(\"Bag Of Tricks Macros\")]\n[bot_MacroButtonsOTMUtils()]\n\n[h, if(isFrameVisible(\"Bag Of Tricks Macros\")): bot_MacroButtonsOTMUtils()]\n\n\n[abort(0)]\n\n\n\n\n\n[if(getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")), CODE:{\n\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n};{\n\t[frame(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0\"): {\n\t\t[r:bot_createMacroButtonsOTMSetup()]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When toggled, the frames will be changed into dialogs,<br> which ARE allowed in full screen. This way when you<br> toggle this button you can have acces to chat and macros<br> in the form of dialogs.<br> In addition, when you have turned on the <i>redefine broadcast<\/i><br> setting in the settings, then when using the broadcast() function<br> a dialog will pop up showing the last message broadcasted.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f2caf604-c35a-4559-b36c-b50ec0424be5",
          "commandChecksum": "9d035610a633da522c04be7a21cc90b1",
          "propsChecksum": "ea60414734dd083d501b7bd3d7fc0e37"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "62",
        "includeLabel": false,
        "sortBy": "62",
        "index": 159,
        "label": "toggleSpecial",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:useAltImage = getLibProperty('useAltImage', 'lib:EventMacros')]\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\n[h:selectedTokens\t= getSelectedNames()]\n[h, if(selectedTokens == \"\"):\n\tallToks\t\t\t= json.toList(json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\")))))\n; \n\tallToks\t\t\t= selectedTokens\n]\n[h:roofToks\t\t\t= \"\"]\n\n[h:specNameList = \"Canopy, Foliage, Roof, Linked\"]\n[h:abort(input(\"tokenName|\"+specNameList+\"|Choose the special tokens on this map to toggle on or off?|LIST|VALUE = STRING\"))]\n[h,foreach(tok, allToks), CODE:{\n\t[if(startsWith(tok, tokenName)), CODE:{\n\t\t[roofToks = listAppend(roofToks, tok)]\n\t\t[setProperty(\"w42.bot.tokens.onHouse\", \"\", tok)]\n\t}; {}]\n}]\n\n[h:assert(roofToks != \"\", \"No \"+tokenName+\" tokens found \"+if(selectedTokens!=\"\", \"in selection\", \"on map\"), 0)]\n[h:tmpTok = listGet(roofToks, 0)]\n\n[h: switchToken(tmpTok)]\n[h, if(getTokenHandout() != \"\"): noRoofImg = getTokenHandout(); noRoofImg = tblImage(\"tbl_Image\",1)]\n[h: currentImg = getTokenImage()]\n[h, if(currentImg != noRoofImg): noRoof = 1; noRoof = 0]\n\n[h:'pause(\"allToks\", \"roofToks\", \"tmpTok\", \"noRoof\", \"currentImg\", \"noRoofImg\")']\n\n[h,if(noRoof), CODE:{\n\t[h, foreach(tok, roofToks), CODE:{\n\t\t[switchToken(tok)]\n\t\t[w\t\t\t= getTokenWidth()]\n\t\t[h\t\t\t= getTokenHeight()]\n\t\t[isArray\t= if(json.type(getTokenVBL())==\"ARRAY\",1,0)]\n\t\t[if(isArray):transferVBL(1,1)]\t\t\n\t\t[setProperty(\"w42.bot.tokens.onHouse\",\"\")]\n\t\t[if(getTokenHandout() != \"\"): noRoofImg = getTokenHandout(); noRoofImg = tblImage(\"tbl_Image\",1)]\n\t\t[roofImg \t= getTokenImage()]\n\t\t[if(roofImg != noRoofImg):setProperty(\"w42.bot.image.original\", roofImg)]\n\n\t\t[setTokenImage(noRoofImg)]\n\t\t[setTokenWidth(w)]\n\t\t[setTokenHeight(h)]\n\t\t[transferVBL(0,1)]\t\t\n\t}]\n}; {\n\t[h, foreach(tok, roofToks), CODE:{\n\t\t[switchToken(tok)]\n\t\t[w\t\t= getTokenWidth()]\n\t\t[h\t\t= getTokenHeight()]\n\t\t[transferVBL(1,1)]\t\t\n\t\t[setProperty(\"w42.bot.tokens.onHouse\",\"\")]\n\t\t[setTokenImage(getProperty(\"w42.bot.image.original\"))]\n\t\t[setHalo(\"None\")]\n\t\t[setTokenWidth(w)]\n\t\t[setTokenHeight(h)]\n\t\t[transferVBL(0,1)]\t\t\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "929eb373-1497-42e3-9784-4a78e5eb9bcb",
          "commandChecksum": "c9e4064b72d2b9d6a884e6bfc23ee09c",
          "propsChecksum": "fc2c7c484bf79643117437d0fcf84927"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 160,
        "label": "tokenLock",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[ids\t= getSelected()]\n[assert(listCount(ids == 1), \"Make sure that at least one token is selected\", 0)]\n\n[h,foreach (id, ids), CODE:{\n\t[switchToken(id)]\n\t[assert(isGM(),\"This macro may only be executed by the GM\",0)]\n\t[lockMovement\t= if(getProperty(\"w42.bot.lockMovement\") == 1, 0, 1)]\n\t[setProperty(\"w42.bot.lockMovement\",lockMovement)]\n\t[broadcast(\"<b>The movement for \"+token.name+\" has been <font color=blue>\"+if(lockMovement,\"LOCKED\",\"UNLOCKED\")+\"<\/font><\/b>\")]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When this is turned ON, no one (gm included) can move the selected token(s).<br>For this to work the toggle in the settings: 'Lock Movement for Locked Tokens' needs to be turned on!<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4af5c8c2-26f5-472b-b14d-800598c6e864",
          "commandChecksum": "5d92bd63e64677cd64d015107705692c",
          "propsChecksum": "b05784e546b3114b1971264776b0af96"
        }
      },
            {
        "autoExecute": true,
        "color": "gray",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 161,
        "label": "Launch Dice Box",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n[h: maxFrames\t= 10]\n[h: frameNum\t= maxFrames + 1]\n[h,count(maxFrames), CODE:{\n\t[frameName = \"Dice Box \"+roll.count]\n\t[if(!isFrameVisible(frameName)):frameNum = min(frameNum, roll.count)]\n}]\n[h:assert(frameNum <= maxFrames, \"You already have the maximum number of frames open\",0)]\n[h:assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\n[h:frameName = \"Dice Box \"+frameNum]\n\n[h: dbArgs = json.set(\"{}\", \"mod\", 0, \"tn\", 0, \"d4s\", 0, \"d5s\", 0, \"d6s\", 0, \"d8s\", 0, \"d10s\", 0, \"d12s\", 0, \"d20s\", 0, \"d100s\", 0, \"showTo\", \"all\", \"breakdown\", \"totalRoll\", \"frameName\", frameName)]\n\n[macro(\"NDB@this\"):dbArgs]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "61dfa0af-bc09-497c-94c7-476a43af9122",
          "commandChecksum": "7731f22f13bc20486b734b29b5246202",
          "propsChecksum": "ebb66dd17e025659bf55b628750b6f03"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 162,
        "label": "NDB",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:dbArgs = macro.args]\n\n\n\n[h,if(json.contains(dbArgs, \"explodeDice\")): explodeCode = if(json.get(dbArgs, \"explodeDice\") !=0 ,\"CHECKED\",\"\"); explodeCode = \"\"]\n\n[h:varsFromStrProp(json.toStrProp(dbArgs))]\n\n[h:frameNum\t\t= replace(frameName, \"Dice Box \", \"\")]\n[h:dieList \t\t= getLibProperty(\"dieList\"+frameNum, \"Lib:EventMacros\")]\n[h:optionsList \t= getLibProperty(\"optionsList\"+frameNum, \"Lib:EventMacros\")]\n\n\n[h:varsFromStrProp(optionsList)]\n\n[if(dieList == \"\"): dieList \t\t= \"4,5,6,8,10,12,20,100\"]\t\t\n\n[h: showAll\t\t= if(showTo == \"all\", \"CHECKED\", \"\")]\n[h: showGMSelf\t= if(showTo == \"gm-self\", \"CHECKED\", \"\")]\n[h: showGM\t\t= if(showTo != \"all\" && showTo != \"gm-self\", \"CHECKED\", \"\")]\n[h: showTotals\t= if(breakdown == \"totalRoll\", \"CHECKED\", \"\")]\n[h: showEach\t= if(breakdown != \"totalRoll\", \"CHECKED\", \"\")]\n\n\n[h:action\t\t= macroLinkText(\"NDBUpdate@this\",\"all\")]\n[h:d4img\t\t= tableImage(\"tbl_Image\",16)]\n[h:d5img\t\t= tableImage(\"tbl_Image\",17)]\n[h:d6img\t\t= tableImage(\"tbl_Image\",18)]\n[h:d8img\t\t= tableImage(\"tbl_Image\",19)]\n[h:d10img\t\t= tableImage(\"tbl_Image\",20)]\n[h:d12img\t\t= tableImage(\"tbl_Image\",21)]\n[h:d20img\t\t= tableImage(\"tbl_Image\",22)]\n[h:d100img\t\t= tableImage(\"tbl_Image\",23)]\n[h:clearAllLink\t= macroLink(\"(Clear All)\", \"NDBCall@\"+getMacroLocation(), \"none\")]\n\n\n[h:diceBoxStr\t= \"\n\t<html><head><title>%{frameName}<\/title><\/head><body><form name='%{frameName}' method='json' action='%{action}'>\n\t<table align='left' color='black' cellpadding='1'><tr><td valign='centre' align='left'>\n\t\t<table cellpadding='1' border='0' valign='centre'><tr><td>\n\t\t<input type='hidden' name='frameName' value='%{frameName}'>\n\"]\n\n\n\n[h,foreach(dice, \"4,5,6,8,10,12,20,100\"): diceBoxStr = diceBoxStr + \"<input type='hidden' name='d\"+dice+\"s'\tvalue=0>\"]\n\n\n\n[h,foreach(dice, dieList): diceBoxStr = diceBoxStr + \"\n\t\t\t<input type='submit' value='<html>-'\tname='clickedButton'>\t<\/td><td>\t\n\t\t\t<img src='%{d\"+dice+\"img}'><\/img>\t\t\t\t\t<\/td><td>\t\n\t\t\t<input type='submit' value='<html>+'\tname='clickedButton'>\t<\/td><td>\t\n\t\t\t<input type='text' name='d\"+dice+\"s'\tvalue='%{d\"+dice+\"s}' size='2'><\/td><\/tr><tr><td>\n\"]\n\n\n[h:diceBoxStr\t= diceBoxStr + \"\n\t\t<\/td><\/tr><\/table>\n\t\t<\/td><td align='left' valign='top' style='font-size:small; '>\n\n\t\t<table cellpadding='1' border='0'><tr><td>\"\n\t\t\t+\tif(showMod,\t\t\"<b>Modifier<\/b>:\t<\/td><td>\t<input type='text'\t\tname='mod'\tvalue='%{mod}' size='3'>\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='mod'\t\t\tvalue='\"+modifier+\"'>\")\n\t\t\t+\tif(showTarget,\t\"<b>Target <\/b>:\t<\/td><td>\t<input type='text'\t\tname='tn'\tvalue='%{tn}' size='3'>\t\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='tn'\t\t\t\tvalue='\"+target+\"'>\")\n\t\t\t+\tif(showExplode,\t\"<b>Explode?<\/b>:\t<\/td><td>\t<input type='checkbox'\tname='explodeDice'  %{explodeCode}>\t\t<\/input><\/td><\/tr><tr><td>\",\t\"<input type='hidden' name='explodeDice'\tvalue='\"+explode+\"'>\")\n\t\t+\"<\/table>\"\n\n\t\t+ if(showResults, \"<b>Show Results To:<\/b>\n\t\t<table  cellpadding='3' border='0'><tr><td>\n\t\t\t<input type='radio' name='showTo' value='all'\t\t%{showAll}><\/input>\t\t<\/td><td> All\t\t\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='showTo' value='gm'\t\t%{showGM}><\/input>\t\t<\/td><td> GM Only\t\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='showTo' value='gm-self'\t%{showGMSelf}><\/input>\t<\/td><td> You and GM\t<\/tr><tr><td>\n\t\t<\/table>\", \"<input type='hidden' name='showTo' value='\"+showGMOption+\"'>\")\n\t\t\n\t\t+ if(showTooltip, \"<b>Tooltip Info:<\/b>\n\t\t<table  cellpadding='3' border='0'><tr><td>\n\t\t\t<input type='radio' name='breakdown' value='totalRoll'\t%{showTotals}>\t<\/td><td> Totals\t<\/tr><tr><td>\n\t\t\t<input type='radio' name='breakdown' value='eachRoll'\t%{showEach}>\t<\/td><td> Each Die\t<\/tr><tr><td>\n\t\t<\/table>\",\"<input type='hidden' name='breakdown' value='\"+eachRollOption+\"'>\")\n\t+\"<\/td><\/tr><\/table>\n<input type='submit' width='40' name='clickedButton' value='Roll'>\t\t \n<input type='submit' width='40' name='clickedButton' value='Clear'>\t\t \n<input type='submit' width='40' name='clickedButton' value='Options'>\n\n\t<\/form><\/body><\/html>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(frameName,\"width=250; height=350; temporary=0; input=1\"):\t{ [r:strformat(diceBoxStr)] }]\n};{\n\t[frame(frameName,\"width=250; height=350; temporary=0; \"):\t\t\t{ [r:strformat(diceBoxStr)] }]\n}]\n\n[h:abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c59d0868-84c1-4899-8450-a94c11228429",
          "commandChecksum": "39c780f9db425b30ab369eed6232e442",
          "propsChecksum": "060dd0a1ff22b90e9ea2f0d627f1944f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 163,
        "label": "NDBUpdate",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:dbArgs\t\t= macro.args]\n[h:frameName\t= json.get(dbArgs, \"frameName\")]\n\n[h:clickedButton = json.get(dbArgs, \"clickedButton\")]\n[h,switch(clickedButton), CODE:\n\tcase \"Clear\":{\n\t\t[dbArgs = json.set(\"{}\", \"mod\", 0, \"tn\", 0, \"d4s\", 0, \"d5s\", 0, \"d6s\", 0, \"d8s\", 0, \"d10s\", 0, \"d12s\", 0, \"d20s\", 0, \"d100s\", 0, \"showTo\", \"all\", \"breakdown\", \"totalRoll\", \"frameName\", frameName)]\n\t\t[macro(\"NDB@this\"): dbArgs]\n\t}; \n\tcase \"Options\":{\n\t\t[frameNum\t\t= replace(frameName, \"Dice Box \", \"\")]\n\t\t[dieList \t\t= getLibProperty(\"dieList\"+frameNum, \"Lib:EventMacros\")]\n\t\t[optionsList \t= getLibProperty(\"optionsList\"+frameNum, \"Lib:EventMacros\")]\n\t\t\n\t\t[varsFromStrProp(optionsList)]\n\n\t\t\n\t\t[showGMOption\t= listFind(\"all,gm, gm-self\", showGMOption)]\n\t\t[eachRollOption\t= if(eachRollOption == \"eachRoll\", 1, 0)]\n\n\t\t[abort(input(\n\t\t\t\"junk|<html><b>Check the dice to show on the form<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"Di4|\"+listContains(dieList, 4)+\"|Show D4|CHECK\",\n\t\t\t\"Di5|\"+listContains(dieList, 5)+\"|Show D5|CHECK\",\n\t\t\t\"Di6|\"+listContains(dieList, 6)+\"|Show D6|CHECK\",\n\t\t\t\"Di8|\"+listContains(dieList, 8)+\"|Show D8|CHECK\",\n\t\t\t\"Di10|\"+listContains(dieList, 10)+\"|Show D10|CHECK\",\n\t\t\t\"Di12|\"+listContains(dieList, 12)+\"|Show D12|CHECK\",\n\t\t\t\"Di20|\"+listContains(dieList, 20)+\"|Show D20|CHECK\",\n\t\t\t\"Di100|\"+listContains(dieList, 100)+\"|Show D100|CHECK\",\n\t\t\t\"junk|<html><b>Check the options you want to show on the form<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"showMod|\"+showMod+\"|Show the 'set modifer' box|CHECK\",\n\t\t\t\"showTarget|\"+showTarget+\"|Show the 'set succes target' box|CHECK\",\n\t\t\t\"showExplode|\"+showExplode+\"|Show the 'explode die' check box|CHECK\",\n\t\t\t\"showResults|\"+showResults+\"|Show the 'show results to' options|CHECK\",\n\t\t\t\"showTooltip|\"+showTooltip+\"|Show the 'show tooltip' options|CHECK\",\n\t\t\t\"junk|<html><b>IF certain options are HIDDEN, THEN what should they be set to<br><\/b>These settings will be ignored if the options are NOT hidden<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"modifier|\"+modifier+\"|Modifier\",\n\t\t\t\"target|\"+target+\"|Target\",\n\t\t\t\"explode|\"+explode+\"|Explode|CHECK\",\n\t\t\t\"showGMOption|All, GM Only, You and GM|Show result to?|RADIO|Select=\"+showGMOption,\n\t\t\t\"eachRollOption|Totals, Each die|Tooltip info|RADIO|Select=\"+eachRollOption\n\t\t))]\n\t\t\n\t\t[showGMOption\t= listGet(\"all,gm, gm-self\", showGMOption)]\n\t\t[eachRollOption\t= if(eachRollOption, \"eachRoll\", \"totalRoll\")]\n\t\t\n\t\t[allDice = \"4,5,6,8,10,12,20,100\"]\n\t\t[dieList = \"\"]\n\t\t[foreach(dice, allDice):dieList = if(eval(\"Di\"+dice),listAppend(dieList, dice), dieList)]\n\n\t\t[optionsList\t= StrPropFromVars(\"showMod,showTarget,showExplode,showResults,showTooltip,modifier,target,explode,showGMOption,eachRollOption\",\"UNSUFFIXED\")]\n\n\t\t['pause(\"frameNum\", \"dieList\", \"optionsList\")']\n\t\t[setLibProperty(\"dieList\"+frameNum, dieList, \"Lib:EventMacros\")]\n\t\t[setLibProperty(\"optionsList\"+frameNum, optionsList, \"Lib:EventMacros\")]\n\t\t[macro(\"NDB@this\"): dbArgs]\n\t}; \n\tcase \"Roll\":{\n\t\t[macro(\"RollDice@this\"):dbArgs] \n\t\t[abort(0)]\n\t}; \n\tdefault:{ \n\t\t -->\n\t\t['assert(startsWith(clickedButton, \"<html>\"), \"\"Error in die roller for value clickedButton: \"+clickedButton\",0)']\n\t\t[sign\t= getGroup(strfind(clickedButton, \"(?<=html\\>)[-+]\"), 1, 0))]\n\t\t[dice\t= getGroup(strfind(clickedButton, \"(?<=--\\\\s)[0-9]+\"), 1, 0))]  \n\t\t\n\t\t[dbArgs\t= eval(strformat(\"json.set(dbArgs, 'd%{dice}s', max(0,number(json.get(dbArgs, 'd%{dice}s'))%{sign}1))\"))]\n\t\t[macro(\"NDB@this\"):dbArgs]\n\t}\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dc91e621-e81d-43f1-935f-1890505e515d",
          "commandChecksum": "727616c36e874c44805ef49faa32d239",
          "propsChecksum": "20f35125dd2941ae68719d0763125c8d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 164,
        "label": "RollDice",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:dbArgs\t\t= macro.args]\n[h:numD4\t= json.get(dbArgs, \"d4s\")]\n[h:numD5\t= json.get(dbArgs, \"d5s\")]\n[h:numD6\t= json.get(dbArgs, \"d6s\")]\n[h:numD8\t= json.get(dbArgs, \"d8s\")]\n[h:numD10\t= json.get(dbArgs, \"d10s\")]\n[h:numD12\t= json.get(dbArgs, \"d12s\")]\n[h:numD20\t= json.get(dbArgs, \"d20s\")]\n[h:numD100\t= json.get(dbArgs, \"d100s\")]\n[h:mod\t\t= json.get(dbArgs, \"mod\")]\n[h:breakout\t= json.get(dbArgs, \"breakdown\")]\n[h:target\t= json.get(dbArgs, \"tn\")]\n[h:showTo\t= json.get(dbArgs, \"showTo\")]\n[h,if(json.contains(dbArgs, \"explodeDice\")): exp = if(json.get(dbArgs, \"explodeDice\") !=0 ,\"e\",\"\"); exp=\"\"]\n\n[h:d4array\t= \"\"]\t[h:d4roll\t= 0]\n[h:d5array\t= \"\"]\t[h:d5roll\t= 0]\n[h:d6array\t= \"\"]\t[h:d6roll\t= 0]\n[h:d8array\t= \"\"]\t[h:d8roll\t= 0]\n[h:d10array\t= \"\"]\t[h:d10roll\t= 0]\n[h:d12array\t= \"\"]\t[h:d12roll\t= 0]\n[h:d20array\t= \"\"]\t[h:d20roll\t= 0]\n[h:d100array= \"\"]\t[h:d100roll\t= 0]\n\n[h,if(breakout==\"eachRoll\"),CODE:{\n\t[h,count(numD4), CODE: {\n\t\t[thisD4 \t= eval(\"1d4\"+exp)]\n\t\t[d4roll \t= d4roll + thisD4]\n\t\t[d4array\t= listAppend(d4array, thisD4)]\n\t}]\n\t[h,count(numD5), CODE: {\n\t\t[thisD5 \t= eval(\"1d5\"+exp)]\n\t\t[d5roll \t= d5roll + thisD5]\n\t\t[d5array\t= listAppend(d5array, thisD5)]\n\t}]\n\t[h,count(numD6),CODE:\t{\n\t\t[thisD6 \t= eval(\"1d6\"+exp)]\n\t\t[d6roll \t= d6roll + thisD6]\n\t\t[d6array\t= listAppend(d6array, thisD6)]\n\t}]\n\t[h,count(numD8),CODE:\t{\n\t\t[thisD8 \t= eval(\"1d8\"+exp)]\n\t\t[d8roll \t= d8roll + thisD8]\n\t\t[d8array\t= listAppend(d8array, thisD8)]\n\t}]\n\t[h,count(numD10),CODE:\t{\n\t\t[thisD10 \t= eval(\"1d10\"+exp)]\n\t\t[d10roll \t= d10roll + thisD10]\n\t\t[d10array\t= listAppend(d10array, thisD10)]\n\t}]\n\t[h,count(numD12),CODE:\t{\n\t\t[thisD12 \t= eval(\"1d12\"+exp)]\n\t\t[d12roll \t= d12roll + thisD12]\n\t\t[d12array\t= listAppend(d12array, thisD12)]\n\t}]\n\t[h,count(numD20),CODE:\t{\n\t\t[thisD20 \t= eval(\"1d20\"+exp)]\n\t\t[d20roll \t= d20roll + thisD20]\n\t\t[d20array\t= listAppend(d20array, thisD20)]\n\t}]\n\t[h,count(numD100),CODE:{\n\t\t[thisD100\t= eval(\"1d100\"+exp)]\n\t\t[d100roll\t= d100roll + thisD100]\n\t\t[d100array\t= listAppend(d100array,thisD100)]\n\t}]\n\n\t[h:rolledDice =\n\t\t\tif(d4roll !=0,\t\tnumD4+\"d4\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d5roll !=0,\t\tnumD5+\"d5\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d6roll !=0,\t\tnumD6+\"d6\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d8roll != 0,\t\tnumD8+\"d8\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d10roll !=0,\t\tnumD10+\"d10\"+exp+\"+\",\t\"\")\n\t\t+\tif(d12roll !=0,\t\tnumD12+\"d12\"+exp+\"+\",\t\"\")\n\t\t+\tif(d20roll != 0,\tnumD20+\"d20\"+exp+\"+\",\t\"\")\n\t\t+\tif(d100roll != 0,\tnumD100+\"d100\"+exp+\"+\",\t\"\")\n\t\t+\tif(mod != 0,\t\tmod+\"+\",\t\t\"\")\n\t]\n\t[h:assert(rolledDice != \"\",\"No dice selected\",0)]\n\t\n\t[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]\n\t\n\t[h:Values = \n\t\t\tif(d4roll == 0,\t\t\"\",\td4roll+\"(\"+d4array+\")\"+\"+\")\n\t\t+\tif(d5roll == 0,\t\t\"\",\td5roll+\"(\"+d5array+\")\"+\"+\")\n\t\t+\tif(d6roll == 0,\t\t\"\",\td6roll+\"(\"+d6array+\")\"+\"+\")\n\t\t+\tif(d8roll == 0,\t\t\"\",\td8roll+\"(\"+d8array+\")\"+\"+\")\n\t\t+\tif(d10roll == 0,\t\"\",\td10roll+\"(\"+d10array+\")\"+\"+\")\n\t\t+\tif(d12roll == 0,\t\"\",\td12roll+\"(\"+d12array+\")\"+\"+\")\n\t\t+\tif(d20roll == 0,\t\"\",\td20roll+\"(\"+d20array+\")\"+\"+\")\n\t\t+\tif(d100roll == 0,\t\"\",\td100roll+\"(\"+d100array+\")\"+\"+\")\n\t\t+\tif(mod == 0,\t\t\"\",\tmod+\"+\")\n\t]\n\t[h:Values = substring(Values, 0,length(Values)-1)]\n}; {\n\t[h:d4roll\t= if(numD4 == \"0\",\t0,\teval(numD4+\"d4\"+exp))]\n\t[h:d5roll\t= if(numD5 == \"0\",\t0,\teval(numD5+\"d5\"+exp))]\n\t[h:d6roll\t= if(numD6 == \"0\",\t0,\teval(numD6+\"d6\"+exp))]\n\t[h:d8roll\t= if(numD8 == \"0\",\t0,\teval(numD8+\"d8\"+exp))]\n\t[h:d10roll\t= if(numD10 == \"0\",\t0,\teval(numD10+\"d10\"+exp))]\n\t[h:d12roll\t= if(numD12 == \"0\",\t0,\teval(numD12+\"d12\"+exp))]\n\t[h:d20roll\t= if(numD20 == \"0\",\t0,\teval(numD20+\"d20\"+exp))]\n\t[h:d100roll\t= if(numD100 == \"0\",0,\teval(numD100+\"d100\"+exp))]\n\t[h:mod\t\t= number(mod)]\n\n\t[h:rolledDice =\n\t\t\tif(d4roll !=0,\t\tnumD4+\"d4\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d5roll !=0,\t\tnumD5+\"d5\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d6roll !=0,\t\tnumD6+\"d6\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d8roll != 0,\t\tnumD8+\"d8\"+exp+\"+\",\t\t\"\")\n\t\t+\tif(d10roll !=0,\t\tnumD10+\"d10\"+exp+\"+\",\t\"\")\n\t\t+\tif(d12roll !=0,\t\tnumD12+\"d12\"+exp+\"+\",\t\"\")\n\t\t+\tif(d20roll != 0,\tnumD20+\"d20\"+exp+\"+\",\t\"\")\n\t\t+\tif(d100roll != 0,\tnumD100+\"d100\"+exp+\"+\",\t\"\")\n\t\t+\tif(mod != 0,\t\tmod+\"+\",\t\t\"\")\n\t]\n\t[h:assert(rolledDice != \"\",\"No dice selected\",0)]\n\t\n\t[h:rolledDice = substring(rolledDice, 0,length(rolledDice)-1)]\n\n\t[h:Values = \n\t\t\tif(d4roll == 0,\t\t\"\", d4roll+\"+\")\n\t\t+\tif(d5roll == 0,\t\t\"\", d5roll+\"+\")\n\t\t+\tif(d6roll == 0,\t\t\"\", d6roll+\"+\")\n\t\t+\tif(d8roll == 0,\t\t\"\", d8roll+\"+\")\n\t\t+\tif(d10roll == 0,\t\"\", d10roll+\"+\")\n\t\t+\tif(d12roll == 0,\t\"\", d12roll+\"+\")\n\t\t+\tif(d20roll == 0,\t\"\", d20roll+\"+\")\n\t\t+\tif(d100roll == 0,\t\"\", d100roll+\"+\")\n\t\t+\tif(mod == 0,\t\t\"\",\tmod+\"+\")\n\t]\n\t[h:Values = substring(Values, 0,length(Values)-1)]\n}]\n\n[h:roll = d4roll+d6roll+d5roll+d8roll+d10roll+d12roll+d20roll+d100roll+mod]\n[h,if(target > 0 && roll > target): success = \"Success!\"; success=\"Failed!\"]\n\n\n[r:dbxOutputTo(showTo,\t\"<span><i>Rolling \"+rolledDice+\"<\/i>:<b> <span title='\"+Values+\"'>\"+roll+\"<\/b><\/span> \"+if(target > 0, success, \"\")+\"<\/span>\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7aa150f3-90c1-4b06-8f02-5c84f834d62a",
          "commandChecksum": "16e75a929c1daef9c004b33e99af1c60",
          "propsChecksum": "0b9c078d0ff0369d34e43d61dfe7f271"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 165,
        "label": "dbxConditionalOutput",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r: json.get(macro.args, 'toSend')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "125c1c7a-ecdf-4e22-aa09-f46b520d4858",
          "commandChecksum": "574b446cde592a874916bcfd6064b1d2",
          "propsChecksum": "9e39f70152f86a5e0c24c6997e8cc867"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "h. Rumbles Dicebox",
        "includeLabel": false,
        "sortBy": "h. Rumbles Dicebox",
        "index": 166,
        "label": "dbxOutputTo",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: toSend = '{}']\n[h: argTest = json.type(arg(0))]\n[h, if(argTest=='ARRAY'), code:\n{\n    [h: toWho = 'list']\n    [h: toSend = json.set(toSend, 'mlOutputList', arg(0))]\n}; {\n    [h: toWho = arg(0)]\n}]\n\n[h: toSend = json.set(toSend, 'toSend', arg(1))]\n[h: conditionalOutput = macroLinkText('dbxConditionalOutput@this', toWho, toSend)]\n[h: execLink(conditionalOutput, 1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "27f0b5e5-1edb-4912-98a5-3c73053fa1e0",
          "commandChecksum": "cad3ab6161fed25af7e65a6441d648fa",
          "propsChecksum": "01bd5b6a07ea2172067625d2c6b540d4"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 167,
        "label": "MassVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:optionList\t= \"Canopy, Roof, Selection, All, Search String\"]\n[h:scaleList\t= \"Number of Cells, Token Size\"]\n[h:gridSize \t= bot_getGridSize()] \n[h:currentMap\t= getCurrentMapName()]\n\n\n[h:lastSettings\t= getLibProperty(\"lastMassVBLSettings\", \"Lib:EventMacros\")]\n[h,if(lastSettings == \"\"): lastSettings = \"option=0 ; searchStr=tree ; doTokenLayer=0 ; doObjectLayer=1 ; doHiddenLayer=0 ; doBackgroundLayer=1 ; scaleOption=0 ; scale=0.5 ; storeVBL=0 ; vblName=maptrees ; \"]\n[h:varsFromStrProp(lastSettings)]\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Set VBL Stamp<\/b><\/html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. For this to work you will need to turn on VBL support<br>in the settings.<br>|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'option|'+optionList+'|<html><span title=\"<html>Tokens to which the VBL layer will be applied.<br><b>Canopy<\/b> will select all tokens with <i>Canopy<\/i> in their name, same for<br><b>Roof<\/b> and <b>Search string<\/b>. with the latter you need to enter a search<br>string in the text box here below.<br><b>All<\/b> will select ALL tokens<br><b>Selection<\/b> will limit to the currently selected tokens.<br><br>Note that the LAYER filter is applied to all except <b>Selection<\/b>. <br><\/html>\">Add VBL to which tokens<\/html><\/span><\/html>|RADIO|SELECT='+option)]\n[h:inputStr \t= json.append(inputStr, 'searchStr|'+searchStr+'|<html><span title=\"<html>If you choose <i>other<\/i> from the radion buttons, enter the search string here.<br>Note that ANY token whos name partialy matches this search string will be added<br>to the VBL list. E.g. <i>can<\/i> will return token named <i>cans<\/i>, <i>canopy<\/i>, <i>cantine<\/i>, etc.<br>One way to limit the results is by adding a whitespace at the start or end of the <br>name if appropriate. E.g. "can " will NOT return the above examples.<\/html>\">Search string<\/html><\/span><\/html>')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Check layers to include<\/html>|<html>The VBL will only be applied to tokens that are on the layers you check here.|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, 'doTokenLayer|'+doTokenLayer+'|<html><span>Token Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doHiddenLayer|'+doHiddenLayer+'|<html><span>Hidden Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doObjectLayer|'+doObjectLayer+'|<html><span>Object Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, 'doBackgroundLayer|'+doBackgroundLayer+'|<html><span>Background Layer|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Scale<\/b><\/html>|<html>|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'scaleOption|'+scaleList+'|<html><span title=\"<html><b>Number of Cells:<\/b> 0.5 is half a (grid) cell, 1 is 1 cell, 2 is 4 cells, etc.<br><b>Token size:<\/b> 0.5 means half the size of the token, 2 means twice the size of the token.<\/html>\">Scaling in terms of<\/html><\/span><\/html>|RADIO|SELECT='+scaleOption)]\n[h:inputStr \t= json.append(inputStr, 'scale|'+scale+'|<html><span title=\"<html>Depends on the radio choice<\/html>\">Scale of VBL shape<\/html><\/span><\/html>')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Saving the VBL<\/b><\/html>|<html>Checking the box will save the VBL as a result of this macro|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'storeVBL|'+storeVBL+'|<html><span title=\"<html>When you check this the VBL will be stored on a lib:token<br>This will allow you to toggle the VBL on or off<\/html>\">Store the VBL<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'vblName|'+vblName+'|<html><span title=\"<html>This will only work if you have checked the <i>Store the VBL<\/i> checkbox.<br>The VBL data will be linked to this map and the name you enter allowing you<br>to toggle this specific VBL on or off. Only use alphanumeric characters for<br>the name<\/html>\">Name of VBL to store<\/html><\/span><\/html>')]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, \"Check at least one of the (Token, Hidden, Object, Background) layer boxes\",0)]\n\n\n[h:setLibProperty(\"lastMassVBLSettings\", strPropFromVars(\"option, searchStr, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer, scaleOption, scale, storeVBL, vblName\",\"UNSUFFIXED\"), \"lib:EventMacros\")]\n\n[h:'']\n[h:chosenLayers = \"[]\"]\n[h,if(doTokenLayer):\t\tchosenLayers = json.append(chosenLayers, \"TOKEN\")]\n[h,if(doObjectLayer):\t\tchosenLayers = json.append(chosenLayers, \"OBJECT\")]\n[h,if(doHiddenLayer):\t\tchosenLayers = json.append(chosenLayers, \"HIDDEN\")]\n[h,if(doBackgroundLayer):\tchosenLayers = json.append(chosenLayers, \"BACKGROUND\")]\n\n[h, if(option == 0): searchStr\t= \"Canopy \"]\n[h, if(option == 1): searchStr\t= \"Roof \"]\n\n[h, if(option == 2): allToks\t= getSelectedNames()]\n[h, if(option == 3): allToks\t= getTokenNames(\",\", json.set(\"{}\", \"layer\", chosenLayers))]\n\n[h, if(option < 2 || option == 4):\tallToks = bot_seekToken(1, searchStr, chosenLayers)]\n\n[h:shape\t\t= \"cross\"]\n[h:jsonVBL\t\t= \"[]\"]\n\n['pause(\"allToks\")']\n\n[h, if(scaleOption), CODE:{\n\t\n\n\t[foreach(tok, allToks): \n\t\tjsonVBL\t= json.append(\n\t\t\tjsonVBL, \n\t\t\tstrformat(\n\t\t\t\t'{\"shape\":\"cross\",\"w\":%s,\"h\":%s,\"x\":%s,\"y\":%s,\"scale\":%{scale}}', \n\t\t\t\tgetTokenWidth(tok),\n\t\t\t\tgetTokenHeight(tok),\n\t\t\t\tgetTokenX(2, tok), \n\t\t\t\tgetTokenY(2, tok)\n\t\t\t)\n\t\t)\n\t]\n};{\n\t\n\t[w\t\t\t= gridSize * scale]\n\t[h\t\t\t= w]\n\t[half\t\t= round(w/2)]\n\t\n\t[foreach(tok, allToks): \n\t\tjsonVBL\t= json.append(\n\t\t\tjsonVBL, \n\t\t\tstrformat(\n\t\t\t\t'{\"w\":%{w},\"shape\":\"cross\",\"h\":%{h},\"x\":%s,\"y\":%s}', \n\t\t\t\tgetTokenX(2, tok) + round(getTokenWidth(tok)/2) - half, \n\t\t\t\tgetTokenY(2, tok) + round(getTokenHeight(tok)/2) - half\n\t\t\t)\n\t\t)\n\t]\n}]\n\n\n[h:jsonVBL\t= replace(jsonVBL, \"'\", \"\")]\n\n\n[h:drawVBL(jsonVBL)]\n\n\n[h,if(storeVBL), CODE:{\n\t\n\t[storedVBL\t\t= getLibProperty(\"storedVBL\", \"lib:EventMacros\")]\n\t[if(json.type(storedVBL)==\"UNKNOWN\"):\t\tstoredVBL\t\t= \"{}\"]\n\t[thisMapVBL\t\t= json.get(storedVBL, currentMap)]\n\t[if(json.type(thisMapVBL)==\"UNKNOWN\"):\t\tthisMapVBL\t\t= \"{}\"]\n\t[thisMapVBLOn\t= json.get(storedVBL, currentMap+\"_ON\")]\n\t[if(json.type(thisMapVBLOn)==\"UNKNOWN\"):\tthisMapVBLOn\t= \"{}\"]\n\t\n\t\n\t[thisMapVBL\t\t= json.set(thisMapVBL, vblName, jsonVBL)]\n\t[thisMapVBLOn\t= json.set(thisMapVBLOn, vblName, 1)]\n\t[storedVBL\t\t= json.set(storedVBL, currentMap, thisMapVBL, currentMap+\"_ON\", thisMapVBLOn)]\n\t[setLibProperty(\"storedVBL\", storedVBL, \"lib:EventMacros\")]\n};{}]\n\n\n[h:broadcast(\"VBL has been added to the following tokens: \"+ allToks)]",
        "maxWidth": "",
        "tooltip": "<html>This function draws VBL crosses on all tokens that match a search string",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aef23339-d739-4a87-bf17-6dd0787eef28",
          "commandChecksum": "ba60afeb5bb4fa542d681383bc92b6d5",
          "propsChecksum": "eb284f8f65f6ce548ec7c58d6ae5ad67"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 168,
        "label": "VBLGrenade",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h,if(argCount()>0): tokOnly\t= arg(0) ; tokOnly\t= 0]\n[h,if(argCount()>1): clearVBL\t= arg(1) ; clearVBL\t= 1]\n[h,if(argCount()>2): allToks\t= arg(2) ; allToks\t= getSelected()]\n\n[h,if(tokOnly), CODE:{\n\t\n\t[radius\t\t= 0]\n\t[sides\t\t= 0]\n};{\n\t[assert(listCount(allToks),\"You need to select at least one token for this to work\",0)]\n\t[abort(input(\n\t\t\"junk|<html><b>Clear VBL around selected tokens<\/b><\/html>|<html>The radius (in grid cells) you choose will be used to clear the VBL directly around the token |LABEL|SPAN=TRUE\",\n\t\t\"radius|1|Radius of VBL to clear around the token (Cells)\",\n\t\t\"junk|<html><b>Sides of VBL clearance circle<\/b><\/html>|<html>A regular polygon will be used as 'circle' here you set how many sides the 'circle' should have|LABEL|SPAN=TRUE\",\n\t\t\"sides|3,4,5,6,7,8,9,10,11,12|Radius of VBL to clear around the token|LIST|Select=5 value=string\",\n\t\t\"tokOnly|0|Override the above and only clear VBL covered by token|CHECK\"\n\t))]\n}]\n\n[h:w\t\t= 0]\n[h:h\t\t= 0]\n[h:facing\t= 0]\n[h:shape\t= if(tokOnly, \"rectangle\", \"circle\")]\n[h:radius\t= bot_getGridSize() * radius]\n\n\n[h:jsonVBL\t\t= \"[]\"]\n[h,foreach(tok, allToks), CODE: {\n\t[if(tokOnly), CODE:{\n\t\t[x\t\t= getTokenX(2,tok)]\n\t\t[y\t\t= getTokenY(2,tok)]\n\t\t[w\t\t= getTokenWidth(tok)]\n\t\t[h\t\t= getTokenHeight(tok)]\n\t\t[facing\t= getTokenFacing(tok)]\n\t\t[if(facing == \"\"): facing = -90]\n\t};{\n\t\t[x\t\t= getTokenX(2, tok) + round(getTokenWidth(tok)/2)]\n\t\t[y\t\t= getTokenY(2, tok) + round(getTokenHeight(tok)/2)]\n\t}]\n\n\t[jsonVBL\t= json.append(jsonVBL, strformat('{\"shape\":\"%{shape}\",\"fill\":1,\"radius\":%{radius},\"sides\":%{sides}, \"facing\":%{facing},\"x\":%{x},\"y\":%{y},\"w\":%{w},\"h\":%{h}}'))]\n}]\n\n\n[h:macro.return\t= getVBL(jsonVBL)]\n[h,if(clearVBL):eraseVBL(jsonVBL)]",
        "maxWidth": "",
        "tooltip": "Select one or more tokens, run macro, set radius (in grid cells) and ALL VBL in that radius around the selected tokens will be cleared.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c9897f2a-193f-4955-bb07-bbe59363ad5b",
          "commandChecksum": "1437d6407d011ce705b5134ddaff278a",
          "propsChecksum": "a383ebf468f75492e0ad647c56c73f10"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 169,
        "label": "createVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[debug\t\t= 0]\n\n\n\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n\n[if(argCount() > 1): check\t= arg(1) ; check\t= 0]\n\n[if(argCount() > 2): isDoor\t= arg(2) ; isDoor\t= 0]\n\n\n[varsFromStrProp(getProperty(\"w42.bot.vblSetup\", me))]\n\n\n[typeList\t= \"cross, rectangle, circle, polygon, polygon, polygon\"]\n[shape\t\t= listGet(typeList, VBLType)]\n[thickness\t= max(1, thickness)]\n[points\t\t= \"[]\"]\n[w\t\t\t= getTokenWidth(me)]\n[h\t\t\t= getTokenHeight(me)]\n[d\t\t\t= max(w,h)]\n[x\t\t\t= getTokenX(2, me)]\n[y\t\t\t= getTokenY(2, me)]\n[facing\t\t= getTokenFacing(me)]\n\n[radius\t\t= 0]\n[vblVars\t= \"shape, VBLType, x, y, w, h, radius, points, scale, thickness, sides, fill, close, offsetX, offsetY, resetFoW, rxOffset, ryOffset\"]\n\n\n[switch(VBLType), CODE:\n\tcase 0: {\n\t\t\n\t\t[if(!centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX + ceil((scale-1)*w/2)]\n\t\t\t[offsetY\t= offsetY + ceil((scale-1)*w/2)]\n\t\t}]\n\t};\n\tcase 1: {\n\t\t\n\t\t[if(centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX - ceil((scale-1)*w/2)]\n\t\t\t[offsetY\t= offsetY - ceil((scale-1)*h/2)]\n\t\t}]\n\t};\n\tcase 2: {\n\t\t\n\t\t[if(centreOffset), CODE:{\n\t\t\t[offsetX\t= offsetX + round(w/2) +1]\n\t\t\t[offsetY\t= offsetY + round(h/2) +1]\n\t\t};{}]\n\n\t\t\n\t\t[radius\t\t= floor(min(w,h)/2)]\n\t};\n\tcase 3: {\n\t\t\n\t\t[if(centreOffset): offsetX= offsetX - ceil((scale-1)*w/2)]\n\t\t\n\t\t[x1\t\t\t= x + offsetX]\n\t\t[x2\t\t\t= x1 + round(scale*w)]\n\t\t[y1\t\t\t= y + round(h/2)]\n\t\t\n\t\t[points\t\t= strformat(\"[{'x':%{x1},'y':%{y1}},{'x':%{x2},'y':%{y1}}]\")]\n\t};\n\tcase 4: {\n\t\t\n\t\t[if(centreOffset): offsetY= offsetY - ceil((scale-1)*h/2)]\n\t\t\n\t\t[y1\t\t\t= y + offsetY]\n\t\t[x1\t\t\t= x + round(w/2)]\n\t\t[y2\t\t\t= y1 + round(scale*h)]\n\n\t\t[points\t\t= strformat(\"[{'x':%{x1},'y':%{y1}},{'x':%{x1},'y':%{y2}}]\")]\n\t};\n\tcase 5: {\n\t\t\n\t\t\n\t\t[x\t\t\t= x + offsetX]\n\t\t[y\t\t\t= y + offsetY]\n\n\t\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x, \"y\", y, \"w\", w, \"h\", h, \"fill\", 1, \"scale\", scale)] \n\t\t[bot_saveFgVBL(me, rectVBL)]\n\t\t\n\t\t[bot_saveBgVBL(me,rectVBL)]\n\t};\n\tdefault: {\n\t\t[assert(0,\"it appears you try to create an unknown shape: \"+VBLType, 0)]\n\t}\n]\n\n\n\n[if(isDoor): vblBgScale = 1 ; vblBgScale = 1.5 * max(1,scale) * ( 1 + thickness/20 + max(abs(offsetX), abs(offsetY))/d )]\n[setProperty(\"w42.bot.vblBgScale\", vblBgScale, me)]\n\n[if(isDoor): vblBgOffsetX = 0 ; vblBgOffsetX\t= ceil((max(vblBgScale,1)-1)*if(h>w && !isDoor, h*h/w, w)/2)]\n[if(isDoor): vblBgOffsetY = 0 ; vblBgOffsetY\t= ceil((max(vblBgScale,1)-1)*if(w>h && !isDoor, w*w/h, h)/2)]\n\n[setProperty(\"w42.bot.vblBgOffsetX\", vblBgOffsetX, me)]\n[setProperty(\"w42.bot.vblBgOffsetY\", vblBgOffsetY, me)]\n\n[if(VBLType != 5), CODE:{\n\t\n\n\t\n\t\n\t\n\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x-vblBgOffsetX, \"y\", y-vblBgOffsetY, \"w\", d, \"h\", d, \"fill\", 1, \"scale\", vblBgScale)]\n\t\n\t\n\t\n\t[x\t\t\t= x + offsetX]\n\t[y\t\t\t= y + offsetY]\n\n\t[VBLData\t= json.fromStrProp(strPropFromVars(vblVars, \"UNSUFFIXED\"))]\n\t[jsonVBL\t= json.append(\"\", VBLData)]\n\t\n\t\n\t[h,if(debug == 1), CODE:{\n\t\t[bot_debugInfo(\"me, vblVars, VBLData, jsonVBL, rectVBL, vblBgScale, vblBgOffsetX, vblBgOffsetY, offsetX, offsetY, d\",0,1,0, getMacroName(), getMacroLocation())]\n\t};{}]\n\n\t[if(check), CODE:{\n\t\n\t\t[rx\t\t\t\t= round(w/2)]\n\t\t[ry\t\t\t\t= round(h/2)] \n\t\t[VBLDataC\t\t= json.set(VBLData,\"rx\", rx, \"ry\", ry,\"tx\", x, \"ty\", y)]\n\t\t[jsonVBLC\t\t= json.append(\"\", VBLDataC)]\n\t\t[checkVBL\t\t= json.get(json.get(getVBL(jsonVBLC,0),0),\"points\")]\n\t\t[macro.return\t= if(!json.isEmpty(checkVBL), jsonVBLC, \"{}\")]\n\t};{\n\t\t\n\t\t\n\t\t[bot_saveBgVBL(me,rectVBL)]\n\t\t\n\t\t[eraseVBL(rectVBL)]\n\t\t\n\t\t[drawVBL(jsonVBL)]\n\t\t\n\t\t[bot_saveFgVBL(me, rectVBL)]\n\t\t\n\t\t[bot_drawBgVBL(me)]\t\n\t\t\n\t\t[bot_drawFgVBL(me)]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9b1c1c4e-5b3d-4a78-b52d-d6197cc0aa12",
          "commandChecksum": "091a1dfaea7a2a0295019c037a993fda",
          "propsChecksum": "dcc96eb2bf9facdf8fa596d6a85b89c1"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 170,
        "label": "drawBgVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[debug\t\t= 0]\n\n\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[vblData\t= getProperty(\"w42.bot.bgVBL\", me)]\n[rectVBL\t= getProperty(\"w42.bot.rectVBL\")]\n[eraseVBL(rectVBL)]\n[points\t\t= json.get(json.get(vblData, 0),\"points\")]\n[if(!json.isEmpty(points)):drawVBL(vblData)]\n\n\n[if(debug == 1): bot_debugInfo(\"me, VBLData, rectVBL, points\",0,1,0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "459cdcf7-198b-4098-8f68-3e2f01a252ad",
          "commandChecksum": "5e40b54e67ba2636b796beb898308191",
          "propsChecksum": "825b4bdb98f458958735f98b7ab708bf"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 171,
        "label": "drawFgVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h:debug\t\t\t= 0]\n\n[h,if(argCount() > 0): toks\t\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:assert(listCount(toks), \"Make sure you have at least one token selected\",0)]\n\n[h,if(argCount() > 1): drawBg\t= arg(1) ; drawBg\t= 1]\n\n\n[h,if(debug == 1): bot_debugInfo(\"toks\",0,1,0, getMacroName(), getMacroLocation())]\n\n[h:w42.bot.final\t= '[ ]']\n[h,foreach(me,toks), CODE:{\n\t[switchToken(me)]\n\t\n\t[x\t\t= getTokenX()]\n\t[y\t\t= getTokenY()]\n\t[w\t\t= getTokenWidth()]\n\t[h\t\t= getTokenHeight()]\n\t[facing\t= getTokenFacing()]\n\t[if(facing == \"\"): facing = -90]\n\n\t[if(drawBg), CODE:{\n\t\t\n\t\t[bot_drawBgVBL(me)]\n\t\t\n\t\t[bot_saveBgVBL(me)]\n\t};{}]\n\n\t\n\t[fgVBL\t= getProperty(\"w42.bot.fgVBL\")]\n\n\t\n\t[rx\t\t\t\t= getTokenX()+round(getTokenWidth()/2) - x]\n\t[ry\t\t\t\t= getTokenY()+round(getTokenHeight()/2) - y] \n\n\t\n\t[w42.bot.shape = json.set(\"{ }\", \"shape\", \"polygon\", \"fill\", 1, \"close\", 1, \"thickness\", 0, \"tx\", x, \"ty\", y, \"rx\", rx, \"ry\", ry, \"facing\", facing, \"points\", fgVBL)]\n\t[w42.bot.final = json.append(w42.bot.final, w42.bot.shape)]\n\n\t\n\t[h,if(debug == 1): bot_debugInfo(\"me, fgVBL, w42.bot.final\",0,1,0, getMacroName(), getMacroLocation())]\n}]\n\n[h,if(!json.isEmpty(w42.bot.final)): drawVBL(w42.bot.final)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "519116e6-dbba-4adb-ba8f-39fc7868f819",
          "commandChecksum": "1e8f63fb337735b4854636d6095dff0c",
          "propsChecksum": "cf9b20095dd52241ed80594ce7ec6622"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 172,
        "label": "extendPoint",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n\n[coordinate\t= arg(0)]\n[endPolygon\t= arg(1)]\n\n[xFP\t\t= json.get(coordinate, \"x\")]\n[yFP\t\t= json.get(coordinate, \"y\")]\n[x0\t\t\t= xFP]\n[y0\t\t\t= yFP]\n\n[if(xFP == x1 && (yFP == y1 || yFP == y2) || xFP == x2 && (yFP == y1 || yFP == y2)), CODE:{\n\t\n\t[offset\t\t\t= if(endPolygon, json.length(newPoints)-2, 1)]\n\t[secondCoord\t= json.get(newPoints, offset)]\n\t[xSP\t\t\t= json.get(secondCoord, \"x\")]\n\t[ySP\t\t\t= json.get(secondCoord, \"y\")]\n\t[yDirection\t\t= if(xFP == xSP, 1,0)]\n\t[xDirection\t\t= if(yFP == ySP, 1,0)]\n['pause(\"xFP\",\"yFP\",\"xSP\",\"ySP\",\"offset\",\"newPoints\",\"coordinate\",\"secondCoord\",\"x1\",\"x2\",\"y1\",\"y2\",\"xDirection\",\"yDirection\")']\n\t\n\t[if(xDirection && !yDirection), CODE:{\n\t\t[if(xFP == x1):\tx0\t= x1 - extendPx]\n\t\t[if(xFP == x2):\tx0\t= x2 + extendPx]\n\t\t[y0\t= yFP]\n\t};{  }]\n\t[if(yDirection && !xDirection), CODE:{\n\t\t[if(yFP == y1):\ty0\t= y1 - extendPx]\n\t\t[if(yFP == y2):\ty0\t= y2 + extendPx]\n\t\t[x0\t= xFP]\n\t};{  }]\n};{\n\t\n\t[if(xFP == x1), CODE:{\n\t\t[x0\t= x1 - extendPx]\n\t\t[y0\t= yFP]\n\t};{}]\n\t[if(xFP == x2), CODE:{\n\t\t[x0\t= x2 + extendPx]\n\t\t[y0\t= yFP]\n\t};{}]\n\t[if(yFP == y1), CODE:{\n\t\t[x0\t= xFP]\n\t\t[y0\t= y1 - extendPx]\n\t};{}]\n\t[if(yFP == y2), CODE:{\n\t\t[x0\t= xFP]\n\t\t[y0\t= y2 + extendPx]\n\t};{}]\n}]\n['pause(\"xFP\",\"yFP\",\"x1\",\"x2\",\"y1\",\"y2\",\"x0\",\"y0\")']\n\n[macro.return\t= json.set(\"{}\",\"x\", x0, \"y\", y0)]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c91e2047-5b94-4ffd-97a4-63aa516f6218",
          "commandChecksum": "3ae080029f0155882d1e942efaaea15f",
          "propsChecksum": "46ac2ef573534fa5e65890818765c1b0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 173,
        "label": "moveStamp",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{\n\t[if(argCount()>0): me\t= arg(0) ; me = getSelected()]\n\t\n\t[bot_drawBgVBL(me)]\t\n\t\n\t[bot_saveBgVBL(me)]\n\t\n\t[bot_drawFgVBL(me)]\n\n\t[toks\t= getTokens(\",\", '{ pc:1 }')]\n\t[if(toks != \"\"):selectTokens(toks,1,\",\")]\n\t[exposeFOW()]\n\t[selectTokens(me)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "240c9a02-d3e6-4837-9e56-0d5613fbc11f",
          "commandChecksum": "1e802b786d752e75fb6590ada6b2136a",
          "propsChecksum": "cee23315b85d918eb519f444f0af58e4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 174,
        "label": "removeVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[me\t\t\t\t= arg(0)]\n<pre>\n[if(hasProperty(\"w42.bot.vblSetup\",me)): resetProperty(\"w42.bot.vblSetup\", me)]\n[if(hasProperty(\"w42.bot.rectVBL\",me)): resetProperty(\"w42.bot.rectVBL\", me)]\n[if(hasProperty(\"w42.bot.bgVBL\",me)): resetProperty(\"w42.bot.bgVBL\", me)]\n[if(hasProperty(\"w42.bot.fgVBL\",me)): resetProperty(\"w42.bot.fgVBL\", me)]\n[if(hasProperty(\"w42.bot.vblBgOffsetX\",me)): resetProperty(\"w42.bot.vblBgOffsetX\", me)]\n[if(hasProperty(\"w42.bot.vblBgOffsetY\",me)): resetProperty(\"w42.bot.vblBgOffsetY\", me)]\n[if(hasProperty(\"w42.bot.vblBgScale\",me)): resetProperty(\"w42.bot.vblBgScale\", me)]",
        "maxWidth": "",
        "tooltip": "this macro removes ALL VBL data from a token. So NOT the VBL itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "88d281db-6346-4ba3-8a2a-d65420b485a1",
          "commandChecksum": "ee342c9ff37cbc0b0f8ddf9bdf7b9709",
          "propsChecksum": "1cd4e5001f6a5538fd870865ab17a1af"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 175,
        "label": "saveBgVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[debug\t= 0]\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[x\t\t\t= getTokenX()]\n[y\t\t\t= getTokenY()]\n[d\t\t\t= max(getTokenWidth(), getTokenHeight())]\n[facing\t\t= getTokenFacing()]\n[if(facing == \"\"): facing = -90]\n\n\n[if(argCount() > 1), CODE: {\n\t[rectVBL\t= arg(1)]\n\t[if(debug == 1): scale = 1]\n};{\n\t\n\t[scale \t\t\t= getProperty(\"w42.bot.vblBgScale\", me)]\n\t[vblBgOffsetX\t= getProperty(\"w42.bot.vblBgOffsetX\", me)]\n\t[vblBgOffsetY\t= getProperty(\"w42.bot.vblBgOffsetY\", me)]\n\n\t[rectVBL\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x-vblBgOffsetX, \"y\", y-vblBgOffsetY, \"w\", d, \"h\", d, \"fill\", 1, \"scale\", scale)]\n}]\n\n[vblData\t= getVBL(rectVBL)]\n\n[setProperty(\"w42.bot.bgVBL\", vblData)]\n[setProperty(\"w42.bot.rectVBL\", rectVBL)]\n\n\n[h,if(debug == 1): bot_debugInfo(\"me, vblData,rectVBL,scale\",0,1,0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "db4470e2-41f5-4b63-b13b-37130b9d12b1",
          "commandChecksum": "5457a4194b15fde370e089ed162dc130",
          "propsChecksum": "8de7235961a5690be751c9fc46bd7b65"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 176,
        "label": "saveFgVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h:debug\t\t= 0]\n\n[if(argCount() > 0): me\t\t= arg(0) ; me\t\t= currentToken()]\n[switchToken(me)]\n\n[x\t\t\t\t= getTokenX()]\n[y\t\t\t\t= getTokenY()]\n[w\t\t\t\t= getTokenWidth()]\n[h\t\t\t\t= getTokenHeight()]\n[facing\t= getTokenFacing()]\n[if(facing == \"\"): facing = -90]\n\n\n[if(argCount() > 1): \n\trectVBL\t\t= arg(1) \n; \n\trectVBL\t\t= json.set(\"{ }\", \"shape\", \"rectangle\", \"x\", x, \"y\", y, \"w\", w, \"h\", h, \"fill\", 1, \"facing\", facing)\n] \n[vblData\t\t= getVBL(rectVBL, 1)]\n\n[if(argCount() < 2):pause()]\n\n[points='[ ]']\n\n\n[len\t\t\t= json.length(vblData)]\n[for(i, 0, len, 2), CODE :{\n\t[x2\t\t\t= json.get(vblData, i)]\n\t[y2\t\t\t= json.get(vblData, i+1)]\n\t[vblData\t= json.set(vblData, i, x2 - x)]\n\t[vblData\t= json.set(vblData, i+1, y2 - y)]\n\t\n\t[newPoints\t= json.set(\"{ }\", \"x\", x2 - x, \"y\", y2 - y)]\n\t[points\t\t= json.append(points, newPoints) ]\n}]\n\n[h:setProperty(\"w42.bot.fgVBL\", points)]\n\n\n[h,if(debug == 1): bot_debugInfo(\"me, x, y, vblData, points\", 0, 1, 0, getMacroName(), getMacroLocation())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5411e6c7-eebf-4beb-8b80-77e24fb4e847",
          "commandChecksum": "c1a018fc47e50a8a80b558de55f378d4",
          "propsChecksum": "69d6a5c5ad60f7e5822359ce1cfd553d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 177,
        "label": "setVBLStamp",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h:allToks\t\t= getSelected()]\n[h:assert(listCount(allToks), \"Make sure that you have at least one token selected. On which you want to apply the VBL stamp\",0)]\n[h:typeList\t\t= \"Cross, Rectangle, Circle, Horizontal Line, Vertical Line, Current VBL\"]\n[h:sideList\t\t= \"\"]\n\n[h,count(10): sideList = listAppend(sideList, roll.count+3)]\n[h:gs\t\t\t= bot_getGridSize()]\n\n\n[h:tok\t\t\t= listGet(allToks, 0)]\n[h:fgVBL\t\t= getProperty(\"w42.bot.fgVBL\", tok)]\n[h:vblPresent\t= if(json.type(fgVBL)==\"ARRAY\", 1, 0)]\n[h:vblSetup\t\t= if(vblPresent, getProperty(\"w42.bot.vblSetup\", tok), \"applyVBL=0;VBLType=0;scaleX=100;scaleY=100;offsetX=0;offsetY=0;thickness=1;fill=0;scale=1;close=0;sides=6;centreOffset=1;resetFoW=1;rxOffset=0;ryOffset=0\")]\n[h:varsFromStrProp(vblSetup)]\n[h:sides\t\t= sides - 3]\n\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, 'junk|<html><b>Set VBL Stamp (This line contains a tooltip)<\/b><br><font color=red>Keep in mind that the VBL layer only moves with<br>the token when its on the TOKEN layer<\/font><br><br><\/html>|<html>With this menu you can setup a VBL stamp for the token that you selected.<br>This stamp will be activated immediately and will move along with the <br>token when you move it. <br><br>The chosen shape will be applies to ALL selected tokens. The <i>Current VBL<\/i><br>option will grab ALL VBL that covers the token and uses that as stamp. |LABEL|SPAN=TRUE')]\n[h:inputStr \t= json.append(inputStr, 'applyVBL|'+applyVBL+'|<html><span title=\"<html>When you check this a VBL layer will be added to the token<\/html>\">Apply a VBL Stamp to token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'VBLType|'+typeList+'|<html><span title=\"<html>Shape of the VBL layer that will be applied<\/html>\">Shape of VBL<\/html><\/span><\/html>|RADIO|SELECT='+VBLType)]\n[h:inputStr \t= json.append(inputStr, 'offsetX|'+offsetX+'|<html><span title=\"<html>X (left/right) Offset in pixels from top left corner<\/html>\">X offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'offsetY|'+offsetY+'|<html><span title=\"<html>Y (top/down) Offset in pixels from top left corner<\/html>\">Y offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'rxOffset|'+rxOffset+'|<html><span title=\"<html>RX (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RX is the offset of that rotational centre<\/html>\">RX offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'ryOffset|'+ryOffset+'|<html><span title=\"<html>RY (left/right) Rotational Offset in pixels from the centre of the token<br>When your change the facing of the token the VBL will rotate around<br>the centre of the token. RY is the offset of that rotational centre<\/html>\">RY offset (in px)<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'thickness|'+thickness+'|<html><span title=\"<html>Thickness of the VBL line in pixels<\/html>\">Thickness of VBL Line<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'scale|'+scale+'|<html><span title=\"<html>Scale 1 is actual size, 0.5 is half, 2 is 2x as big, etc.<\/html>\">Scale VBL shape<\/html><\/span><\/html>')]\n[h:inputStr \t= json.append(inputStr, 'fill|'+fill+'|<html><span title=\"<html>Checked results in a solid (filled) shape, unchecked in a hollow shape<\/html>\">Solid shape<\/html><\/span><\/html>|CHECK')]\n[h:inputStr \t= json.append(inputStr, 'centreOffset|'+centreOffset+'|<html><span title=\"<html><b>UNCHECKED<\/b>: will align the TOP LEFT corner of the VBL to the TOP LEFT corner of the token<br>(in case of the circle this means that its centre will be aligned to the top left corner)<br><b>CHECKED<\/b>: will align the CENTRE of the VBL to the CENTRE of the token.<\/html>\">Align with Centre of token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Circle Only<\/b><\/html>|<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'sides|'+sideList+'|<html><span title=\"<html>Note that its not actually  a circle but a regular polygon.<br>Hence the option to set the number of sides<\/html>\">Number of sides<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+sides)]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>General<\/b><\/html>|<html>-|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, 'resetFoW|'+resetFoW+'|<html><span title=\"<html>When you check this the Fog of War will be reset entirely and cleared<br>for the current line of sight of the player tokens everytime the VBL<br> token is moved. <\/html>\">Reset FoW after moving token<\/html><\/span><\/html>|CHECK')]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n[h: vblSetup = strPropFromVars(\"applyVBL,VBLType,scaleX,scaleY,offsetX,offsetY,thickness,scale, fill, close, sides, centreOffset, resetFoW, rxOffset, ryOffset\",\"UNSUFFIXED\")]\n\n\n[h, foreach(me, allToks), CODE:{\n\t\n\t[varsFromStrProp(vblSetup)]\n\t[if(applyVBL), CODE:{\n\t\t\n\t\t[setProperty(\"w42.bot.vblSetup\", vblSetup, me)]\n\n\t\t\n\t\t[bot_createVBL(me)]\n\t};{\n\t\t\n\t\t[bot_drawBgVBL(me)]\n\t\t[bot_removeVBL(me)]\n\t}]\n}]\n\n[if(resetFoW): exposePCOnlyArea()]",
        "maxWidth": "",
        "tooltip": "<html>This function applies a VBL (Vision Blocking Layer) upon a token. The VBL will move with the token as you move it.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e1fb9888-9690-4a20-bad0-9be62b3f54f4",
          "commandChecksum": "557a671672a214735bd50152b44efced",
          "propsChecksum": "164c54799c8297b9eb231b7f6f6652b5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 178,
        "label": "toggleMassVBL",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:assert(getLibProperty('vblSupport','lib:EventMacros'),\"This version of maptool does NOT support VBL manipulation\",0)]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:storedVBL\t= getLibProperty(\"storedVBL\", \"lib:EventMacros\")]\n[h,if(json.type(storedVBL)==\"UNKNOWN\"): storedVBL = \"{}\"]\n[h:thisMapVBL\t= json.get(storedVBL, currentMap)]\n[h:thisMapVBLOn\t= json.get(storedVBL, currentMap+\"_ON\")]\n[h,if(json.type(thisMapVBLOn)==\"UNKNOWN\"):\tthisMapVBLOn\t= \"{}\"]\n\n[h:assert(json.type(thisMapVBL)!=\"UNKNOWN\",\"This map contains no stored VBL\", 0)]\n\n[h:vblList\t\t= json.fields(thisMapVBL)]\n\n[H:inputstr\t\t= \"\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Toggle Mass VBL Layer<\/b><\/html>|<html>Here you can turn on or off the stored Mass VBL resulting from the Mass VBL macro.<br>|LABEL|SPAN=TRUE\")]\n[h, foreach(vblName, vblList): inputStr\t= json.append(inputStr, vblName+'_ON|Deactivated, Activated, Delete from list|'+vblName+'|RADIO|ORIENT=H SELECT='+json.get(thisMapVBLOn, vblName))]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[vblChangedList = \"\"]\n[h, foreach(vblName, vblList), CODE:{\n\t[if(eval( vblName+'_ON') != json.get(thisMapVBLOn, vblName)): vblChangedList = listAppend(vblChangedList, vblName)]\n}]\n\n[h,foreach(vblName, vblChangedList), CODE:{\n\t\n\t[jsonVBL\t\t= json.get(thisMapVBL, vblName)]\n\t[if(eval(vblName+'_ON')): drawVBL(jsonVBL) ; eraseVBL(jsonVBL)]\n\t\n\t[thisMapVBLOn\t= json.set(thisMapVBLOn, vblName, eval(vblName+'_ON'))]\n\t[storedVBL\t\t= json.set(storedVBL, currentMap+\"_ON\", thisMapVBLOn)]\n}]\n\n[setLibProperty(\"storedVBL\", storedVBL, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>With this function you can toggle saved mass VBL structures (set with Mass VBL macro) on and off",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b181f177-b29c-4838-9328-05272edb491b",
          "commandChecksum": "706352ef00da1c14157fae1dbf65a305",
          "propsChecksum": "b4ecbd479a58e7528da3fcaf78a7a2a3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "35",
        "includeLabel": false,
        "sortBy": "35",
        "index": 179,
        "label": "SelectAndCentre",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:me = arg(0)]\n[h:switchToken(me)]\n[h:assert(findToken(me) != \"\", Me+\" cannot be found on the map\",0)]\n[h:'']\n[h, if(getSelected() != me):selectTokens(me)]\n[h:goto(me)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "77469f2a-3000-4f17-a7f3-9d60c28ae960",
          "commandChecksum": "e9fb0c705d4a42b7ccae308c45e887a1",
          "propsChecksum": "2abbf5bbd0a6bb565b55226ad5f18fc8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "6a. Door Button",
        "index": 180,
        "label": "SwitchFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me = getSelected()]\n\n[frame(\"Door Buttons and Full Screen Checker\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: macroLinkText(\"buttonHandler@Lib:OnTokenMove\", \"none\", me)]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\tPlease leave this frame open. While this frame is open the following functions are activated:<br>\n\t\t\t- Door Switches (user can click them to open doors) <br>\n\t\t\t- Event Buttons (user can click them to activate linked macro) <br>\n\t\t\t- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>\n\t\t\t- Group select tokens (user can select one token and the rest is auto-selected)<br>\n\t\t\t- Force token selection (token that gm selects on his client is also selected on a player client)<br>\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "<html>This macro activates a frame. As long as that frame is open the following functions are active:<br>- Door Switches (user can click them to open doors) <br>- Event Buttons (user can click them to activate linked macro) <br>- Full screen mode (if turned on in the settings, frames are automatically turned into Dialogs) <br>- Group select tokens (user can select one token and the rest is auto-selected)<br><\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "41c47ac3-2aae-4bdf-a7da-a55ad7111561",
          "commandChecksum": "3f072eb275e26161622a62db9b93b979",
          "propsChecksum": "fcd3ce524ea43120a738af030300c3aa"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "6a. Door Button",
        "index": 181,
        "label": "buttonHandler",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:'']\n[h:varsFromStrProp(getLibProperty(\"toggles\", \"lib:EventMacros\"))]\n\n[h: tokenId\t= getSelectedNames()]\n\n\n[h:IFS\t\t= json.get(getInfo(\"client\"),\"isFullScreen\")]\n[h,if(isNumber(IFS) && doFullScreenMode),CODE:{\n\t[if(IFS != getLibProperty(\"fullScreenMode\", \"Lib:EventMacros\")): bot_toggleFullScreen()]\n};{}]\n\n\n[h, if(listCount(tokenId) !=1 ): abort(0)]\n\n\n\n[h, if(bot_timeOut(1)), CODE:{\n\t[bot_resetTimer(1)]\n}; {\n\t\n\t\n\t[h, if(getProperty(\"w42.bot.isShadowToken\", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(tokenId, 0, length(tokenId) - 7))]\n\t\n\t[abort(0)]\n}]\n\n\n\n[h,token(tokenId),if(startsWith(token.label,\"group\")), CODE:{\n\t[if(getLibProperty('showGroupPanelOnSelect','lib:EventMacros') && !isFrameVisible(\"Group Move Macros\")):bot_MacroButtonsGroupMove()]\n}]\n\n\n\n\t[h,token(tokenId), if(getProperty(\"w42.bot.isShadowToken\", tokenId) == 1 && canSelectShadowTok == 2): selectTokens(substring(token.name, 0,length(token.name) - length(\" shadow\")))]\n\n\n\n[h,if(isGM() && forceSelectClient !=\"\"), CODE:{\n\t[broadcast(macroLink(\"<span  style='text-decoration:none'> <\/span>\", 'SelectAndCentre@this', 'none', tokenId ), forceSelectClient)]\n}]\n\n\t\n\n\n[h:tokButton\t= hasProperty(\"buttonArgs\", tokenId)]\n\n\n[h:forceButtons\t= if(isGM() && getPlayerName() != \"forceButtons\" && json.contains(getLibProperty(\"gmNames\",\"Lib:EventMacros\"), \"forcebuttons\"),1,0)]\n\n[h: abort(tokButton + forceButtons)]\n\n[h, if(tokButton), CODE:{\n\t[buttonArgs = getProperty(\"buttonArgs\", tokenId)]\n\t[varsFromStrProp(buttonArgs)]\n\n\t\n\t[macroLink = macroLinkText(macroToCall, \"none\", buttonArgs)]\n\t[execLink(macroLink, 1)]\n}; {}]\n\n[h, if(forceButtons), CODE:{\n\t\n\t[broadcast(macroLink(\"<span  style='text-decoration:none'> <\/span>\", 'SelectAndCentre@this', 'none', tokenId ),\"forceButtons\")]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4b183d4f-1727-4437-b1ac-6117a09d0a41",
          "commandChecksum": "05eef6061cf349003264f97694695aa5",
          "propsChecksum": "171968f8669edc42c699ef91ac60edf0"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "maroon",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 182,
        "label": "openFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n[h:bot_resetTimer(1)]\n[h:bot_execAllPlayers(\"SwitchFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>Turns on door switches at selected players. This will allow players to use doorswitches",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "930928e1-0840-4164-b52e-c76257e93b84",
          "commandChecksum": "d5cae4ce29ac4294c945cb30b983a95b",
          "propsChecksum": "70dfa4d5a9af7bad65cfa21ca001cafc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "6a. Door Button",
        "index": 183,
        "label": "operateLever",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:varsFromStrProp(arg(0))]\n[h:switchToken (mainDoor)]\n[h:leverToken = getSelected()]\n[h:closeEnough= 1]\n[h:operator = \"\"]\n[h:tokenList = \"\"]\n\n[h,if(proximity), CODE:{\n\t['tokenList\t\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"range\",json.set(\"{}\",\"token\",leverToken, \"upto\", proximity)))']\n\t[tokenList\t\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"pc\", 1, \"range\",json.set(\"{}\",\"token\",leverToken, \"upto\", proximity)))]\n\n\t[tokenList\t\t= listDelete(tokenList, listFind(tokenList,getName(mainDoor)))]\n\t[closeEnough\t= 0]\n\t[player\t\t\t= getPlayerName()]\n\t[foreach(tok, tokenList), CODE:{\n\t\t[if(isOwner(player, tok)): closeEnough = 1]\n\t\t[if(isOwner(player, tok)): operator = tok]\n\t}]\n}; {\n\t['tokenList\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"range\",json.set(\"{}\",\"token\",leverToken)))']\n\t[ tokenList\t= getTokenNames(\",\",json.set(\"{}\", \"layer\", \"TOKEN\", \"pc\", 1, \"range\",json.set(\"{}\",\"token\",leverToken)))]\n\t[operator\t= listGet(getOwned(getPlayerName()),0)]\n\t[if(operator != \"\"): operator = getName(operator)]\n}]\n\n\n[h,if(getTokenFacing(leverToken)==\"\"):setTokenFacing(-90,leverToken)]\n[h, if(closeEnough): setTokenFacing(180+getTokenFacing(leverToken), leverToken)]\n\n\n[h: bot_toggleDoor(mainDoor, closeEnough, operator, tokenList)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c5cb82d1-16a0-46fd-869c-5b775b90de5e",
          "commandChecksum": "67e54a03b4d4e70479e08b4806f104ab",
          "propsChecksum": "e8b54cfbb5760919ea3b692c8d1a16f8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6a. Door Button",
        "includeLabel": false,
        "sortBy": "6a. Door Button",
        "index": 184,
        "label": "toggleLock",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n[h:tokenId = getSelected()]\n[h:assert(listCount(tokenId)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(tokenId)]\n\n[h:setState('Locked', 1-getState('Locked'))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a159f891-35b0-4021-a01a-e6ea51f49b05",
          "commandChecksum": "9f268309c184a07046c9f1e3712acc33",
          "propsChecksum": "2dd81309081407dfb2d00106457c658c"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 188,
        "label": "getFullInfo",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:broadcast(\"\n\tServer:\n\t<pre>\"+json.indent(getinfo(\"server\"),1)+\"\n\t_________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tClient:<br>\n\t<pre>\"+json.indent(getinfo(\"client\"),1)+\"\n\t_________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tCampaign:<br>\n\t<pre>\"+json.indent(getinfo(\"campaign\"),1)+\"\n\t__________________________________________________________\n\")]\n\n[r:broadcast(\"\n\tCurrent Map:<br>\n\t<pre>\"+json.indent(getinfo(\"map\"),1)\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4f82d498-49dc-4ab7-912d-ea9d7c1e5335",
          "commandChecksum": "c7ece7820f26de648ba4db06353fa291",
          "propsChecksum": "a22e8d720eaf62339244a448e3335145"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 189,
        "label": "all",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return=json.fromList(getAllPlayerNames())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "38e9abf0-d123-4402-ab0b-3d898555acc2",
          "commandChecksum": "482a799bc5b3ccf4f6b4f2db7bd9c295",
          "propsChecksum": "b94009bd5abc00600d27d911b7f49a16"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 190,
        "label": "gm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return=getLibProperty(\"gmNames\", \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d06e2e1c-a5f7-48f9-ad00-161682ef13b7",
          "commandChecksum": "e40ee4f6bbcbcbb4125473ef05d9f5c5",
          "propsChecksum": "463376f9be0252b9b070c2e61485730b"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 191,
        "label": "message",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n[h:message\t\t= arg(0)]\n\n\n[h,if(argCount() > 1): headerText\t= arg(1) ; headerText\t= \"\"]\n[h, if (indexOf(headerText, \":width=\") != -1), CODE:{\n\t\n\t[break\t\t= indexOf(headerText, \":width=\")]\n\t[width\t\t= substring(headerText, break + 7)]\n\t[headerText\t= substring(headerText, 0, break)]\n};{}]\n\n[h,if(argCount() > 2): color \t\t= arg(2) ; color\t\t= \"black\"]\n[h,if(indexOf(color, \"-\")+1), CODE:{\n\t[break\t\t= indexOf(color, \"-\")]\n\t[bgColor\t= substring(color, 0, break)]\n\t[textColor\t= substring(color, break + 1)]\n}; {\n\t[bgColor\t= color]\n\t[textColor\t= \"white\"]\n}]\n\n[h,if(argCount() > 3): userList\t\t= arg(3) ; userList\t\t= \"[]\"]\n\n[h,if(argCount() > 4 ), CODE:{\n\t[h,if(arg(4) != \"\"), CODE:{\n\t\t[me\t\t\t= arg(4)]\n\t\t[token(me): meImage\t= getTokenImage()]\n\t\t[me\t\t\t= strformat(\"<b>%{me}<\/b> \")]\n\t\t[meImage\t= strformat(\"<img src='%{meImage}' height='20' width='20' alt='%{me}'/>\")]\n\t}; {\n\t\t[me\t\t\t= \"\"]\n\t\t[meImage\t= \"\"]\n\t}] \n};{\n\t[me\t\t\t= \"\"]\n\t[meImage\t= \"\"]\n}]\n\n[h,if(argCount() > 5), CODE:{\n\t[target\t= arg(5)]\n\t[if(target != \"\"), CODE:{\n\t\t[token(target):\ttargetImage\t= getTokenImage()]\n\t\t[targetImage\t= strformat(\"<img src='%{targetImage}' height='20' width='20' alt='%{target}'/>\")]\n\t}; {\n\t\t[targetImage\t= \"\"]\n\t}]\n}; {\n\t[target\t\t\t= \"\"]\n\t[targetImage\t= \"\"]\n}] \n\n[h,if(argCount() > 6): bc\t\t\t= arg(6) ; bc\t\t= 1]\n\n[h,if(argCount() > 7): width\t\t= arg(7) ; width\t= \"100%\"]\n\n[h,if(argCount() > 8): me = if(arg(8), \"\", me)] \n\n\n[h:txtResult\t= strformat(\"\n\t<table bgcolor='%{bgColor}' width='\"+width+\"' cellpadding='3' cellspacing='0'><font color = '%{textColor}'>\n\t\t<tr>\n\t\t\t<td>\n\t\t\t\t%{meImage}\n\t\t\t<\/td>\n\t\t\t<td align='middle'>\n\t\t\t\t%{me}%{headerText}\n\t\t\t<\/td>\n\t\t\t<td align='right'>\n\t\t\t\t%{targetImage}\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/font><\/table>\"+\n\tif(message != \"\", \"\n\t\t<table bgcolor='%{bgColor}' width='\"+width+\"' cellpadding='1' cellspacing='0'>\n\t\t\t<table bgcolor='White' width='100%'>\n\t\t\t\t<tr>\n\t\t\t\t\t<td>\n\t\t\t\t\t\t%{message}\n\t\t\t\t\t<\/td>\n\t\t\t\t<\/tr>\n\t\t\t<\/table>\n\t\t<\/table>\n\t\", \"\")\n))]\n\n[h, if(bc), CODE:{\n\t[if(!json.isEmpty(userList)): broadcast(txtResult, userList); broadcast(txtResult)]\n\t\n\t[varsFromStrProp(getLibProperty(\"toggles\", \"lib:EventMacros\"))]\n\t[if(doFullScreenMode),CODE:{\n\t\t[isFullScreen\t= json.get(getInfo(\"client\"),\"isFullScreen\")]\n\t\t[frameVisible\t= isFrameVisible(\"Bag Of Tricks Macros\") + isDialogVisible(\"Bag Of Tricks Macros\")]\n\t\t[if(isFullScreen == 1 && frameVisible), CODE:{\n\t\t\t[dialog(\"Bag Of Tricks Macros\", \"width=215; height=700; temporary=0; input=1\"): {\n\t\t\t\t[r:bot_createMacroButtonsOTMUtils(txtResult)]\n\t\t\t''\n\t\t\t}]\n\t\t''\n\t\t};{}]\n\t''\n\t};{}]\n''\n}; {\n\t[macro.return = txtResult]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "810d8fdc-3843-476a-9440-3683fc98d3eb",
          "commandChecksum": "b26a452243683d7fba86424b041e71bb",
          "propsChecksum": "2205265b455fdef26cff425fb51a3c07"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "31",
        "includeLabel": false,
        "sortBy": "31",
        "index": 193,
        "label": "ngm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), getLibProperty(\"gmNames\", \"lib:EventMacros\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2fc01eae-a97e-4156-895c-558d935819b5",
          "commandChecksum": "fe21b549bf4fe31468021854d6ba787a",
          "propsChecksum": "281fc190b362d8a8967493e4e631019d"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "52",
        "includeLabel": false,
        "sortBy": "52",
        "index": 194,
        "label": "nownergm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = json.difference(getAllPlayerNames(\"json\"), getLibProperty(\"gmNames\", \"lib:EventMacros\"))]\n};{\n\t[h,if(isOwnedByAll(tok)):\t\n\t\tmacro.return = []\n\t; \n\t\tmacro.return = json.difference(getAllPlayerNames(\"json\"), bot_ownergm())\n\t]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8123a241-6306-44ef-bcfc-c89c8c88a232",
          "commandChecksum": "daa1e4a5582e255a6e1434d7f54cd4b9",
          "propsChecksum": "db4504f1f9004b727a1e974de32e7783"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "41",
        "includeLabel": false,
        "sortBy": "41",
        "index": 195,
        "label": "nself",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), json.fromList(getPlayerName()))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f37a2fbb-4c9b-479a-942b-64768f0e5a48",
          "commandChecksum": "2ef7b99d54bb1737dd19c1278a49165b",
          "propsChecksum": "adb516db03a9a26e00211a9287a745e1"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "43",
        "includeLabel": false,
        "sortBy": "43",
        "index": 196,
        "label": "nselfgm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return = json.difference(getAllPlayerNames(\"json\"), json.union(getLibProperty(\"gmNames\", \"lib:EventMacros\"), json.fromList(getPlayerName())))]",
        "maxWidth": "",
        "tooltip": "returns all but self and gm",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "28d52a7e-8963-4c27-b4af-7c83f7af638d",
          "commandChecksum": "9fdd9fa1bb4df719447dd354e88b6b2b",
          "propsChecksum": "28f047ff8893018016300b3db36d9c5f"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "53",
        "includeLabel": false,
        "sortBy": "53",
        "index": 197,
        "label": "owner",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = \"\"]\n};{\n\t[if(isOwnedByAll(tok)):\t\n\t\tmacro.return = getAllPlayerNames() \n\t; \n\t\tmacro.return = getOwners(\"json\",tok)\n\t]\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "564d31a1-8521-42e8-b875-f7f18715f6b5",
          "commandChecksum": "162eb8d97bb5e62aaccc84d234a46158",
          "propsChecksum": "97f432a6c0892054fe53abc785dc8563"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 198,
        "label": "self",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return=json.fromList(getPlayerName())]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6af7cd66-6950-484e-b978-363cb9e42013",
          "commandChecksum": "ba8b2f8207f773b301579d1018bccccc",
          "propsChecksum": "2bd8629b3c76f4970a93ddfff2e6908a"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 199,
        "label": "selfgm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:macro.return = json.union(getLibProperty(\"gmNames\", \"lib:EventMacros\"), json.fromList(getPlayerName()))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2583830f-2c9d-4559-93ee-7bf0f15d3b95",
          "commandChecksum": "62c055709201b66da435ddab61257171",
          "propsChecksum": "426a2c4e58f1fe0600c5530814f5a2cb"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "16",
        "includeLabel": false,
        "sortBy": "16",
        "index": 200,
        "label": "altInitMap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h: assert(getImpersonated() == \"\", \"Make sure no token is impersonated while running this macro\", 0)]\n[h,if(argCount()>0): allToks = arg(0); allToks = \"\"]\n[h:map = getCurrentMapName()]\n\n[h:libCoordName\t= strformat(\"lib:Coords %{map}\")]\n[h:libCoordSize = getLibProperty(\"libCoordSize\", \"lib:EventMacros\")]\n[h:existTok\t\t= findToken(libCoordName)]\n[h,if(existTok != \"\"): initRun = getLibProperty(\"initRun\", libCoordName); initRun = 0]\n[h,if(initRun == \"\"): initRun = 0]\n[h:baseMapName\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h,if(initRun == 0 && existTok != \"\"), CODE:{\n\t[message = \"It seems you have Initialized this map before, if there are any lib:Coords XxYy tokens on the map, press Cancel and delete these first.<br>These tokens can typically be found at the 0,0 coordinate.<br>If there are no lib:Coords XxYy on the map, press ok to continue\"]\n\t[pause(\"message\")]\n}]\n\n[h,if(initRun > 0), CODE:{\n\t[h:'']\n\t[h:numMinX = 0]\n\t[h:numMinY = 0]\n\t[h:numMaxX = 0]\n\t[h:numMaxY = 0]\n}; {\n\t[h:'']\n\t[h:'']\n\t[h:specNameList = \"Canopy, Foliage, InterPad, PadStart, PadEnd, InterPadBorder, PadStartBorder, PadEndBorder, PadJump, InterJump, PadJumpBorder, InterJumpBorder, MappedPad, Roof, EventPad, Ward\"]\n\t[h, if(allToks == \"\"): allToks = json.toList(json.sort(getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"OBJECT\", \"HIDDEN\",\"BACKGROUND\")))))]\n\n\t[h:tokList = \"\"]\n\t[h, foreach(tok, allToks), CODE:{\n\t\t[padName = getGroup(strfind(tok, \"[A-z]+\"), 1,0)]\n\t\t[if(listContains(specNameList, padName)): tokList = listAppend(tokList, tok)]\n\t}]\n\n\t[h:numToks = listCount(tokList)]\n\t[h:assert(numToks <= 1000, \"Fatal error: The number (\"+numToks+\") of special pads on this map is more than 1000. This tool can handle upto 1000 special pads. Please remove \"+(numToks - 1000)+\" pads from this map\",0)]\n\n\t[h:tok = listGet(tokList, 0)]\n\t[h:switchToken(tok)]\n\t[h:xMin=getTokenX(0)]\n\t[h:yMin=getTokenY(0)]\n\n\t[xSize\t= getProperty(\"w42.bot.xSize\")]\n\t[ySize\t= getProperty(\"w42.bot.ySize\")]\n\t[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]\n\t[h:xMax=xMin + xSize]\n\t[h:yMax=yMin + ySize]\n\n\t[h, foreach(tok, tokList), CODE:{\n\t\t[switchToken(tok)]\n\n\t\t[xSize\t= getProperty(\"w42.bot.xSize\")]\n\t\t[ySize\t= getProperty(\"w42.bot.ySize\")]\n\t\t[if(!isNumber(xSize) || !isNumber(ySize)): bot_determineTokSize()]\n\t\t\n\t\t[h:x = getTokenX(0)]\n\t\t[h:y = getTokenY(0)]\n\t\t[h:xMin = min(xMin, x)]\n\t\t[h:yMin = min(yMin, y)]\n\t\t[h:xMax = max(xMax, x + xSize)]\n\t\t[h:yMax = max(yMax, y + xSize)]\n\t}]\n\t\n\tUpper left\t= ([r:xMin], [r:yMin])<br>\n\tLower Right\t= ([r:xMax], [r:yMax])<br><br>\n\t[h:numMinX = floor(xMin/libCoordSize)]\n\t[h:numMinY = floor(yMin/libCoordSize)]\n\t[h:numMaxX = floor(xMax/libCoordSize)+1]\n\t[h:numMaxY = floor(yMax/libCoordSize)+1]\n\n\t[h:'pause(\"xMin\",\"yMin\",\"xMax\",\"yMax\",\"numMinX\",\"numMinY\",\"numMaxX\",\"numMaxY\",\"libCoordSize\")']\n\n\t[h:initRun = 1]\n}]\n\n[h:'']\n[h,if(existTok != \"\"): createdCoordLibs = getLibProperty(\"createdCoordLibs\", libCoordName); createdCoordLibs = \"\"]\n[h,for(x, numMinX, numMaxX,1, \"<br>\"),CODE:{\n\t[r,for(y, numMinY, numMaxY, 1, \"<br>\"),CODE:{\n\t\t[h:xCoord = x*libCoordSize]\n\t\t[h:yCoord = y*libCoordSize]\n\t\t[h:name = strformat(\"lib:Coords %{map} X%{xCoord}Y%{yCoord}\")]\n\t\t[h:existTok = findToken(name)]\n\t\t[h,if(existTok != \"\"):removeToken(existTok)]\n\t\t[h:updates = '{\"name\":\"[r: name]\", \"useDistance\":\"0\", \"x\":\"[r:x]\", \"y\":\"[r:y]\"}']\n\t\t[r:createdCoordLibs = listAppend(createdCoordLibs, getName(copyToken(\"lib:Coords\", 1, baseMapName, updates)))] \n\t}]\n}]\nCreated: [r:createdCoordLibs]\n\n[h:'']\n[r, if(initRun == 1), CODE:{\n\t[h:existTok = findToken(libCoordName)]\n\t[h,if(existTok != \"\"):removeToken(existTok)]\n\t[h:x = numMinX - 1]\n\t[h:y = numMinY - 1]\n\t[h:updates = '{\"name\":\"[r: libCoordName]\", \"useDistance\":\"0\", \"x\":\"[r:x]\", \"y\":\"[r:y]\"}']\n\t<br>[r:getName(copyToken(\"lib:Coords\", 1, baseMapName, updates))] Created<br>\n\t[h:answer\t= input(\"junk|<html>This break is necessary for the just created lib:Coords tokens.<br>Click ok to continue.<br><br>his is also a good moment to mention that it is VITAL that FREESIZE<br>(or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize<\/b> special pad tokens, its advisable (but<br>not necessary) to set the size of these tokens before you run this macro.<br>To do this select the token and click the set size macro. If you don't<br>do this up front this macro will pop-up the size request for each of<br>these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads<\/b> you'll need to<br>initialize the campaign 'normally' first so they get setup properly.<br>This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <br>b>delete the lib:coords files<\/b> that have just been created and check<br>the tokens you're not sure of and/or run the 'normal' initialize pads.<\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(answer == 0), CODE:{\n\t\t\n\t\t[foreach(tok, createdCoordLibs): removeToken(tok)]\n\t\t[removeToken(libCoordName)]\n\t\t[assert(0,\"Alt. init. Process aborted\",0)]\n\t};{}]\n\n\t[message = \"This break is necessary for the just created lib:Coords tokens. Click ok to continue.<br><br>This is also a good moment to mention that it is VITAL that FREESIZE (or native size) tokens are NOT SET TO SNAP TO GRID.<br><br>In case you are using <b>Freesize<\/b> special pad tokens, its advisable (but not necessary) to set the size of these tokens before you run this macro. To do this select the token and click the set size macro. If you don't do this up front this macro will pop-up the size request for each of these tokens.<br><br>For <b>Interpads, InterJumpBorder and MappedPads<\/b> you'll need to initialize the campaign 'normally' first so they get setup properly. This only needs to be done once (unless you change or add those tokens).<br><br>Make sure you've done all this, if you're not sure, press cancel, <b>delete the lib:coords files<\/b> that have just been created and check the tokens you're not sure of and/or run the 'normal' initialize pads.\"]\n[pause(\"message\")]\n\n\t[h:setLibProperty(\"initRun\", initRun, libCoordName)]\n\t[h:setLibProperty(\"libCoordSize\", libCoordSize, libCoordName)]\n}]\n[h:setLibProperty(\"createdCoordLibs\", createdCoordLibs, libCoordName)]\n\n[h:'']\n\n[r,if(initRun == 1), CODE:{\n\t[h:numToks \t\t\t= listCount(tokList)]\n\t[h:maxPadsPerRun \t= getLibProperty(\"maxPadsPerRun\", \"lib:EventMacros\")]\n\t[h:numRuns \t\t\t= ceil(numToks/maxPadsPerRun)]\n\t[h:tokList \t\t\t= json.fromList(tokList)]\n\n\t[h,for(i, 1, numRuns+1), CODE:{\n\t\t[runToksname = \"runToks\"+i]\n\t\t[if(i < numRuns):\tset(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, i * maxPadsPerRun - 1))); \n\t\t\t\t\t\t\tset(runToksname, json.toList(json.get(tokList, (i-1) * maxPadsPerRun, -1)))\n\t\t]\n\t\t[setLibProperty(runToksname, eval(runToksname), libCoordName)]\n\t}]\n\n\t[h:setLibProperty(\"numRuns\", numRuns, libCoordName)]\n\t[h:tokList = runToks1]\n\t[h:'pause(\"runToks1\",\"runToks2\",\"runToks3\",\"runToks4\",\"numRuns\", \"tokList\")']\n\n}; {\n\t[h:tokList = getLibProperty(\"runToks\"+initRun, libCoordName)]\n}]\n\nRun [r:initRun]:\n[h: bot_abortProcess(1)]\n[h: link = macroLinkText(\"deferInitialize@Lib:OnTokenMove\", \"self\", json.append(\"\",listCount(tokList), tokList))]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e32b0117-f0d7-40f9-b2a0-49be6413d248",
          "commandChecksum": "8f8c3167a6f5bd5e9adbd7afbec41bbd",
          "propsChecksum": "1b8009079f62d0a57b4d3f6dd547b43a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 201,
        "label": "checkInterPads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h,if(json.contains(interPadCheckList, fullPadName)), CODE:{\n\t[tmp = json.get(interPadCheckList, fullPadName)]\n\n\t[if(json.contains(tmp, \"map1\")), CODE:{\n\t\t[map1 = 1]\n\t\t[map1Name = json.get(tmp, \"map1\")]\n\t}; {\n\t\t[map1 = 0]\n\t}]\n\n\t[if(json.contains(tmp, \"map2\")), CODE:{\n\t\t[map2 = 1]\n\t\t[map2Name = json.get(tmp, \"map2\")]\n\t}; {\n\t\t[map2 = 0]\n\t}]\n\n\t[if(map1 && map2), CODE:{\n\t\t[txtOutPut = txtOutPut + \"<font color='red'>Error: found three (or more) identical <u>\"+padName+\" \"+tmpNum+\"<\/u> on maps \" + map1Name + \", \" + map2Name + \" and \" + currentMap + \"<br><\/font>\"]\n\t\t[error = 1]\n\t}; {}]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d477a457-cb76-4c1f-aa33-5b2a6feef14d",
          "commandChecksum": "aa59133e608903d8d53a439f26800373",
          "propsChecksum": "b04921339f8ca9fabb183f90a9cff514"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 202,
        "label": "chkMoveStop",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:pathPadList = bot_path2pads(json.get(lastPath,1,-2))]\n[h:moveStopList = \"Ward\"]\n\n[r,foreach(item, moveStopList), if(bot_inStr(pathPadList, item)), CODE:{\n\t[h:newLastPath = \"[]\"]\n\t[h:clear = 1]\n\t[h:edgePoint = \"\"]\n\t[h,foreach(step, lastPath), CODE:{\n\t\t[pads = bot_path2pads(step)]\n\t\t[if(clear): newLastPath = json.append(newLastPath, step)]\n\t\t[foreach(item, moveStopList): clear = if(bot_inStr(pads, item),0, clear)]\n\t\t[h:'']\n\t\t[if(!clear && edgePoint == \"\"): edgepoint = varsFromStrProp(json.toStrProp(step))]\n\t}]\n\t[r:lastPath = newLastPath]\n\t[h,if(!clear): moveToken(x,y,0)]\n\t[h:'']\n\t[if(roll.count < 1 && !clear):pathPadList = bot_path2pads(json.get(lastPath,1,-2))]\n}; {\n\t[h:clear = 1]\n\t[r:lastPath]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b01b7c11-c51c-42f9-9f7f-b72d68b2765e",
          "commandChecksum": "2b02b6ca3c891b530875cf5f884a01dc",
          "propsChecksum": "d07df6afc974a9557e09537959b47a80"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 203,
        "label": "deferFinishInit",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:map \t\t\t\t= getCurrentMapName()]\n[h:libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h:numRuns \t\t\t= getLibProperty(\"numRuns\", libCoordName)]\n[h:initRun \t\t\t= getLibProperty(\"initRun\", libCoordName)]\n[h:createdCoordLibs = getLibProperty(\"createdCoordLibs\", libCoordName)]\n[h:closeFrame(\"Progress Bar\")]\n[h:done = if(initRun == numRuns, 1, 0)]\n\n[h: message = if(done, \"Map is initialized\", \"There are a total of \"+numRuns+ \" runs necessary to complete the initialization. This is run \"+initRun+\". Run the macro again for Run \"+(initRun + 1))]\n\n[h, if(!done): initRun = initRun + 1]\n[h:setLibProperty(\"initRun\", initRun, libCoordName)]\n[r:message]\n\n[h:'']\n[h: allProps = \"[]\"]\n[h,foreach(tok,createdCoordLibs), CODE:{\n\t[props = getPropertyNamesRaw (\"json\", tok)]\n\t[foreach(prop, props):set(prop, getProperty(prop, tok))]\n\t[allProps = json.merge(allProps, props)]\n}]\n\n[h:'']\n[h:mappedCoords = strPropFromVars( json.toList(allProps), \"UNSUFFIXED\")]\n[h:'']\n[h:mappedCoords = replace(mappedCoords, \", \", \",\")]\n[h:setLibProperty(\"mappedCoords\", mappedCoords, libCoordName)]\n[h:setLibProperty(\"allCoordsArray\", allProps, libCoordName)]\n\n[h:'']\n\n[h,if(done), CODE:{\n\t[foreach(tok, createdCoordLibs): removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "729956c9-b386-49fa-9156-f451f4c9f531",
          "commandChecksum": "ee320fcdc40885ccf69f0f2237cfa914",
          "propsChecksum": "c6592a588df84880ee3bae33703297a5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 204,
        "label": "deferInitialize",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:assert(getLibProperty(\"abortProcess\", \"lib:EventMacros\")!=0, \"Process Aborted\", 0))]\n\n[h:totalIteration = arg(0)]\n[h:tokList = arg(1)]\n[h:currentIteration = totalIteration - listCount(tokList)]\n\n[h:output = \"\n\t<table width=305px bgcolor='red'>\n\t\t<tr><td>\n\t\t\t[h:prog.percentage = floor(100*currentIteration/totalIteration)]\n\t\t\t<table width=[r:3*prog.percentage]px bgcolor = 'green' color='white'>\n\t\t\t\t<tr><td>\n\t\t\t\t\t[r:prog.percentage]% \" + if(band(currentIteration,1), '0', 'o') + \"\n\t\t\t\t<\/td><\/tr>\n\t\t\t<\/table>\n\t\t<\/td><\/tr>\n\t<\/table>\n\n\t \n\t<table width=100px bgcolor='black' cellpadding='1'>\n\t\t<table width=100% bgcolor='red'><td align='center')>\n\t\t\t<td>\n\t\t\t\t<span  style='text-decoration:none; color:yellow'>\n\t\t\t\t\t\" + macroLink('Abort process', 'abortProcess@this', '', 0) + \"\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n\t<\/table>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Progress Bar\", \"width=410; height=20; temporary=1; ouptut=1\"): {[r:output]}]\n};{\n\t[frame(\"Progress Bar\", \"width=410; height=20; temporary=1\"): {[r:output]}]\n}]\n\n[h:'']\n\n[h:tok\t\t\t= listGet(tokList, 0)]\n[h:tokList\t\t= listDelete(tokList, 0)]\n[h:xSize\t\t= getProperty(\"w42.bot.xSize\", tok)]\n[h:ySize\t\t= getProperty(\"w42.bot.ySize\", tok)]\n[h:map\t\t\t= getCurrentMapName()]\n[h:libCoordSize\t= getLibProperty(\"libCoordSize\", strformat(\"lib:Coords %{map}\"))]\n[h:'']\n[r, token(tok):token.name] \n(\n\t[r, token(tok):xTok = getTokenX(0)] \n\t[r, token(tok):yTok = getTokenY(0)] \n)\n<br>\n[h:'']\n[h:'e.g: lib:Coords Grasslands X-50Y-50']\n[h, for(x, xTok, xTok + xSize), CODE:{\n\t[for(y, yTok, yTok + ySize), CODE:{\n\t\t[xCoord\t\t= floor(x/libCoordSize)*libCoordSize]\n\t\t[yCoord\t\t= floor(y/libCoordSize)*libCoordSize]\n\t\t[if(x<0):xn = replace(x,\"-\",\"_\"); xn = x]\n\t\t[if(y<0):yn = replace(y,\"-\",\"_\"); yn = y]\n\t\t[coordName\t= strformat(\"X%{xn}Y%{yn}\")]\n\t\t[libName \t\t= strformat(\"lib:Coords %{map} X%{xCoord}Y%{yCoord}\")]\n\t\t[setLibProperty(coordName, listAppend(getLibProperty(coordName, libName),tok), libName)]\n\t}]\n}]\n\n[h:'']\n\n[h, if(listCount(tokList)):\texecLink(macroLinkText(\"deferInitialize@Lib:OnTokenMove\", \"self\", json.append(\"\",totalIteration, tokList)),1); \n\t\t\t\t\t\t\texecLink(macroLinkText(\"deferFinishInit@Lib:OnTokenMove\", \"self\"),1)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9d288ba1-3d4b-4572-8f1a-c32f8e8448b1",
          "commandChecksum": "5faf3dea44609f7aec0dfecc71ea9c92",
          "propsChecksum": "7005988c1a9fd4c0bbb90f016921ccd4"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 205,
        "label": "deferOnMultipleTokensMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'\n\n\n[h: varsFromStrProp(arg(0))]\n\n\n[h: varsFromStrProp(arg(1))]\n\n\n\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\n\n[h,if(doVBLCheck), CODE:{\n\t[foreach(tok,toks):bot_moveVBLToken(tok, eval(\"lastPath\"+roll.count))]\n}; {}]\n\n\n\n[h,if(doVBLStamp), CODE:{\n\t\n\t\n\t\n\t[foreach(tok,toks), CODE:{\n\t\t[hasVBL\t= if(json.type(getProperty(\"w42.bot.fgVBL\", tok))==\"ARRAY\",1,0)]\n\t\t[if(hasVBL): \tbot_moveStamp(tok)]\n\t}]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t\n\t[token(json.get(toks,0)):lastPPath = getLastPath(0)]\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\n\t\n\t\n\t\n\t\n\t[Path\t\t= '[]']\n\t[firstPoint = '[]']\n\t[lastPoint\t= '[]']\n\t[foreach(tok, toks), CODE:{\n\t\t[token(tok):lastPPath = getLastPath(0)]\n\t\t\n\t\t[if(!oneStepOnly && doInnerPointsPath): bot_chkMoveStop()]\n\t\t[if(!oneStepOnly): Path = json.union(Path, json.get(lastPPath,1,-2)); Path = \"[]\"]\n\t\t[firstPoint\t= json.union(firstPoint,json.get(lastPPath,0,0))]\n\t\t[lastPoint\t= json.union(lastPoint,\tjson.get(lastPPath,-1,-1))]\n\t}]\n\t[lastPointPadList\t= bot_path2pads(lastPoint)]\n\t\n\t\n\t\n\t[if(doFirstPointPath), CODE:{\n\t\t\n\t\t[firstPointPadList\t\t= bot_path2pads(firstPoint)]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t\n\t\t[pathPadList \t\t\t= bot_path2pads(Path)]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'']\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h:doLinkedPads\t\t\t\t= if(!json.isEmpty(linkedPads),1,0)]\n[h,if(doLinkedPads), CODE:{\n\t[lastLinkId\t\t\t\t= getLibProperty(\"lastLinkId\",\"lib:EventMacros\")]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[actList\t\t\t\t= \"startLinkId=;endLinkId=\"]\n\t[foreach(id, linkedIdList): actList = setStrProp(actList, \"activated\"+id, 0)]\n};{}]\n\n\n\n[h:numToks = listCount(toks)-1]\n[h,foreach(tok, toks), CODE:{\n\t\n\t[h:doAbort\t\t\t\t\t= if(roll.count == numToks, 0,1)]\n\t[h:switchToken(tok)]\n\t[h:lastPath\t\t\t\t\t= eval(\"lastPath\"+roll.count)]\n\t[h:tok\t\t\t\t\t\t= eval(\"tok\"+roll.count)]\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\t[h:startingLocation\t\t\t= eval(\"startingLocation\"+roll.count)]\n\t[h:currentLocation\t\t\t= eval(\"currentLocation\"+roll.count)]\n\t\n\t[h,if(doLinkedPads):varsFromStrProp(actList)]\n\n\t\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks,\"<br>\"):bot_EventArea()]\n\n\t\n\t[h,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[h,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[h,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\n\t\n\t[h, if(eventMacroPostMultipleTokensMove != \"<none>\"), CODE:{[macro(eventMacroPostMultipleTokensMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads)):setLibProperty(\"lastLinkId\", endLinkId, \"lib:EventMacros\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3bdfc979-7e68-4c58-b765-da9d72730fd8",
          "commandChecksum": "0e91037cea8264951b9af9f1e26060a5",
          "propsChecksum": "cc464dac8d7ffb610eaab544a9dcb78f"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 206,
        "label": "deferOnTokenMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'\n\n[h: vars\t\t\t\t= arg(0)]\n[h: varsFromStrProp(vars)]\n[h: switchToken(tok)]\n\n\n[h: varsFromStrProp(arg(1))]\n\n\n[h,if(doGroups && startsWith(token.label,\"group\")), CODE:{\n\t[groupName\t\t\t= token.label]\n\t[startingLocation\t= json.toList(json.get(lastPath,0,0))]\n\t[currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[xDiff\t\t\t\t= json.get(currentLocation, \"x\") - json.get(startingLocation, \"x\")]\n\t[yDiff\t\t\t\t= json.get(currentLocation, \"y\") - json.get(startingLocation, \"y\")]\n\t[tokList\t\t\t= getProperty(\"w42.boT.\"+token.label)]\n\t[foreach(tmpTok,tokList), CODE:{\n\t\t[token(tmpTok), if(findToken(tmpTok) != \"\"):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]\n\t}]\n}]\n\n\n[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]\n\n\n[h,if(doInvisibility):bot_checkInvisibility()]\n\n\n[h,if(doSnap2Grid):bot_snapToGrid(tokId)]\n\n\n[h: doVBLStamp = if(doVBLStamp && json.type(getProperty(\"w42.bot.fgVBL\"))==\"ARRAY\", 1, 0)]\n[h,if(doVBLStamp), CODE:{\n\t\n\t\n\t\n\t[bot_moveStamp(tok)]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n\n[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]\n\n\n[h:'[h,if(1):bot_followMe(tok,lastPath)]']\n\n\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t\n\t\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\t\n\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\t[if(!oneStepOnly && doInnerPointsPath):\tbot_chkMoveStop(); pathPadList = \"\"]\n\t\t\n\t\t[if(oneStepOnly):\tclear = 1 ; clear = 0]\n\n\t\t\n\t[lastPointPadList\t\t= bot_path2pads(json.get(lastPPath,-1,-1))]\n\n\t\n\t\n\t[if(doFirstPointPath), CODE:{\n\t\t\n\t\t[firstPointPadList\t\t= bot_path2pads(json.get(lastPPath,0,0))]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t\n\t\t[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'']\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h,if(!json.isEmpty(linkedPads)), CODE:{\n\t[lastLinkId\t\t\t\t= getLibProperty(\"lastLinkId\",\"lib:EventMacros\")]\n\t[startLinkId\t\t\t= \"\"]\n\t[endLinkId\t\t\t\t= \"\"]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[foreach(id, linkedIdList): set(\"activated\"+id, 0)]\n};{}]\n\n\n[h:resetMove\t\t\t\t\t= 0]\n\t\n\n\t\n\t\n\n\t\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\n\t\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks): bot_EventArea()]\n\t\n\t[r,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[r,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[r,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]\n\t\n\t[h,if(eventMacroPostTokenMove != \"<none>\"), CODE:{[macro(eventMacroPostTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads)):setLibProperty(\"lastLinkId\", endLinkId, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4628c747-d6ba-4475-ba99-3564b647718a",
          "commandChecksum": "0daeb0bb2df2756ce1ac562aa587d4ca",
          "propsChecksum": "e106e606faf763561052ab8f7a577c84"
        }
      },
            {
        "autoExecute": true,
        "color": "silver",
        "fontColor": "red",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 207,
        "label": "deferOnTokenMove TMP",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'\n\n[h: vars\t\t\t\t= arg(0)]\n[h: varsFromStrProp(vars)]\n\n[h: tokId\t= string(getStrProp(vars, \"tokId\"))]\n\n[h: switchToken(tok)]\n\n\n[h: varsFromStrProp(arg(1))]\n\n\n[h,if(doGroups && startsWith(token.label,\"group\")), CODE:{\n\t[groupName\t\t\t= token.label]\n\t[startingLocation\t= json.toList(json.get(lastPath,0,0))]\n\t[currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[xDiff\t\t\t\t= json.get(currentLocation, \"x\") - json.get(startingLocation, \"x\")]\n\t[yDiff\t\t\t\t= json.get(currentLocation, \"y\") - json.get(startingLocation, \"y\")]\n\t[tokList\t\t\t= getProperty(\"w42.boT.\"+token.label)]\n\t[foreach(tmpTok,tokList), CODE:{\n\t\t[token(tmpTok), if(findToken(tmpTok) != \"\"):moveToken(getTokenX()+xDiff, getTokenY()+yDiff)]\n\t}]\n}]\n\n\n[r, if(eventMacroOnTokenMove != \"<none>\"), CODE:{[macro(eventMacroOnTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok)]}; {}]\n\n\n[h,if(doVBLCheck):bot_moveVBLToken(tokId, lastPath)]\n\n\n[h: doVBLStamp = if(doVBLStamp && json.type(getProperty(\"w42.bot.fgVBL\"))==\"ARRAY\", 1, 0)]\n[h,if(doVBLStamp), CODE:{\n\t\n\t\n\t\n\t[bot_moveStamp(tok)]\n\t[if(doResetFoW): exposePCOnlyArea()]\n}; {}]\n\n\n[h,if(doShowPath && isSnapToGrid()):bot_getPath(doShowPath, 1, tok, lastPath)]\n\n\n[h:abort(doSpecialPads)]\n\n[h,if(isAltInit), CODE:{\n\t[mappedCoords \t= getLibProperty(\"mappedCoords\", libCoordName)]\n\t[allCoordsArray\t= getLibProperty(\"allCoordsArray\", libCoordName)]\n\t\n\t[varsFromStrProp(mappedCoords, \"UNSUFFIXED\")]\n\n\t\n\t\n\t[abort(if(listCount(json.fromList(lastPPath))<3,0,1))]\n\t[oneStepOnly = if(listCount(json.fromList(lastPPath))<5,1,0))]\n\t\n\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\t\n\t\t[if(!oneStepOnly && doInnerPointsPath):\tbot_chkMoveStop(); pathPadList = \"\"]\n\t\t\n\t\t[if(oneStepOnly):\tclear = 1 ; clear = 0]\n\n\t\t\n\t[lastPointPadList\t\t= bot_path2pads(json.get(lastPPath,-1,-1))]\n\n\t\n\t\n\t[if(doFirstPointPath), CODE:{\n\t\t\n\t\t[firstPointPadList\t\t= bot_path2pads(json.get(lastPPath,0,0))]\n\t\t[firstPointPadCheckList = \"Canopy, Foliage, Roof, EventPad\"]\n\t\t[padTypeList\t\t\t= replace(firstPointPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= firstPointPadList]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[firstPointPadList\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(firstPointPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): firstPointPadList = listAppend(firstPointPadList, listGet(oldPadList, i))]\n\t}]\n\n\t[if(doInnerPointsPath), CODE:{\n\t\t\n\t\t[if(!clear):pathPadList = bot_path2pads(json.get(lastPPath,1,-2))]\n\t\t[pathPadCheckList\t\t= \"Ward, EventPad, PadJumpBorder, InterJumpBorder, PadStartBorder, PadEndBorder, InterPadBorder\"]\n\t\t[padTypeList\t\t\t= replace(pathPadList, \" [0-9]+\", \"\")]\n\t\t[oldPadList\t\t\t\t= pathPadList]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}; {\n\t\t[padTypeList \t\t\t= \"\"]\n\t\t[pathPadList\t\t\t= \"\"]\n\t}]\n\t[for(i, 0, listCount(padTypeList)), CODE:{\n\t\t[check = listContains(pathPadCheckList, listGet(padTypeList, i))]\n\t\t[if(check): pathPadList = listAppend(pathPadList, listGet(oldPadList, i))]\n\t}]\n}; {\n\t\n\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t[if( json.type(allMapsPads) != 'OBJECT' ), CODE:{\n\t\t[broadcast(\"The pads of this campaign are not initialized yet, doing so now...\")]\n\t\t[bot_initializePads()]\n\t\t[allMapsPads = getLibProperty(\"allMapsPads\", \"lib:EventMacros\")]\n\t}; {}]\n\t[abort(json.contains(allMapsPads,getCurrentMapName()))]\n\t[pathPadList\t\t\t\t= json.get(allMapsPads, getCurrentMapName())]\n\t[firstPointPadList\t\t\t= \"\"]\n\t[lastPointPadList\t\t\t= \"\"]\n}]\n\n[h:'']\n\n\n[h: linkedAreas = getLibProperty(\"linkedAreas\", \"lib:EventMacros\")]\n[h,if(json.contains(linkedAreas, map)), CODE:{\n\t[thisMapLinks\t\t\t= json.get(linkedAreas, map)]\n\t[thisMapAreas\t\t\t= json.get(getLibProperty(\"storedAreas\",\"lib:EventMacros\"),map)]\n\t\n\t[DpC\t\t\t\t\t= json.get(json.get(getInfo(\"map\"),\"grid\"),\"units per cell\")]\n}; {\n\t[thisMapLinks = \"{}\"]\n}]\n\n\n[h:linkedPads\t\t\t\t= json.get(getLibProperty(\"linkedMappedPads\", \"lib:EventMacros\"), getCurrentMapName())]\n[h,if(!json.isEmpty(linkedPads)), CODE:{\n\t\n\t[lastLinkSettings\t\t= getLibProperty(\"lastLinkSettings\",\"lib:EventMacros\")]\n\t[varsFromStrProp(lastLinkSettings)]\n\t[startLinkId\t\t\t= \"\"]\n\t[endLinkId\t\t\t\t= \"\"]\n\t[linkedIdList\t\t\t= json.fields(linkedPads)]\n\t[if(getCurrentMapName() != currentMap), CODE:{\n\t\t\n\t\t[currentMap\t\t\t= getCurrentMapName()]\n\t\t[lastLinkId\t\t\t= \"\"]\n\t\t[lastLinkSettings\t= strPropFromVars(\"currentMap, lastLinkId\",\"UNSUFFIXED\")]\n\t\t[foreach(id, linkedIdList): lastLinkSettings = setStrProp(lastLinkSettings, \"activated\"+id, 0)]\n\t\t\n\t\t[varsFromStrProp(lastLinkSettings)]\n\t\t\n\t\t[strPropList\t\t= listAppend(json.fields(json.fromStrProp(lastLinkSettings)), \"strPropList\")]\n\t\t\n\t\t[lastLinkSettings\t= setStrProp(lastLinkSettings, \"strPropList\", strPropList)]\n\t\t\n\t}]\n\t[foreach(id, linkedIdList): set(\"activated\"+id, 0)]\n\t['pause(\"activated1\", \"activated2\", \"linkedIdList\")']\n};{}]\n\n\n[h:resetMove\t\t\t\t\t= 0]\n\t\n\n\t[h,if(!doTriggerOnZeroMove && json.length(lastPath)==1):abort(0)]\n\n\t\n\t[h:ignoreStartPath\t\t= json.remove(lastPath,0)]\n\t[h,foreach(areaName, thisMapLinks): bot_EventArea()]\n\n\t\n\t[r,foreach(padName, firstPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[r,foreach(padName, pathPadList,\"\"):\t\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[r,foreach(padName, lastPointPadList,\"\"):\teval(\"bot_\"+getGroup(strfind(padName, \"[A-z]+\"), 1,0)+\"()\")]\n\t\n\t[h,if(doCentreOnTok):goto(getTokenX(0), getTokenY(0))]\n\t\n\t[h,if(eventMacroPostTokenMove != \"<none>\"), CODE:{[macro(eventMacroPostTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok)]}; {}]\n\t[h,if(!json.isEmpty(linkedPads) && lastLinkId != endLinkId), CODE:{\n\t\t[lastLinkId\t\t\t= endLinkId]\n\t\t[lastLinkSettings\t= strPropFromVars(strPropList,\"UNSUFFIXED\")]\n\t\t[setLibProperty(\"lastLinkSettings\", lastLinkSettings, \"lib:EventMacros\")]\n\t};{}]\n['pause(\"linkedPads\",\"lastLinkId\",\"startLinkId\",\"endLinkId\",\"lastLinkSettings\",\"strPropList\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cbf67b58-df82-4f77-b9d9-738f07ed4e63",
          "commandChecksum": "c1b9530215d882bee711444798396ab9",
          "propsChecksum": "d6b3b6684708d21e134552bca93232e5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 208,
        "label": "determineTokSize",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(getLibProperty('vblSupport','lib:EventMacros')), CODE:{\n\t\n\t[h:gridSize\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n\t[xtmp\t= getTokenWidth()]\n\t[ytmp\t= getTokenHeight()]\n\n\t\n\t[xSize\t= round(xtmp/gridSize) + 1]\n\t[ySize\t= round(ytmp/gridSize) + 1]\n\n\t[setProperty(\"w42.bot.xSize\", xSize,tok)]\n\t[setProperty(\"w42.bot.ySize\", ySize,tok)]\n};{\n\t\n\t[sizeList = \"Fine=1; Diminutive=1; Tiny=1; Small=1; Medium=1; Large=2; Huge=3; Gargantuan=4; Colossal=6\"]\n\t[xSize = getProperty(\"w42.bot.xSize\",tok)]\n\t[ySize = getProperty(\"w42.bot.ySize\",tok)]\n\n\t\n\t[if(xSize == \"\"): xSize = getProperty(\"w42.mtt.xSize\",tok)]\n\t[if(ySize == \"\"): ySize = getProperty(\"w42.mtt.ySize\",tok)]\n\n\t[size = getSize()]\n\t[if(size == \"\"), CODE:{\n\t\t[abort(input(\n\t\t\t\"xSize|\"+xSize+\"|The size of token: \"+tok+\" is unknown, pls enter the width (from left to right) in number of cells\",\n\t\t\t\"ySize|\"+ySize+\"|The size of token: \"+tok+\" is unknown, pls enter the length (from top to bottom) in number of cells\"\n\t\t))]\t\t\n\t}; {\n\t\t[xSize = getStrProp(sizeList, size, \"\")]\n\t\t[ySize = getStrProp(sizeList, size, \"\")]\n\t}]\n\n\t[setProperty(\"w42.bot.xSize\", xSize,tok)]\n\t[setProperty(\"w42.bot.ySize\", ySize,tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cd5bc413-4491-4265-9eb1-393789d9af91",
          "commandChecksum": "3546c02d35b7ea631ad31b041ecb25ab",
          "propsChecksum": "939db4c3edcdecb5993a02371a417dab"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 209,
        "label": "initializeMap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h,if(argCount() > 0): initialize\t= arg(0) ; initialize = 0]\n\n[h,if(!initialize), CODE:{\n\t[currentMap\t\t\t= getCurrentMapName()]\n\t[padNameList \t\t= getLibProperty(\"padNameList\", \"lib:EventMacros\")]\n\t[numericIdOnly\t\t= getLibProperty(\"numericIdOnly\", \"lib:EventMacros\")]\n\t[doCanopy\t\t\t= 0]\n\t[interPadCheckList\t= \"{}\"]\n\t[txtOutPut\t\t\t= \"<u>Found the following special pads:<br><\/u>\"]\n};{}]\n\n[h:linkedList\t\t= \"\"]\n[h:linkedPadList\t= \"\"]\n[h:padCounter.json\t= '{}']\n[h:tokenList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\n\n[h: libCoordName\t= strformat(\"lib:Coords %{currentMap}\")]\n[h: error\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h,if(error): txtOutPut\t= txtOutPut + \"<font color='red'>Error: <u>\"+libCoordName+\"<\/u> found on map \"+currentMap+\". This means that the alternative initialization method is used for this map and that is NOT compatible with the normal initialization. So either:<br>- remove ALL lib:coords from this map (should only be one), which is usually located at coord 0,0. Or<br>- exclude this map from initialization in the settings --> exclusions --> check: <i>\"+currentMap+\"<br><br><\/i><\/font>\"]\n\n\n[h, foreach(padName, padNameList), CODE:{\n\t[set(\"lst\"+padName, \"\")]\n\t[set(\"lstName\"+padName, \"\")]\n}]\n[h:newList\t\t= \"\"]\n[h:canopyList\t= \"\"]\n\n\n \n\n[h: allTokensJson\t= json.fromList(tokenList)]\n[H: cleanTokenJSON\t= \"[]\"]\n\n\n[H, FOREACH(padName, padNameList), CODE: {\n\t\n\t[tempRegex = '.*\"' + padName + '\\\\s.*']\n\t[IF(matches(allTokensJson, tempRegex)), CODE:{\n\t\t\n\t\t[tempRegex\t\t= '\\\\[(.*?)(\"' + padName + '\\\\s.*)']\n\t\t[tempJSON\t\t= replace(json.sort(allTokensJson, \"a\"), tempRegex, '[\\$2')]\n\t\t\n\t\t[tempJSON\t\t= replace(json.sort(tempJSON, \"d\"), tempRegex, '[\\$2')]\n\t\t\n\t\t[cleanTokenJSON\t= json.sort(json.merge(cleanTokenJSON, tempJSON),\"a\")]\n['pause(\"tempJSON\",\"cleanTokenJSON\",\"allTokensJson\", \"PadName\", \"padnamelist\")']\n\t};{}]\n}]\n\n[h:'pause(\"cleanTokenJSON\")']\n[h:tokenList\t= json.toList(cleanTokenJSON)]\n\n[h:numToks\t\t= listCount(tokenList)]\n[h:assert(numToks <= 1000, \"Fatal error: The number (\"+numToks+\") of special pads on map (\"+currentMap+\") is more than 1000. This tool can handle upto 1000 special pads. Please remove \"+(numToks - 1000)+\" pads from \" + currentMap,0)]\n\n[h,foreach(token,tokenList,\"\"), CODE:{\n\t[pos\t= indexOf(token, \" \")]\n\n\t\n\t[assert(findToken(token) != \"\", strformat(\"Error (Process aborted): could not find token <u>%{token}<\/u> on the current map. This might happens when you e.g. create a token with a reserverd name as partial string. For example '<b>The<\/b> Roof 1', will result in a token list with 'Roof 1' which does not exist, or when you accidentily use trailing spaces ' ', e.g. 'Roof 1 '. So check the map for this and correct it.\"),0)]\n\t\n\t[isPad\t= 0]\n\t[if(pos != -1), CODE:{\n\t\t[padName\t= substring(token, 0, pos)]\n\t\t[padId\t\t= substring(token, pos)]\n\t\t\n\t\t[isPad\t\t= if((isNumber(padId) || !numericIdOnly) && listContains(padNameList, padName),1,0)]\n\t}; {\n\t\t\n\t\t[padName\t= \"\"]\n\t}]\n\t\n\t[if(isPad && startsWith(padName, \"Linked\")), CODE:{\n\t\t\n\t\t\n\t\t\n\t\t[regId\t\t= strfind(token, \"[^\\\\s]+\")]\n\t\t[nPieces\t= getFindCount(regId)]\n\t\t[error\t\t= if(nPieces != 4, 1, 0)]\n\t\t[if(error): txtOutPut\t= txtOutPut + \"<font color='red'>Error: <u>\"+token+\"<\/u> found on map \"+currentMap+\" is incorrectly named. A linked pad should ALWAYS consist out of 4 pieces 'Linked ID PadTyp ID', e.g. 'Linked 1 Canopy 2'. This name consists out of \"+nPieces+\" pieces.<br><\/font>\"]\n\t\t[if(error): PadType\t\t= padName ; PadType = getGroup(regId, 3, 0)]\n\t\t[if(error): isPad\t\t= 0]\n\n\t\t\n\t\t[if(!error): linkedList \t= listAppend(linkedList, getGroup(regId, 2, 0))]\n\t\t[if(!error): linkedPadList\t= listAppend(linkedPadList, token)]\n\t}; {\n\t\t[PadType\t= padName]\n\t}]\n\n\t\t\n['pause(\"pos\",\"padName\",\"isPad\",\"padNameList\",\"padName\",\"padId\")']\n\t[if(isPad), CODE:{\n\t\t\n\t\t[tmpNum\t\t= padId]\n\t\t[tmpLst\t\t= eval(\"lst\"+padName)]\n\t\t[tmpLstName\t= eval(\"lstName\"+padName)]\n\t\t\n\t\t[if(listContains(tmpLst, tmpNum)): error = 1]\n\t\t[if(listContains(tmpLst, tmpNum)): txtOutPut = txtOutPut + \"<font color='red'>Error: duplicate <u>\"+padName+\" \"+tmpNum+\"<\/u> found on map \"+currentMap+\"<br><\/font>\"]\n\t\t\n\t\t\n\t\t[set(\"lst\"+padName, listAppend(tmpLst, tmpNum))]\n\t\t[set(\"lstName\"+padName, listAppend(tmpLstName, token))]\n\t}; {}]\n\t\n\t[if(isPad && startsWith(padName, \"Inter\")), CODE:{\n\t\t\n\t\t[if(bot_inStr(token, \"Drop\")): fullPadName = replace(token,\"Drop\",\"Jump\"); fullPadName \t= token]\n\t\t\n\t\t[bot_checkInterPads()]\n\t\t[if(json.contains(interPadCheckList, fullPadName)):\t\n\t\t\tinterPadCheckList = json.set(interPadCheckList, fullPadName, json.set(json.get(interPadCheckList, fullPadName), \"map2\", currentMap))\n\t\t; \n\t\tinterPadCheckList = json.set(interPadCheckList, fullPadName, json.set('{}', \"map1\", currentMap))\n\t\t]\n\t}; {}]\n\n\t[if(isPad && (padType == \"Canopy\") && doCanopy), CODE:{\n\t\t\n\t\t\n\t\t[treeTrunkkAssetID = listGet(treeTrunkImages, roll(1,numTrunkImages) - 1)]\n\t\t[token(token): handout = getTokenHandout()]\n\t\t[token(token), if(handout == \"\"): setTokenHandout(treeTrunkkAssetID); canopyList = listAppend(canopyList, tmpNum)]\n\t}]\n\n\t[if(isPad && padName == \"Roof\"), CODE:{\n\t\t\n\t\t[if(isSnapToGrid(token)): error = 1]\n\t\t[if(isSnapToGrid(token)): txtOutPut = txtOutPut + \"<font color='red'>Error: <u>\"+padName+\" \"+tmpNum+\"<\/u> found on map \"+currentMap+\" is snapped to grid. Make certain its unsnapped<br><\/font>\"]\n\t}]\n['pause(\"cleanTokenJSON\",\"padNameList\", \"padName\", \"token\", \"tokenList\", \"isPad\", \"tmpLstName\")']\n}]\n\n[h, if(listCount(canopyList)): txtOutPut = txtOutPut + \"The following Canopy Pads already had an image in the Token Handout Section. No (new) trunk image has been set for <b><u>Canopy<\/u><\/b> : \"+canopyList+\"<br>\"]\n\n\n[h:result = \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{currentMap}", "%s", "3", "0", "0"]'>%s<\/a>\"]\n[h, foreach(padName, padNameList,\"\"), CODE:{\n\t\n\t[tmpLst = listSort(eval(\"lst\"+padName),\"N+\")]\n\t\n\t[tmpLstName = listSort(eval(\"lstName\"+padName),\"N+\")]\n\t\n\t[if(tmpLst != \"\"), CODE:{\n\t\t[txtOutPut = txtOutPut + \"<b>\"+padName+\"<\/b>: \"]\n\t\t[tmpURLList = \"\"]\n\t\t[foreach(pad, tmpLst): tmpURLList\t= listAppend(tmpURLList, strformat(result, padName + \" \" + pad, pad))]\n\t\t[txtOutPut = txtOutPut + tmpURLList + \"<br>\"]\n\t};{}]\n\t\n\t\n\t[isDrop = if(startsWith(padName,\"PadDrop\") || startsWith(padName, \"InterDrop\"), 1, 0)]\n\t[if(!isDrop):padCounter.json = json.set(padCounter.json, padName, tmpLstName)]\n['pause(\"padNameList\", \"padName\", \"padCounter.json\", \"tmpLstName\")']\n}]\n\n\n[h:startPads= eval(\"lstPadStart\")]\n[h:endPads\t= eval(\"lstPadEnd\")]\n[h:numStart\t= listCount(startPads)]\n[h:numEnd\t= listCount(endPads)]\n\n[h, if(numStart != numEnd), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadStart(\"+numStart+\")<\/b> and <b>PadEnd(\"+numEnd+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, startPads), CODE:{\n\t\t[exists = findToken(\"PadEnd \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadStart \"+pad+\"<\/b> does not have a <b>PadEnd \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, endPads), CODE:{\n\t\t[exists = findToken(\"PadStart \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadEnd \"+pad+\"<\/b> does not have a <b>PadStart \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n\n[h:startPadBorders\t= eval(\"lstPadStartBorder\")]\n[h:endPadBorders\t= eval(\"lstPadEndBorder\")]\n[h:numStartBorder\t= listCount(startPadBorders)]\n[h:numEndBorder\t\t= listCount(endPadBorders)]\n\n[h, if(numStart != numEnd), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadStartBorder(\"+numStartBorder+\")<\/b> and <b>PadEndBorder(\"+numEndBorder+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, startPadBorders), CODE:{\n\t\t[exists = findToken(\"PadEndBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadStartBorder \"+pad+\"<\/b> does not have a <b>PadEndBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, endPadBorders), CODE:{\n\t\t[exists = findToken(\"PadStartBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadEndBorder \"+pad+\"<\/b> does not have a <b>PadStartBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n\n[h:jumpPads\t= eval(\"lstPadJump\")]\n[h:dropPads\t= eval(\"lstPadDrop\")]\n[h:numJump\t= listCount(jumpPads)]\n[h:numDrop\t= listCount(dropPads)]\n\n[h, if(numJump != numDrop), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadJump(\"+numJump+\")<\/b> and <b>PadDrop(\"+numDrop+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, jumpPads), CODE:{\n\t\t[exists = findToken(\"PadDrop \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadJump \"+pad+\"<\/b> does not have a <b>PadDrop \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, dropPads), CODE:{\n\t\t[exists = findToken(\"PadJump \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadDrop \"+pad+\"<\/b> does not have a <b>PadJump \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n[h:jumpBorderPads\t= eval(\"lstPadJumpBorder\")]\n[h:dropBorderPads\t= eval(\"lstPadDropBorder\")]\n[h:numJumpBorder\t= listCount(jumpBorderPads)]\n[h:numDropBorder\t= listCount(dropBorderPads)]\n\n[h, if(numJumpBorder != numDropBorder), CODE:{\n\t [error = 1]\n\t [txtOutPut = txtOutPut + \"<font color='red'>Error: there are an unequal amount of <b>PadJumpBorder(\"+numJumpBorder+\")<\/b> and <b>PadDropBorder(\"+numDropBorder+\")<\/b> tokens found on map \"+currentMap+\"<br><\/font>\"]\n}; {\n\t[foreach(pad, JumpBorderPads), CODE:{\n\t\t[exists = findToken(\"PadDropBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadJumpBorder \"+pad+\"<\/b> does not have a <b>PadDropBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n\t[foreach(pad, DropBorderPads), CODE:{\n\t\t[exists = findToken(\"PadJumpBorder \" + pad)]\n\t\t[if(!exists): error = 1]\n\t\t[if(!exists): txtOutPut = txtOutPut + \"<font color='red'>Error: <b>PadDropBorder \"+pad+\"<\/b> does not have a <b>PadJumpBorder \"+pad+\"<\/b> on map \"+currentMap+\"<br><\/font>\"]\n\t}]\n}]\n\n\n[h:linkedJson\t\t= '{}']\n\n[h:allLinksList\t= json.get(padCounter.json, \"Linked\")]\n[h,if(listCount(linkedList)), CODE:{\n\t[foreach(linkId, linkedList), CODE:{\n\t\t[regex\t\t= strformat(\"(?i)([^,]*(Linked %{linkId})[^,]*)\")]\n\t\t[resultList\t= \"\"]\n\t\t[id\t\t\t= strfind(allLinksList, regex)]\n\t\t[numFound\t= getFindCount(id)]\n\t\t[count(numFound):\tresultList\t= listAppend(resultList, getGroup(id, roll.count+1, 0))]\n\t\t[linkedJson\t= json.set(linkedJson, linkId, resultList)]\n\t}]\n};{}]\n\n\n[h,if(initialize):newMapsPads\t\t= json.set(newMapsPads, currentMap, padCounter.json)]\n\n\n[h,if(initialize):linkedMappedPads\t= json.set(linkedMappedPads, currentMap, linkedJson)]\n\n[h:'pause(\"newMapsPads\",\"padCounter.json\")']\n[h, if(error): txtOutPut = txtOutPut + \"Error detected, please fix first, else errors will occur on this map (\"+currentMap+\") will work<br>\"; \"No errors detected, pads have been initialized<br>\"]\n\n[h,if(!initialize), CODE:{\n\t\n\t[frame(\"Special Tokens on \"+currentMap, \"width=300; height=400; temporary=1\"): {\n\t\t<html>\n\t\t\t<head>\n\t\t\t<\/head>\n\t\t\t<body>\n\t\t\t\t<form action='[r:macroLinkText(\"initializeMap@Lib:OnTokenMove\", \"none\")]' method=\"json\">\n\t\t\t\t[r:txtOutPut]\n\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Refresh\"\t>\n\t\t\t<\/form>\n\t\t\t<\/body>\n\t\t<\/html>\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "Show overview of special pads on map",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad8a11a5-4d1c-46be-88c4-2b3f3e7037ad",
          "commandChecksum": "7f7f058f7f4f7a209b1202d297f3be86",
          "propsChecksum": "76243143890fa766c0dddda751b72e8f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 210,
        "label": "initializePads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h, if(argCount()):passResult = arg(0); passResult = 0]\n[h:mapList\t\t\t= getAllMapNames(\"json\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:'']\n[h:padNameList \t\t= getLibProperty(\"padNameList\", \"lib:EventMacros\")]\n[h:newMapsPads\t\t= '{}']\n[h:allMappedPads\t= '{}']\n[h:linkedMappedPads\t= '{}']\n\n[h:setLibProperty(\"lastLinkSettings\", \"currentMap=;lastLinkId=\", \"lib:EventMacros\")]\n[h:txtOutput\t\t= \"<b><u><font color='red'>INITIALIZE PADS<\/font><\/u><\/b><br><br>\"]\n[h:interPadCheckList= \"{}\"]\n[h:treeTrunkImages\t= getLibProperty(\"treeTrunkImages\", \"lib:EventMacros\")]\n[h:numTrunkImages\t= listCount(treeTrunkImages)]\n[h:doCanopy\t\t\t= 0]\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:numericIdOnly\t= getLibProperty(\"numericIdOnly\", \"lib:EventMacros\")]\n\n\n[h:toggles\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:tmpList\t\t\t= json.toList(mapList)]\n[h, if(listContains(tmpList, baseMapName)), CODE:{\n\t[h, if(numTrunkImages), CODE:{\n\t\t[txtOutput\t= txtOutput  + \"'Trunk' images have been found and are initialized<br>\"] \n\t\t[doCanopy\t= 1]\n\t}; {\n\t\t[txtOutput\t= txtOutput  + \"<font color='red'><b>No 'Trunk' images have been set (Run 'Choose Trunks' do so), so 'Canopy Tokens' will not be initialized!<\/b><\/font><br>\"]\n\t}]\n}; {\n\t[txtOutput\t= txtOutput  + \"<b><font color='red'>No map called \"+ baseMapName +\" found, so 'Canopy Tokens' will not be initialized! Also the Token Buttons (door switches) wont work correctly (you can set the correct name in the settings.)<\/b><\/font><br>\"]\n}]\n\n[h:'']\n[h:excludedMaps\t= getLibProperty(\"excludedMaps\", \"lib:EventMacros\")]\n[h:txtOutput\t= txtOutput  + \"The following maps will not be initialized (see settings): <b><u>\"+json.toList(excludedMaps)+\"<\/b><\/u><br><br>\"]\t\n[H:activeMaps\t= json.difference(mapList,excludedMaps)]\n\n[H,foreach(currentMap,activeMaps), CODE:{\n\n\t[setCurrentMap(currentMap)]\n\t[txtOutput\t\t= txtOutput  + \"<b><u>\"+currentMap+\"<\/b><\/u.<br>\"]\t\n\t[bot_initializeMap(1)]\n\t\n\t\n\t[allMappedPads\t= json.set(allMappedPads, currentMap, lstMappedPad)]\n\t[txtOutput\t\t= txtOutput  + \"<br>\"]\t\n\t\n\t\n\t[h:linkedList\t= json.toList(json.unique(json.fromList(linkedList)))]\n\t\n\t\n\t[h,foreach(tok,tokenList,\"\"), CODE:{\n\t\t[resetProperty(\"w42.bot.linked\",\t\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedBridge\",\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedTunnel\",\ttok)]\n\t\t[resetProperty(\"w42.bot.linkedSpecial\",\ttok)]\n\t''\n\t}]\n\t\n\t\n\t\n\t[h,foreach(linkId, linkedList), CODE:{\n\t\t[linkedAll\t\t= \"\"]\n\t\t[linkedBridge\t= \"\"]\n\t\t[linkedTunnel\t= \"\"]\n\t\t[linkedSpecial\t= \"\"]\n\t\t\n\t\t[foreach(pad, linkedPadList), if(startsWith(pad, \"Linked \"+linkId)), CODE:{\n\t\t\t[linkedAll\t\t= listAppend(linkedAll, pad)]\n\t\t\t[if(bot_inStr(pad, \"Bridge\")):\tlinkedBridge\t= listAppend(linkedBridge, pad)]\n\t\t\t[if(bot_inStr(pad, \"Tunnel\")):\tlinkedTunnel\t= listAppend(linkedTunnel, pad)]\n\t\t\t\n\t\t\t[PadType\t= getGroup(strfind(pad, \"[^\\\\s]+\"), 3, 0)]\n\t\t\t[if(listContains(\"roof, canopy, foliage\", PadType)):\tlinkedSpecial\t= listAppend(linkedSpecial, pad)]\n\t\t''\n\t\t};{}]\n\t\t[set(\"linkedAll\"\t\t+ linkId, linkedAll)]\n\t\t[set(\"linkedBridge\"\t\t+ linkId, linkedBridge)]\n\t\t[set(\"linkedTunnel\"\t\t+ linkId, linkedTunnel)]\n\t\t[set(\"linkedSpecial\"\t+ linkId, linkedSpecial)]\n\t''\n\t}]\n\t\n\t[h,foreach(linkId, linkedList), CODE:{\n\t\t[linkedAll\t\t= eval(\"linkedAll\"\t\t+linkId)]\n\t\t[linkedBridge\t= eval(\"linkedBridge\"\t+linkId)]\n\t\t[linkedTunnel\t= eval(\"linkedTunnel\"\t+linkId)]\n\t\t[linkedSpecial\t= eval(\"linkedSpecial\"\t+linkId)]\n\t\t\n\t\t[foreach(pad, linkedPadList), if(startsWith(pad, \"Linked \"+linkId)), CODE:{\n\t\t\t[setProperty(\"w42.bot.linked\",\t\t\tlinkedAll, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedBridge\",\tlinkedBridge, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedTunnel\",\tlinkedTunnel, pad)]\n\t\t\t[setProperty(\"w42.bot.linkedSpecial\",\tlinkedSpecial, pad)]\n\t\t''\n\t\t};{}]\n\t''\n\t}]\n''\n}]\n\n[h:'']\n[h, foreach(pad, interPadCheckList), CODE:{\n\t[padMaps\t\t= json.get(interPadCheckList, pad)]\n\t[if(json.contains(padMaps, \"map1\")), CODE:{\n\t\t[map1\t\t= 1]\n\t\t[mapName1 = json.get(padMaps, \"map1\")]\n\t''\n\t};{[map1\t\t= 0][error\t= 1]}]\n\n\t[if(json.contains(padMaps, \"map2\")), CODE:{\n\t\t[map2\t\t= 1]\n\t\t[mapName2\t= json.get(padMaps, \"map2\")]\n\t''\n\t};{[map2\t\t= 0][error\t= 1]}]\n['if(!map1 || !map2):pause(\"map1\",\"map2\",\"pad\",\"interPadCheckList\",\"mapName1\",\"mapName2\", \"padMaps\")']\n\t[if(!map1): txtOutPut\t= txtOutPut + \"<font color='red'>Error: found only one <u>\"+pad+\"<\/u> on map \" + mapName2 + \"<br><\/font>\"]\n\t[if(!map2): txtOutPut\t= txtOutPut + \"<font color='red'>Error: found only one <u>\"+pad+\"<\/u> on map \" + mapName1 + \"<br><\/font>\"]\n\n\t[if(map1 && map2 && doSwitchInterMap == 2), CODE:{\n\t\t[if(startsWith(pad, \"InterJump\")): pad = replace(pad, \"Jump\", \"Drop\")]\n\t\t\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[x1\t= getTokenX(0,pad)]\n\t\t\t[y1\t= getTokenY(0,pad)]\n\t\t\t\n\t\t\t[wX\t= getTokenWidth(pad)]\n\t\t\t[w1\t= bot_ppc2GridCoord(wX)]\n\t\t\t[h1\t= bot_ppc2GridCoord(getTokenHeight(pad))]\n\t\t''\n\t\t};{[x1=0][y1=0][w1=0][h1=0] }]\n\n\t\t[setCurrentMap(mapName2)]\n\t\t[if(startsWith(pad, \"InterDrop\")): pad = replace(pad, \"Drop\", \"Jump\")]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[setProperty(\"w42.bot.pairedMap\", mapName1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadX\", x1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadY\", y1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadW\", w1, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadH\", h1, pad)]\n\t\t\t[x2\t= getTokenX(0,pad)]\n\t\t\t[y2\t= getTokenY(0,pad)]\n\t\t\t[w2\t= bot_ppc2GridCoord(getTokenWidth(pad))]\n\t\t\t[h2\t= bot_ppc2GridCoord(getTokenHeight(pad))]\n\t\t''\n\t\t};{[x2=0][y2=0][w2=0][h2=0] }]\n\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"), CODE:{\n\t\t\t[setProperty(\"w42.bot.pairedMap\", mapName2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadX\", x2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadY\", y2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadW\", w2, pad)]\n\t\t\t[setProperty(\"w42.bot.otherPadH\", h2, pad)]\n\t\t''\n\t\t};{}]\n\t''\n\t};{}]\n\t\n\t[if(map1 && map2 && doSwitchInterMap != 2), CODE:{\n\t\t[setCurrentMap(mapName1)]\n\t\t[if(findToken(pad) != \"\"):setProperty(\"w42.bot.pairedMap\", mapName2, pad)]\n\t\t[setCurrentMap(mapName2)]\n\t\t[if(findToken(pad) != \"\"):setProperty(\"w42.bot.pairedMap\", mapName1, pad)]\n\t''\n\t};{}]\n}]\n\n[h:'']\n\n[h,FOREACH(mapJSON, allMappedPads), CODE:{\n\t[setCurrentMap(mapJSON)]\n\t[lstMapped\t= json.get(allMappedPads, mapJSON)]\n\t\n\t[inputStr\t= \"[]\"]\n\t[inputStr\t= json.append(inputStr,\"junk|<html><b>Map the pads for map: \"+mapJSON+\"<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t= json.append(inputStr,\"junk|<html><b>enter numbers or dicerolls only!!<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[foreach(iMap, lstMapped), CODE:{\n\t\t[MappedPad\t= getProperty(\"w42.bot.MappedPad\", \"MappedPad \"+iMap)]\n\t\t[inputStr\t= json.append(inputStr, \"MappedPad\"+iMap+\"|\"+MappedPad+\"|Link MappedPad \"+iMap+\" to which other MappedPad\")]\n\t}]\n\t[if(lstMapped != \"\"):hasInput = abort(input(json.toList(inputStr,\"##\")))]\n\t\n\t[foreach(iMap, lstMapped):\tsetProperty(\"w42.bot.MappedPad\", eval(\"MappedPad\"+iMap), \"MappedPad \"+iMap)]\n}]\n[h:'']\n[h:setCurrentMap(oldMap)]\n\n[h:'']\n[h:'']\n[h:oldMapsPads\t= newMapsPads]\n[h,FOREACH(mapJSONKey, oldMapsPads), CODE:{\n\t[pathPadList\t= \"\"]\n\t[mapJSON\t\t= json.get(oldMapsPads, mapJSONKey)]\n\t[foreach(padType, padNameList), CODE:{\n\t\t[tmpList\t= json.get(mapJSON, padType)]\n\t\t[if(tmpList != \"\"): pathPadList\t= listAppend(pathPadList, tmpList)]\n\t}]\n\t[newMapsPads\t= json.set(newMapsPads, mapJSONKey, pathPadList)]\n}]\n[h:'pause(\"newMapsPads\",\"oldMapsPads\")']\n[h:'']\n[h, if(passResult), CODE:{\n\t[macro.return = newMapsPads]\n};{\n\t[setLibProperty(\"allMapsPads\", newMapsPads,\"lib:EventMacros\")]\n\t[setLibProperty(\"allMapsPadsJson\", oldMapsPads,\"lib:EventMacros\")]\n\t[setLibProperty(\"linkedMappedPads\", linkedMappedPads,\"lib:EventMacros\")]\n}]\n\n[r,if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Initialization result\",\"input=1\")\t:{[r:txtOutPut]}]\n};{\n\t[r,frame(\"Initialization result\")\t\t\t\t:{[r:txtOutPut]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "42c92fef-1d24-4957-9544-388ae86b8515",
          "commandChecksum": "c8d693e0a97d56a871e98255f6a251af",
          "propsChecksum": "0c59fbe53de45203f4ba6411878960ba"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "15",
        "includeLabel": false,
        "sortBy": "15",
        "index": 211,
        "label": "moveVBLToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[H: id = arg(0)]\n[H: path = arg(1)]\n[H: switchToken(id)]\n[H: pathLength = json.length(path)]\n[H: hasVision = if(isPC(),1,0)]\n\n\n[H: tokenSizes = json.append(\"\",\"Medium\",\"Large\",\"Huge\",\"Gargantuan\",\"FreeSize\",\"Colossal\")]\n[H: tokenSizeMod = max(1,json.indexOf(tokenSizes,getSize(id))+1)]\n[H: gridSize = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]\n[H: sizeInPixels = gridSize * tokenSizeMod]\n[H: offset = round(sizeInPixels/2)]\n\n\n[H: firstPosition = json.get(path,0)]\n[H: x = json.get(firstPosition,\"x\")]\n[H: y = json.get(firstPosition,\"y\")]\n[H: moveToken(x,y,1,id)]\n\n\n[H: clearSoftFog = doResetFoW]\n\n\n[H: canSee = 1]\n[H: counter = 0]\n[H: movementStopped = -1]\n[H, while(canSee && movementStopped), code: {\n   [H, if(counter < pathLength): next = json.get(path,counter)]\n   [H: x = json.get(next,\"x\")]\n   [H: y = json.get(next,\"y\")]\n   [H: canSee = isVisible(x+offset,y+offset)]\n   [H, if(canSee), code: {\n      [H: moveToken(x,y,1,id)]\n      [H, if(hasVision): exposeFOW()]\n   }; {\n      [H, if(counter < pathLength): movementStopped = counter]\n   }]\n   [H, if(counter >= pathLength): canSee = 0]\n   [H: counter = counter + 1]\n}]\n\n\n[H: tport = 0]\n[H: hasInput = 0]\n[H, if(isGM() && movementStopped >= 0 && isPC()): hasInput = input(\n\tstrformat(\"header|<html><font size=+3><b>%s<\/b><\/font><\/html> %s||LABEL|SPAN=TRUE ICON=TRUE\",getName(),getTokenImage()),\n\tstrformat(\"tip|<html><HR /><font size=+2 color=blue><b>    Movement was stopped at step %{movementStopped}    <\/b><\/font><HR /><BR /><\/html>||LABEL|SPAN=TRUE\"),\n\t\"tport|<html><font size=+1 color=red><b>NO<\/b><\/font>                              <\/html>,<html><font size=+1 color=green><b>YES<\/b><\/font><\/html>|<html><font size=+1><b>T-port to final position?<\/b><\/html>|RADIO|ORIENT=H SELECT=1\",\n\tstrformat(\"clearSoftFog|<html><font size=+1 color=red><b>NO<\/b><\/font>                              <\/html>,<html><font size=+1 color=green><b>YES<\/b><\/font><\/html>|<html><font size=+1><b>Clear Soft Fog on T-port?<\/b><\/html>|RADIO|ORIENT=H SELECT=%{clearSoftFog}\")\n)]\n[H, if(tport && hasInput && isPC()), code: {\n   [H: lastPosition = json.get(path,pathLength-1)]\n   [H: x = json.get(lastPosition,\"x\")]\n   [H: y = json.get(lastPosition,\"y\")]\n   [H: moveToken(x,y,1,id)]\n   [H, if(hasVision), code: {\n      [H, if(clearSoftFog): exposePCOnlyArea(); exposeFOW()]\n   }; {}]\n}; {\n    [H, if(isNPC() && isGM()), code: {\n      \n      [H: lastPosition = json.get(path,pathLength-1)]\n      [H: x = json.get(lastPosition,\"x\")]\n      [H: y = json.get(lastPosition,\"y\")]\n      [H: moveToken(x,y,1,id)]\n   }; {}]\n   [H, if(clearSoftFog && isPC() && hasVision): exposePCOnlyArea()]\n}]\n\n[H, if(movementStopped != -1 && ! isGM()): broadcast(\"<b>Movement stopped by VBL.  Try using [spacebar] to set way points.  You can not clip corners.<\/b>\")]\n\n\n[H: z = eval(\"0\"+getProperty(\"elevation\"))]\n\n[H: drawOrder = (y + offset) * 1000 + (x + offset) - (tokenSizeMod -1) * gridSize + floor(z/5) * gridSize]\n[H: setTokenDrawOrder(drawOrder,id)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8c480d74-94d4-422d-aa99-c4123c826dc8",
          "commandChecksum": "d64190e35ffbec77a295f5a7e51e5399",
          "propsChecksum": "be41fe8f6ecc8dd20152992cd5b06357"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 212,
        "label": "onMultipleTokensMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h: toks \t\t\t\t= macro.args]\n[h: tok\t\t\t\t\t= getName(json.get(toks, 0))]\n\n[h:'']\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:'']\n[h, if(eventMacroPreTokenMove != \"<none>\"), CODE:{[macro(eventMacroPreTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, getLastpath(0), getLastpath(1))]}; {}]\n\n[h:'']\n[h,if(doLockMovement), CODE:{\n\t[tmpToks\t= \"[]\"]\n\t[foreach(id, toks), CODE:{\n\t\t[token(id),if(getProperty(\"w42.bot.lockMovement\", id)==1): moveToken(json.get(json.get(getLastPath(), 0),\"x\"), json.get(json.get(getLastPath(), 0),\"y\"))]\n\t\t[if(getProperty(\"w42.bot.lockMovement\", id)!=1):tmpToks\t= json.append(tmpToks, id)]\n\t}]\n\t[toks\t= tmpToks]\n};{}]\n\n[h:'']\n[h: abort(!listContains(excludePropertyTypes, getPropertyType(tok)))]\n\n[h:'']\n[h: map\t\t\t\t\t= getCurrentMapName()]\n[h: libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h: isAltInit\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h: doAbort\t\t\t\t= 0]\n\n[h:'']\n[h: arguments \t\t\t= strPropFromVars(\"toks,map,libCoordName,isAltInit,doAbort\",\"UNSUFFIXED\")]\n[h,foreach(tok, toks, \"\"), CODE:{\n\t[h: switchToken(tok)]\n\t[h: lastPath \t\t= getLastPath(1)]\n\t[h: startingLocation= json.toList(json.get(lastPath,0,0))]\n\t[h: currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[h:\tusedMove\t\t= getMoveCount()]\n\n\t[h: set(\"tok\"\t\t\t\t+roll.count, getName(tok))]\n\t[h: set(\"lastPath\"\t\t\t+roll.count, lastPath)]\n\t[h: set(\"startingLocation\"\t+roll.count, startingLocation)]\n\t[h: set(\"currentLocation\"\t+roll.count, currentLocation)]\n\t[h: set(\"usedMove\"\t\t\t+roll.count, usedMove)]\n\n\t\n\t[h:lastPPath\t\t= getLastPath(0)]\n\t\n\t[h, if(isAltInit): \n\t\tset(\"lastPPath\"\t\t\t+roll.count, getLastPath(0))\n\t; \n\t\tset(\"lastPPath\"\t\t\t+roll.count, \"[]\")\n\t]\n\n\t[h: tmpStrprop\t\t= strPropFromVars(strformat(\"tok%{roll.count}, lastPath%{roll.count}, startingLocation%{roll.count}, currentLocation%{roll.count}, usedMove%{roll.count}, lastPPath\"), \"UNSUFFIXED\")]\n\t[h: arguments\t\t= listAppend(arguments, tmpStrProp, \"; \")]\n\t[h:'']\n\t[h,if(limitMovement !=0):bot_limitMovement()]\n}]\n[h:'']\n[H, if(doVBLCheck): tokens.denyMove = 1]\n[h, if(movementLock && !isGM() || doAbort), CODE:{\n\t[tokens.denyMove\t= 1]\n\t[if(!doAbort): broadcast(\"<b>Movement is locked by GM.<\/b>\")]\n}; {\n\t\n\t[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]\n\t[link\t\t\t\t= macroLinkText(\"deferOnMultipleTokensMove@\"+getMacroLocation(),\"none\",json.append(\"\",arguments,toggles))]\n\t[execLink(link,1)]\n\n\t\n\t[if(eventMacroOnMultipleTokensMove != \"<none>\"), CODE:{[macro(eventMacroOnMultipleTokensMove+\"@Lib:EventMacros\"): json.append(\"\", toks, lastPPath, lastPath)]}; {}]\n\n\n\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2e5134e9-bc82-4860-bb1f-3dad38b9ca53",
          "commandChecksum": "18370bdd5927a91b4b0c63f8f2d19e04",
          "propsChecksum": "d0245645a3c8abf393f1829c80f2abf6"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "yellow",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 213,
        "label": "onTokenMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h,if (tokens.moveCount > 1): abort(0)]\n\n[h: tokId\t\t\t\t\t= getSelected()]\n[h:'']\n[h:toggles\t\t\t\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:varsFromStrProp(toggles)]\n\n[h:'']\n[h, if(eventMacroPreTokenMove != \"<none>\"), CODE:{[macro(eventMacroPreTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tokId, getLastpath(0), getLastpath(1))]}; {}]\n\n\n[h:'']\n[h,if(doLockMovement && getProperty(\"w42.bot.lockMovement\")==1), CODE:{\n\t[moveToken(json.get(json.get(getLastPath(), 0),\"x\"), json.get(json.get(getLastPath(), 0),\"y\"))]\n\t[abort(0)]\n};{}]\n\n[h:'']\n[h, if(drawArea), CODE:{\n\t[token(tokId):area\t= getLastPath(1)]\n\t\n\t[area\t\t\t= json.get(area, 0,-2)]\n\t[area\t\t\t= json.unique(area)]\n\n\t\n\t[tmpDraWArea\t= getLibProperty(\"tmpDraWArea\", \"lib:EventMacros\")]\n\t[area\t\t\t= json.difference(area, tmpDrawArea)]\n\t\n\t[setLibProperty(\"tmpDraWArea\", json.union(area, tmpDrawArea), \"lib:EventMacros\")]\n\n\t[layer\t\t\t= getLayer(tokId)]\n\t[areaToken\t\t= getLibProperty(\"drawTokenName\", \"lib:EventMacros\")]\n\t[drawTokenMap\t= getLibProperty(\"drawTokenMap\", \"lib:EventMacros\")]\n\t[drawTokenName\t= getLibProperty(\"drawTokenName\", \"lib:EventMacros\")]\n\t\n\t[assert(!json.isEmpty(area), \"that area contains no coordinates\",0)]\n\t\n\t[h:broadcast(\"Area coordinates are: \"+json.indent(area,2))]\n\n\t\n\t\n\t[splices\t\t\t= bot_createSplices(area)]\n\t\n\t[foreach(splice, splices, \"\"), CODE:{\n\t\t[foreach(coord, splice, \"\"): lastCopy = copyToken(drawTokenName, 1, drawTokenMap, json.set(coord,\"useDistance\", 1, \"layer\", layer))]\n\t}]\n\t\n\t[abort(0)]\n}]\n\n[h:'']\n[h: abort(!listContains(excludePropertyTypes, getPropertyType(tokId)))]\n\n[h:'']\n[h: map\t\t\t\t\t= getCurrentMapName()]\n[h: libCoordName\t\t= strformat(\"lib:Coords %{map}\")]\n[h: isAltInit\t\t\t= if(findToken(libCoordName) == \"\",0,1)]\n[h: doAbort\t\t\t\t= 0]\n\n\t[h: lastPath\t\t= getLastPath(1)]\n\t[h: startingLocation= json.toList(json.get(lastPath,0,0))]\n\t[h: currentLocation\t= json.toList(json.get(lastPath,-1,-1))]\n\t[h:\tusedMove\t\t= getMoveCount()]\n\n\t[h, if(isAltInit): lastPPath = getLastPath(0); lastPPath = \"[]\"]\n\n\t[h:'']\n\t[h,if(limitMovement != 0):bot_limitMovement()]\n\n[h:'']\n[H, if(doVBLCheck): tokens.denyMove = 1]\n[h, if(movementLock && !isGM() || doAbort), CODE:{\n\t[tokens.denyMove \t= 1]\n\t[if(!doAbort): broadcast(\"<b>Movement is locked by GM.<\/b>\")]\n}; {\n\t\n\t[if(doResetFoW && !doVBLCheck):exposePCOnlyArea()]\n\t[tok\t\t\t\t= getName(tokId)]\n\t[link\t\t\t\t= macroLinkText(\"deferOnTokenMove@\"+getMacroLocation(),\"none\",json.append(\"\",strPropFromVars(\"tok,tokId,map,libCoordName,lastPath,isAltInit,lastPPath,usedMove,doAbort,startingLocation,currentLocation\",\"UNSUFFIXED\"),toggles))]\n\t[execLink(link,1)]\n\n\t\n\t[if(eventMacroOnTokenMove != \"<none>\"), CODE:{[macro(eventMacroOnTokenMove+\"@Lib:EventMacros\"): json.append(\"\", tok, lastPPath, lastPath)]}; {}]\n\n\n\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0fec22af-e717-439f-8419-c693262ee5f5",
          "commandChecksum": "d6bf3b65d6f9b7ddca294438d6277a9b",
          "propsChecksum": "a517373358f9585f9a097a774d927c38"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 214,
        "label": "path2pads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:'']\n[h:lastPathJson\t\t= replace(arg(0), '-', '_')]\n[h:lastPathJson\t\t= replace(lastPathJson, '\\\\{\"x\":(.*?),\"y\":(.*?)\\\\}', '\"X\\$1Y\\$2\"') ] \n\n\n[h:pathIntersect\t= json.intersection(allCoordsArray, lastPathJson)]\n\n[h:'']\n[h:pathResult\t\t= replace(pathIntersect, \t\t'\"(.*?)\"', '[r:\\$1]')] \n[h:pathResult\t\t= replace(pathResult,\t\t\t'\\\\[\\\\[(.*?)\\\\]\\\\]', '[\"[\\$1]\"]')] \n\n\n[h:pathResult\t\t= json.evaluate(pathResult)]\n[h:pathResult\t\t= replace(pathResult,\t\t',', '\",\"')]\n[h:macro.return\t\t= json.toList(json.unique(pathResult))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2c91c4b7-39a0-43d4-99e6-23347a5bd8c5",
          "commandChecksum": "dd939accea8690eef9754b53b6d68a4b",
          "propsChecksum": "9fd9e744106df294c492e33fa24389b5"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 215,
        "label": "animateMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h, if(argCount()>0):me\t\t\t\t= arg(0); me\t\t\t= getSelected()]\n[h:assert(listCount(me)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(me)]\n[h, if(argCount()>3):relative\t\t= arg(3); relative\t\t= 0]\n[h, if(argCount()>4):stopOnImpact\t= arg(4); stopOnImpact\t= 0]\n[h, if(argCount()>5):layer\t\t\t= arg(5); layer\t\t\t= '[\"token\",\"object\"]']\n[h, if(argCount()>6):vbl\t\t\t= arg(6); vbl\t\t\t= 0]\n[h, if(argCount()>7):delay\t\t\t= arg(7); delay\t\t\t= 0]\n[h, if(argCount()>8):distance\t\t= arg(8); distance\t\t= 0][h:'']\n[h, if(argCount()>9):runMacro\t\t= arg(9); runMacro\t\t= 0] \n[h, if(argCount()>10):runMacroFinal\t= arg(10); runMacroFinal= 0] \n[h, if(argCount()>11):dr\t\t\t= arg(11); dr\t\t\t= 0] \n[h, if(argCount()>12):rStep\t\t\t= arg(12); rStep\t\t= 5] \n[h, if(argCount()>13):dStep\t\t\t= arg(13); dStep\t\t= 0] \n[h, if(argCount()>14):snap2Grid\t\t= arg(14); snap2Grid\t= 0] \n\n[h:'']\n[h, if(runMacro == \"\"):\t\t\trunMacro\t\t= 0]\n[h, if(runMacroFinal == \"\"):\trunMacroFinal\t= 0]\n\n[h, if(argCount()>2), CODE:{\n\t\n\t[x1  = if(relative, arg(1) + getTokenX(dStep), arg(1))]\t  \n\t[y1  = if(relative, arg(2) + getTokenY(dStep), arg(2))]\t  \n}; {\n\t[abort(input(\t\n\t\t\t\t\t\"junk|<html><b>You have the following options, the Token travels:<br>- to the given coords (relative unchecked; distance=0)<br>- the relative distance (relative checked; distance=0)<br>- in the direction of the exact coords to distance=n (relative unchecked)<br>- in the direction of the relative coords to distance=n (relative checked)<br><\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\t\t\"x1|0|<html><b>X<\/b> New coordinate of token (in grid coords if D-stepsize=0, else in pixel coords)\",\n\t\t\t\t\t\"y1|0|<html><b>Y<\/b> New coordinate of token (dito X)\",\n\t\t\t\t\t\"dStep|0|<html><b>D-Stepsize<\/b> 0=step per cell, >0=per that many pixels\",\n\t\t\t\t\t\"dr|180|<html><b>R<\/b> Degrees it rotates\",\n\t\t\t\t\t\"rStep|5|<html><b>R-Stepsize<\/b> Degrees per step (the higher the faster)\",\n\t\t\t\t\t\"distance|0|<html><b>Distance<\/b> the token travels\",\n\t\t\t\t\t\"relative|1|<html><b>Relative<\/b> to current position|CHECK\",\n\t\t\t\t\t\"snap2Grid|0|<html><b>Snap token<\/b> to grid when done|CHECK\",\n\t\t\t\t\t\"stopOnImpact|Bounce, Continue, Stop|What should it do when it hits something|RADIO|SELECT=1\",\n\t\t\t\t\t\"delay|0|Set delay per step\",\n\t\t\t\t\t\"junk|<html><b>Which layers should be checked for bounce or stop on impact?<\/b><br><i>Note that checking the four 'Token' layers can slow the animation<br>down considerably<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\t\t\"Token|0|Token Layer|CHECK\",\n\t\t\t\t\t\"Hidden|0|Hidden Layer|CHECK\",\n\t\t\t\t\t\"Object|0|Object Layer|CHECK\",\n\t\t\t\t\t\"Background|0|Background Layer|CHECK\",\n\t\t\t\t\t\"vbl|1|Vision Blocking Layer (Token MUST have vision!!)|CHECK\"\n\t))]\n\t[stopOnImpact\t= stopOnImpact - 1]\n\t[layer \t\t\t= \"[]\"]\n\t[if(Token):\t\t\tlayer = json.append(layer, \"Token\")]\n\t[if(Hidden):\t\tlayer = json.append(layer, \"Hidden\")]\n\t[if(Object):\t\tlayer = json.append(layer, \"Object\")]\n\t[if(Background):\tlayer = json.append(layer, \"Background\")]\n\n\t[if(relative), CODE:{\n\t\t[x1  = x1 + getTokenX(dStep))]\t  \n\t\t[y1  = y1 + getTokenY(dStep))]\t  \n\t}; {}]\n}]\n\n[h:x0\t\t= getTokenX(dStep)]\t  \n[h:y0\t\t= getTokenY(dStep)]\n[h:r0\t\t= bot_getTokenFacing(me, 1)]\n[h:dx\t\t= abs(x1 - x0)]\n[h:dy\t\t= abs(y1 - y0)]\n[h:x\t\t= x0]\n[h:y\t\t= y0]\n[h:r\t\t= r0]\n[h:n \t\t= if(!distance, 1 + dx + dy, 0)]\n[h:xInc\t\t= if(x1 > x0, max(1, dStep - 1), -max(1, dStep - 1))]\n[h:yInc\t\t= if(y1 > y0, max(1, dStep - 1), -max(1, dStep - 1))]\n[h:error\t= dx - dy]\n[h:dx\t\t= 2 * dx]\n[h:dy\t\t= 2 * dy]\n[h:direction= \"\"]\n[h:lastDiag\t= 0]\n[h:steps\t= 0]\n[h,if(dr && !rStep): dr = 0]\n\n[h:check = if(dx < dy, \"X\", \"Y\")]\n[h:'']\n[h:lastTime = 0]\n[h:gridSize = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]\n\n[h:'']\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:initiator\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:oldOwners \t\t\t= isOwnedByAll()]\n[h,if(oldOwners): oldOwners = json.fromList(onlinePlayers); oldOwners = json.fromList(getOwners())]\n\n[h,if(animationPerClient), CODE:{\n\t[otherPlayers = listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]\n\t[setOwner(initiator, me)]\n\t[setOwnerOnlyVisible(1, me)]\n}; {\n\t[otherPlayers = \"\"]\n}]\n[h:mainMe = \"\"]\n\n[h:args = strPropFromVars(\"me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, dStep, rStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid\", \"UNSUFFIXED\")]\n\n[h,macro('deferAnimateMove@'+getMacroLocation()): args]\n\n[h:mainMe = me]\n[h,foreach(user, otherPlayers), CODE:{\n\t[me\t\t= getName(copyToken(mainMe))]\n\t[setOwnerOnlyVisible(1, me)]\n\t[setOwner(user, me)]\n\t[args\t= strformat(argString)]\t\n\t[broadcast(macroLink(\"<color='white'>\", 'deferAnimateMove@'+getMacroLocation(), 'none', args,user))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8e5524da-849c-4060-a14f-c68d0e595cd6",
          "commandChecksum": "13310e47394e79ed43afd0bb579cdf4c",
          "propsChecksum": "be5da3debb17a71ec0be7c588cfd3a7b"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 216,
        "label": "animateText",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:numArgs = argCount()]\n[h:assert(numArgs, \"This function requires at least one parameter:<br>animateText <i>(text[, title, position, html-header, width, height, delay, upper])\",0)]\n\n[h:'']\n[h:txt \t\t\t\t\t\t\t= arg(0)]\n[h:lastCharPos = length(txt)-1]\n\n[h:'']\n[h, if(numArgs > 1): title\t\t= arg(1); title\t\t= \"Message\"] \n\n[h:'']\n[h, if(numArgs > 2): position\t= arg(2); position\t= 0]\n[h:position = min(lastCharPos, position)]\n\n[h:'']\n[h, if(numArgs > 3): html\t\t= arg(3); html\t\t= \"<html><head><\/head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>\"]\n[h, if(html == \"Default\"): html = \"<html><head><\/head><body text='#00CC00' style='font-family:Courier' bgcolor = 'black'><table padding=3><font face='Courier'>\"]\n\n[h:'']\n[h, if(numArgs > 4): width\t\t= arg(4); width\t\t= 640]\n[h, if(numArgs > 5): height\t\t= arg(5); height\t= 480]\n\n[h:'']\n[h, if(numArgs > 6): delay\t\t= arg(6); delay\t\t= 15]\n\n[h:'']\n[h, if(numArgs > 7): upper\t\t= arg(7); upper\t\t= 0]\n\n[h,if(upper): txt = upper(txt)]\n\n[h:output\t= html + substring(txt, position, position+1)]\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(title, \"width=\"+width+\"; height=\"+height+\"; temporary=1; input=1\"): {[r:output]}]\n};{\n\t[frame(title, \"width=\"+width+\"; height=\"+height+\"; temporary=1\"): {[r:output]}]\n}]\n\n[H:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h:ok=0]\n[h,while (!ok), CODE:{\n\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[if(currentTime+delay < newTime):ok=1]\n}]\n\n[h:position = min(lastCharPos, position + 1)]\n\n[h:varList = \"title, html, txt, position, delay\"]\n[h:args = strPropFromVars(varList, \"UNSUFFIXED\")]\n\n[h:link = macroLinkText(\"deferAnimateText@\"+getMacroLocation(),\"none\",args)]\n[h:execLink(link,1)]\n\n\n[h:initiator\t\t\t= getPlayerName()]\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:otherPlayers\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, initiator))]\n[h,foreach(user, otherPlayers), CODE:{\n\t[broadcast(macroLink(\"<color='white'>\", 'deferAnimateText@'+getMacroLocation(), 'none', args,user))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa3c9d3b-b079-4623-a08f-1b371755ee10",
          "commandChecksum": "a1b8665e1491bc52ceafb6cf69019aeb",
          "propsChecksum": "26523bcb4e41ed85249d666f4de7dadf"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 217,
        "label": "animateTextInput",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:lastSettings\t= getLibProperty(\"lastAnimatedTextSettings\", \"lib:EventMacros\")]\n[h:varsFromStrProp(lastSettings)]\n\n[h:abort(input(\n\tstrformat(\"Animated text|text=%{text}; title=%{title}; html=%{html}||PROPS|SPAN=TRUE SETVARS=UNSUFFIXED\"), \n\t\"position|\"+position+\"|Start position of animation\", \n\t\"width|\"+width+\"|Width of the frame\", \n\t\"height|\"+height+\"|Heigth of the frame\", \n\t\"delay|\"+delay+\"|Delay per character (in ms)\", \n\t\"upper|\"+upper+\"|Print text in upper class?|CHECK\")\n)]\n\n[h:bot_animateText(text, title, position, html, width, height, delay, upper)]\n\n[h:varList \t\t= \"text, title, position, html, width, height, delay, upper\"]\n[h:lastSettings = strPropFromVars(varList, \"UNSUFFIXED\")]\n[h:setLibProperty(\"lastAnimatedTextSettings\", lastSettings, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5e2a9114-2566-403a-8d06-adf9ac0315c8",
          "commandChecksum": "92a3e8b6a4a83fb82ff7bb232ac4b07f",
          "propsChecksum": "abe03ec42ac501b30ddc4b10e58a7e5f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 218,
        "label": "defOwners",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:varsFromStrProp(macro.args)]\n[h:setOwnerOnlyVisible(0, mainMe)]\n[h:setOwner(oldOwners, mainMe)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "10c3ff6f-1651-432c-b324-9f9daadeaf82",
          "commandChecksum": "3ae2d73f00c6507e90674326f7bb6fb5",
          "propsChecksum": "ebb926d0bb6771ff127545e808013217"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 219,
        "label": "deferAnimateMove",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:abort(1)]\n[h:varsFromStrProp(macro.args)]\n[h:switchToken(me)]\n[h:setHasSight(1)]\n[h:xMove = 0]\n[h:yMove = 0]\n[h:'broadcast(macro.args)']\n\n\n[h,if(direction != check), CODE:{\n\t\n\t\n\t\n\t\n\t[xB \t\t\t= 0]\n\t[yB \t\t\t= 0]\n\t[cB \t\t\t= 0]\n\t[blockType\t\t= \"\"]\n\n\t\n\t\n\t\n\t[if(stopOnImpact), CODE:{\n\t\t[if(vbl), CODE:{\n\t\t\t\n\t\t\t[if(xInc > 0):\txOffset = gridSize*1.5*xInc); xOffset = gridSize*0.5*xInc)]\n\t\t\t[if(yInc > 0):\tyOffset = gridSize*1.5*yInc); yOffset = gridSize*0.5*yInc)]\n\t\t\t[if(dx): \t\txB\t\t= if(isVisible( getTokenX(1) + xOffset, getTokenY(1)\t\t\t), 0,1)]\n\t\t\t[if(dy): \t\tyB\t\t= if(isVisible( getTokenX(1), \t\t\tgetTokenY(1) + yOffset\t), 0,1)]\n\t\t\t[if(dx && dy):\tcB\t\t= if(isVisible( getTokenX(1) + xOffset,\tgetTokenY(1) + yOffset\t), 0,1)]\n\t\t''\n\t\t}]\n\t\t\n\t\t[if(!json.isEmpty(layer)), CODE:{\n\t\t\t\n\t\t\t[if(dx && !xB): \t\txB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':0}]}}\")))]\n\t\t\t[if(dy && !yB): \t\tyB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':0,'y':%{yInc}}]}}\")))]\n\t\t\t[if(dx && dy && !cB):\tcB\t= listCount(getTokens(\",\", strformat(\"{'layer':%{layer},'area':{'token':'%{me}','offsets':[{'x':%{xInc},'y':%{yInc}}]}}\")))]\n\t\t''\n\t\t}]\n\n\t\t[if(xB || yB || cB), CODE:{\n\t\t\t\n\t\t\t\n\t\t\t[if(xB && !yB):blockType\t= \"x\"]\n\t\t\t[if(yb && !xB):blockType\t= \"y\"]\n\t\t\t[if((cB&&!xB&&!yB)||(!cB&&xB&&yB)||(cB&&xB&&yB)):blockType = \"c\"]\n\n\t\t\t\n\t\t\t[if(stopOnImpact > 0 && blockType != \"\"), CODE:{\n\t\t\t\t[abort(0)]\n\t\t\t''\n\t\t\t};{\n\t\t\t\t\n\t\t\t\t[if(blockType == 'x' || blockType == 'c'), CODE:{\n\t\t\t\t\t[xInc = -xInc]\n\t\t\t\t\t[x = x + 2*xInc]\n\t\t\t\t''\n\t\t\t\t}]\n\t\t\t\t[if(blockType == 'y' || blockType == 'c'), CODE:{\n\t\t\t\t\t[yInc = -yInc]\n\t\t\t\t\t[y = y + 2*yInc]\n\t\t\t\t''\n\t\t\t\t}]\n\t\t\t''\n\t\t\t}]\n\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t\n\t\n\t\n\t\n\t\n\t\n\t[xMove = x - getTokenX(dStep)]\n\t[yMove = y - getTokenY(dStep)]\n\t[h, if((xMove || yMove) && n > 0), CODE:{\n\t\t\n\t\t[if(!lastTime):lastTime = json.get(getInfo(\"client\"),\"timeInMs\") - 2*delay]\n\t\t[continue = if(json.get(getInfo(\"client\"),\"timeInMs\") < (lastTime + delay),0,1)]\n\t\t[while(!continue): continue = if(json.get(getInfo(\"client\"),\"timeInMs\") < (lastTime + delay),0,1)]\n\n\t\t\n\t\t\n\t\t[moveToken(x,y,dStep)]\n\t\t\n\t\t[lastTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t\t\n\t\t[steps = steps + max(1, dStep - 1)]\n\t''\n\t}]\n''\n};{\n\t\n\t[if(lastDiag): steps = steps + max(1, dStep - 1)]\n\t[lastDiag = 1- lastDiag]\n''\n}]\n\n\t\n\t\n\t\n[h, if(dr > 0), CODE:{\n\t['pause(\"rStep\", \"r\", \"dr\")']\n\t[dr\t= dr - rStep]\n\t[r\t= r + rStep + if(dr<0, dr,0)]\n\t[bot_setTokenFacing(r, me, 1)]\n\t[if(dr<0):dr=0]\n};{\n\t[if(dr < 0), CODE:{\n\t\t[dr\t= dr + rStep]\n\t\t[r\t= r - rStep - if(dr>0, dr,0)]\n\t\t[bot_setTokenFacing(r, me, 1)]\n\t\t[if(dr>0):dr=0]\n\t\t['pause(\"rStep\", \"r\", \"dr\")']\n\t}]\n}]\n\n\n\n\n[h,if(error>0), CODE:{\n\t[x\t\t\t= x+xInc]\n\t[error\t\t= error-dy]\n\t[direction\t= \"X\"]\n}; {\n\t[y\t\t\t= y+yInc]\n\t[error\t\t= error+dx]\n\t[direction\t= \"Y\"]\n}]\n\n\n[h,if((runMacro != 0 && runMacro != \"\") && (xMove || yMove)): evalMacro(strformat(runMacro))]\n\n[h:n = n - max(1, dStep - 1)]\n[h,if(n > 0 || steps < distance || dr != 0), CODE:{\n\t\n\t\n\t\n\t[args = strPropFromVars(\"me, mainMe, initiator, oldOwners, n, x, y, r, dx, dy, dr, rStep, dStep, xInc, yinc, steps, distance, lastDiag, check, direction, error, stopOnImpact, layer, vbl, gridSize, delay, runMacro, runMacroFinal, lastTime, snap2Grid\", \"UNSUFFIXED\")]\n\t[link = macroLinkText(\"deferAnimateMove@\"+getMacroLocation(),\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t\n\t\n\t\n\t[if(mainMe != \"\"), CODE:{\n\t\t[args = strformat(\"mainMe = %{mainMe}; oldOwners = %{oldOwners}\")]\n\t\t\n\t\t[broadcast(macroLink(\"<color='white'>\", 'defOwners@'+getMacroLocation(), 'none', args, initiator))]\n\t\t[removeToken(me)]\n\t};{\n\t\t\n\t\t[if(snap2Grid): bot_snapToGrid(me)]\n\t}]\n\t[if((runMacroFinal != 0)): evalMacro(strformat(runMacroFinal))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8847edcf-17dc-42a7-adec-29551ee950a4",
          "commandChecksum": "830db253adf72e57b5f5d33e53245d50",
          "propsChecksum": "3bb682a1f7fa93031d5f057102850ecd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 220,
        "label": "deferAnimateText",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[debug = 0]\n\n[h:varsFromStrProp(macro.args)]\n\n[h,if(debug), CODE:{\n\t[args\t= macro.args]\n\t[bot_debugInfo(\"position, txt, args\",0)]\n};{}]\n\n[h,if(position <= length(txt)), CODE:{\n\t[h:output\t= html + substring(txt, 0, position)]\n\n\t[if(bot_isFullScreen()), CODE:{\n\t\t[dialog(title, \"width=215; height=460; temporary=0; input=1\"): {\n\t\t\t[r:output]\n\t\t[h:'']\n\t\t}]\n\t''\n\t};{\n\t\t[frame(title, \"width=215; height=460; temporary=0\"): {\n\t\t\t[r:output]\n\t\t[h:'']\n\t\t}]\n\t''\n\t}]\n\t\n\t[h:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[h:ok=0]\n\t[h,while (!ok), CODE:{\n\t\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t\t[if(currentTime+delay < newTime):ok=1]\n\t''\n\t}]\n\n\t[h:position = position + 1]\n\t\n\t[h:varList = \"title, html, txt, position, delay\"]\n\t[h:args = strPropFromVars(varList, \"UNSUFFIXED\")]\n\t\n\t[link = macroLinkText(\"deferAnimateText@\"+getMacroLocation(),\"none\",args)]\n\t[execLink(link,1)]\n''\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "492f3770-1b5d-4b6e-b529-173d766f92eb",
          "commandChecksum": "be53ce01384cbd3fd1ba366f342470db",
          "propsChecksum": "36554a8101681314e350e4f760f41c4f"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 221,
        "label": "delay",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:delay = arg(0)]\n[H:currentTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h:ok=0]\n[h,while (!ok), CODE:{\n\t[newTime = json.get(getInfo(\"client\"),\"timeInMs\")]\n\t[if(currentTime+delay < newTime):ok=1]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "62fea4fc-2172-4e74-a8fd-fd5a6a66ff1f",
          "commandChecksum": "1a991236c8dcbfbed805437b7b90f276",
          "propsChecksum": "2791e1f7b25a388bd67f1654201192bd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "7a. Event Area Macros",
        "index": 222,
        "label": "assignArea",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n[h:macroList\t\t= getMacros(\",\",\"lib:EventMacros\")]\n[h:setCurrentMap(oldMap)]\n[h:assert(macroList != \"\",\"First create at least one macro on the lib:EventMacro token with which this event area can be associated\",0)]\n\n\n[h:storedAreas\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n[h:assert(!json.isEmpty(storedAreas), \"No areas have been defined\", 0)]\n[h:linkedAreas\t\t= getLibProperty(\"linkedAreas\", \"Lib:EventMacros\")]\n[h:mapNames\t\t\t= json.fields(storedAreas)]\n[h:macroList\t\t= listAppend(\"<None>\", macroList)]\n\n\n[h, if(json.type(linkedAreas) == \"UNKNOWN\"): linkedAreas = \"{}\"]\n\n[h:triggerTypeList\t= \"movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain\"]\n\n\n[h:tabNr\t\t= 0]\n[h:inputStr\t\t= \"\"]\n\n[h,foreach(mapName, mapNames), CODE: {\n\t\n\t[inputStr \t= json.append(inputStr, 'tab'+tabNr+' |'+mapName+'|| TAB')]\n\t[inputStr\t= json.append(inputStr, 'junk|<html><b>LINK EVENT MACRO TO AN EVENT AREA<\/b><br><\/html><\/span><\/html>|-|LABEL|SPAN=TRUE')]\n\n\t[if(json.contains(linkedAreas, mapName)): \t\t\t\tthisMapLinks\t= json.get(linkedAreas, mapName)\t\t\t ; thisMapLinks = \"{}\"]\n\t[if(json.contains(linkedAreas, mapName+\".W42.Limit\")):\tthisMapLimits\t= json.get(linkedAreas, mapName+\".W42.Limit\") ; thisMapLimits = \"{}\"]\n\n\t[areaList\t= json.fields(json.get(storedAreas, mapName))]\n\t[listLength = listCount(areaList)-1]\n\t[i = 0]\n\t[foreach(area, areaList), CODE:{\n\t\t[if(json.type(thisMapLinks) == \"OBJECT\"):\t\tstrPropVars = json.get(thisMapLinks, area); strPropVars = \"\"]\n\t\t\n\t\t[if(strPropVars != \"\"):\t\t\t\t\t\tvarsFromStrProp(strPropVars)]\n\t\t[if(strPropVars != \"\"):\t\t\t\t\t\toldSelection = listFind(macroList, eventMacro) ; oldSelection = 0]\n\t\t[if(json.type(thisMapLimits) == \"OBJECT\"):\toldSelection = max(oldSelection,listFind(macroList, json.get(thisMapLimits, area)))\t\t\t\t\t]\n\t\t[inputStr \t= json.append(inputStr, 'assignedArea_'+tabNr+'_'+i+'|'+macroList+'|<html><span title=\"<html>When you move over a predefined Area you can have a certain<br>macro (event) triggered. Here you can link an Event Macro to<br>the predefined areas. The areas are sorted per map (in tabs).<br><br>Note that <i>Limit Movement<\/i> is a special and reserved<br>macro that is run BEFORE the pads are checked and based on<br>this outcome (and whether its turned on) the path of the<br>token is shortened to the maximum allowed steps.<br><br><b>Therefore the Event Triggers will be IGNORED for LIMIT MOVEMENT<\/b><br><br>You can turn <i>Limit Movement<\/i> on in the settings.<\/html>\"><b><font color=#FF0000>'+area+'<\/b><\/font><\/html><\/span><\/html>|LIST|SELECT='+oldSelection+' VALUE=STRING')]\n\n\t\t[varsFromStrProp(\"movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0\")]\n\t\t[if(strPropVars == \"\"):\teventTriggerList = \"\"]\n\t\t[foreach(event, eventTriggerList): set(event, 1)]\n\t\t\n\t\t[inputStr \t= json.append(inputStr, 'junk|<html><i>Which actions trigger this event area (all events are mutual exclusive):<\/i><\/html>|-|LABEL|SPAN=TRUE')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOn_'+tabNr+'_'+i+'|'\t\t+movedOn+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves onto this area<\/b>.<\/html>\">Token moves onto area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOff_'+tabNr+'_'+i+'|'\t+movedOff+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>leaves this area.<\/html>\">Token moves off area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedOver_'+tabNr+'_'+i+'|'\t+movedOver+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves over this area.<\/html>\">Token moves over area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedNot_'+tabNr+'_'+i+'|'\t+movedNot+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>on this area is moved<br>from and back to the same postion on this area<br>without using waypoints.<\/b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.<\/html>\">Token does zero move on area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedReturn_'+tabNr+'_'+i+'|'\t+movedReturn+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>moves off this area<br>and back onto it, using waypoints.<\/html>\">Token leaves and returns onto area<\/html><\/span><\/html>|CHECK')]\n\t\t[inputStr \t= json.append(inputStr, 'movedRemain_'+tabNr+'_'+i+'|'\t+movedRemain+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this area,<br>will be triggered when a token <b>is moved but remains<br>on the area the entire move.<\/html>\">Token moves but remains on area<\/html><\/span><\/html>|CHECK')]\n\t\t[if(i < listLength):inputStr \t= json.append(inputStr, 'junk|<html>_____________________________________________________<\/html>|-|LABEL|SPAN=TRUE')]\n\t\t[i = i + 1]\n\t}]\n\t[tabNr\t\t= tabNr +1]\n}]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[h:linkedAreas = \"{}\"]\n[h:tabNr = 0]\n[h,foreach(mapName, mapNames), CODE: {\n\t[areaList\t\t= json.fields(json.get(storedAreas, mapName))]\n\t[thisMapLinks\t= \"{}\"]\n\t[thisMapLimits\t= \"{}\"]\n\t[i = 0]\n\t[foreach(area, areaList), CODE:{\n\t\t[eventMacro = eval(\"assignedArea_\"+tabNr+\"_\"+i)]\n\t\t[if(eventMacro == \"Limit Movement\"): thisMapLimits\t= json.set(thisMapLimits, area, eventMacro)]\n\n\t\t[eventTriggerList = \"\"]\n\t\t[foreach(trigger, triggerTypeList), if(eval(trigger+'_'+tabNr+'_'+i)): eventTriggerList = listAppend(eventTriggerList, trigger)]\n\t\t\n\t\t[if(eventMacro != \"Limit Movement\"): thisMapLinks = json.set(thisMapLinks, area, strPropFromVars(\"eventMacro, eventTriggerList\",\"UNSUFFIXED\"))]\n\t\t[i = i + 1]\n\t}]\n\t[linkedAreas\t= json.set(linkedAreas, mapName, thisMapLinks, mapName+\".W42.Limit\", thisMapLimits)]\n\t[tabNr\t\t\t= tabNr + 1]\n}]\n\n[h:setLibProperty(\"linkedAreas\", linkedAreas, \"Lib:EventMacros\")]\n[h:broadcast(\"The Event links have been created\")]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can link predefined Areas to Event Macros and to the Limit Movement macro<br>The Event Macro will be triggered when a token moves over the Area. The handling of this is left<br>to the macro itself",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8a47e022-ed47-41c6-8df5-ff43376a9dd6",
          "commandChecksum": "f6fae60fe20f97f8033c5fbc701ef525",
          "propsChecksum": "af9564a9e9682605f96ac2213e9345c9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 227,
        "label": "assignPads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"))]\n[h:assPads\t\t= listSort(getTokenNames(\",\",conditions),\"A+\")]\n[h:allPads\t\t= \"\"]\n[h:padTypeList\t= \"\"]\n[h:padType\t\t= \"\"]\n[h:lstPads\t\t= \"\"]\n\n[h,foreach(tok,assPads),CODE:{\n\t[if(startsWith(tok, \"AssignedPad \")), CODE:{\n\t\t\n\t\t[allPads\t= listAppend(allPads, tok)]\n\t\t\n\t\t[hasPadType\t= if(getFindCount(strfind(tok, \"\\\\s\"))==2, 1,0)]\n\t\t\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(tok, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t\n\t\t[padName\t= trim(getGroup(strfind(tok,\"^.*?(\\\\w+)\\\\Z\"),1,1))]\n\t\t\n\t\t[newType\t= if(hasPadType && !listContains(padTypeList, padType), 1,0)]\n\t\t\n\t\t[if(newType): padTypeList = listAppend(padTypeList, padType)]\n\n\t\t\n\t\t[if(padType == \"\")\t\t\t\t: lstPads = listAppend(lstPads, padName)]\n\n\t\t\n\t\t[if(newType)\t\t\t\t\t: set(\"lstPad\"+padType, padName)]\n\t\t[if(padType != \"\" && !newType)\t: set(\"lstPad\"+padType, listAppend(eval(\"lstPad\"+padType), padName))]\n['pause(\"assPads\", \"tok\", \"padType\", \"padName\", \"newType\", \"lstPad\"+padType, \"lstPads\")']\n\t}; {}] \n}]\n[h:assert(listCount(allPads), \"No AssignedPads found on map\", 0)]\n\n\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\"))]\n[h:tokens\t\t= getTokenNames(\",\",conditions)]\n[h:tokList\t\t= \"<none>\"]\n\n[h,foreach(tok,tokens),CODE:{\n\t[if(!startsWith(tok, \"AssignedPad \")): tokList = listAppend(tokList, tok)]\n}]\n[h:tokList = listSort(tokList, \"A+\")]\n\n[h:assert(listCount(tokList), \"No tokens found on map\", 0)]\n\n\n[h:tabNr = 0]\n[h,if(listCount(padTypeList)), CODE: {\n\t[inputStr = \"\"]\n\t\n\t[h,if(listCount(lstPads)), CODE:{\n\t\t\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |Ungrouped|| TAB\", \"##\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Assign the tokens to the pads<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"##\")]\n\t\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|\"+tokList+\"|\"+pad+\" |LIST|SELECT=\"+listFind(tokList, getProperty(\"w42.bot.linkedToken\", \"AssignedPad \"+pad))+\" VALUE=STRING\", \"##\")]\n\t}; {}]\n\t\n\t\n\t[h,foreach(padType, padTypeList), CODE:{\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |\"+padType+\"|| TAB\", \"##\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Assign the tokens to the pads<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"##\")]\n\n\t\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t\t[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+padType+\"_\"+pad+\"|\"+tokList+\"|\"+pad+\" |LIST|SELECT=\"+listFind(tokList, getProperty(\"w42.bot.linkedToken\", \"AssignedPad \"+padType+\" \"+pad))+\" VALUE=STRING\", \"##\")]\n\t}]\n}; {\n\t\n\t[inputStr\t\t\t= \"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\", \"##\")]\n}]\n\n\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \", \", \"##\")]\n[H: abort(eval(inputStr))]\n\n\n[h, foreach(pad, lstPads): setProperty(\"w42.bot.linkedToken\", eval(\"AssignedPad_\"+pad), \"AssignedPad \"+pad )]\n[h,foreach(padType, padTypeList), CODE:{\n\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t[foreach(pad, lstGroupPads): setProperty(\"w42.bot.linkedToken\", eval(\"AssignedPad_\"+padType+\"_\"+pad), \"AssignedPad \"+padType+\" \"+pad )]\n}]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can assign token that are on the TOKEN or HIDDEN layer to Assignpads.<br>Tokens assigned to Assignpads will be moved onto their assigned pad when you run Execute<br>Assignpads<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "22b2b443-39ac-4704-a767-dbc020512e50",
          "commandChecksum": "936151c60ac1d4f7036ba8bde9497e38",
          "propsChecksum": "5e1423054382484c6573475dd45a5fcb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 228,
        "label": "execAssignPads",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n\n[h,if(argCount()):\t\texecAll\t= arg(0); execAll = 0]\n[h,if(argCount() > 1):\tgroup\t= arg(1); group = \"\"]\n\n[h:conditions\t= json.set(\"{}\", \"layer\", json.append(\"[]\", \"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"))]\n[h:assPads\t\t= listSort(getTokenNames(\",\",conditions),\"A+\")]\n[h:allPads\t\t= \"\"]\n[h:padTypeList\t= \"\"]\n[h:padType\t\t= \"\"]\n[h:lstPads\t\t= \"\"]\n\n\n[h,foreach(tok,assPads),CODE:{\n\t[linkedToken = getProperty(\"w42.bot.linkedToken\", tok)]\n\t[if(startsWith(tok, \"AssignedPad \") &&  linkedToken != \"<none>\" && linkedToken != \"\"), CODE:{\n\t\t\n\t\t[allPads\t= listAppend(allPads, tok)]\n\t\t\n\t\t[hasPadType\t= if(getFindCount(strfind(tok, \"\\\\s\"))==2, 1,0)]\n\t\t\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(tok, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t\n\t\t[padName\t= trim(getGroup(strfind(tok,\"^.*?(\\\\w+)\\\\Z\"),1,1))]\n\t\t\n\t\t[newType\t= if(hasPadType && !listContains(padTypeList, padType), 1,0)]\n\t\t\n\t\t[if(newType): padTypeList = listAppend(padTypeList, padType)]\n\n\t\t\n\t\t[if(padType == \"\")\t\t\t\t: lstPads = listAppend(lstPads, padName)]\n\n\t\t\n\t\t[if(newType)\t\t\t\t\t: set(\"lstPad\"+padType, padName)]\n\t\t[if(padType != \"\" && !newType)\t: set(\"lstPad\"+padType, listAppend(eval(\"lstPad\"+padType), padName))]\n\n\t\t[if(debug): bot_debugInfo(\"tok, padType, padName, newType, lstPads\",1)]\n\n\t\t}; {}] \n}]\n\n[h:assert(listCount(allPads), \"No AssignedPads found on map\", 0)]\n\n\n[h,if(execAll), CODE:{\n\t[foreach(pad, allPads), CODE:{\n\t\t[switchToken(pad)]\n\t\t[hasPadType\t= if(getFindCount(strfind(pad, \"\\\\s\"))==2, 1,0)]\n\t\t[if(hasPadType): padType = trim(getGroup(strfind(pad, \"\\\\s.*\\\\s\"),1,0)) ; padType = \"\")]\n\t\t[linkedToken\t= getProperty(\"w42.bot.linkedToken\")]\n\t\t[if(group == \"\" || group == padType): moveToken(getTokenX(0), getTokenY(0), 0, linkedToken)]\n\t}]\n\t\n\t[padTypeList = \"\"]\n\t[lstPads = \"\"]\n}]\n\n\n[h:tabNr = 0]\n[h,if(listCount(padTypeList)), CODE: {\n\t\n\t[inputStr\t\t\t= \"tab\"+tabNr+\" |Groups|| TAB\"]\n\t[tabNr\t\t\t\t= tabNr +1]\n\t[inputStr\t\t\t= listAppend(inputStr,\"junk|<html><b>Check the Groups to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\n\t[if(listCount(lstPads)): inputStr = listAppend(inputStr, \"ungroupedPads|1|Ungrouped pads|CHECK\") ; ungroupedPads = 0]\n\t\n\t[foreach(padType, padTypeList): inputStr = listAppend(inputStr, \"group\"+padType+\"|1|\"+padType+\" | CHECK\")]\n\t\n\t\n\t[if(listCount(lstPads)), CODE:{\n\t\t\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |Ungrouped|| TAB\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n\t}; {}]\n\t\n\t\n\t[foreach(padType, padTypeList), CODE:{\n\t\t[inputStr\t\t= listAppend(inputStr,\"tab\"+tabNr+\" |\"+padType+\"|| TAB\")]\n\t\t[tabNr\t\t\t= tabNr +1]\n\t\t[inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\n\t\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t\t[foreach(pad, lstGroupPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+padType+\"_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n\t}]\n}; {\n\t\n\t[ungroupedPads = 1]\n\t[inputStr\t\t\t= \"junk|<html><b>Check the Pads to execute <\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[foreach(pad, lstPads): inputStr = listAppend(inputStr, \"AssignedPad_\"+pad+\"|1|\"+pad+\" | CHECK\")]\n}]\n\n\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\")]\n[H, if(!execAll): abort(eval(inputStr))]\n\n\n[h,if(ungroupedPads), CODE:{\n\t[foreach(pad, lstPads), CODE:{\n\t\t[switchToken(\"AssignedPad \"+pad)]\n\t\t[if(eval(\"AssignedPad_\"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty(\"w42.bot.linkedToken\"))]\n\t}]\n}; {}]\n\n[h,foreach(padType, padTypeList), if(eval(\"group\"+padType)), CODE:{\n\t[lstGroupPads\t= eval(\"lstPad\"+padType)]\n\t[foreach(pad, lstGroupPads), CODE:{\n\t\t[switchToken(\"AssignedPad \"+padType+\" \"+pad)]\n\t\t[if(eval(\"AssignedPad_\"+padType+\"_\"+pad)):moveToken(getTokenX(0), getTokenY(0), 0, getProperty(\"w42.bot.linkedToken\"))]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5e0c30dd-2e25-428a-8772-fd0991d9a6a5",
          "commandChecksum": "3cc9f75663eeadb8b6c6ca1bbabd54fd",
          "propsChecksum": "1c2ddf7706cff5b183975f73b767c06e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 229,
        "label": "autoDisguiseButton",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[H, if(json.isEmpty(macro.args)), CODE: {\n\t[propText\t\t= '*autoDisguiseButton:[macro(\"autoDisguiseButton@lib:OnTokenMove\"): currentToken()]']\n\t[input(\n\t\t\"label|<html><b>Copy text in to Token Property to auto load Disguise Button:<\/b><br><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"Text|%{propText}||TEXT|SPAN=TRUE WIDTH=50\")\n\t)]\n};{\n\t[id\t\t\t\t= json.get(macro.args,0)]\n\t[switchToken(id)]\n\t[disguiseMacro\t= getLibProperty(\"am.bot.disguiseMacro\",getMacroLocation())]\n\t[setProperty(\"autoDisguiseButton\",\"\")]\n\t[if(!hasMacro(\"Use Disguise\")): createMacro(disguiseMacro)]\n}]",
        "maxWidth": "",
        "tooltip": "<html>When you click this, a text box will appear with<br>a token property you can add to your Campaign<br>Property token properties to automatically<br>add the <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e201264b-d0a0-4dab-ac08-bbf5b80641dc",
          "commandChecksum": "4d3901050fd3bc5ca82ef0f2488e7249",
          "propsChecksum": "b978baf1793ab919caf229fb4c1f094d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 230,
        "label": "useDisguise",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:'']\n[h, if(argCount() > 1): tTableName = arg(1); tTableName = \"Polymorph\" ]\n\n[h:toks\t\t= getSelectedNames()]\n\n[h:imgList\t= \"\"]\n[h, if(bot_inStr(toks, \"image\")), CODE:{\n\t[me\t\t= \"\"]\n\t[foreach(tok, toks), CODE:{\n\t\t[if(bot_inStr(tok, \"image\")): imgList\t= listAppend(imgList, getImage(tok)) ; me = listAppend(me,tok)]\n\t}]\n\t[toks\t= me]\n};{}]\n\n[h:assert(listCount(toks)==1, \"Make sure (only) one token (other then an 'image:token') is selected\",0)]\n[h:switchToken(toks)]\n\n[h: jTables\t\t= json.get(getInfo(\"campaign\"),\"tables\") ]\n[h: hasTable\t= json.contains(jTables,tTableName) ]\n[h: jAll\t\t= \"[]\"]\n[h, if(hasTable): cntAll = table(tTableName, 0); cntAll = 0]\n[h, if(hasTable), for(i,1,cntAll+1): jAll = json.append(jALL, tableimage(tTableName, i))]\n\n[h: jVis\t\t= \"[]\"]\n[h: tTokens\t\t= json.difference(getVisibleTokens(\"json\"), json.fromList(toks))]\n[h, foreach( tok, tTokens ),CODE: {\n\t[TOKEN(tok): jVis = json.append(jVis, getTokenImage()) ]\n}]\n[jvis\t= json.unique(jvis)]\n\n[h: disguises\t= getProperty(\"am.bot.disguise\")]\n[h, if(json.isEmpty(disguises)): disguises\t= \"[]\"]\n[h, if(listCount(imgList)): disguises = json.union(disguises, json.fromList(imgList))]\n\n[h: tokenImg\t= getTokenImage()]\n[h: inputStr\t= \"Images available on selected token | Disguise | | TAB\"]\n[h, if(!json.contains(disguises,tokenImg)), CODE: {\n\t[disguises\t= json.append(disguises,tokenImg)]\n\t[inputStr\t= json.append(inputStr,\n\t\t\"label|<html><b>Token Image added to Disguise List:<\/b><\/html>||LABEL|SPAN=TRUE\",\n\t\tstrformat(\"tip|<html>%{tokenImg}<\/html>||LABEL|SPAN=TRUE ICONSIZE=100 ICON=TRUE\")\n\t)]\n};{\n\t[inputStr\t= json.append(inputStr,\"label|<html><b>Change Token Image to add to Diguise List<\/b><\/html>||LABEL|SPAN=TRUE\")]\n}]\n\n[h: nSelect\t\t= json.indexOf(disguises, tokenImg)]\n[h: menu\t\t= -1]\n\n[h, if(json.length(disguises) > 1): inputStr\t= json.append(inputStr,\n\tstrformat(\"Menu|Change Image, Delete Image||RADIO|SPAN=TRUE SELECT=%{menu}\")\n)]\n\n[h: inputStr\t= json.append(inputStr,strformat(\"image|%s||LIST|ICON=TRUE SPAN=TRUE ICONSIZE=40 VALUE=STRING SELECT=\"+nSelect,json.toList(disguises)),\n\t\"label|<html><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\")]\n\n[h:image2\t\t= \"\"]\n[H, if(! json.isEmpty(jVis)): \n\tinputStr = json.append(\n\t\tinputStr,\"Images from tokens visible on this map | Visible Map Images | | TAB\",\n\t   strformat(\"image2|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING\",(\" ,\"+json.toList(jVis))),\n\t   'label|<html><br><font color=red><i><b>Hit \"Cancel\" to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE'\n\t)\n]\n\n[h:image3\t\t= \"\"]\n[h:width\t\t= 0]\n[h:height\t\t= 0]\n[h, if(hasTable): \n\tinputStr\t= json.append(\n\t\tinputStr, \"Images from the table 'Polymorph' | \" + tTableName + \" Table Images | | TAB\",\n\t\tstrformat(\"image3|%s||LIST|ICON=TRUE SPAN=TRUE VALUE=STRING\",(\" ,\"+json.toList(jAll))),\n\t\t\"label|<html><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\",\n\t\t\"label|<html><b>Here you can change the size of the token.<br>0 = do not change.<\/b><br>Please note that below MT version 1.4.x<br>only sizes 1,2,3,4 and 6 will work!!<\/html>||LABEL|SPAN=TRUE\",\n\t\t\"width|0|Width of token in grid cells|text|width=3\",\n\t\t\"height|0|Height of token in grid cells|text|width=3\"\n\t)\n;\n\tinputStr\t= json.append(\n\t\tinputStr, \"Images from the table 'Polymorph' | \" + tTableName + \" Table Images | | TAB\",\n\t\tstrformat(\"label|<html>The table 'Polymorph' does not exist. You will need to create it first:<br>- open panel: menu-->window-->tables<br>- create new table Polymorph<br>- first entry 'range':0 'value': enter total nr of images in table<br>- the rest start with 'range' 1, leave 'value' blank and add an image.<br><br><font color=red><i><b>Hit Cancel to close...<\/b><\/i><\/font><\/html>||LABEL|SPAN=TRUE\")\n\t)\n]\n\n[h: hasInput\t= input(json.toList(inputStr,\"##\"))]\n\n[h, if(hasInput), CODE: {\n\t[if(image2 != \"\"):\t\t\t\t\t\t\t\t\timage\t\t= image2; \"\" ]\n\t[if(image3 != \"\"):\t\t\t\t\t\t\t\t\timage\t\t= image3; \"\" ]\n\t[if(menu == 0 || image2 != \"\" || image3 != \"\" ):\tsetTokenImage(image)]\n\t[if(menu == 0):\t\t\t\t\t\t\t\t\t\tsetTokenImage(image)]\n\t[if(menu == 1):\t\t\t\t\t\t\t\t\t\tdisguises\t= json.difference(disguises,json.append(\"\",image))]\n\t[if(!json.isEmpty(disguises)):\t\t\t\t\t\tsetProperty(\"am.bot.disguise\",json.difference(disguises,json.append(\"\",\"\")))]\n\t[macro(\"useDisguise@lib:OnTokenMove\"): \"\"]\n};{\n\t[if(!json.isEmpty(disguises)):\t\t\t\t\t\tsetProperty(\"am.bot.disguise\",json.difference(disguises,json.append(\"\",\"\")))]\n}]\n\t\n[h,if(width && width==height), CODE:{\n\t\n\t\n\n\t[h,switch(width),code:\n\tcase 1: {\n\t\t[setSize(\"Medium\")]\n\t};\n\tcase 2: {\n\t\t[setSize(\"Large\")]\n\t};\n\tcase 3: {\n\t\t[setSize(\"Huge\")]\n\t};\n\tcase 4: {\n\t\t[setSize(\"Gargantuan\")]\n\t};\n\tcase 6: {\n\t\t[setSize(\"Colossal\")]\n\t};\n\tdefault: {\n\t\t[setTokenWidth(width*bot_getGridSize())]\n\t\t[setTokenHeight(width*bot_getGridSize())]\n\t}]\n};{\n\t[if(width):setTokenWidth(width*bot_getGridSize())]\n\t[if(height):setTokenHeight(height*bot_getGridSize())]\n}]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Use Disguise<\/i> button will add the current token image to your disguise list.<br> - Changing your image and clicking the button again will add a new image to list.<br> OR<br> - Selecting <i>image:tokens<\/i> together with the token will add those images to the disguise<br>list of the token<br><br>- A list will be shown for all the possible images you have loaded.<br> - You have the option to Change or Delete an image from your list.<br> - On the lib file, if you click <i>autoDisguiseButton<\/i> a text box will appear with a token<br>property you can add to your Campaign Property token properties to automatically add the<br> <i>Use Disguise<\/i> button to tokens.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85a06842-a7f8-4082-93cd-d9ff44f7df26",
          "commandChecksum": "cfe2b2ad564b823727721ceb937e3517",
          "propsChecksum": "a6e24782ca47c4c922c5e77fe5df9d54"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 231,
        "label": "bringToFront",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:ids\t\t\t= getSelectedNames(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n[h:bringToFront(json.get(json.get(jsonOrder, 0),\"id\"))]\n\n\n[h: link = macroLinkText(\"deferBtF@lib:OnTokenMove\", \"none\", jsonOrder)]\n[h: execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a20d0c0f-3793-412f-95c8-3fe1718fa676",
          "commandChecksum": "9e448b283afdbab11aeb82658f02dd48",
          "propsChecksum": "6ba0dcb0a5b30f118224a26a483086bb"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 232,
        "label": "decDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): setTokenDrawOrder(json.get(item,\"order\")-1,json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens draw order have been increased with one step\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "de0fb90c-cd9b-48e1-ab7a-fb8fe0ec3ee0",
          "commandChecksum": "d0ed537e34dc7dd116fb7da7a3932a8a",
          "propsChecksum": "9ee528777c4b8cf279522cbb7395811e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 233,
        "label": "incDrawOrder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): setTokenDrawOrder(json.get(item,\"order\")+1,json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens draw order have been increased with one step\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "36ff9b71-b63c-4016-99ea-5c2a9afb31e3",
          "commandChecksum": "47a431e34944ae433caabd36b852365a",
          "propsChecksum": "4c671d25ade6a7ad8013f0fc865bcb60"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 234,
        "label": "openOrderFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n\n\n[h:bot_resetTimer(3)]\n[h:bot_execAllPlayers(\"orderFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c96dab12-022d-4fa3-8a16-a46185f0bc4d",
          "commandChecksum": "a34c94ab47351dd35e086d37500b3583",
          "propsChecksum": "4d99c06b9612df5b8916ac914a1e7d39"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 235,
        "label": "orderFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n[h: doShape\t= getLibProperty('vblSupport','lib:EventMacros')]\n\n\n[h:currentSelection\t= getSelected(\"json\")]\n\n\n[h:token\t\t= \"\"]\n[h:hidden\t\t= \"\"]\n[h:object\t\t= \"\"]\n[h:background\t= \"\"]\n\n\n[h:degrees\t\t= getLibProperty('w42.bot.processOrder.degrees','lib:EventMacros')]\n[h,if(!isNumber(degrees)): degrees = 90]\n\n[h,if(json.length(currentSelection)):layer\t\t= getLayer(json.get(currentSelection,0));layer=\"TOKEN\"]\n[h,switch(layer):\n\tcase \"TOKEN\":\t\ttoken\t\t= \"selected\";\n\tcase \"HIDDEN\":\t\thidden\t\t= \"selected\";\n\tcase \"OBJECT\":\t\tobject\t\t= \"selected\";\n\tcase \"BACKGROUND\":\tbackground\t= \"selected\";\n\tdefault:\t\t\ttoken\t\t= \"selected\";\n]\n\n\n[h,if(doShape),CODE:{\n\t[h:TOPDOWN\t= \"\"]\n\t[h:CIRCLE\t= \"\"]\n\t[h:SQUARE\t= \"\"]\n\n\t[h,if(json.length(currentSelection)):shape\t\t= getTokenShape(json.get(currentSelection,0));shape=\"TOPDOWN\"]\n\t[h,switch(shape):\n\t\tcase \"Top down\":\tTOPDOWN\t\t= \"selected\";\n\t\tcase \"Circle\":\t\tCIRCLE\t\t= \"selected\";\n\t\tcase \"Square\":\t\tSQUARE\t\t= \"selected\";\n\t\tdefault:\t\t\tTOPDOWN\t\t= \"selected\";\n\t]\n};{}]]\n\n\n[h:jsonOrder\t\t= \"[]\"]\n[h,foreach(tok, currentSelection), CODE:{\n\t[jsonOrder\t\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n}]\n[h,if(debug): bot_debugInfo(\"jsonOrder\")]\n[h:jsonOrder\t\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n[h:orderString\t\t= \"<table border=1><tr><td>Token<\/td><td>Img<\/td><td>Z-Order\"]\n[h:numSelect\t\t= json.length(jsonOrder)]\n[h,if(numSelect), CODE:{\n\t[minOrder\t\t\t= json.get(json.get(jsonOrder,0), \"order\")]\n\t[maxOrder\t\t\t= json.get(json.get(jsonOrder,numSelect-1), \"order\")]\n\t[foreach(tok, jsonOrder), CODE:{\n\t\t[tokId\t= json.get(tok,\"id\")]\n\t\t[token(tokId): orderString\t= listAppend(orderString, strformat(\"%s<\/td><td><img height='20' width='20' src='%s'><\/img><\/td><td><input size='5' type='text' name=%{tokId} value=%s>\", getName(tokId), getTokenImage(), getTokenDrawOrder(tokId)), \"<\/td><\/tr><tr><td>\")]\n\t}]\n};{\n\t[minOrder\t\t\t= \"\"]\n\t[maxOrder\t\t\t= \"\"]\n}]\n[h:orderString\t\t= orderString + \"<\/td><\/tr><\/table>\"]\n[h,if(isFrameVisible(\"Group Select Panel\")), CODE:{\n\t[link\t\t= \"\" ]\n\t[groupTxt\t= \"<font color='red'>When you close the <b><u>Group Select Panel<\/u><\/b> you need to restart this order panel or it won't work<\/font>\"]\n};{\n\t[link\t\t= macroLinkText(\"orderHandler@Lib:OnTokenMove\", \"none\")]\n\t[groupTxt\t= \"\"]\n}]\n\n\n[frame(\"Draw Order\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: link]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\t<form action='[r:macroLinkText(\"processOrder@Lib:OnTokenMove\", \"none\")]' method=\"json\">\n\t\t\t<table  cellpadding='0' cellspacing='0'>\n\t\t\t\t<tr><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-1\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-10\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-100\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"-1000\">\n\t\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+1\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+10\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+100\"\t>\n\t\t\t\t\t<\/td><td>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"+1000\">\n\t\t\t\t<\/td><\/tr><tr><td colspan=4 width=196>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reorder Selection\"\t>\n\t\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reorder ALL\"\t>\n\t\t\t\t<\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<table border=1><tr><td>min<\/td><td>[r:minOrder] <\/td><td>max<\/td><td>[r:maxOrder] <\/td><td>Total<\/td><td>[r:numSelect] <\/td><td><input type=\"submit\" name=\"button\" value=\"Help\"\t><\/td><\/tr><\/table>\n\n\t\t\t<table cellpadding='0' cellspacing='0'><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"<- Rotate Tokens\"\t>\n\t\t\t\t<\/td><td>\n\t\t\t\t\tDegr:\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Tokens ->\"\t>\n\t\t\t<\/td><\/tr><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"<- Rotate Group\"\t\t>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"text\"\t\tname=\"degrees\"\tvalue=\"[r:degrees]\"\tsize=\"3\">\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Group ->\"\t\t>\n\t\t\t<\/td><\/tr><tr><td align=\"right\">\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Rotate Random\"\t\t\t>\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\"\tname=\"button\"\tvalue=\"Remove Rotation\"\t\t\t>\n\t\t\t<\/td><\/tr><tr><td colspan=\"3\" align=\"center\">\n\t\t\t\t\t________________________________\n\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Submit Change\"\t>\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t<input type=\"submit\" name=\"button\" value=\"Reset Change\"\t\t>\n\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\tLayer\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\tShape\n\t\t\t\t<\/td><\/tr><tr><td>\n\t\t\t\t\t<select name=\"layer\" size=\"1\">\n\t\t\t\t\t\t<option \"[r:TOKEN]\">TOKEN<\/option>\n\t\t\t\t\t\t<option \"[r:HIDDEN]\">HIDDEN<\/option>\n\t\t\t\t\t\t<option \"[r:OBJECT]\">OBJECT<\/option>\n\t\t\t\t\t\t<option \"[r:BACKGROUND]\">BACKGROUND<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td><td>\n\t\t\t\t<\/td><td>\n\t\t\t\t\t[r,if(doShape),CODE:{\n\t\t\t\t\t\t<select name=\"shape\" size=\"1\">\n\t\t\t\t\t\t\t<option \"[r:TOPDOWN]\">TOP DOWN<\/option>\n\t\t\t\t\t\t\t<option \"[r:CIRCLE]\">CIRCLE<\/option>\n\t\t\t\t\t\t\t<option \"[r:SQUARE]\">SQUARE<\/option>\n\t\t\t\t\t\t<\/select>\n\t\t\t\t\t};{b89+ only}]\n\t\t\t<\/td><\/tr><\/table>\n\t\t\t\n\t\t\t\n\t\t\t[r:orderString]\n\t\t\t[r:groupTxt]\n\t\t<\/form>\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0c1957da-fb80-48b3-96d0-e4f160810ba6",
          "commandChecksum": "4caf763cd6ea14e5e3a45d8bca4525ef",
          "propsChecksum": "77542898c6b6620be5dc39443a13e1fc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 236,
        "label": "orderHandler",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:maxOrderSelect\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:currentSelection\t= getSelected(\"json\")]\n[h:numSelect\t\t= json.length(currentSelection)]\n[h,if(numSelect > maxOrderSelect), CODE:{\n\t[bot_orderWarning(numSelect)]\n\t[abort(0)]\n};{}]\n\n[h, if(bot_timeOut(3)), CODE:{\n\t[bot_resetTimer(3)]\n\t[bot_orderFrame()]\n\t[bot_resetTimer(3)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "57874896-cd60-4841-ae09-16d183b9d7b4",
          "commandChecksum": "23a3d1b5d9ddb4fd95f9ed6117108c8e",
          "propsChecksum": "3e2a6ec4a49dd2017f5bb7edb3569475"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 237,
        "label": "orderWarning",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h: tooMany\t= arg(0)]\n\n[h,if(isFrameVisible(\"Group Order Panel\")): link = \"\" ; link = macroLinkText(\"orderHandler@Lib:OnTokenMove\", \"none\")]\n\n[frame(\"Group Order\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: link]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\tYou have currently too many tokens selected: [r:tooMany]\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3eee448e-188e-4c66-bff1-89ee34d00797",
          "commandChecksum": "127ab0a446a569f18b8bacedc1ca0dbe",
          "propsChecksum": "e555a1f0451e4a915c58b95df297e888"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 238,
        "label": "processOrder",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:doShape\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:result\t\t= macro.args]\n['pause(\"result\")']\n[h:toks\t\t= json.fields(result)]\n\n\n[h:toks\t\t= listDelete(toks, listFind(toks,\"degrees\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"button\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"layer\"))]\n[h:toks\t\t= listDelete(toks, listFind(toks,\"shape\"))]\n\n[h:output\t\t= \"\"]\n[h:degrees\t= json.get(result, \"degrees\")]\n[h:setLibProperty('w42.bot.processOrder.degrees',degrees, 'lib:EventMacros')]\n\n\n[h:layer\t\t= json.get(result, \"layer\")]\n[h,if(listCount(toks)):oldLayer = getLayer(listGet(toks,0)) ; oldLayer = layer]\n[h,if(layer != oldLayer), CODE:{\n\t[foreach(tok, toks): setLayer(layer, tok)]\n};{}]\n\n\n[h,if(doShape), CODE:{\n\t[shape\t\t= json.get(result, \"shape\")]\n\t[if(listCount(toks)):oldShape = getTokenShape(listGet(toks,0)) ; oldShape = shape]\n\t[if(shape != oldShape), CODE:{\n\t\t[foreach(tok, toks), CODE:{ \n\t\t\t[token(tok):setTokenShape(shape)]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n''\n};{}]\n\n\n[h:button\t= json.get(result, \"button\")]\n\n\n[h,if(isNumber(button)), CODE:{\n\t[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok)+button, tok)]\n};{\n\t\n\t[switch(button),code:\n\tcase \"Reorder Selection\": {\n\t\t[selected\t= getSelected(\"json\")]\n\t\t[bot_reOrderTokens(selected)]\n\t\t[selectTokens(selected, 0, \"json\")]\n\t};\n\tcase \"Reorder ALL\": {\n\t\t[selected\t= getSelected(\"json\")]\n\t\t[bot_reOrderTokens()]\n\t\t[selectTokens(selected, 0, \"json\")]\n\t};\n\tcase \"<- Rotate Tokens\" : {\n\t\t[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)+degrees, tok)]\n\t};\n\tcase \"Rotate Tokens ->\" : {\n\t\t[foreach(tok, toks): bot_setTokenFacing(bot_getTokenFacing(tok)-degrees, tok)]\n\t};\n\tcase \"<- Rotate Group\" : {\n\t\t[bot_rotateCCW()]\n\t};\n\tcase \"Rotate Group ->\" : {\n\t\t[bot_rotateCW()]\n\t};\n\tcase \"Rotate Random\" : {\n\t\t[stepSize\t= round(360/degrees,0)]\n\t\t[foreach(tok, toks): bot_setTokenFacing(roll(1,stepSize)*degrees, tok)]\n\t};\n\tcase \"Remove Rotation\" : {\n\t\t[foreach(tok, toks): removeTokenFacing(tok)]\n\t};\n\tcase \"Submit Change\": {\n\t\t[foreach(tok, toks): setTokenDrawOrder(json.get(result, tok), tok)]\n\t};\n\tcase \"Reset Change\": {\n\t};\n\tcase \"Help\": {\n\t\t[output\t= \"\n\t\tThis panel can be used for reordering the draw order (aka z-order) of the tokens on the map. If you select a couple of tokens you will notice that they appear below. Some pointers:<br>\n\t\t<br>\n\t\t<table><tr><td width='100'>\n\t\t\t<b>MIN/MAX/Total<\/b>\t\t<\/td><td>The min/max shows the minimum and maximum draw order of the current selection. <\/td><\/tr><tr><td>\n\t\t\t<b>Z-ORder<\/b>\t\t\t\t<\/td><td>You can enter a draw order number directly next to the token. When you click 'submit change' it will be applied<\/td><\/tr><tr><td>\n\t\t\t<b>reset change<\/b>\t\t\t<\/td><td>resets the changes you've just made (but does not undo applied changes)<\/td><\/tr><tr><td>\n\t\t\t<b>+/- 1/10/100/1000<\/b>\t<\/td><td>adds that number to the z-order of the current selection<\/td><\/tr><tr><td>\n\t\t\t<b>reorder all<\/b>\t\t\t<\/td><td>orders ALL TOKENS ON ALL LAYERS in consecutive order, starting at 0. Their relative order remains intact<\/td><\/tr><tr><td>\n\t\t\t<b>reorder selection<\/b>\t<\/td><td>orders all currently selected tokens consecutively, starting at the lowest value order. Their relative order remains intact. <\/td><\/tr><tr><td>\n\t\t\t<b><- Rotate Tokens<\/b>\t<\/td><td>Rotates the individual tokens the give amount of degrees Counter Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Tokens -><\/b>\t\t<\/td><td>Rotates the individual tokens the give amount of degrees Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b><- Rotate Group<\/b>\t<\/td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Counter Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Group -><\/b>\t\t<\/td><td>Rotates the entire selected group 45 (unsnapped) or 90 (snapped) degrees Clockewise<\/td><\/tr><tr><td>\n\t\t\t<b>Rotate Random<\/b>\t\t<\/td><td>Rotates the individual tokens the give amount of degrees in random steps. So e.g. 90 degrees will rotate a token either 0,90,180,270 degrees<\/td><\/tr><tr><td>\n\t\t\t<b>Remove Rotations<\/b>\t\t<\/td><td>Clears token facing<\/td><\/tr><tr><td>\n\t\t\t<b>Layer<\/b>\t\t\t\t<\/td><td>Will set ALL selected tokens to the layer of your choice<\/td><\/tr><tr><td>\n\t\t\t<b>Shape<\/b>\t\t\t\t<\/td><td>(b89+) Will set ALL selected tokens to the shape of your choice.\n\t\t<\/td><\/tr><table>\n\t\t\"]\n\t};\n\tdefault: {}]\n\n}]\n[h,if(output != \"\"), CODE:{\n\t[frame(\"Group Order Help\", \"width=500; height=100; temporary=1\"): {[r:output]}]\n};{}]\n\n[h:bot_orderFrame()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "775f8936-c457-4410-83fe-497e1df7e6d3",
          "commandChecksum": "688ef4fa0922bb55347ae7595e040ce9",
          "propsChecksum": "9c7a5d687de66a3f9e96a8e161500a8b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 239,
        "label": "reOrderTokens",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h: hasArg\t= argCount()]\n[h,if(hasArg): ids\t= arg(0) ; ids = getTokens(\"json\", json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")))]\n\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n\n[h:i\t\t= if(hasArg, json.get(json.get(jsonOrder, 0), \"order\"), 0)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group), CODE:{\n\t\t[id\t= json.get(item, \"id\")]\n\t\t[setTokenDrawOrder(i,id)]\n\t\t[i\t= i + 1]\n\t}]\n}]\n\n\n[output\t= if(hasArg, \"The z-order of the selected tokens have been reordered\", \"The z-order of ALL the tokens on the entire map have been reordered\")]\n[h:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "64457b89-2d2d-4f74-aeec-9c83cbe31681",
          "commandChecksum": "8b6470ab5376be1f1050fcc5dc0f6ef7",
          "propsChecksum": "39647e524c23617889d46bfdeab68b05"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "darkgray",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 240,
        "label": "sendToBack",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:ids\t\t\t= getSelected(\"json\")]\n[h:idsJson\t\t= bot_createSplices(ids)]\n[h:jsonOrder\t= \"[]\"]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(tok, group), CODE:{\n\t\t[jsonOrder\t= json.append(jsonOrder, json.set(\"{}\",\"id\", tok, \"order\", getTokenDrawOrder(tok)))]\n\t}]\n}]\n\n\n[h:jsonOrder\t= json.sort(jsonOrder,\"a\",\"order\")]\n\n\n[h:idsJson\t= bot_createSplices(jsonOrder)]\n[h,foreach(group, idsJson), CODE:{\n\t[foreach(item, group): sendToBack(json.get(item,\"id\"))]\n}]\n\n[h:broadcast(\"Selected tokens have been send to back\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d215d5db-0861-4bfe-ac42-6a0a415d93f4",
          "commandChecksum": "f05b5963359fb46e73ca0069f5dd2c1d",
          "propsChecksum": "6ced9def8b4bfcd43aff58b510f0e5d5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "43",
        "includeLabel": false,
        "sortBy": "43",
        "index": 241,
        "label": "buildField",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:closeDialog(\"Map Editor\")]\n[H:layer\t= json.get(macro.args, \"layer\")]\n[h:removeToken(json.get(macro.args, \"bound1\"))]\n[h:removeToken(json.get(macro.args, \"bound2\"))]\n\n[h:xmin\t= getLibProperty(\"mapField.xMin\", \"lib:EventMacros\")]\n[h:ymin\t= getLibProperty(\"mapField.yMin\", \"lib:EventMacros\")]\n[h:xmax\t= getLibProperty(\"mapField.xMax\", \"lib:EventMacros\")]\n[h:ymax\t= getLibProperty(\"mapField.yMax\", \"lib:EventMacros\")]\n[h:BASE\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h:fieldToks\t= \"\"]\n[h,for(x, xmin, xmax+1), CODE:{\n\t[for(y, ymin, ymax+1), CODE:{\n\t\t[lastCopy\t= copyToken(\"GridCoordMarker\", 1, BASE, json.set(\"{}\", \"x\", x, \"y\", y, \"layer\", layer))]\n\t\t[fieldToks\t= json.append(fieldToks, lastCopy)]\n\t}]\n}]\n\n[h:setLibProperty(\"fieldToks\", fieldToks, \"lib:EventMacros\")]\n[h:selectTokens(lastCopy)]\n[h:bot_fieldEditDialog()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "31810898-3045-453b-9a0a-7f846b95b6c9",
          "commandChecksum": "46b889be87ae0b5c97e2bc61e2756149",
          "propsChecksum": "27a931180908a5b2601f5498eec4b999"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 242,
        "label": "buildForest",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h: '']\n[h: tokList = getSelected()]\n[h: assert(tokList != \"\", \"No token(s) have been selected\")]\n[h: maxDensity = 20]\n[h: '']\n[h: '']\n[h:specNameList = \"No special token, Canopy, Foliage, Roof, Ward, EventPad, MappedPad, PadStart, PadEnd, InterPad, PadStartBorder, PadEndBorder, InterPadBorder, PadJumpBorder, PadDropBorder, InterJumpBorder, InterDropBorder, PadJump, PadDrop, InterJump, InterDrop\"]\n\n[h:densityList = \"\"]\n[h,count(maxDensity):densityList = listAppend(densityList,roll.count+1)]\n[h:layerList = \"TOKEN, HIDDEN, OBJECT, BACKGROUND\"]\n\n[h:'']\n[h:tokChkList = \"\"]\n[h:i = 0]\n[h,foreach(tok, tokList), CODE:{\n\t[size = getSize(tok)]\n\t[if(size == \"\"), CODE:{\n\t\t[tokChkList = listAppend(tokChkList, tok)]\n\t\t[xSize = getProperty(\"w42.bot.xSize\", tok)]\n\t\t[ySize = getProperty(\"w42.bot.ySize\", tok)]\n\t\t[if(isNumber(xSize)):set(\"xSize\" + i, xSize); set(\"xSize\" + i, 1)]\n\t\t[if(isNumber(ySize)):set(\"ySize\" + i, ySize); set(\"ySize\" + i, 1)]\n\t\t[i = i + 1]\n\t}; {\n\t\t[switchToken(tok)]\n\t\t[bot_determineTokSize()]\n\t}]\n}]\n\n[h:'']\n[h:tokNameList = bot_ids2Names(tokChkList)]\n\n[h:'']\n[h:inputStr = \"\"]\n[h:inputStr = listAppend(inputStr, \t\"junk|<html><b>make sure that freesize images are NOT snapped to grid!!<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"tokenName|\"+specNameList+\"|Type of token to scatter over the map?|LIST|VALUE=STRING SELECT=1\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"areaWidth|75|Width of designated area\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"areaLength|75|Length of designated area\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"density|\"+densityList+\"|Choose the density of the area (20 is the most dense)?|LIST|VALUE=STRING SELECT=14\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"layer|\"+layerList+\"|Choose the layer where the tokens are scattered?|LIST|VALUE=STRING SELECT=2\", \"@\")]\n[h:inputStr = listAppend(inputStr, \t\"rotate|1|Rotate images when scattering?|CHECK\", \"@\")]\n\n[h, if(listCount(tokNameList)): inputStr\t= listAppend(inputStr, \"junk|<html><b>Set Size (in Cells) of Images<br><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n[H,FOREACH(tok, tokNameList), CODE:{\n\t[varNameX = \"xSize\"+roll.count]\n\t[varNameY = \"ySize\"+roll.count]\n\t[ inputStr = listAppend(inputStr, varNameX+\"|\"+eval(varNameX)+\"|Set size width (left to right)(in number of cells) of token: \"+tok, \"@\") ]\n\t[ inputStr = listAppend(inputStr, varNameY+\"|\"+eval(varNameY)+\"|Set size length (top to bottom)(in number of cells) of token: \"+tok, \"@\") ]\n}]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[H,FOREACH(tok, tokNameList), CODE:{\n\t[varNameX = \"xSize\"+roll.count]\n\t[varNameY = \"ySize\"+roll.count]\n\t[setProperty(\"w42.bot.xSize\", eval(varNameX), tok)]\n\t[setProperty(\"w42.bot.ySize\", eval(varNameY), tok)]\n\n}]\n\n[h: '']\n[h, if(tokenName == \"No special token\"): tokenName = \"\"]\n[h, foreach(tok, tokList), CODE:{\n\t[token(tok), if(tokenName != \"\"): token.name = tokenName + \" \" + token.name]\n}]\n[h:bot_renumberToks(tokenName, tokList)]\n\n[h: '']\n[h: area = areaWidth * areaLength]\n[h: numToks = listCount(tokList)]\n\n[h: numCopies\t= floor(  area * (density / maxDensity) * (1 / numToks) * 1/4    )]\n[h: spread\t\t= maxDensity + 1 - density]\n[h: distNorth\t= floor(areaLength /2)]\n[h: distSouth\t= ceil(areaLength /2)]\n[h: distEast\t= floor(areaWidth /2)]\n[h: distWest\t= ceil(areaWidth /2)]\n[h: ids\t\t\t= json.fromList(tokList)]\n[h: multiToken\t= \"ofEach\"]\n[h: rotation\t= if(rotate, \"Free\", \"None\")]\n[h: sizeRange\t= -1]\n\n[h: '']\n[h:args = json.set(\"{}\", \"numCopies\", numCopies, \"distNorth\", distNorth, \"distEast\", distEast, \"distSouth\", distSouth, \"distWest\", distWest, \"ids\", ids, \"spread\", spread, \"layer\", layer, \"rotation\", rotation, \"multiToken\", multiToken, \"sizeRange\", sizeRange, \"tokenName\", tokenName)]\n[r,macro(\"scatterImages@this\"): args]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c637597e-2a1e-45b7-94d9-192cae8deba1",
          "commandChecksum": "2e2ba26cce4dc1476e44a3f3556074d7",
          "propsChecksum": "4a9115f5616c235f23b0107eff8ab752"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 243,
        "label": "chooseCrowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:'']\n[h: bot_getValidCrowd(useCurrentMap)]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Choose the images you wish to use<br><\/html>|-|LABEL|SPAN=TRUE\"]\n[H,FOREACH(tok, fancyCrowdList), CODE:{\n\t[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',\"@\")]\n\t[ inputStr = listAppend(inputStr, \"tok\"+roll.count+\"|1|\"+tok+\"|CHECK\",\"@\")]\n}]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h:crowd.tokens = \"[]\"]\n[H,FOREACH(id, crowdTokens), CODE:{\n\t[if(eval(\"tok\"+roll.count)): crowd.tokens = json.append(crowd.tokens, id)]\n}]\n\n[h:setLibProperty(\"crowd.tokens\", crowd.tokens,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect crowd tokens images<br>which are on the BASE map. The checked images will be (randomly) used for<br>the <i>Create Crowd<\/i> macro.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fd4ef448-7d5c-4cc0-838d-84d0593be7de",
          "commandChecksum": "99b17274f7338946624d52129b5aced7",
          "propsChecksum": "31c968d6ce9620002db30d409a42d072"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 244,
        "label": "chooseTrunks",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:'']\n[h: bot_getValidTrunks(useCurrentMap)]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Choose the trunks you wish to use<br><\/html>|-|LABEL|SPAN=TRUE\"]\n[H,FOREACH(treeTrunk, fancyTrunkList), CODE:{\n\t[ inputStr = listAppend(inputStr, 'junk|________________________________________|-|LABEL|SPAN=TRUE',\"@\")]\n\t[ inputStr = listAppend(inputStr, \"image\"+roll.count+\"|1|\"+treeTrunk+\"|CHECK\",\"@\")]\n}]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h:treeTrunkImages = \"\"]\n[H,FOREACH(id, treeTrunkImageList), CODE:{\n\t[if(eval(\"image\"+roll.count)): treeTrunkImages = listAppend(treeTrunkImages, id)]\n}]\n\n[h:setLibProperty(\"treeTrunkImages\", treeTrunkImages,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This will show a form where you can select or deselect tree trunk images<br>which are on the BASE map. The checked images will be (randomly) used for the <i>Canopy<\/i> pads<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0b406f98-b8f0-4b54-bd05-dadbc2912472",
          "commandChecksum": "94488fffbb7b29741733e1713964175d",
          "propsChecksum": "5bb87d011bc564419236cc62a13c45de"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 245,
        "label": "createCrowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[dialog(\"Create Crowd\", \"temp=1; closebutton=0; width=300; height=450\"): {\n    [macro(\"crowdDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d1ab27d2-3ad3-4b94-9c81-cd6b8a0fc931",
          "commandChecksum": "be0b5985c3b04f42fcf72d427e8f0f8f",
          "propsChecksum": "c0e817ced7237b5318faeaa91709789e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 246,
        "label": "crowdDialog",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: '']\n\n[h:selList\t\t= getLibProperty(\"crowd.tokens\", \"lib:EventMacros\")]\n[h:boundaryToks\t= getSelected(\"json\")]\n[h:boundaryChk\t= if(json.length(boundaryToks) == 2, 1,0)]\n\n[h,if(boundaryChk), CODE:{\n\t[boundaryTok0\t= json.get(boundaryToks, 0)]\n\t[boundaryTok1\t= json.get(boundaryToks, 1)]\n\t[x0\t\t\t\t= getTokenX(0, boundaryTok0)]\n\t[y0\t\t\t\t= getTokenY(0, boundaryTok0)]\n\t[x1\t\t\t\t= getTokenX(0, boundaryTok1)]\n\t[y1\t\t\t\t= getTokenY(0, boundaryTok1)]\n};{\n\t[boundaryTok0\t= \"\"]\n\t[boundaryTok1\t= \"\"]\n\t[x0\t\t\t\t= 0]\n\t[y0\t\t\t\t= 0]\n\t[x1\t\t\t\t= 0]\n\t[y1\t\t\t\t= 0]\n}]\n\n[h:xmin\t\t\t= min(x0,x1)]\n[h:ymin\t\t\t= min(y0,y1)]\n[h:xmax\t\t\t= max(x0,x1)]\n[h:ymax\t\t\t= max(y0,y1)]\n\n[h:setLibProperty(\"crowd.xMin\", xmin, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.yMin\", ymin, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.xMax\", xmax, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.yMax\", ymax, \"lib:EventMacros\")]\n\n\n[h:tokUL\t\t= if(xmin == x0, boundaryTok0, boundaryTok1) ]\n\n\n[h:distNorth\t= 0]\n[h:distWest\t\t= 0]\n\n[h:distEast\t\t= xmax - xmin]\n[h:distSouth\t= ymax - ymin]\n\n<html>\n\t<head>\n\t\tCreate Crowd\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' \n\t\t\t\t\thref='[r:macroLinkText(\"createCrowd@this\")]'>\n\t<\/head>\n\t<body>\n\t<form name=in action=[r:macroLinkText(\"scatterImages@this\")] method=\"json\">\n\t\t<input type=\"hidden\" name=\"distNorth\"\t\tvalue='[r:distNorth]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distEast\"\t\tvalue='[r:distEast]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distSouth\"\t\tvalue='[r:distSouth]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"distWest\"\t\tvalue='[r:distWest]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"ids\"\t\t\t\tvalue='[r:selList]'>\t<\/input>\n\t\t<input type=\"hidden\" name=\"boundaryToks\"\tvalue='[r:boundaryToks]'><\/input>\n\t\t<input type=\"hidden\" name=\"multiToken\"\t\tvalue='randomlySelected'><\/input>\n\t\t<input type=\"hidden\" name=\"map\"\t\t\t\tvalue='[r:getLibProperty(\"baseMapName\",\"Lib:EventMacros\")]'><\/input>\n\t\t<input type=\"hidden\" name=\"centreTok\"\t\tvalue='[r:tokUL]'>\t\t<\/input>\n\t\t<input type=\"hidden\" name=\"sizeRange\"\t\tvalue='0'>\t\t\t\t<\/input>\n\t\t<input type=\"hidden\" name=\"macro\"\t\t\tvalue='createCrowd'>\t<\/input>\n\t\t<table>\n\t\t\t<tr>\n\t\t\t\t<th width=70% align='right'>\n\t\t\t\t\t<label for=\"numCopies\">How many people:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=30%>\n\t\t\t\t\t<input name=\"numCopies\" value=\"100\"><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"rotation\">Facing of the crowd:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<select name=\"rotation\">\n\t\t\t\t\t\t<option value=\"Free\" selected=\"selected\">Free<\/option>\n\t\t\t\t\t\t<option value=\"SquareEdges\">Square (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"Square\">Square<\/option>\n\t\t\t\t\t\t<option value=\"VHexEdges\">Vertical Hex (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"VHex\">Vertical Hex<\/option>\n\t\t\t\t\t\t<option value=\"HHexEdges\">Horizontal Hex (Edges)<\/option>\n\t\t\t\t\t\t<option value=\"HHex\">Horizontal Hex<\/option>\n\t\t\t\t\t\t<option value=\"None\">None<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<div title=\"This is my tooltip\"><label for=\"layer\">Layer to place crowd:<\/label><\/div>\n\t\t\t\t<\/th>\n\t\t\t\t<td>\n\t\t\t\t\t[h,if(json.isEmpty(boundaryToks)), code: {\n\t\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t\t} ; {\n\t\t\t\t\t\t[h: obj = json.get(boundaryToks, 0)]\n\t\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t\t}]\n\t\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t\t<\/select>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"spread\">Spreading:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"spread\" value = 0><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"speed\">Flee Speed (#cells):<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"speed\" value = 2d6><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\n\t\t\t<tr>\n\t\t\t\t<th align='right'>\n\t\t\t\t\t<label for=\"antagonist\">Antagonists:<\/label>\n\t\t\t\t<\/th>\n\t\t\t\t<td width=70>\n\t\t\t\t\t<input name=\"antagonist\" value = '<enter list of tokens>'><\/input>\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t\t\n\t\t\t[r,if(json.length(boundaryToks) == 2), CODE:{\n\t\t\t\t[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{\n\t\t\t\t\t<tr><td align='right'>Upper Left:\t\t<\/td><td>([r:xmin],[r:ymin])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Lower Right:\t<\/td><td>([r:xmax],[r:ymax])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Covered Area:\t<\/td><td>([r:distEast],[r:distSouth]) cells<\/td><\/tr>\n\t\t\t\t};{\n\t\t\t\t\t<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)<\/td><\/tr>\n\t\t\t\t}]\n\t\t\t};{\n\t\t\t\t<tr><td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the crowd scene.<\/td><\/tr>\n\t\t\t}]\n\t\t<\/table>\n\t\t<table width=33% align=center>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t[r,if(json.isEmpty(selList) != 1), code: {\n\t\t\t\t\t\t<input type=submit name=go value=\"Build Crowd\"><\/input>\n\t\t\t\t\t};{\n\t\t\t\t\t\t<font color='red'>No crowd tokens found. Use 'Choose Crowd' macro in the setup panel.<\/font>\n\t\t\t\t\t}]\n\t\t\t\t<\/td>\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\t<b>Short Manual<\/b><br>\n\t\tYou can typically use this to emulate a square or bar where (e.g.) a 'fight goes down'. Especially if people start throwing grenades, the general public has the tendancy to move itself in the exact opposite direction.<br><br>\n\t\tAlternatively you can emulate a <i>Zombie Fest<\/i> where the the crowd is moving TOWARDS the event instead of away.<br>\n\t\tThat is what this tool does.<br><br>\n\t\tThe steps:<br>\n\t\t1. Put two tokens in the corners of the square you wish to populate (make sure that they are UPPER LEFT and LOWER RIGHT). Select (only!) the two tokens.<br>\n\t\t2. Enter the fields explained below<br>\n\t\t3. Hit the 'Move Crowd' or 'Move Crowd +' button on the campaign panel (or BoT panel) <br>\n\t\tThe former simply moves the crowd to the border or the area. The latter does the same but more intelligently. E.g A token stops when running into another and has 50% chance to fall prone (hence the requirement of the prone state). It also is removed when it crosses the border. Prone tokens stand up the next round.<br>\n\t\tIn terms of time: on an average computer it takes roughly 0.5 seconds to do 100 tokens with 'Move Crowd', while the '+' version takes about 13 seconds for the same 100 tokens. Both buttons can be used at all times, also alternately. They just calculate the current crowd differently. \n\t\t<br><br>\n\t\t<b>Note<\/b> that for now only ONE crowd per CAMPAIGN is allowed (so NOT per map), if you create a second crowd either on the same or other map, the original crowd settings will be overwritten.<br><br>\n\t\t\n\t\t<b>Explanation of the fields<\/b>\n\t\t<table border=1 cellpadding=2>\n\t\t<tr><td valign='top'>How many:\t\t\t\t\t<\/td><td>\tis simply the amount of tokens that will populate the square. Keep the number below 1000 !!.\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Facing:\t\t\t\t\t<\/td><td>\twhen the tokens are distributed there facing (rotation) can be set randomly. Determine the method.\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Layer to place the crowd:\t<\/td><td>\tI guess thats evident.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Spreading:\t\t\t\t\t<\/td><td>\t<b>-1<\/b> means, just drop the n tokens and leave them.<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>0<\/b> means that tokens that are on top of eachother are removed.<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>1 and higher<\/b> are the number of cells that will AT LEAST be between two tokens.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThis is achieved by REMOVING tokens that are too close. Which means that if you don't enter -1 its most likely that the total crowd will consist out of less then the number you entered in the 'How Many' box.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Flee Speed: \t\t\t\t<\/td><td>\tWhen everything is setup, you can hit the 'Move Crowd' macro that will move each individual token a number of cells equal to the given number here. This CAN be code, like 2d6.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>Note:<\/b><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif you want to emulate a <i>'Zombie Fest'<\/i>, that is have the crowd move TOWARDS the antagonists, simply enter a negative number, e.g. -3d4.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<tr><td valign='top'>Antagonist: \t\t\t\t<\/td><td>\tHere you enter one or more names of the token(s) from which 'The Crowd' is running from.<br><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>Notes:<\/b><br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- you can move this/these tokens during the crowd movement, which WILL influence their path!!<br>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t- If you enter multiple token names, seperate their names by comma \",\". E.g. <i>Dragon, Dragon 1, Dragon 2, etc.<\/i>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t<\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ea33db5b-e62c-4b61-aefe-12c060c231f6",
          "commandChecksum": "d178a177ed8ae189c1083b9b31c9a58b",
          "propsChecksum": "405cec722f954bc979692fe85af81593"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "33",
        "includeLabel": false,
        "sortBy": "33",
        "index": 247,
        "label": "deferFinishScatter",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h: tokenName\t\t= arg(0)]\n\n[h: macro\t\t\t= arg(1)]\n[h: remainingCopies = arg(2)]\n\n[h,if(macro == \"scatterToken\"), CODE:{\n\t[if(tokenName != 0): bot_renumberToks(tokenName)]\n\t[bot_initializePads()]\n};{\n\t[setLibProperty(\"crowd\", remainingCopies, \"lib:EventMacros\")]\n}]\n\n[h: broadcast(\"Spread Calculations are finished\")]\n[h: closeFrame(\"Progress Bar\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bcfee45c-0e8a-4ba6-b52a-9730a39133de",
          "commandChecksum": "9705b93077e301be9c21202daae7b58c",
          "propsChecksum": "7ddb6a340aa8f234b7147ab6ee36ab69"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 248,
        "label": "deferRemoveToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:assert(getLibProperty(\"abortProcess\", \"lib:EventMacros\")!=0, \"Process Aborted\", 0))]\n\n[h: '']\n\n[h:copies\t\t\t= arg(0)]\n[h:layer\t\t\t= arg(1)]\n[h:spread\t\t\t= arg(2)]\n[h:tokenName\t\t= arg(3)]\n[h:totalCopies\t\t= arg(4)]\n[h:macro\t\t\t= arg(5)]\n[h:remainingCopies\t= arg(6)]\n\n[h:currentIteration = json.length(copies)]\n[h:broadcast(\"Tokens left to check: \" + currentIteration)]\n\n[h:prog.percentage = floor(100*currentIteration/totalCopies)]\n\n[h:output\t= \"\n\t<table width=305px bgcolor='red'><tr><td>\n\t\t<table width=\" + 3*prog.percentage + \"px bgcolor = 'green' color='white'><tr><td>\" + prog.percentage + \"% \" + if(band(currentIteration,1), '0', 'o') + \"<\/td><\/tr><\/table>\n\t<\/td><\/tr><\/table>\n\t\n\t \n\t<table width=100px bgcolor='black' cellpadding='1'>\n\t\t<table width=100% bgcolor='red'><td align='center')>\n\t\t\t<td>\n\t\t\t\t<span  style='text-decoration:none; color:yellow'>\n\t\t\t\t\t\" + macroLink('Abort process', 'abortProcess@lib:OnTokenMove', '', 0) + \"\n\t\t\t\t<\/span>\n\t\t\t<\/td>\n\t\t<\/table>\n\t<\/table>\n\"]\n\n[if(bot_isFullScreen()), CODE:{\n\t[dialog(\"Progress Bar\", \"width=410; height=10; temporary=0; input=1\"): {[r:output]}]\n};{\n\t[frame(\"Progress Bar\", \"width=410; height=10; temporary=0\"): {[r:output]}]\n}]\n\n[h:'']\n\n[h:'']\n[tok\t\t\t\t= json.get(copies,roll(1,json.length(copies))-1)]\n[if(findToken(tok) != \"\"), CODE:{\n\t[setTokenDrawOrder(1d1000, tok)]\n\t[conditions\t\t\t= \"{'layer':'\"+layer+\"', 'range':{'token':'\"+tok+\"', 'distancePerCell':0, 'upto':\"+spread+\"}}\"]\n\t[toRemove\t\t\t= bot_ids2NamesArray(getTokens(\"json\", conditions))]\n\t[FOREACH(remTok, toRemove), if(json.contains(remainingCopies, remTok)): removeToken(remTok)]\n\t[remainingCopies\t= json.difference(remainingCopies,toRemove)]\n\t[copies\t\t\t\t= json.difference(copies, toRemove)]\n};{}]\n[copies\t\t\t\t= json.difference(copies, json.append(\"[]\",tok))]\n\n['remainingCopies = json.sort(remainingCopies)']\n['copies = json.sort(copies)']\n['toRemove = json.sort(toRemove)']\n['pause(\"remainingCopies\",\"toRemove\", \"copies\", \"tok\")']\n[h:'']\n\n[if(!json.isEmpty(copies)):\n\texecLink(macroLinkText(\"deferRemoveToken@lib:onTokenMove\",\"none\",json.append(\"\",copies,layer,spread,tokenName,totalCopies, macro, remainingCopies)),1)\n; \n\texecLink(macroLinkText(\"deferFinishScatter@lib:onTokenMove\",\"none\",json.append(\"\",tokenName,macro,remainingCopies)),1)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9bef293c-abd2-45f4-88b3-90bfb9a58001",
          "commandChecksum": "bcf09f7bdff17c14bdc14bb2aabd4111",
          "propsChecksum": "2a84bf65224d47c4775dedf18b9b4900"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "44",
        "includeLabel": false,
        "sortBy": "44",
        "index": 249,
        "label": "fieldEditDialog",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h, if(bot_timeOut(4)), CODE:{\n\t[bot_resetTimer(4)]\n\n\t[h:selected\t\t= getSelectedNames(\"json\")]\n\t[assert(json.length(selected)==1, \"\",0)]\n\t[h:selTok\t\t= json.get(selected, 0)]\n\n\t[h:imgTok\t\t= macro.args]\n\t[h:x\t\t\t= 0]\n\t[h:y\t\t\t= 0]\n\n\t[h,if(startsWith(selTok, \"GridCoordMarker\")), CODE:{\n\t\t[coordToken = selTok]\n\t\t[existImg\t= if(findToken(imgTok) != \"\", 1, 0)]\n\t};{\n\t\t[coordToken = \"\"]\n\t\t[imgTok\t\t= selTok]\n\t\t[existImg\t= 1]\n\t}]\n\n\t[h:xmin\t= getLibProperty(\"mapField.xMin\", \"lib:EventMacros\")]\n\t[h:ymin\t= getLibProperty(\"mapField.yMin\", \"lib:EventMacros\")]\n\t[h:xmax\t= getLibProperty(\"mapField.xMax\", \"lib:EventMacros\")]\n\t[h:ymax\t= getLibProperty(\"mapField.yMax\", \"lib:EventMacros\")]\n\t[h:BASE\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n\t[if(coordToken != \"\" && findToken(imgTok) != \"\"), CODE:{\n\t\t[x\t= getTokenX(0, coordToken)]\n\t\t[y\t= getTokenY(0, coordToken)]\n\t\t['pause(\"x\",\"y\",\"coordToken\",\"imgTok\")']\n\t\t[tmpState\t= getState(\"editFieldMarker\",imgTok)]\n\t\t[setState(\"editFieldMarker\", 1, imgTok)]\n\t\t\t[newImgTok\t=\tgetName(copyToken(imgTok, 1, getCurrentMapName(), json.set(\"{}\", \"x\", x, \"y\", y)))]\n\t\t[setState(\"editFieldMarker\",tmpState, imgTok)]\n\t\t[imgTok\t\t\t= newImgTok]\n\t};{}]\n\n\t[if(existImg), CODE:{\n\t\t[switchToken(imgTok)]\n\t\t[imgTok\t\t= token.name]\n\t\t[htmlImg\t= \"<img src='\"+getTokenImage(100)+\"'><\/img>\"]\n\t};{\n\t\t[htmlMsg\t= \"Select ANY (not map field) token and the click on the field to auto-copy-paste it there\"]\n\t\t[imgTok\t\t= \"\"]\n\t}]\n\n\t[h:macroLink\t= macroLinkText(\"fieldEditDialog@this\", \"none\", imgTok)]\n\n\t[frame(\"Map Editor\", \"temp=1; closebutton=0; width=200; height=200\"): {\n\t\t<html>\n\t\t\t<head>\n\t\t\t\tMap Editor\n\t\t\t\t<link rel='stylesheet' type='text/css' \n\t\t\t\t<link rel='onChangeSelection' type='macro' href='[r:macroLink]')>\n\t\t\t<\/head>\n\t\t\t<body>\n\t\t\t\t<table>\n\t\t\t\t\t<tr><td>Current edit token<\/td><\/tr>\n\t\t\t\t\t<tr><td>[r,if(existImg):htmlImg ; htmlMsg]\n\t\t\t\t\t<\/td><\/tr>\n\t\t\t\t<\/table>\n\t\t\t<\/body>\n\t\t<\/html>\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa4cd3fb-7a00-4583-a090-06f9c9bbb84a",
          "commandChecksum": "a31c56d80fd78cadb58d3a3019d0066f",
          "propsChecksum": "b753a5a050e64931f3440f5695eb5971"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "14",
        "includeLabel": false,
        "sortBy": "14",
        "index": 250,
        "label": "getValidCrowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n\n[H: '']\n[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n[h, if(useCurrentMap):setCurrentMap(oldMap)]\n\n[h:conditions\t\t= '{\"layer\":\"TOKEN\"}']\n[h:tokenList\t\t= getTokenNames(\",\",conditions)]\n[h:tokenList \t\t= listSort(tokenList, \"N\")]\n\n[h:fancyCrowdList\t= \"\"]\n[h:crowdTokens\t\t= \"\"]\n\n[h:foundOne\t\t\t= 0]\n[H,FOREACH(tok, tokenList), CODE:{\n\t[h, if(startsWith(tok, \"Crowd\")), CODE:{\n\t\t[token(tok): assetID\t= getTokenImage()]\n\t\t[crowdTokens\t\t\t= listAppend(crowdTokens, tok)]\n\t\t[fancyCrowdList\t\t\t= listAppend(fancyCrowdList, '<html><span style=\"color:black; vertical-align:middle\"  >'+tok+'<\/span><img src=\"'+assetID+'\" height=\"100\" width=\"100\"><\/img><\/html>')]\n\t\t[foundOne\t\t\t\t= 1]\n\t};{}]\n}]\n\n[h:assert(foundOne,\"There are no tokens found which names start with 'Crowd' on THE TOKEN LAYER of map:\"+baseMapName+\". Make sure you have these images on the object layer of that map before running this macro\",0)]\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "66196301-54ce-4b16-8715-cae523bbfd2f",
          "commandChecksum": "1733cc0c399a01b5d8008d3154aa2759",
          "propsChecksum": "aff466a508037a063e83fd79d5de8732"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "23",
        "includeLabel": false,
        "sortBy": "23",
        "index": 251,
        "label": "getValidTrunks",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[H: '']\n[h,if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n\n[h: oldMap = getCurrentMapName()]\n[h:baseMapName = getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\n[h, if(oldMap != baseMapName):setCurrentMap(baseMapName)]\n[h, if(useCurrentMap):setCurrentMap(oldMap)]\n\n[h:conditions\t= '{\"layer\":\"OBJECT\"}']\n[h:tokenList\t= getTokenNames(\",\",conditions)]\n[h:tokenList \t= listSort(tokenList, \"N\")]\n\n[h:fancyTrunkList\t= \"\"]\n[h:treeTrunkImageList\t= \"\"]\n\n[h:foundOne\t\t= 0]\n[H,FOREACH(tok, tokenList), CODE:{\n\t[h, if(startsWith(tok, \"Trunk\")), CODE:{\n\t\t[token(tok): assetID = getTokenImage()]\n\t\t[treeTrunkImageList = listAppend(treeTrunkImageList, assetID)]\n\t\t[fancyTrunkList = listAppend(fancyTrunkList, '<html><span style=\"color:black; vertical-align:middle\"  >'+tok+'<\/span><img src=\"'+assetID+'\" height=\"100\" width=\"100\"><\/img><\/html>')]\n\t\t[foundOne\t\t= 1]\n\t}; {}]\n}]\n[h:assert(foundOne,\"There are no tokens found which names start with 'Trunk' on THE OBJECT LAYER of map:\"+baseMapName+\". Make sure you have these images on the object layer of that map before running this macro\",0)]\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f551f9cf-c9b4-4d32-b870-f51fb36988f1",
          "commandChecksum": "b59945cb2177d145a0e72b778d71adf6",
          "propsChecksum": "a4e8f18703462f4e517990d82adf7629"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "41",
        "includeLabel": false,
        "sortBy": "41",
        "index": 252,
        "label": "mapEditor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[dialog(\"Map Editor\", \"temp=1; closebutton=0; width=330; height=600\"): {\n    [macro(\"mapEditorDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "<html>Use this macro to create a square filled with tokens (a crowd),<br>that can later be dispersed by using the 'move crowd' macro<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5dcd343d-fc99-4ce1-9871-d980634850eb",
          "commandChecksum": "41c7c8c494203bbddc5b1bb995b269e6",
          "propsChecksum": "5ce4cf46f8967cf19655553067e603b4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "42",
        "includeLabel": false,
        "sortBy": "42",
        "index": 253,
        "label": "mapEditorDialog",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:boundaryToks\t= getSelected(\"json\")]\n[h:boundaryChk\t= if(json.length(boundaryToks) == 2, 1,0)]\n\n[h,if(boundaryChk), CODE:{\n\t[boundaryTok0\t= json.get(boundaryToks, 0)]\n\t[boundaryTok1\t= json.get(boundaryToks, 1)]\n\t[x0\t\t\t\t= getTokenX(0, boundaryTok0)]\n\t[y0\t\t\t\t= getTokenY(0, boundaryTok0)]\n\t[x1\t\t\t\t= getTokenX(0, boundaryTok1)]\n\t[y1\t\t\t\t= getTokenY(0, boundaryTok1)]\n};{\n\t[boundaryTok0\t= \"\"]\n\t[boundaryTok1\t= \"\"]\n\t[x0\t\t\t\t= 0]\n\t[y0\t\t\t\t= 0]\n\t[x1\t\t\t\t= 0]\n\t[y1\t\t\t\t= 0]\n}]\n\n[h:xmin\t\t\t= min(x0,x1)]\n[h:ymin\t\t\t= min(y0,y1)]\n[h:xmax\t\t\t= max(x0,x1)]\n[h:ymax\t\t\t= max(y0,y1)]\n\n[h:setLibProperty(\"mapField.xMin\", xmin, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.yMin\", ymin, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.xMax\", xmax, \"lib:EventMacros\")]\n[h:setLibProperty(\"mapField.yMax\", ymax, \"lib:EventMacros\")]\n\n\n[h:tokUL\t\t= if(xmin == x0, boundaryTok0, boundaryTok1) ]\n\n\n<html>\n\t<head>\n\t\tBuild Map Editor Field\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' href='[r:macroLinkText(\"mapEditor@this\")]'>\n\t<\/head>\n\t\n\t<body>\n\t<form name=in action=[r:macroLinkText(\"buildField@this\")] method=\"json\">\n\t<input type=\"hidden\" name=\"bound1\"\t\tvalue='[r:boundaryTok0]'>\t<\/input>\n\t<input type=\"hidden\" name=\"bound2\"\t\tvalue='[r:boundaryTok1]'>\t<\/input>\n\n\t\t<table>\n\t\t\n\t\t\t<th align='right'>\n\t\t\t\t<div title=\"This is my tooltip\"><label for=\"layer\">Layer where you wish to edit:<\/label><\/div>\n\t\t\t<\/th>\n\t\t\t<td>\n\t\t\t\t[h,if(json.isEmpty(boundaryToks)), code: {\n\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t} ; {\n\t\t\t\t\t[h: obj = json.get(boundaryToks, 0)]\n\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t}]\n\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t<\/select>\n\t\t\t<\/td>\n\n\t\t\n\t\t\t[r,if(json.length(boundaryToks) == 2), CODE:{\n\t\t\t\t[r,if(getTokenY(0,tokUL) != ymax && xmin != xmax), CODE:{\n\t\t\t\t\t<tr><td align='right'>Upper Left:\t\t<\/td><td>([r:xmin],[r:ymin])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'>Lower Right:\t<\/td><td>([r:xmax],[r:ymax])<\/td><\/tr>\n\t\t\t\t\t<tr><td align='right'><input type=submit name=go value=\"Create Edit Field\"><\/input><\/td><td><\/td><\/tr>\n\t\t\t\t};{\n\t\t\t\t\t<tr><td colspan=2><b><font color='red' size=3>Make sure that one of the selected boundary tokens is in the UPPER LEFT and the other token is LOWER RIGHT (this is currently NOT the case)<\/td><\/tr>\n\t\t\t\t}]\n\t\t\t};{\n\t\t\t\t<tr>\t<td colspan=2><b><font color='blue' size=3>Make sure you have exactly TWO tokens selected. These two tokens form the boundary of the part of the map that you can edit.<\/td><\/tr>\n\t\t\t}]\n\t\t<\/table>\n\t\t<b>Short Manual<\/b><br>\n\t\tThis editor works really simple. Just select two tokens (any will do) that outline the field you wish to edit. Make sure that one is the upper left and the other the lower right.<br>\n\t\tOnce you have done that you can hit the 'Create Edit Field' button. If you have no tokens selected, you will not see that button. Additionally you can choose on which layer you wish to edit. Personally I find the object layer the best spot.<br><br>\n\t\tAfter you hit that button, the outline tokens will be removed and a 'field' of transparent tokens will be put on the chosen layer. Note that the field will cover the spots of the outline tokens.<br><br>\n\t\tTo start editing select just ANY token (except one of the transparent tokens, although nothing will break when you do). That token will be your 'copy-paste' token. <br><br>\n\t\tNow just start selecting the transparent tokens and the previously selected token will be pasted there. Note that you can rotate, resize, add states, halos etc. and those will be copy pasted as well.<br><br>\n\t\tThats it. Post on the Bag of Tricks thread on the forum if you have any questions.\t<\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "375075c8-19d5-445c-850c-830be1a3085e",
          "commandChecksum": "32284be11514fc20ac2abe96ea9c8a0d",
          "propsChecksum": "56f452cfe4b44f6af3fde30ed4c5fa8b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "15",
        "includeLabel": false,
        "sortBy": "15",
        "index": 254,
        "label": "moveCrowd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h:crowd\t\t= getLibProperty(\"crowd\",\"lib:EventMacros\")]\n[h:speed\t\t= getLibProperty(\"crowd.speed\",\"lib:EventMacros\")]\n[h:antagonists\t= getLibProperty(\"crowd.antagonist\",\"lib:EventMacros\")]\n\n[h:assert(findToken(json.get(crowd,0)) != \"\",\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n\n[h:xMin\t\t\t= getLibProperty(\"crowd.xMin\",\"lib:EventMacros\")]\n[h:yMin\t\t\t= getLibProperty(\"crowd.yMin\",\"lib:EventMacros\")]\n[h:xMax\t\t\t= getLibProperty(\"crowd.xMax\",\"lib:EventMacros\")]\n[h:yMax\t\t\t= getLibProperty(\"crowd.yMax\",\"lib:EventMacros\")]\n\n\n[h:aX\t\t\t= 0]\n[h:aY\t\t\t= 0]\n[h, foreach(antagonist, antagonists), CODE:{\n\t[assert(findToken(antagonist) != \"\",\t\t\t\"Antagonist (\"+antagonist+\") NOT found. Make sure its on the map\",0)]\n\t[aX\t= aX + getTokenX(0, antagonist)]\n\t[aY\t= aY + getTokenY(0, antagonist)]\n}]\n[h:aX\t\t\t= round( aX/listCount(antagonists), 0 )]\n[h:aY\t\t\t= round( aY/listCount(antagonists), 0 )]\n\n\n\n[h:'bot_startTime()']\n[h,foreach(poorSoul, crowd), CODE:{\n\t[moveToken(\n\t\tmin(xMax,max(xMin,round(getTokenX(0, poorSoul) + eval(string(speed))/max(1,sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2)) * (getTokenX(0, poorSoul) - aX),0))),\n\t\tmin(yMax,max(yMin,round(getTokenY(0, poorSoul) + eval(string(speed))/max(1,sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2)) * (getTokenY(0, poorSoul) - aY),0))),\n\t\t0,\n\t\tpoorSoul\n\t)]\n}]\n[h:'broadcast(json.length(crowd))']\n[h:'broadcast(bot_totalTime(1))']",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br>Make sure the antagonist is on the map.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6d92d37f-3ea2-4862-85b6-751b2296b914",
          "commandChecksum": "f37c5c10bdb12000a886769b25180609",
          "propsChecksum": "980457cb5915b38b874fb9942d1ac9d2"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "15",
        "includeLabel": false,
        "sortBy": "15",
        "index": 255,
        "label": "moveCrowdPlus",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n\n[h:crowd\t\t= getLibProperty(\"crowd\",\"lib:EventMacros\")]\n[h:speed\t\t= getLibProperty(\"crowd.speed\",\"lib:EventMacros\")]\n[h:antagonists\t= getLibProperty(\"crowd.antagonist\",\"lib:EventMacros\")]\n\n[h:assert(json.length(crowd),\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n[h:assert(findToken(json.get(crowd,0)) != \"\",\t\"Crowd NOT found on map. Create one first using the 'Create Crowd' macro in the Setup Macro Panel\",0)]\n\n[h:xMin\t\t\t= getLibProperty(\"crowd.xMin\",\"lib:EventMacros\")-2]\n[h:yMin\t\t\t= getLibProperty(\"crowd.yMin\",\"lib:EventMacros\")-2]\n[h:xMax\t\t\t= getLibProperty(\"crowd.xMax\",\"lib:EventMacros\")+2]\n[h:yMax\t\t\t= getLibProperty(\"crowd.yMax\",\"lib:EventMacros\")+2]\n\n\n[h:aX\t\t\t= 0]\n[h:aY\t\t\t= 0]\n[h, foreach(antagonist, antagonists), CODE:{\n\t[assert(findToken(antagonist) != \"\",\t\t\t\"Antagonist (\"+antagonist+\") NOT found. Make sure its on the map\",0)]\n\t[aX\t= aX + getTokenX(0, antagonist)]\n\t[aY\t= aY + getTokenY(0, antagonist)]\n}]\n[h:aX\t\t\t= round( aX/listCount(antagonists), 0 )]\n[h:aY\t\t\t= round( aY/listCount(antagonists), 0 )]\n\n[h:'bot_startTime()']\n\n[h:newCrowd = crowd]\n[h,foreach(poorSoul, crowd), CODE:{\n\t[if(getState(\"Prone\", poorSoul) == 1), CODE:{\n\t\t[setState(\"Prone\",0,poorSoul)]\n\t''\n\t};{\n\t\t\n\t\t[distance\t= eval(string(speed))]\n\t\t[inTheWays\t= bot_selectOnLine(\n\t\t\tpoorSoul,\n\t\t\tmin(xMax,max(xMin,round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0))),\n\t\t\tmin(yMax,max(yMin,round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0))),\n\t\t\t1\n\t\t)]\n\t\t[if(listCount(inTheWays) > 1), CODE:{\n\t\t\t[inTheWay\t= getName(listGet(inTheWays, 1))]\n\t\t\t\n\t\t\t[distance\t= getDistance(inTheWay,0,poorSoul) - 1]\n\t\t\t[if(1d100 < 51): setState(\"Prone\",1,poorSoul)]\n\t\t''\n\t\t};{\n\t\t\t[inTheWay = \"\"]\n\t\t''\n\t\t}]\n\t\t[poorSoulX\t= round(getTokenX(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenX(0, poorSoul) - aX),0)]\n\t\t[poorSoulY\t= round(getTokenY(0, poorSoul) + distance/sqrt((getTokenX(0, poorSoul) - aX)^2+(getTokenY(0, poorSoul) - aY)^2) * (getTokenY(0, poorSoul) - aY),0)]\n\t\t\n\t\t[if(poorSoulX >= xMax || poorSoulX <= xMin || poorSoulY >= yMax || poorSoulY <= yMin), CODE:{\n\t\t\t[removeToken(poorSoul)]\n\t\t\t[newCrowd\t= json.remove(newCrowd, json.indexOf(newCrowd,poorSoul))]\n\t\t''\n\t\t};{\n\t\t\t[moveToken(poorSoulX, poorSoulY, 0,poorSoul)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n}]\n[h:setLibProperty(\"crowd\", newCrowd, \"lib:EventMacros\")]\n[h:'broadcast(json.length(crowd))']\n[h:'broadcast(bot_totalTime(1))']",
        "maxWidth": "",
        "tooltip": "<html>Disperses a crowd created by the 'Create Crowd' macro.<br> Make sure the antagonist is on the map.<br> <br> This macro uses more intelligence however and is more realistic<br> but MUCH slower (roughly 1 second per 10 tokens)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "17e975d1-7a79-4cb4-b41a-3bfd76f86f84",
          "commandChecksum": "d82336fe7e89befd97d202d2aefe63fb",
          "propsChecksum": "e7f20c287b995908ed10ebee9957a3ea"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "46",
        "includeLabel": false,
        "sortBy": "46",
        "index": 256,
        "label": "moveToHidden",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks), CODE:{\n\t[shape\t= getTokenShape(tok)]\n\t[setLayer(\"HIDDEN\", tok)]\n\t[setTokenShape(shape, tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1fa2ce90-7a4c-4282-9356-5113edc77fbb",
          "commandChecksum": "33c001424f34453bfe236f281c13ceaf",
          "propsChecksum": "f3f1e44ed2aef0eb5dd236ddf0fe98cc"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "red",
        "group": "46",
        "includeLabel": false,
        "sortBy": "46",
        "index": 257,
        "label": "moveToToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks), CODE:{\n\t[shape\t= getTokenShape(tok)]\n\t[setLayer(\"TOKEN\", tok)]\n\t[setTokenShape(shape, tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "81f8d369-fd88-4241-862c-db02811d082d",
          "commandChecksum": "4c9924d1e2c590e518ad8efa34559528",
          "propsChecksum": "d01e9a9ef81e7c1d715685480075c119"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "44",
        "includeLabel": false,
        "sortBy": "44",
        "index": 258,
        "label": "quitEditor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:fieldToks\t= getLibProperty(\"fieldToks\",\"lib:EventMacros\")]\n[h,foreach(tok, fieldToks), if(findToken(tok) != \"\"):removeToken(tok)]\n[h:closeFrame(\"Map Editor\")]\n\n[h: '']\n[moveToks\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", '[\"editFieldMarker\"]' ))]\n[foreach(tok, moveToks):setAllStates(0,tok)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d39b39eb-c449-4197-9812-e91d7e9ee094",
          "commandChecksum": "abc7e240794778a1c7d6ed3d539a3c2c",
          "propsChecksum": "d8ceb6c1f91ca863711332e8e973c4f5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 259,
        "label": "scatter",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[dialog(\"ScatterDialog\", \"temp=1; closebutton=0; width=300; height=450\"): {\n    [macro(\"scatterDialog@this\"): \"\"]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "75dd2d0d-9854-4213-8395-893c53ca5401",
          "commandChecksum": "3f46ebfe988b80af5d449c299453cc6b",
          "propsChecksum": "051cfe92b77a51d24090ac8f3c8a7772"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 260,
        "label": "scatterDialog",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: '']\n\n[h: selList = getSelected(\"json\")]\n<html>\n\t<head>\n\t\tCopy and Scatter\n\t\t<link rel='stylesheet' type='text/css' \n\t\t<link rel='onChangeSelection' type='macro' \n\t\t\t\t\thref='[r:macroLinkText(\"scatter@this\")]'>\n\t<\/head>\n\t<body>\n\t\t<table width=33% align=center border=1>\n\t\t\t<tr>\n\t\t\t\t\t[r,if(json.isEmpty(selList)), code: {\n\t\t\t\t\t\t<br>Select A Token or Object<br><br><br>\n\t\t\t\t\t} ; {\n\t\t\t\t\t\t[h: rows = sqrt(json.length(selList))]\n\t\t\t\t\t\t[h: perRow = ceil(json.length(selList)/rows)]\n\t\t\t\t\t\t[h: count = 0]\n\t\t\t\t\t\t[r,foreach(obj, selList,\"\"), code: {\n\t\t\t\t\t\t\t[h: count = count +1]\n\t\t\t\t\t\t\t[r,if(count > perRow): \"<\/tr><tr>\"]\n\t\t\t\t\t\t\t[h,if(count > perRow): count=1]\n\t\t\t\t\t\t\t<td><img width=[r:round(100/perRow)] height=[r:round(100/perRow)] \n\t\t\t\t\t\t\t\t src='[r,token(obj): getTokenImage()]'><\/img><\/td>\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t<\/tr>\n\t\t<\/table>\n\t\t\t<form name=in action=[r:macroLinkText(\"scatterImages@this\")]\n\t\t\t\t\t\tmethod=\"json\">\n\t\t\t\t<table>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"numCopies\">Number of Copies<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"numCopies\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distNorth\">Distance North<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distNorth\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distEast\">Distance East<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distEast\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distSouth\">Distance South<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distSouth\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"distWest\">Distance West<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"distWest\" value=\"100\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"spread\">Spreading<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<input name=\"spread\" value=\"5\"><\/input>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"rotation\">Rotation<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"rotation\">\n\t\t\t\t\t\t\t\t<option value=\"Free\" selected=\"selected\">Free<\/option>\n\t\t\t\t\t\t\t\t<option value=\"SquareEdges\">Square (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Square\">Square<\/option>\n\t\t\t\t\t\t\t\t<option value=\"VHexEdges\">Vertical Hex (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"VHex\">Vertical Hex<\/option>\n\t\t\t\t\t\t\t\t<option value=\"HHexEdges\">Horizontal Hex (Edges)<\/option>\n\t\t\t\t\t\t\t\t<option value=\"HHex\">Horizontal Hex<\/option>\n\t\t\t\t\t\t\t\t<option value=\"None\">None<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"sizeRange\">Range of Size<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"sizeRange\">\n\t\t\t\t\t\t\t\t<option value=\"-1\">Keep size of original<\/option>\n\t\t\t\t\t\t\t\t<option value=\"0\" selected=\"selected\">0<\/option>\n\t\t\t\t\t\t\t\t<option value=\"1\">1<\/option>\n\t\t\t\t\t\t\t\t<option value=\"2\">2<\/option>\n\t\t\t\t\t\t\t\t<option value=\"3\">3<\/option>\n\t\t\t\t\t\t\t\t<option value=\"4\">4<\/option>\n\t\t\t\t\t\t\t\t<option value=\"5\">5<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"layer\">Layer<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td>\n\t\t\t\t[h,if(json.isEmpty(selList)), code: {\n\t\t\t\t\t\t\t\t[lyr=\"\"]\n\t\t\t\t\t\t\t} ; {\n\t\t\t\t\t\t\t\t[h: obj = json.get(selList, 0)]\n\t\t\t\t\t\t\t\t[lyr=getLayer(obj)]\n\t\t\t\t}]\n\t\t\t\t\t\t\t<select name=\"layer\">\n\t\t\t\t\t\t\t\t<option value=\"Token\"[r: if(lyr==\"TOKEN\", \" selected='selected'\", \"\")]>Token<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Hidden\"[r: if(lyr==\"GM\", \" selected='selected'\", \"\")]>Hidden<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Object\"[r: if(lyr==\"OBJECT\", \" selected='selected'\", \"\")]>Object<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Background\"[r: if(lyr==\"BACKGROUND\", \" selected='selected'\", \"\")]>Background<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t<label for=\"tokenName\">Special Token<\/label>\n\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t<select name=\"tokenName\">\n\t\t\t\t\t\t\t\t<option value=\"0\">No<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Canopy\" selected=\"selected\">Canopy<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Foliage\">Foliage<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Roof\">Roof<\/option>\n\t\t\t\t\t\t\t\t<option value=\"Ward\">Ward<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"EventPad\">EventPad<\/option>\n\t\t\t\t\t\t\t\t<option value=\"MappedPad\">MappedPad<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadStart\">PadStart<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadEnd\">PadEnd<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterPad\">InterPad<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadStartBorder\">PadStartBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadEndBorder\">PadEndBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterPadBorder\">InterPadBorder<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadJumpBorder\">PadJumpBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadDropBorder\">PadDropBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterJumpBorder\">InterJumpBorder<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterDropBorder\">InterDropBorder<\/option>\n\n\t\t\t\t\t\t\t\t<option value=\"PadJump\">PadJump<\/option>\n\t\t\t\t\t\t\t\t<option value=\"PadDrop\">PadDrop<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterJump\">InterJump<\/option>\n\t\t\t\t\t\t\t\t<option value=\"InterDrop\">InterDrop<\/option>\n\t\t\t\t\t\t\t<\/select>\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\n\t\t\t\t\t[r,if(json.length(selList) > 1), code:{\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<th>\n\t\t\t\t\t\t\t\t<label for=\"mutiToken\">Number Copies <\/label>\n\t\t\t\t\t\t\t<\/th>\n\t\t\t\t\t\t\t<td width=70>\n\t\t\t\t\t\t\t\t<select name=\"multiToken\">\n\t\t\t\t\t\t\t\t\t<option value=\"ofEach\" selected=\"selected\">of each<\/option>\n\t\t\t\t\t\t\t\t\t<option value=\"randomlySelected\">randomly selected<\/option>\n\t\t\t\t\t\t\t<\/td>\n\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t} ; { \n\t\t\t\t\t}]\n\t\t\t\t<\/table>\n\t\t\t\t<table width=33% align=center>\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t[r,if(json.isEmpty(selList) != 1), code: {\n\t\t\t\t\t\t\t\t<input type=submit name=go value=\"Scatter\"><\/input>\n\t\t\t\t\t\t\t} ; {\n\t\t\t\t\t\t\t}]\n\t\t\t\t\t\t<\/td>\n\t\t\t\t\t<\/tr>\n\t\t\t\t<\/table>\n\t\t\t\t<input type=\"hidden\" name=\"ids\"\t\t\tvalue='[r:selList]'><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"map\"\t\t\tvalue='[r:getCurrentMapName()]'><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"centreTok\"\tvalue=''><\/input>\n\t\t\t\t<input type=\"hidden\" name=\"macro\"\t\tvalue='scatterToken'><\/input>\n\t\t <\/form>\n\t<\/body>\n<\/html>",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "383ac586-78f0-4cff-90fa-2dbadced955b",
          "commandChecksum": "51a4f4ffa062df9a5aa0291c47d4cc00",
          "propsChecksum": "291d31d86c6099727563ec73b2ec0b7f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "31",
        "includeLabel": false,
        "sortBy": "31",
        "index": 261,
        "label": "scatterImages",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: '']\n[h:closeDialog(\"Create Crowd\")]\n[h: numCopies\t= json.get(macro.args, \"numCopies\")]\n[h: distNorth\t= json.get(macro.args, \"distNorth\")]\n[h: distEast\t= json.get(macro.args, \"distEast\")]\n[h: distSouth\t= json.get(macro.args, \"distSouth\")]\n[h: distWest\t= json.get(macro.args, \"distWest\")]\n[h: ids\t\t\t= json.get(macro.args, \"ids\")]\n[h: spread\t\t= json.get(macro.args, \"spread\")]\n[h: speed\t\t= json.get(macro.args, \"speed\")]\n[h: antagonist\t= json.get(macro.args, \"antagonist\")]\n[h: sizeRange\t= json.get(macro.args, \"sizeRange\")]\n\n[h:setLibProperty(\"crowd.speed\", speed, \"lib:EventMacros\")]\n[h:setLibProperty(\"crowd.antagonist\", antagonist, \"lib:EventMacros\")]\n\n[h: tokenName\t= json.get(macro.args, \"tokenName\")]\n[h: map\t\t\t= json.get(macro.args, \"map\")]\n[h: centreTok\t= json.get(macro.args, \"centreTok\")]\n\n[h: macro\t\t= json.get(macro.args, \"macro\")]\n\n[h:assert(isNumber(numCopies),\"Number Copies must be numeric\",0)]\n[h:assert(isNumber(distNorth),\"Distance North must be numeric\",0)]\n[h:assert(isNumber(distEast),\"Distance East must be numeric\",0)]\n[h:assert(isNumber(distSouth),\"Distance South must be numeric\",0)]\n[h:assert(isNumber(distWest),\"Distance West must be numeric\",0)]\n\n[h: layer\t\t= json.get(macro.args, \"layer\")]\n[h: rotation\t= json.get(macro.args, \"rotation\")]\n\n[h,switch(rotation):\n\tcase \"Free\": \t\trotStr\t= \"1d360-1\"; \n\tcase \"SquareEdges\":\trotStr\t= \"(1d4-1) * 90\"; \n\tcase \"Square\":\t\trotStr\t= \"(1d8-1) * 45\"; \n\tcase \"VHexEdges\":\trotStr\t= \"(1d6-1) * 60 + 30\"; \n\tcase \"VHexEdges\":\trotStr\t= \"(1d12-1) * 30\"; \n\tcase \"HHexEdges\":\trotStr\t= \"(1d6-1) * 60\"; \n\tcase \"HHexEdges\":\trotStr\t= \"(1d12-1) * 30\"; \n\tcase \"None\":\t\trotStr\t= \"\"; \n] \n\n\n[h: method\t= json.get(macro.args, \"multiToken\")]\n\n[h,if(method == \"\"): method\t= \"randomlySelected\")]\n\n[h:'']\n[h:numCopyArr\t= \"[]\"]\n[h: numIds\t\t= json.length(ids)]\n[h,if(method == \"ofEach\"), code: {\n\t[for(i, 0, numIds): numCopyArr\t= json.append(numCopyArr, numCopies)]\n} ; { \n\t\n\t[for(i, 0, numIds): numCopyArr\t= json.append(numCopyArr, floor(numCopies/numIds))]\n\t\n\t[sum\t= evalMacro(replace(replace(numCopyArr, \"\\\\[\", \"[r:\"), \",\", \"+\"))]\n\t[toAdd\t= max(0,numCopies - sum)]\n\t\n\t[count(toAdd): numCopyArr\t= json.set(  numCopyArr, min(numIds,roll.count), json.get(numCopyArr, min(numIds,roll.count)) + 1  )]\n}]\n\n[h: sizeList\t= \"Fine, Diminutive, Tiny, Small, Medium, Large, Huge, Giant, Gargantuan, Colossal\"]\n[h, if(sizeRange == 5): sizeStr\t= \"[r:listGet(sizeList, 1d10-1)]\"); sizeStr\t= \"[r:listGet(sizeList, 1d\" + (2*sizeRange+1) + \"+\" + (3-sizeRange) + \")]\" ]\n[h, if(sizeRange == \"-1\"): sizeStr\t= \"\" ]\n[h: spreadChkList\t= \"[]\"]\n[h,for(i, 0, numIds), code: {\n\t[obj\t\t= json.get(ids, i)]\n\t[copies\t\t= json.get(numCopyArr, i)]\n\t\n\t[centreX\t= getTokenX(0, if(centreTok == \"\", obj, centreTok))]\n\t[centreY\t= getTokenY(0, if(centreTok == \"\", obj, centreTok))]\n\n\t[xstr\t\t= \"centreX\" + (-1 * (distWest + 1)) + \"+ 1d\" + (distWest + distEast + 1)]\n\t[ystr\t\t= \"centreY\" + (-1 * (distNorth + 1)) + \"+ 1d\" + (distNorth + distSouth + 1)]\n\n\t[updates\t= json.set(\"{}\", \"layer\", layer)]\n\t[updates\t= json.set(updates, \"useDistance\", 0)]\n\t[if(rotStr != \"\"): updates\t= json.set(updates, \"facing\", \"[r:\" + rotStr + \"]\")]\n\t[updates\t= json.set(updates, \"x\", \"[r:\" + xstr + \"]\")]\n\t[updates\t= json.set(updates, \"y\", \"[r:\" + ystr + \"]\")]\n\t[if(sizeStr != \"\"): updates\t= json.set(updates, \"size\", sizeStr)]\n\t[copies\t\t= copyToken(obj, copies, map, updates)]\n\t[spreadChkList\t= json.merge(spreadChkList, copies)]\n\n\t['tmp\t= bot_ids2Names(spreadChkList)']\n\t['tmp1\t= bot_ids2Names(copies)']\n\t['pause(\"tmp\",\"tmp1\")']\n}]\n\n[spreadChkList\t\t= bot_ids2NamesArray(spreadChkList)]\n\n[h,if(spread > -1), CODE: {\n\t[txt\t= \"All the tokens have now been scattered in the designated area. Now the field will be checked for the 'spreading'. Any token closer than \"+spread+\" will be removed. Press cancel if you do not want this.<br><br><b>Note<\/b> that this will mean that the resulting amount of tokens will be less then the 'Number of Copies' you have set.<br><br>(also note that this pause is vital, so don't remove it from the code)\"]\n\t[pause(\"txt\")]\n\t[bot_abortProcess(1)]\n\t[link\t= macroLinkText(\"deferRemoveToken@lib:onTokenMove\",\"none\",json.append(\"\",spreadChkList,layer,spread,tokenName,json.length(spreadChkList),macro,spreadChkList))]\n\t[execLink(link,1)]\n}; {\n\t['broadcast(spreadChkList)']\n\t[if(macro == \"createCrowd\"):setLibProperty(\"crowd\", spreadChkList, \"lib:EventMacros\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4bdd8dc9-b029-45d9-a5b1-38239c3ce195",
          "commandChecksum": "c379535dda4a912e7c97989c0df3bd17",
          "propsChecksum": "f90332622ef051e43a60553ff6dce64b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "b. bubblobill Input String Builder",
        "includeLabel": false,
        "sortBy": "b. bubblobill Input String Builder",
        "index": 262,
        "label": "buildInputString",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n\n[h,code:{\n[inData=macro.args][inType=''][inputDisplay=''][newString=''][prevStrings=json.fromList(\"\")][runFrom=getMacroLocation()]\n[TEXT=\"Text\"]\n\t[txtvarName=\"myTextVar\"][txtprompt=\"TextLabel\"][txtspan=\"\"][txtspanchk=\"\"][txtvalue=\"DefaultText\"][txtwidth=\"16\"]\n[LIST=\"Listbox\"]\n\t[lstvarName=\"myListVar\"][lstlabel=\"ListboxName\"][lstspan=\"\"][lstspanchk=\"\"][lstvalue=\"String, List, Example\"][lstindex=\"0\"][lststring=\"\"]\n[CHECK=\"Checkbox\"]\n\t[chkvarName=\"myCheckVar\"][chkprompt=\"CheckboxName\"][chkspan=\"\"][chkspanchk=\"\"][chkvalue=\"0\"]\n[RADIO=\"Radio button\"]\n\t[radvarName=\"myRadioVar\"][radprompt=\"RadioGroupName\"][radspan=\"\"][radspanchk=\"\"][radvalues=\"String, List, Example\"][radvalue=\"0\"][radstring=\"\"][radorient=\"\"]\n[LABEL=\"Label\"]\n\t[lblprompt=\"LabelName\"][lblvalue=\"<b>LabelContent<\/b>\"][lblspan=\"\"][lblspanchk=\"\"]\n[PROPS=\"Props\"]\n\t[propvarName=\"myPropVar\"][propprompt=\"PropListGroupName\"][propspan=\"\"][propspanchk=\"\"][propvalue=encode(\"String=Prop; List=example\")][propvar=\"\"][propvar_=\"\"]\n[TAB=\"Tab\"]\n\t[tabvarName=\"myTabVar\"][tabvalue=\"TabName\"][tabstart=\"\"]\n[SHOW=\"Show\"]\n}]\n\n\n[h,if(!json.isEmpty(macro.args)==1),code:{\n\n\t\n\n\t\n\t[types=\"TEXT,LIST,CHECK,RADIO,LABEL,PROPS,TAB,SHOW\"]\n\t[foreach(type,types):inType=add(inType,json.get(inData,type))]\n\n\t\n\t[varList=json.fields(inData)]\n\t[foreach(var,varList),CODE:{\n\t\t[value = json.get(inData,var)]\n\t\t[set(var,value)]\n\t\t}]\n\t[propvalue=decode(propvalue)]\n\t[prevStrings=decode(prevStrings)]\n\n\t\n\t[switch(inType),code:\n\tcase \"Text\":\t{[newString=strformat(\"'%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}<\/html>|TEXT|WIDTH=%{txtwidth} %{txtspan}'\")]};\n\tcase \"Text\":\t{[newString=strformat(\"'%{newString}%{txtvarName}|%{txtvalue}|<html>%{txtprompt}<\/html>|TEXT|WIDTH=%{txtwidth} %{txtspan}'\")] };\n\tcase \"Listbox\":\t{[newString=strformat(\"'%{newString}%{lstvarName}|%{lstvalue}|<html>%{lstlabel}<\/html>|LIST|%{lstspan} %{lststring} SELECT=%{lstindex}'\")]};\n\tcase \"Checkbox\":{[newString=strformat(\"'%{newString}%{chkvarName}|%{chkvalue}|<html>%{chkprompt}<\/html>|CHECK|%{chkspan}'\")]};\n\tcase \"Radio button\":\t{[newString=strformat(\"'%{newString}%{radvarName}|%{radvalues}|%{radprompt}|RADIO|SELECT=%{radvalue} %{radspan} %{radstring} %{radorient}'\")]};\n\tcase \"Label\":\t{[newString=strformat(\"'%{newString}junkvar|<html>%{lblvalue}<\/html>|%{lblprompt}|LABEL|%{lblspan}'\")]};\n\tcase \"Props\":\t{[newString=strformat(\"'%{newString}%{propvarName}|%{propvalue}|%{propprompt}|PROPS|%{propspan} %{propvar} %{propvar_}'\")]};\n\tcase \"Tab\":\t\t{[newString=strformat(\"'%{newString}%{tabvarName}|%{tabvalue}||TAB|%{tabstart} '\")]};\n\tcase \"Show\":\t{[newString=\" \")]}\n\t]\n\t\n\t\n\t\n\t[if(prevStrings==\"\"): inputDisplay=newString; inputDisplay = strformat (\"'%{prevStrings}'%{newString}\")]\n\t[inputDisplay=replace(inputDisplay,\"&#\"+59,\";\")]\n\t[inputDisplay=replace(inputDisplay,\"<(.*?)>\",\"<\\$1>\")]\n\t[inputDisplay=replace(inputDisplay,\"''\",\" ## \")]\n\t};{\n\n\t\n\t[h, if (runFrom == \"token\"):setSpeech(\"input\",\"\");\"\"]\n\n}]\n\n\n[h:formLink = macroLinkText(\"buildInputString@lib:OnTokenMove\",\"\",\"\",\"\")]\n\n[h:CHECKED=string('CHECKED=\"CHECKED\"')][h:SPAN=string('SPAN=TRUE')][h:STRINGVALUE=string('VALUE=STRING')]\n\n\n[h,code:{\n[txtspanchk=if(txtspan==SPAN,CHECKED,\"\")]\n[lstspanchk=if(lstspan==SPAN,CHECKED,\"\")]\n[chkspanchk=if(chkspan==SPAN,CHECKED,\"\")]\n[radspanchk=if(radspan==SPAN,CHECKED,\"\")]\n[lblspanchk=if(lblspan==SPAN,CHECKED,\"\")]\n[propspanchk=if(propspan==SPAN,CHECKED,\"\")]\n[chkvaluechk=if(chkvalue==1,CHECKED,\"\")]\n[lststringchk=if(lststring==STRINGVALUE,CHECKED,\"\")]\n[radstringchk=if(radstring==STRINGVALUE,CHECKED,\"\")]\n[radorientchk=if(radorient==\"ORIENT=H\",CHECKED,\"\")]\n[propvarchk=if(propvar==\"SETVARS=UNSUFFIXED\", CHECKED,\"\")]\n[propvar_chk=if(propvar_==\"SETVARS=SUFFIXED\",CHECKED,\"\")]\n}]\n\n[h:css='<style>\ntable.mytable \t\t{ color:black }\ntable.mytable th \t{ background-color: #660066; font-weight:bold; color:white }\ntable.mytable tr\t{ background-color: #C0C0C0 }\ntable.mytable .alt \t{ background-color: #FFFFFF }\ntable.table2 tr td \t{ background-color: #FFFFEE; color: black }\ntable.table2 .note \t{ background-color: #FFFFFF; color: blue }\n<\/style>']\n\n\n[h:displayString='<html>\n<head>\n<title>Build input string<\/title>\n'+css+'\n<\/head>\n<form action=\"'+formLink+'\" method=json >\n\n<table width=100% class=\"mytable\">\n\t<tr>\n\t\t<th><\/th>\n\t\t<th>Variable name\t\t\t\t\t\t\t<\/th>\n\t\t<th>Label / Prompt / Tooltip\t\t\t\t<\/th>\n\t\t<th>Hide<br>label\t\t\t\t\t\t\t<\/th>\n\t\t<th colspan=2>Prefill / value\t\t\t\t<\/th>\n\t\t<th colspan=2 align=right width=80>Options\t<\/th>\n\t\t<th colspan=5>\t\t\t\t\t\t\t\t<\/th>\n\t\t<\/tr>\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"TAB\" value=\"Tab\">\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"tabvarName\" size=\"18\" maxlength=\"\" value=\"'+tabvarname+'\">\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"tabvalue\" size=\"18\" maxlength=\"\" value=\"'+tabvalue+'\">\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\tStarting tab\t\t<\/td><td><input type=\"checkbox\" name=\"tabstart\" value=\"SELECT=TRUE\"><\/td>\n\t\t<\/tr>\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"TEXT\" value=\"Text\">\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"txtvarName\" size=\"18\" maxlength=\"\" value=\"'+txtvarName+'\">\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"txtprompt\" size=\"18\" maxlength=\"\" value=\"'+txtprompt+'\">\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"txtspan\" value=\"SPAN=TRUE\" '+txtspanchk+'>\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"txtvalue\" size=\"18\" maxlength=\"\" value=\"'+txtvalue+'\">\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tField width\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t<input type=\"text\" name=\"txtwidth\" size=\"3\" maxlength=\"\" value=\"'+txtwidth+'\">\t\t\t\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"LIST\" value=\"Listbox\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lstvarName\" size=\"18\" maxlength=\"\" value=\"'+lstvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lstlabel\" size=\"18\" maxlength=\"\" value=\"'+lstlabel+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"lstspan\" value=\"SPAN=TRUE\" '+lstspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"lstvalue\" size=\"18\" maxlength=\"\" value=\"'+lstvalue+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tPreselect index\t\t<\/td><td><input type=\"text\" name=\"lstindex\" size=\"3\" maxlength=\"\" value=\"'+lstindex+'\">\t<\/td>\n\t\t<td align=right>\t\t\t\tSet string not no.\t<\/td><td><input type=\"checkbox\" name=\"lststring\" value=\"VALUE=STRING\" '+lststringchk+'>\t<\/td>\n\t\t<\/tr>\n\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"CHECK\" value=\"Checkbox\">\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"chkvarName\" size=\"18\" maxlength=\"\" value=\"'+chkvarName+'\">\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"chkprompt\" size=\"18\" maxlength=\"\" value=\"'+chkprompt+'\">\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"chkspan\" value=\"SPAN=TRUE\" '+chkspanchk+'>\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\tChecked\t\t\t\t<\/td><td><input type=\"checkbox\" name=\"chkvalue\"value=\"1\" '+chkvaluechk+'>\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"RADIO\" value=\"Radio button\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"radvarName\" size=\"18\" maxlength=\"\" value=\"'+radvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"radprompt\" size=\"18\" maxlength=\"\" value=\"'+radprompt+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"radspan\" value=\"SPAN=TRUE\" '+radspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"radvalues\" size=\"18\" maxlength=\"\" value=\"'+radvalues+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tPreselect index\t\t<\/td><td><input type=\"text\" name=\"radvalue\" size=\"3\" maxlength=\"\" value=\"'+radvalue+'\">\t<\/td>\n\t\t<td align=right>\t\t\t\tSet string not no.\t<\/td><td><input type=\"checkbox\" name=\"radstring\" value=\"VALUE=STRING\", '+radstringchk+'><\/td>\n\t\t<td align=right>\t\t\t\tHorizontal\t\t\t<\/td><td><input type=\"checkbox\" name=\"radorient\" value=\"ORIENT=H\" '+radorientchk+'>\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"LABEL\" value=\"Label\">\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"lblprompt\" size=\"18\" maxlength=\"\" value=\"'+lblprompt+'\">\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"lblspan\" value=\"SPAN=TRUE\" '+lblspanchk+'>\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"lblvalue\" size=\"18\" maxlength=\"\" value=\"'+lblvalue+'\">\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<\/tr>\n\n\t<tr>\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"PROPS\" value=\"Props\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"propvarName\" size=\"18\" maxlength=\"\" value=\"'+propvarName+'\">\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right>\t\t\t\t<input type=\"text\" name=\"propprompt\" size=\"18\" maxlength=\"\" value=\"'+propprompt+'\">\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=center>\t\t\t\t<input type=\"checkbox\" name=\"propspan\" value=\"SPAN=TRUE\" '+propspanchk+'>\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\t<input type=\"text\" name=\"propvalue\" size=\"18\" maxlength=\"\" value=\"'+decode(propvalue)+'\">\t\t\t\t\t\t<\/td>\n\t\t<td align=right colspan=2>\t\tSet variables (var)\t<\/td><td><input type=\"checkbox\" name=\"propvar\" value=\"SETVARS=UNSUFFIXED\" '+propvarchk+'>\t<\/td>\n\t\t<td align=right>\t\t\t\tSet variables (var_)<\/td><td><input type=\"checkbox\" name=\"propvar_\" value=\"SETVARS=SUFFIXED\" '+propvar_chk+'>\t<\/td>\n\t\t<\/tr>\n\t\t\n\t<tr class=\"alt\">\n\t\t<td align=right bgcolor=#A0A0A0><input type=\"submit\" name=\"SHOW\" value=\"Show\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<\/td>\n\t\t\t<td colspan=12>\n\t\t\t\n\t\t\t\t<table width=100% border=1>\n\t\t\t\t\t<table border=0 width=100% class=\"table2\">\n\t\t\t\t\t<td><\/td><td align=center><b>Input String<\/b><\/style><\/td><td><\/td>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td width=4%><\/td>\n\t\t\t\t\t\t\t<td width=92% border=1 height=90 class=\"note\" align=center><textarea name=\"prevStrings\" cols=\"104\" rows=\"7\">'+decode(inputDisplay)+'<\/textarea>\n\t\t\t\t\t\t\t<td width=4%><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td><\/td><td><\/td><td><\/td>\n\t\t\t\t\t\t\t<\/tr>\n\t\t\t\t\t<\/table>\n\t\t\t\t<\/table>\n\t\t\t<\/td>\n\t\t<\/tr>\n<\/table>\n<\/form>\n<\/html>']\n\n\n[r:inputDisplay]\n[h:inString=replace(inputDisplay,\"<(.*?)>\",\"<\\$1>\")]\n[h:input(inString)]\n[h, if (runFrom == \"token\"):setSpeech(\"input\",inString);\"\"]\n<br>\n\n\n[r,dialog('Input String Builder','width=1050; height=540; temporary=1;'):\n{\n[r:displayString]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bd917860-88f6-4211-832c-c58f7ca83bf5",
          "commandChecksum": "fdbfcf874c568c7fa24b79b1b9d4d412",
          "propsChecksum": "81a48f0d74ef1459cc82123c8e4ec3e1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 263,
        "label": "clearGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount()>0):switchToken(arg(0)); switchToken(listGet(getSelectedNames(),0))]\n[h:'assert(startsWith(token.label,\"group\"),\"This token does not belong to a group\",0)']\n[h:groupName = token.label]\n[h:tokList = getProperty(\"w42.boT.\"+token.label)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):resetProperty(\"w42.boT.\"+token.label)]\n\t[token(tmpTok):token.label=\"\"]\n}]\n[h:resetProperty(\"w42.boT.\"+token.label)]\n[h:token.label=\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e86d8b2d-6074-46a2-900a-edf4a3138716",
          "commandChecksum": "4d1913516da3a2d3b5adbfddcc4d9d16",
          "propsChecksum": "2965f79a11bb6d67fe2ed62dd985fe4b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 264,
        "label": "contractGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX()]\n[h:y0 = getTokenY()]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+round(0.5*(getTokenX()-x0),0), y0+round(0.5*(getTokenY()-y0),0))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "10d254f9-e56b-46d5-9e49-6c0fdb1abcfe",
          "commandChecksum": "fd592130b3ac283f4ca4eb97fab35c39",
          "propsChecksum": "3832aa26d9dddc7cfb59281d85fcc123"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 265,
        "label": "formationEchelon",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+roll.count, y0+roll.count, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f94bf23c-7717-41e0-9299-9d608351613c",
          "commandChecksum": "1a8fd46294599497d49f4dd3d8578928",
          "propsChecksum": "219a2cb4ed3236b2447605d7d8020164"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 266,
        "label": "formationLine",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+roll.count, y0, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e5a991a6-6245-456e-8e2e-6400fd339032",
          "commandChecksum": "97391d1f1e7e580f850bc05c835ad339",
          "propsChecksum": "f5c57caed4de9fa0c0d013002e381a7a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 267,
        "label": "formationPWedge",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:length\t\t= floor(numToks/4)]\n[h:tokCount\t= 0]\n[h,for(yF,0,length+2), CODE:{\n\t[for(xF,-yF,+yF+1), CODE:{\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9670dbc0-fa89-41a6-8df3-fdcfddcda28e",
          "commandChecksum": "0a09a38e1442c2c5f66095cbac329c27",
          "propsChecksum": "24c66ade1ad3a363a0f93cdc3f9a11c9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 268,
        "label": "formationSquare",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[yF = floor((roll.count) / width)]\n\t[xF = roll.count - yF*width]\n\t[token(tmpTok):moveToken(x0+xF, y0+yF, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7c66346b-7391-4ef4-9044-42d0811d752f",
          "commandChecksum": "3d8787c2d7987f7bd683188430a9e3b1",
          "propsChecksum": "09b94f2391f2850abe6166052fbeb53c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 269,
        "label": "formationStagger",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = listAppend(currentToken(), getProperty(\"w42.boT.\"+token.label)); tokList = getSelectedNames()]\n\n[h:numToks\t= listCount(tokList)]\n[h:width\t\t= round(sqrt(numToks),0)]\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+if(odd(roll.count),1,0), y0+roll.count, 0)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "314d5ae6-c45d-448c-9db5-4b8770190eff",
          "commandChecksum": "75f0fe97ed1ae341c87a88fc9ec033e9",
          "propsChecksum": "c4e6dad5b359bfb57a18efe1a7c015c3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 270,
        "label": "formationWedge",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:selToks = getSelected()]\n[h:switchToken(listGet(selToks,0))]\n[h:x0 = getTokenX(0)]\n[h:y0 = getTokenY(0)]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = listDelete(selToks,listFind(selToks, currentToken()))]\n\n[h:numToks\t= listCount(tokList)]\n[h:length\t= floor(numToks-1/2)]\n[h:tokCount\t= 0]\n[h,for(yF,1,length+1), CODE:{\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0-yF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\n\t\t[tmpTok = listGet(tokList, tokCount)]\n\t\t[token(tmpTok):moveToken(x0+yF, y0+yF, 0)]\n\t\t[tokCount = tokCount +1]\n\t\t[assert(tokCount < numToks,\"\",0)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8cfe2688-60d1-4218-a502-ce55fb24c8c4",
          "commandChecksum": "29c8d523ae6f65153086d868a4f09924",
          "propsChecksum": "4f47b69beda9f0ee012ca5aa888147dc"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 271,
        "label": "rotateCCW",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_rotateGroup(90)]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "92f72983-1c7d-466c-8f50-a00194f9b3a4",
          "commandChecksum": "2848b05ed40bcf92c58ebadf40b06767",
          "propsChecksum": "7dcdb1a53a08a487fe1e95e2fa83d394"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 272,
        "label": "rotateCCW BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:selected\t= getSelectedNames()]\n[h:switchToken(listGet(selected,0))]\n[h:x0\t\t= getTokenX()]\n[h:y0\t\t= getTokenY()]\n[h:SG\t\t= isSnapToGrid()]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h, if(SG), CODE:{\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken(getTokenY(1, tmpTok)-y0+x0, y0-getTokenX(1, tmpTok)+x0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+90, tmpTok)]\n\t}]\t\n};{\n\t[fDiff\t= 45]\n\t[fCurr\t= getTokenFacing()]\n\t[if(listCount(selected) == 1 && fCurr != \"\"), CODE:{\n\t\t[fOld\t= getProperty(\"w42.bot.oldFacing\")]\n\t\t[if(fOld == \"\"): fDiff = fCurr ; fDiff = fCurr - fOld)]\n\t\t[setProperty(\"w42.bot.oldFacing\", fCurr)]\n\t};{}]\t\n\t[a\t\t= bot_toRadians(fDiff)]\n\t[cos\t= bot_cos(a)]\n\t[sin\t= bot_sin(a)]\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken((getTokenX(1,tmpTok)-x0)*cos + (getTokenY(1,tmpTok)-y0)*sin + x0, -(getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)+fDiff, tmpTok)]\n\t}]\t\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a56544be-5e31-4285-8ccc-8d7a86b5ffaf",
          "commandChecksum": "f5050d9fc368a9e2feafc65fc35ac1ef",
          "propsChecksum": "6fece74435087c2f29b99cb20678b755"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 273,
        "label": "rotateCW",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_rotateGroup(-90)]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a8858340-1e00-4c8f-b27b-18480ee16c66",
          "commandChecksum": "b8e785af60d14a727a32c149e028dea9",
          "propsChecksum": "23d6b02ffa497b544310543364ca8d58"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 274,
        "label": "rotateCW BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:selected\t= getSelectedNames()]\n[h:switchToken(listGet(selected,0))]\n[h:x0\t\t= getTokenX()]\n[h:y0\t\t= getTokenY()]\n[h:SG\t\t= isSnapToGrid()]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h, if(SG), CODE:{\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken(-getTokenY(1, tmpTok)+y0+x0, getTokenX(1, tmpTok)+y0-x0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-90, tmpTok)]\n\t}]\n};{\n\t[fDiff\t= 45]\n\t[a\t\t= bot_toRadians(fDiff)]\n\t[fCurr\t= getTokenFacing()]\n\t[if(listCount(selected) == 1 && fCurr != \"\"), CODE:{\n\t\t[fOld\t= getProperty(\"w42.bot.oldFacing\")]\n\t\t[if(fOld == \"\"): fDiff = fCurr ; fDiff = fCurr - fOld)]\n\t\t[fDiff\t= 360-fDiff]\n\t\t[a\t\t= bot_toRadians(fDiff)]\n\t\t[setProperty(\"w42.bot.oldFacing\", fCurr)]\n\t};{}]\t\n\t[cos\t= bot_cos(a)]\n\t[sin\t= bot_sin(a)]\n\t[foreach(tmpTok,tokList),CODE:{\n\t\t[moveToken((getTokenX(1,tmpTok)-x0)*cos - (getTokenY(1,tmpTok)-y0)*sin + x0, (getTokenX(1,tmpTok)-x0)*sin + (getTokenY(1,tmpTok)-y0)*cos + y0, 1, tmpTok)]\n\t\t[bot_setTokenFacing(bot_getTokenFacing(tmpTok)-fDiff, tmpTok)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0b61cf31-6940-4dbc-a771-20f07302ecec",
          "commandChecksum": "e39198d8585459b22b36ccfdea8a35be",
          "propsChecksum": "792810d1749153a9d806f76d7c4a90e1"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "8. Group Move",
        "includeLabel": false,
        "sortBy": "8. Group Move",
        "index": 275,
        "label": "rotateGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[debug=0]\n\n\n[rotation\t= arg(0)]\n[assert(rotation/90 == floor(rotation/90), \"You can only give multiples of 90 degrees\",0)]\n\n[if(argCount() > 1): toks\t= arg(1) ; toks\t= getSelectedNames()]\n[assert(listCount(toks) > 0, \"Make sure you have a centreTok AND its otherToks selected\",0)]\n\n\n[foreach(tok,toks), CODE:{\n\t[bot_setTokenFacing(bot_getTokenFacing(tok) + rotation,tok)]\n}]\n[centreTok\t= listGet(toks, 0)]\n[otherToks\t= listDelete(toks,0)]\n\n\n[X0\t= getTokenX(1, centreTok)\t+ round(getTokenWidth(centreTok)/2)]\n[Y0\t= getTokenY(1, centreTok)\t+ round(getTokenHeight(centreTok)/2)]\n\n\n[stepSize\t= if(rotation<0, -90, 90)]\n[for(rot, 0, rotation, stepSize), CODE:{\n[foreach(tok, otherToks), CODE:{\n\t\t\n\t\t\n\t\t[sizeDoor\t= round(max(getTokenWidth(tok),getTokenHeight(tok)))]\n\t\t\n\t\t[XD\t\t\t= getTokenX(1, tok)]\n\t\t[YD\t\t\t= getTokenY(1, tok)]\n\t\t\n\t\t[X\t\t\t= if(rotation < 0, -1, 1)*(YD-Y0) + X0 - if(rotation < 0, sizeDoor, 0)]\n\t\t[Y\t\t\t= if(rotation > 0, -1, 1)*(XD-X0) + Y0 - if(rotation > 0, sizeDoor, 0)]\n\t\t[if(debug == 1): pause(\"X0\",\"Y0\",\"XD\",\"YD\",\"X\",\"Y\",\"centreTok\",\"tok\",\"sizeDoor\")]\n\t\t[moveToken(X,Y,1,tok)]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "tokens in the group CANNOT be set to freesize",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "40f9695e-7e9b-4e7e-b4bd-8a78d5669848",
          "commandChecksum": "352c1f40d5beb0221fa35fa0532d4c66",
          "propsChecksum": "b65e0d8aaff102a7362ee69c060b7487"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 276,
        "label": "setGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h,if(argCount()): grpList = arg(0) ; grpList = getSelectedNames()]\n[h,if(argCount()>1): name = arg(1) ; name=\"name\"]\n[h,if(argCount()>1): askName = 0 ; askName = 1]\n\n\n[h, foreach(tok, grpList), CODE:{\n\t[token(tok),if(startsWith(token.label, \"group_\")), CODE:{\n\t\t[name = substring(token.label, 6)]\n\t\t[bot_clearGroup(tok)]\t\n\t}; {}]\n}]\n\n\n[h, if(askName):abort(input(\"name|\"+name+\"|Enter name (no spaces)\"))]\n\n[h, foreach(tok, grpList), CODE:{\n\t[switchToken(tok)]\n\t\n\t[token.label = \"group_\"+name]\n\t\n\t[tmpList = listDelete(grpList, listFind(grpList, tok))]\n\t\n\t[setProperty(\"w42.boT.\"+token.label, tmpList)]\n}]\n[r:grpList+\" have grouped into one group names: \"+name]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9204b7ea-cc4a-4894-82d6-741c6060f1c8",
          "commandChecksum": "97f324a0df3eaff7f0300d77c85835eb",
          "propsChecksum": "c1ba9d587923914c6023fd201ed49cdd"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 277,
        "label": "spreadGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:switchToken(listGet(getSelectedNames(),0))]\n[h:x0 = getTokenX()]\n[h:y0 = getTokenY()]\n\n\n[h,if(startsWith(token.label,\"group_\")):tokList = getProperty(\"w42.boT.\"+token.label); tokList = getSelectedNames()]\n\n[h,foreach(tmpTok,tokList), CODE:{\n\t[token(tmpTok):moveToken(x0+2*(getTokenX()-x0), y0+2*(getTokenY()-y0))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b8b79e84-2e98-469a-b25b-46b4b6eb4ee7",
          "commandChecksum": "9427ff532e6eacf936e433895c793cda",
          "propsChecksum": "e1013778f8013115331aaecd18337ef6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 278,
        "label": "clearSelectGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:tokenId\t= listGet(getSelected(),0)]\n[h:groupTokenLst\t= getProperty(\"w42.bot.groupToken\", tokenId)]\n[h, foreach(tok, groupTokenLst), if(findToken(tok)!=\"\"):resetProperty(\"w42.bot.groupToken\", tok)]\n\n[h:broadcast(\"Tokens have been ungrouped.\")]",
        "maxWidth": "",
        "tooltip": "<html>This ungroups a 'Select Group'. You only need to select one token of the group to ungroup the entire group",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "70f486be-7c89-4fbc-ac49-9c2a00283800",
          "commandChecksum": "3a1d0c699ad1eaec0b2e72da6b892e65",
          "propsChecksum": "3354701545bb49eef7f57abf30578882"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 279,
        "label": "groupFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h,if(argCount()): tooMany\t= arg(0) ; tooMany\t= 0]\n[frame(\"Group Select Panel\", \"width=70; height=4; temporary=1\"): {\n\t<html>\n\t\t<head>\n\t\t\t<link rel='onChangeSelection' type='macro' href='[r: macroLinkText(\"groupHandler@Lib:OnTokenMove\", \"none\")]'>\n\t\t<\/head>\n\t\t<body>\n\t\t\t[r:if(tooMany, \"Group Select Panel is deactivated cause their are currently too many tokens selected: \"+tooMany+\"<br>\", \"\")]\n\t\t\tPlease leave this frame open, it auto selects the 'siblings' of a 'select group'\n\t\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "09279a03-ef42-4329-acba-188ed44a2cdb",
          "commandChecksum": "c53cee85d725681865de412a70a2ec56",
          "propsChecksum": "53ad0e0772df0b1be462bdf2ef8a1491"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 280,
        "label": "groupHandler",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:currentSelection\t= getSelected(\"json\")]\n\n[h:maxGroupSelect\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:numSelect\t\t= json.length(currentSelection)]\n[h,if(numSelect > maxGroupSelect), CODE:{\n\t[bot_groupFrame(numSelect)]\n\t[abort(0)]\n};{}]\n\n\n[h, if(bot_timeOut(2)), CODE:{\n\t[bot_resetTimer(2)]\n\t[lastSelection\t= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]\n\t\n\t[redoSelection\t= if(numSelect == 1 && json.length(lastSelection) > 1 && json.length(json.intersection(lastSelection, currentSelection)) == 1,1,0)]\n\t[if(redoSelection):newSelection\t= lastSelection ; newSelection\t= json.difference(currentSelection, lastSelection)]\n\t[if(json.length(newSelection) >= 1), CODE:{\t\n\t\t\n\t\t[toSelect\t= \"[]\"]\n\t\t[foreach(tok, newSelection): toSelect = json.union(toSelect, if(json.type(getProperty(\"w42.bot.groupToken\", tok))=='ARRAY', getProperty(\"w42.bot.groupToken\", tok), '[]')))]\n\t\t\n\t\t[groupTokenLst\t= json.difference(json.unique(toSelect), currentSelection)]\n\t\t\n\t\t[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,\"json\")]\n\t};{}]\n\n\t[if(isFrameVisible(\"Draw Order\")), CODE:{\n\t\t[maxOrderSelect\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n\t\t[if(numSelect > maxOrderSelect): bot_orderWarning(numSelect) ; bot_orderFrame()] \n\t};{}]\n\n\t\n\t[bot_resetTimer(2)]\n\t[setLibProperty('lastSelection.GroupSelect', getSelected(\"json\"), 'lib:EventMacros')]\n}; {\n\t\n\t[lastSelection\t= getLibProperty('lastSelection.GroupSelect','lib:EventMacros')]\n\t[groupTokenLst\t= json.difference(lastSelection, currentSelection)]\n\t[if(json.length(groupTokenLst)): selectTokens(groupTokenLst,1,\"json\")]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fba6533b-79c9-4ea6-84e6-8987d1381f22",
          "commandChecksum": "174cbc02d03ed0161d745421c3f77084",
          "propsChecksum": "c7aeaaf96c004dd1fe8ee8569265fd63"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 281,
        "label": "openGroupFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n[h:userList\t= getAllPlayerNames()]\n\n[h,if(listCount(userList) != 1), CODE:{\n\t[h:'']\n\t[h:inputStr\t= \"junk|<html><b>Turn on door switches for selected players<br><\/html>|-|LABEL|SPAN=TRUE\"]\n\t[H,FOREACH(player, userList): inputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\n\t[h:'']\n\t[h:abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\n\t[h:playerList = \"\"]\n\t[H,FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t}]\n};{\n\t[h:playerList = userList]\n}]\n\n\n[h:bot_resetTimer(2)]\n[h:setLibProperty('lastSelection.GroupSelect', '[]', 'lib:EventMacros')]\n\n[h:bot_execAllPlayers(\"groupFrame@lib:OnTokenMove\",\"\", playerList)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a 'group select' frame which is required for the 'Select Group' to function.<br>When this panel is closed you can still group and ungroup, but the 'auto select' will only<br>work when this frame is active.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "01e91621-fbc3-4bd0-9f4a-00d8b6ac218e",
          "commandChecksum": "79db991374d118fcf81e05ce29f8adac",
          "propsChecksum": "fd31598ecc024f093f546cb9d867df73"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 282,
        "label": "setSelectGroup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n \n\n[h:selected\t= getSelected(\"json\")]\n[h,foreach(tok, selected): setProperty(\"w42.bot.groupToken\", selected, tok)]\n[h:broadcast(\"Tokens have been grouped.\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro creates a 'select group' of all currently selected tokens.<br>After a group is set (and the group select frame is active) when you<br>select one token of the group, all the other tokens of the group will be<br>automatically selected as well. This is particularly usefull when drawing<br>maps and you want to group a set of tokens into one object.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4f8ece2e-7fed-46f2-82b9-201755b34aac",
          "commandChecksum": "cbb4408215f9d78c7a15520fd9da6b97",
          "propsChecksum": "1bc1b1b6a168e0f34bc40665441b1607"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 287,
        "label": "convertTrapPit",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h, if(argCount()):passResult = arg(0); passResult = 0]\n[h:mapList = getAllMapNames(\"json\")]\n[h:oldMap = getCurrentMapName()]\n\n[h:tmpList = json.toList(mapList)]\n[h:excludedMaps = getLibProperty(\"excludedMaps\", \"lib:EventMacros\")]\n[H:activeMaps = json.difference(mapList,excludedMaps)]\n\n[r,foreach(currentMap,activeMaps), code: {\n\t[h:setCurrentMap(currentMap)]\n\t[h:allToks = getTokenNames(\",\", json.set(\"{}\", \"layer\", json.append(\"\",\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\")))]\n\tFixed following tokens on map <b>{currentMap}<\/b>:\n\t[h:fixedList = \"\"]\n\t[h:i=1]\n\t[h,foreach(me,allToks), CODE:{\n\t\t[isTrap\t= if(startsWith(me,\"Trap \"),1,0)]\n\t\t[isPit\t= if(startsWith(me,\"Pit \"),1,0)]\n\t\t[fixIt\t= if(isPit || isTrap,1,0)]\n\t\t[if(fixIt): padNumber\t= substring(me, indexOf(me, \" \"))]\n\t\t['pause(\"isTrap\", \"isPit\", \"me\", \"padNumber\", \"allToks\")']\n\t\t[if(fixIt): fixIt\t\t= if(isNumber(padNumber),1,0)]\n\t\t\n\t\t[if(fixIt): switchToken(me)]\n\t\t[if(fixIt): token.name = \"EventPad \"+ i]\n\t\t[if(fixIt): i=i+1]\n\t\t\n\t\t[if(fixIt && isTrap): setProperty(\"w42.bot.eventTypeList\", \"movedOn, movedOver, movedReturn\")]\n\t\t[if(fixIt && isPit): setProperty(\"w42.bot.eventTypeList\", \"movedOn, movedOff, movedOver, movedReturn\")]\n\n\t\t[if(fixIt): fixedList = listAppend(fixedList, me)]\n\t}]\n\t{fixedList}\n}]\n[h:setCurrentMap(oldMap)]\n[r:bot_initializePads()]",
        "maxWidth": "",
        "tooltip": "<html>This macro will convert ALL Pits and Traps on ALL (not excluded) maps to EventPads.<br>For pits you will need to rewrite the macro slightly before it works again.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e943fd17-0f41-4b94-a1b8-a2b7d9c434d2",
          "commandChecksum": "5f7de00db1392e000903380f8c98677c",
          "propsChecksum": "4f3d46ca803737ff6359ca0eff34a38d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 288,
        "label": "executeEvent",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h:'']\n\n[h:oldMap = getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n[h:macroLabels\t= getMacros(\",\", \"lib:EventMacros\")]\n\n[h:groupList\t= \"\"]\n[h, foreach(macro, macroLabels, \"<br>\"), CODE:{\n\t[tmp\t\t= getMacroIndexes(macro, \",\", \"lib:EventMacros\")]\n\t[group\t\t= getStrProp(getMacroProps(tmp, \"; \", \"lib:EventMacros\"), \"group\")]\n\t[if(!listContains(groupList, group)): groupList = listAppend(groupList, group)]\n}]\n[h:groupList = listSort(groupList, \"N+\")]\n\n[h:'']\n[h:inputStr\t\t= \"junk|<html><b>Select an event macro from the lists<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n\n[h,foreach(group, groupList), CODE:{\n\t[groupName\t\t= \"group_\"+roll.count]\n\t[macroList\t\t= getMacroGroup(group, \",\", \"lib:EventMacros\")]\n\t[macroNameList\t= \"<none>\"]\n\t[foreach(macro, macroList,\"\"): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(macro, \"; \", \"lib:EventMacros\"), \"label\"))]\n\t[h:macroNameList\t= listSort(macroNameList, \"N+\")]\n\t[if(group == \"\"): group = \"~Ungrouped~\"]\n\t[inputStr\t\t= listAppend(inputStr, groupName+\"|\"+macroNameList+\"|\"+group+\" |LIST|VALUE=STRING\", \"##\")]\n}]\n[h:setCurrentMap(oldMap)]\n\n[h:'']\n[h: inputStr\t\t\t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \", \", \"##\")]\n[H: abort(eval(inputStr))]\n\n[h:'']\n[h,foreach(group, groupList), CODE:{\n\t[choice\t\t= eval(\"group_\"+roll.count)]\n\t[if(choice != \"<none>\"), CODE:{[r,macro(choice+\"@Lib:EventMacros\"): \"\"]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c53f9654-be33-4e43-8259-3b189f451d6b",
          "commandChecksum": "4021fb2f445a5a9ce0100b5af0def126",
          "propsChecksum": "b750970566f286e862b74ea9d904831b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 289,
        "label": "getEventType",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[pathLength\t\t= json.length(lastPath)]\n[triggerLength\t= json.length(eventPadTriggered)]\n\n[startedOnPad\t= if(json.contains(eventPadTriggered,startingLocation),1,0)]\n[endedOnPad\t\t= if(json.contains(eventPadTriggered,currentLocation),1,0)]\n[didMove\t\t= min(1, json.length(lastPath)-1)]\n[sameLength\t\t= if(pathLength == triggerLength, 1, 0)]\n\n\n[if(triggerLength):\ttriggerString = strformat(\"%{startedOnPad}%{endedOnPad}%{didMove}%{sameLength}\") ; triggerString = 0]\n[triggerTypeList\t= \"noInteraction, movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain, movedWard\"]\n[triggerStringList\t= \"0,110,1010,10,1101,1110,1111,1001\"]\n\n\n[if(listContains(triggerStringList, triggerString)): \n\ttriggerType\t\t= listGet(triggerTypeList, listFind(triggerStringList, triggerString))\n; \n\tassert(0,\"Error occured in getEventType: \"+triggerString+\" trigger (started, ended, moved, not left) string is unknown\",1)\n]\n\n[macro.return = triggerType]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9523f979-1b36-4799-b6c2-2801b663f7d6",
          "commandChecksum": "2f4512dca4fc3017031eb00a84257fe9",
          "propsChecksum": "f0abdc53bce11c3b787e781cb885e872"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 290,
        "label": "resetPit",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h, token(getSelected()):  setTokenImage(getTokenPortrait())]",
        "maxWidth": "",
        "tooltip": "<html>This will reset a sprung pit. Select the pit and click this button<br>This macro can also be put on the selection panel of the token.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ac337351-7db6-45de-b55a-2232c1513595",
          "commandChecksum": "54356cc226fc0fac3e9c1d0b96f69ca0",
          "propsChecksum": "05ba159169611ba21b096f81e56bb232"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 291,
        "label": "setEventButton",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug=0]\n[h:assert(isGM(),\"GM only!\",0)]\n\n\n[h:selectedTokens = getSelectedNames()]\n\n[h:assert(listCount(selectedTokens),\"Please select at least one token first before running this macro\",0)]\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\n\n[h:macroIDList\t\t= getMacroGroup(\"Event Button macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n\n[h:setCurrentMap(oldMap)]\n\n[h:me\t\t\t\t= listGet(selectedTokens,0)]\n[h:all.buttonArgs\t= getProperty(\"buttonArgs\",me)]\n\n[h,if(getStrProp(all.buttonArgs, \"macroToCall\")==\"\"), CODE:{\n\t[macroToCall\t= \"name of macro\"]\n\t[buttonArgs\t\t= \"argumentName=give argument;\"]\n};{\n\t[macroToCall\t= getStrProp(all.buttonArgs, \"macroToCall\")]\n\t[buttonArgs\t\t= deleteStrProp(all.buttonArgs, \"macroToCall\")]\n\t\n\t[macroToCall\t= substring(macroToCall, 0, indexOf(macroToCall,\"@\"))]\n}]\n\n[h:assert(macroNameList != \"\",\"First create at least one macro on the lib:EventMacro token with which this eventPad can be associated\",0)]\n[h,if(listContains(macroNameList, macroToCall)):currentMacro = listFind(macroNameList,macroToCall) ; currentMacro = 0]\n\n[h,if(debug == 1):pause(\"macroToCall\", \"macroNameList\", \"currentMacro\", \"buttonArgs\")]\n\n\n[h:abort(input(\n\t'junk|<html><b>Associated Macro<\/b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'<\/u><br>Note that only the macros from the group: \"Event Button macros\" on \"Lib:EventMacros\" are in the drop downlist <\/html>|-|LABEL|SPAN=TRUE',\n\t'macroToCall|'\t+macroNameList\t+'|<html><span title=\"<html><b>Enter here the name of the macro that is used when the button is activated.<\/html>\">Name of associated macro<\/html><\/span><\/html>|LIST|SELECT='+currentMacro,\n\t'buttonArgs|'\t+buttonArgs\t+'|<html><span title=\"<html>Enter the argument(s) to be passed to the activated macro<br>as a stringproperty, e.g."toMap=Fair Haven"<br>Here it is important that both the the arguments name (toMap)<br>and the arguments (Fair Haven) contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a ;.<br>E.g. toMap=Fair Haven;message=Going to Fair Haven.<br><\/html>\">Give arguments for macro<\/html><\/span><\/html>|TEXT|WIDTH=50',\n\t'removeLink|0|<html>Check to remove any macro linked to selected token(s).<\/html>|CHECK'\n))]\n\n[h:macroToCall\t= listGet(macroNameList, macroToCall)]\n[h:buttonArgs\t= setStrProp(buttonArgs, \"macroToCall\", macroToCall+\"@lib:EventMacros\")]\n\n[r,gm,if(removeLink), CODE:{\n\t[h,foreach(me, selectedTokens):resetProperty(\"buttonArgs\", me)]\n\t[r, gm:\"The Macro <u>\"+macroToCall+\"<\/u> is now <b>REMOVED<\/b> from the following token(s)<u> \"+selectedTokens+\"<\/u>.\"]\n};{\n\t[h,foreach(me, selectedTokens):setProperty(\"buttonArgs\", buttonArgs, me)]\n\t[r, gm:\"The Macro <u>\"+macroToCall+\"<\/u> is now linked to the following token(s)<u> \"+selectedTokens+\"<\/u>. This macro will be executed when this (or one of these) tokens are selected: <u>\"+selectedTokens+\"<\/u>. Keep in mind that you first need to run 'Activate Switches' before they work!\"]\n}]\n\n\n[h:selectTokens(selectedTokens,1,\",\")]\n\n[h,if(debug==1), CODE:{\n\t[me\t\t\t= listGet(selectedTokens,0)]\n\t[butArgs\t= getProperty(\"buttonArgs\", me)]\n\t[bot_debugInfo(\"butArgs, me, selectedTokens\",1,1,0, getMacroName(), getMacroLocation() )]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to a Event Button.<br><br>1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the<br>code that is activated when the button, e.g. 'Switch To Map'<br>2. Select the button (any token will do) to which that macro should apply e.g. \"Switch to Fair Haven\"<br>3. Run this macro<br>4. Select \"Switch Map\" from the list<br>5. In the \"Give Arguments\" box enter the arguments as a stringproperty, e.g.\"toMap=Fair Haven\"<br><br>Here it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>contains ONLY alphanumeric  characters!<br>Note that you can give multiple arguments! Just seperate them with a",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bc61f04c-9866-483a-8cb7-58ba62a77681",
          "commandChecksum": "9c42c3ca1c9ac104d5ef2d2304529110",
          "propsChecksum": "8e423fd59a6188ac9bf7ee043c1b7bbb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 292,
        "label": "setEventPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:selectedTokens = getSelectedNames()]\n\n[h:assert(listCount(selectedTokens),\"Please select an EventPad first before running this macro\",0)]\n[h,foreach(me, selectedTokens):assert(startsWith(me, \"EventPad \"),\"Make sure only Eventpad(s) are selected\",0)]\n[h:me = listGet(selectedTokens,0)]\n[h:switchToken(me)]\n\n\n[h:oldMap = getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Pad Macros\", \",\", \"lib:EventMacros\")]\n\t\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"movedOn, movedOff, movedOver, movedNot, movedReturn, movedRemain\"]\n[h:varsFromStrProp(\"movedOn=0; movedOff=0; movedOver=0; movedNot=0; movedReturn=0; movedRemain=0\")]\n[h, foreach(event, eventTypeList): set(event, 1)]\n[h:assert(macroNameList != \"\",\"First create at least one macro on the lib:EventMacro token with which this eventPad can be associated\",0)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n\n[h:abort(input(\n\t'junk|<html><b>Associated Macro<\/b><br>This macro will be linked to ALL currently selected tokens:<br><u>'+selectedTokens+'<\/u><br>Note that only the macros from the group: \"Event Pad macros\" on \"Lib:EventMacros\" are in the drop downlist <\/html>|-|LABEL|SPAN=TRUE',\n\t'macroName|'\t+macroNameList+'|<html><span title=\"<html><b>Enter here the name of the macro that is used when this EventPad is triggered.<\/html>\">Name of associated macro<\/html><\/span><\/html>|LIST|SELECT='+currentMacro,\n\t'junk|<html><b>Which events trigger this pad (all events are mutual exclusive)<\/b><\/html>|-|LABEL|SPAN=TRUE',\n\t'movedOn|'\t\t+movedOn+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves onto this pad<\/b>.<\/html>\">Token moves onto pad<\/html><\/span><\/html>|CHECK',\n\t'movedOff|'\t\t+movedOff+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>leaves this pad.<\/html>\">Token moves off pad<\/html><\/span><\/html>|CHECK',\n\t'movedOver|'\t+movedOver+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves over this pad.<\/html>\">Token moves over pad<\/html><\/span><\/html>|CHECK',\n\t'movedNot|'\t\t+movedNot+\t\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>on this pad is moved<br>from and back to the same postion on this pad<br>without using waypoints.<\/b><br>Note that zero move is turned off per default in the<br>settings, in which case this event will never occur.<\/html>\">Token does zero move on pad<\/html><\/span><\/html>|CHECK',\n\t'movedReturn|'\t+movedReturn+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>moves off this pad<br>and back onto it, using waypoints.<\/html>\">Token leaves and returns onto pad<\/html><\/span><\/html>|CHECK',\n\t'movedRemain|'\t+movedRemain+\t'|<html><span title=\"<html><b>When checked:<\/b> The macro associated with this pad,<br>will be triggered when a token <b>is moved but remains<br>on the pad the entire move.<\/html>\">Token moves but remains on pad<\/html><\/span><\/html>|CHECK'\n))]\n\n[h:macroName = listGet(macroNameList, macroName)]\n\n[h,foreach(me, selectedTokens), CODE:{\n\t[switchToken(me)]\n\t[setProperty(\"w42.bot.macroName\", macroName)]\n\t[eventTypeList = \"\"]\n\t[foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t[setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n}]\n\n[r, gm:\"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+selectedTokens+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList]",
        "maxWidth": "",
        "tooltip": "<html>This macro can be used to link an Event Macro to an EventPad<br><br>1. Create a macro on the lib:EventMacros token in the group:<br>'Event Pad Macros', containing the code that is activated when the<br>Event is triggered. For example 'Spear Trap<br>2. Select an 'Event token'. This is a token which name starts with<br>'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'.<br>This token can be placed on any layer<br>3. Run the macro 'Set Event Pad'<br>4. Pick an Event macro from the list, e.g. 'Standard Pit'<br>5. Then select the events on which this macro is triggered<br>7. Click OK <br>8. Run 'Initialize Maps'<br><br>The Event Pad is now set<br>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2004eb83-9abb-4cf2-9bd1-328bbd8a2c2b",
          "commandChecksum": "f91c8365f9c862682777ab4591aafd6d",
          "propsChecksum": "5ba8ca04bd643f6faa3f190bfcc5e9d9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 293,
        "label": "cos",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[H: radians = arg(0)]\n[H: cosine = 1]\n[H: product = 1]\n[H, for(i,2,21,2), code: {\n   [H: product = product * -1 * i * (i-1)]\n   [H: cosine = cosine + power(radians,i) / product]\n}]\n[H: macro.return = cosine ]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "056574ec-cade-428b-afee-513cf3a5a420",
          "commandChecksum": "85deff6d16d2b708c828cca655daa7a5",
          "propsChecksum": "4030aef5b7fb7d078e5b84ce33796a4e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 294,
        "label": "facingToCoord",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h:macro.return = strformat(\n\t'{\"x\":%s,\"y\":%s}', \n\targ(0) + round(arg(2)*bot_cos(bot_toRadians(arg(3)+90)),0),\n\targ(1) - round(arg(2)*bot_sin(bot_toRadians(arg(3)+90)),0)\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "01e021c4-ae8e-4ce6-896c-99d0a8f280a5",
          "commandChecksum": "1a4d4f3bc5bcd34f944f6a5f6e04f64c",
          "propsChecksum": "0801cb61a4d51aa88372871d3845975e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 295,
        "label": "facingToCoordX",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h:macro.return = arg(0) + round(arg(1)*bot_cos(bot_toRadians(arg(2)+90)),0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8b2245aa-196f-4602-904b-4fa14d5f2914",
          "commandChecksum": "0f083de3db5bdb5d7379ada27814445b",
          "propsChecksum": "eae775fa2b683e01649e25f2283792b7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 296,
        "label": "facingToCoordY",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h:macro.return = arg(0) - round(arg(1)*bot_sin(bot_toRadians(arg(2)+90)),0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "333b466f-bcbe-4288-9ce2-712891cf12f2",
          "commandChecksum": "e5d1147c91b3fed3f3b4eeb6ec1919c5",
          "propsChecksum": "6194a8e98dcf7a1e6685e0a03d0a416e"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 297,
        "label": "getTokenFacing",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h,if(argCount()>0):\tangle\t= getTokenFacing(arg(0)) ; angle\t= getTokenFacing(currentToken())]\n[h,if(argCount()>1):\ttype\t= arg(1) ; type\t= 0]\n\n[h,if(angle == \"\"):\t\tangle\t= -90]\n[h,if(type == 1): \t\tangle\t= angle + 90]\n[h:angle\t= if(angle <0, angle + 360, angle)]\n[r,if(type && angle):\tmacro.return = 360-angle ; macro.return = angle]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d475770-8092-4705-8dd2-ffe5fe2a477a",
          "commandChecksum": "628199b97cd0a47a36544724113917fa",
          "propsChecksum": "b4de496f56be140096c72730bdcd5d56"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 298,
        "label": "mod",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: macro.return = arg(0) - arg(1) * floor(arg(0) / arg(1))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "08f3378e-6d75-4dbf-b8a4-4409cf9aae2c",
          "commandChecksum": "05a7ff2851f7af58be99bc6ff79a4ee2",
          "propsChecksum": "2e3e5d523ac6917ebbf92902ad792b20"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 299,
        "label": "odd",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[r:if(band(arg(0),1) == 0, 0, 1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d5356670-09dd-496a-89cf-a5193043090b",
          "commandChecksum": "78bf12da8ae60a5907cbf9f80de6bdc0",
          "propsChecksum": "4938ad5b2c3ea793f32ecd2567389c69"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 300,
        "label": "pi",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: macro.return = 3.14159265358979323846 ]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f4eea1bc-9bff-467a-97be-da09bdc075fe",
          "commandChecksum": "3c80e35fcbd3709c8307039e46c30624",
          "propsChecksum": "e4fa3be032d3137c379bfe2ba22dd517"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 301,
        "label": "setTokenFacing",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:angle\t= arg(0)]\n[h,if(argCount()>1):\tme\t\t= arg(1) ; me\t\t= currentToken()]\n[h,if(argCount()>2):\ttype\t= arg(2) ; type\t\t= 0]\n\n[h:macro.return = setTokenFacing(if(type, 360-angle-90, angle), me)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "efab08bf-9880-4f9b-88cd-acc94ee525c9",
          "commandChecksum": "d06d3337e3330aa9f0c3b9a2fdc13a57",
          "propsChecksum": "ec28dd086f0788607c9f5e90d484f82b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 302,
        "label": "sin",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[H: radians = arg(0)]\n[H: sine = radians]\n[H: product = 1]\n[H, for(i,3,24,2), code: {\n   [H: product = product * -1 * i * (i-1)]\n   [H: sine = sine + power(radians,i) / product]\n}]\n[H: macro.return = sine]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "45f1ee54-9f59-46ac-a748-055f38ea3754",
          "commandChecksum": "42ed38c6a5b5ae59922c5db69bd3710f",
          "propsChecksum": "90ab21359678ecc1c4cf47eeefe397c9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 303,
        "label": "tan",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: macro.return = bot_sin(arg(0)) / bot_cos(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6b245bae-cd64-434c-846c-3638b0f9b1f3",
          "commandChecksum": "5b6feae0b3aefd5e199e39073c1ef866",
          "propsChecksum": "d6acab4961265eaba5cb6cd9d8c3a878"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 304,
        "label": "toRadians",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[H: macro.return = arg(0) * (bot_pi() / 180)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "971ceec2-2670-4432-b6b9-79402501454a",
          "commandChecksum": "dc67fbddb0b01c444e3688116e231c94",
          "propsChecksum": "eadb77a87d8af1141e870083ff4fd1bf"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "g. Rumbles Delete Macro Utility",
        "index": 305,
        "label": "cpyDelMacros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n\n[h,if(getMacros() != \"\"): fullMacList\t= getMacros(); assert(0, \"There are no macros on the token <b>\"+token.name+\"<\/b>\", 0)]\n[h:fullMacList\t\t= listSort(fullMacList,\"N+\")]\n[h:fullMacList\t\t= json.fromList(fullMacList))]\n[h:macroList\t\t= json.unique(fullMacList)]\n\n\n[h:groupArray\t\t= \"\"]\n[h,foreach(macro,macroList),CODE:{\n\t[indexes\t\t= getMacroIndexes(macro)]\n\t[foreach(index,indexes): \n\t\tgroupArray\t= if(\n\t\t\tgetStrProp(getMacroProps(index),\"group\")\t== \"\", \n\t\t\tjson.append(groupArray, \"__no group name__\"), \n\t\t\tjson.append(groupArray, getStrProp(getMacroProps(index), \"group\"))\n\t\t)\n\t]\n}]\n\n\n[h:groupList\t\t= listSort(json.toList(json.unique(groupArray)), \"N+\")]\n\n[h:macrosInGroup\t= \"{}\"]\n[h,foreach(macroGroup, groupList),CODE:{\n\t[tmpObj\t\t= \"\"]\n\t[foreach(macro,macroList),CODE:{\n\t\t[indexes\t= getMacroIndexes(macro)]\n\t\t[foreach(index, indexes): tmpObj\t= \n\t\t\tif(\n\t\t\t\tif(\tgetStrProp(getMacroProps(index),\"group\") == \"\", \n\t\t\t\t\t\"__no group name__\", \n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")\n\t\t\t\t) == macroGroup,\n\t\t\t\tlistAppend(tmpObj, macro), \n\t\t\t\ttmpObj\n\t\t\t)\n\t\t]\n\t}]\n\t[macrosInGroup\t= json.set(macrosInGroup, macroGroup, tmpObj)]\n}]\n\n[h:inputParams\t\t= json.append(\"\", \n\t\t\t\t\t\t\"initial|ALL MACROS||TAB\",\n\t\t\t\t\t\t\"deleteMacros|Copy Macros, Delete Macros|<html><b>Copy or Delete Selected Macros<\/b><\/html>|RADIO|SELECT=0\",\n\t\t\t\t\t\t\".|<html><b>Copy<\/b> will cache the selected macros to a property on lib:EventMacros.<br>After this is done you can select another token and paste the macros onto them.<br><b>Delete<\/b> will delete the selected macros from this token immediately.<br><br><\/html>||LABEL|SPAN=TRUE\",\n\t\t\t\t\t\t\"doUndo|1|<html><b>Allow Undo<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Allow undo<\/b> will store the macro on the property: <i>rumble.bot.deleteMacroUndo<\/i> on<br>the selected token. This will allow you to undo the deletion later on, but will also<br>increase token size<br><br><\/html>||LABEL|SPAN=TRUE\",\n\t\t\t\t\t\t\"deleteAllMacros|0|<html><b>Select ALL macros<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Select ALL macros from the following groups!<\/b><\/html>||LABEL|SPAN=TRUE\"\n)]\n\n[h,foreach(macroGroup, groupList):\n\tinputParams\t\t= json.append(inputParams, \"groupDelete_\"+roll.count+\"|0|\"+macroGroup+\"|CHECK\")\n)]\n\n[h,foreach(macroGroup, groupList),CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[inputParams\t= json.append(inputParams, \"group_\"+roll.count+\"|\"+macroGroup+\"||TAB\")]\n\t[inputParams\t= json.append(inputParams, \".|<html><b>Select individual macros you wish to copy or delete.<\/b><\/html>||LABEL|SPAN=TRUE\")]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[idx\t\t= getMacroIndexes(macroLabel)]\n\t\t[foreach(index, idx): inputParams\t= \n\t\t\tif(\n\t\t\t\tif(\n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")==\"\", \n\t\t\t\t\t\"__no group name__\", \n\t\t\t\t\tgetStrProp(getMacroProps(index),\"group\")\n\t\t\t\t) == macroGroup, \n\t\t\t\tjson.append(inputParams, \"macro_\"+index+\"|0|<html>\"+macroLabel+\" \"+if(getStrProp(getMacroProps(index),\"tooltip\")==\"\", \"(no tooltip available)\", \"(\"+getStrProp(getMacroProps(index),\"tooltip\")+\")\")+\"<\/html>|CHECK\"), \n\t\t\t\tinputParams\n\t\t\t)\n\t\t]\n\t}]\n}]\n\n\n\n[h:abort(input(json.toList(inputParams, \"##\")))]\n\n[h:deleteGroupList\t= \"\"]\n[h,foreach(macroGroup, groupList),CODE:{\t\n\t[if(eval(\"groupDelete_\"+roll.count)): deleteGroupList\t= listAppend(deleteGroupList, macroGroup)]\n}]\n\n\n[h:backUpMacros\t\t= \"{}\"]\n[h,foreach(macro,macroList),CODE:{\n\t[macroIndexes\t= getMacroIndexes(macro)]\n\t[foreach(index, macroIndexes),code:{\n\t\t[group\t\t= getStrProp(getMacroProps(index),\"group\")]\n\t\t[group\t\t= if(group == \"\", \"__no group name__\", group)]\n\t\t[checked\t= eval(\"macro_\"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] \n\t\t[if(checked): backUpMacros\t= json.set(backUpMacros, macro, getMacroProps(index, \"json\"))]\n\t\t[if(checked && deleteMacros): removeMacro(index)]\n\t }]\n}]\n\n[r, if(deleteMacros), CODE:{\n\t[r,if(doUndo), CODE:{\n\t\t[h:setProperty(\"rumble.bot.deleteMacroUndo\", backUpMacros)]\n\t\tBackup of macros stored on token. <br>\n\t};{}]\n\tMacro(s) removed.\n};{\n\t[h:setLibProperty(\"cpDel.backUpMacros\", backUpMacros, \"lib:EventMacros\")]\n\t[h:setLibProperty(\"cpDel.groupList\", groupList, \"lib:EventMacros\")]\n\t[h:setLibProperty(\"cpDel.macrosInGroup\", macrosInGroup, \"lib:EventMacros\")]\n\tMacro(s) copied.\n}]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to select macros on the selected token. The selected macros you can copy or delete.<br> <br> In case of <b>copy<\/b>, they will be stored in a property on lib:EventMacros. When you select another token you can <br> click <i>Paste Macros<\/i>. This will open a similar frame where you can select the macros to paste on the selected<br> token.<br> In case of <b>delete<\/b> you have the option to <i>allow undo<\/i>. The selected macros will be deleted from the token<br> and if allow undo is turned on, they will be stored in a property on that token. So you can later choose to undo the<br> process. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6b9d2bd5-a6c9-48d5-a2ee-31d55dbfb136",
          "commandChecksum": "fcb97596bbca4e257080b1b46beeab5a",
          "propsChecksum": "ce953f2d0c1b83bbe777506f9e15e3af"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "g. Rumbles Delete Macro Utility",
        "index": 306,
        "label": "pasteMacros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n[h:backUpMacros\t\t= getLibProperty(\"cpDel.backUpMacros\",\t\"lib:EventMacros\")]\n[h:groupList\t\t= getLibProperty(\"cpDel.groupList\",\t\t\"lib:EventMacros\")]\n[h:macrosInGroup\t= getLibProperty(\"cpDel.macrosInGroup\",\t\"lib:EventMacros\")]\n\n[h:assert(json.type(backUpMacros) == \"OBJECT\", \"No back-up macros were ever stored on this token\", 0)]\n[h:assert(json.length(backUpMacros) > 0, \"No macros left to undelete\", 0)]\n\n[h:macroList\t\t= json.fields(backUpMacros)]\n\n[h:inputParams\t\t= json.append(\"\", \n\t\t\t\t\t\t\"initial|ALL MACROS||TAB\",\n\t\t\t\t\t\t\"deleteAllMacros|0|<html><b>Select ALL macros<\/b><\/html>|CHECK\",\n\t\t\t\t\t\t\".|<html><b>Select ALL macros from the following groups!<\/b><\/html>||LABEL|SPAN=TRUE\"\n)]\n\n[h,foreach(macroGroup, groupList):\n\tinputParams\t\t= json.append(inputParams, \"groupDelete_\"+roll.count+\"|0|\"+macroGroup+\"|CHECK\")\n)]\n\n[h:index\t\t\t= 0]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[inputParams\t= json.append(inputParams, \"group_\"+roll.count+\"|\"+macroGroup+\"||TAB\")]\n\t[inputParams\t= json.append(inputParams, \".|<html><b>Select individual macros you wish to paste.<\/b><\/html>||LABEL|SPAN=TRUE\")]\n\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, index, inputParams\", 0,0,0,0,0)]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[macroData\t= json.get(backUpMacros, macroLabel)]\n\t\t[toolTip\t= json.get(macroData, \"tooltip\")]\n\t\t[if(toolTip == \"\"): toolTip ==\"(no tooltip available)\"]\n\t\t[inputParams = json.append(inputParams, \"macro_\"+index+\"|0|<html>\"+macroLabel+\" \"+toolTip+\"<\/html>|CHECK\")]\n\t\t[index\t= index + 1]\n\t\t\n\t\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, macroData, toolTip, index, macroLabel, inputParams\", 0,0,0,0,0)]\n\t}]\n}]\n\n\n\n[h:abort(input(json.toList(inputParams, \"##\")))]\n\n[h:deleteGroupList\t= \"\"]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[if(eval(\"groupDelete_\"+roll.count)): deleteGroupList\t= listAppend(deleteGroupList, macroGroup)]\n}]\n\n[if(debug): pause(\"deleteGroupList\")]\n\n\n[h:index\t\t\t= 0]\n[h,foreach(macroGroup, groupList), CODE:{\t\n\t[macroLabels\t= listSort(json.get(macrosInGroup, macroGroup), \"N+\")]\n\t[foreach(macroLabel, macroLabels),CODE:\t{\n\t\t[macroData\t= json.get(backUpMacros, macroLabel)]\n\t\t[group\t\t= json.get(macroData, \"group\")]\n\t\t[group\t\t= if(group == \"\", \"__no group name__\", group)]\n\t\t[checked\t= eval(\"macro_\"+index) + deleteAllMacros + if(listContains(deleteGroupList, group),1,0)] \n\t\t[if(checked): pasteProps = json.get(backUpMacros, macroLabel)]\n\t\t[if(checked): createMacro(pasteProps)]\n\t\t[index\t= index + 1]\n\t\t[if(debug): bot_debugInfo(\"groupList, macroGroup, macroLabels, macroLabel, group, deleteGroupList, checked, macroData\", 0,0,1,0,0)]\n\t}]\n}]\n\nmacros have been copied.",
        "maxWidth": "",
        "tooltip": "<html> This button you can use to paste macro on the selected token. Before you do this, you first need to run the <br> Copy/Del Macros button on another token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "12b4c57a-dbe0-4b9a-abde-e0183efe973a",
          "commandChecksum": "003532fd4cfd6a4a23e0622925e87b7a",
          "propsChecksum": "848d7f8c14b632d47a603d6c0af53cdd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "g. Rumbles Delete Macro Utility",
        "includeLabel": false,
        "sortBy": "g. Rumbles Delete Macro Utility",
        "index": 307,
        "label": "undoDelMacros",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[ids\t= getSelected()]\n[assert(listCount(ids) == 1, \"Make sure that (only) one token is selected\", 0)]\n[switchToken(ids)]\n\n[h:copiedMacros\t\t= getLibProperty(\"macroCopies\", \"lib:EventMacros\")]\n[h:assert(json.type(copiedMacros) == \"OBJECT\", \"No back-up macros were ever stored on this token\", 0)]\n[h:assert(json.length(copiedMacros) > 0, \"No macros left to undelete\", 0)]\n\n[h:deletedMacroList\t= json.fields(copiedMacros)]\n[h:abort(input(\"macToRestore|\"+deletedMacroList+\"|Choose Macro to Paste|LIST|SELECT=0 VALUE=STRING\"))]\n[h:restoreProps\t\t= json.get(copiedMacros, macToRestore)]\n[h:copiedMacros\t\t= json.remove(copiedMacros, macToRestore)]\n[h:createMacro(restoreProps)]\n\n<i>[r:macToRestore]<\/i> macro restored.",
        "maxWidth": "",
        "tooltip": "<html> If you deleted macros on the selected token using the Copy/Del Macros function<br> AND you had <i>allow undo<\/i> turned on, then you can use this function to undo<br> that process <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6aa4ea66-9e3c-4b8d-b799-3c373b5ba54c",
          "commandChecksum": "64f2447d682dd2d06cc08c1c028676d6",
          "propsChecksum": "9104e75e42c4dfe361ff15ad110ca428"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 308,
        "label": "createSplices",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h: theList = arg(0)]\n\n[h, if(json.type(theList) == \"UNKNOWN\"): theList = json.fromList(theList)]\n\n[h: maxCount\t\t\t= json.length(theList)]\n[h: splices\t\t\t\t= \"\"]\n[h: from\t\t\t\t= 0]\n[h: to\t\t\t\t\t= from + 999]\n\n\n[h, if(maxCount < 1):\tto = -1]\n\n[h, while(to >= 0), code: {\n\t[if(to >= maxCount): to = -1]\n\t[thisSplice\t= json.get(theList, from, to)]\n\t[splices\t= json.append(splices, thisSplice)]\n\t[from\t\t= from + 1000]\n\t[if(to != -1):to = from + 999]\n}]\n\n[h:macro.return = splices]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "382bc8b6-7dd7-497b-89be-3b1fc6c2703c",
          "commandChecksum": "d0eb00b2db936d4240bea1b2be554a47",
          "propsChecksum": "0dbfbb07167f8f1a6dbefc4ee0841c2b"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 309,
        "label": "debugInfo",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[\t\t\t\t\t w42_debug_vars\t\t= arg(0)]\n[if(argCount() > 1): w42.debug.oneLine\t= arg(1) ; w42.debug.oneLine\t= 1]\n[if(argCount() > 2): w42.debug.showTok\t= arg(2) ; w42.debug.showTok\t= 1]\n[if(argCount() > 3): w42.debug.pause\t= arg(3) ; w42.debug.pause\t\t= 0]\n[if(argCount() > 4): w42.debug.macro\t= arg(4) ; w42.debug.macro\t\t= \"\"]\n[if(argCount() > 5): w42.debug.location\t= arg(5) ; w42.debug.location\t= \"\"]\n\n[if(currentToken() != \"\" && w42.debug.showTok), CODE:{\n\t[w42.debug.currTok\t\t= getName(currentToken())]\n\t[token(w42.debug.currTok): w42.debug.currTok.img = getTokenImage()]\n};{\n\t[if(w42.debug.showTok), CODE:{\n\t\t[w42.debug.currTok\t\t= \"<i><font color='gray'>none<\/font><\/i>\"]\n\t\t[w42.debug.currTok.img\t= \"\"]\n\t};{\n\t\t[w42.debug.currTok\t\t= \"\"]\n\t}]\n}]\n\n[if(hasImpersonated() && w42.debug.showTok), CODE:{\n\t[w42.debug.impTok\t= getImpersonatedName()]\n\t[token(w42.debug.impTok): w42.debug.impTok.img = getTokenImage()]\n};{\n\t[if(w42.debug.showTok), CODE:{\n\t\t[w42.debug.impTok\t\t= \"<i><font color='gray'>none<\/font><\/i>\"]\n\t\t[w42.debug.impTok.img\t= \"\"]\n\t};{\n\t\t[w42.debug.impTok\t\t= \"\"]\n\t}]\n}]\n\n[w42.debug.textOut\t=\"<table border='1'>\" +\n\tif(w42.debug.macro\t\t!= \"\", \"<tr><td><b>Running from:\t\t<\/b><\/td>\t<td colspan='2'>%{w42.debug.macro}@%{w42.debug.location}<\/td><\/tr>\", \"\") + \n\tif(w42.debug.currTok\t!= \"\", \"<tr><td><b>Current Token:\t\t<\/b><\/td>\t<td><img height='15' width='15' src='%{w42.debug.currTok.img}'><\/img><\/td>\t<td>%{w42.debug.currTok}<\/td><\/tr>\", \"\") + \n\tif(w42.debug.impTok\t\t!= \"\", \"<tr><td><b>Impersonated Token:\t<\/b><\/td>\t<td><img height='15' width='15' src='%{w42.debug.impTok.img}'><\/img><\/td>\t<td>%{w42.debug.impTok}<\/td><\/tr>\", \"\") + \n\t\"<\/tr><\/table>\"\n]\n\n[if(w42.debug.oneLine), CODE:{\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<table border='1'><tr>\"]\n\t[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + \"<td><b>\"+w42_debug_var+\":<\/b><\/td><td>%{\"+w42_debug_var+\"}<\/td>\")]\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<\/tr><\/table>\"]\n};{\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<table border='1'>\"]\n\t[foreach(w42_debug_var, w42_debug_vars): w42.debug.textOut = w42.debug.textOut + \"<tr><td><b>\"+w42_debug_var+\":<\/b><\/td><td>%{\"+w42_debug_var+\"}<\/td><\/tr>\")]\n\t[w42.debug.textOut\t= w42.debug.textOut + \"<\/table>\"]\n}]\n\n[broadcast(strformat(w42.debug.textOut))]\n\n[if(w42.debug.pause), CODE:{\n\t[frame(\"Debug Info\", \"width=400; height=600;\"):{\n\t\t[r:strformat(w42.debug.textOut)]\n\t}]\n\t[pause()]\n};{}]\n[h:'']",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e1e86157-e99c-4621-a19e-13c793144f22",
          "commandChecksum": "d68a72bdf9a83c6afbeb44882081a6d2",
          "propsChecksum": "263fbaec38f1cfd303d1c229d390c981"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 310,
        "label": "execAllPlayers",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h,if(argCount() > 2), CODE:{\n\t[userList = arg(2)]\n\t[if(json.type(userList)==\"ARRAY\"):userList = json.toList(userList)]\n};{\n\t[userList = getAllPlayerNames()]\n}]\n[h,if(argCount() > 3), CODE:{\n\t[outputList = arg(3)]\n\t[if(json.type(outputList)==\"ARRAY\"):outputList = json.toList(outputList)]\n};{\n\t[outputList = \"none\"]\n}]\n\n[h: self\t= getPlayerName()]\n[h: others\t= listDelete(userList, listFind(userList, self))]\n\n[h, if(others != \"\"):broadcast(macroLink(\"<color='red'>\", arg(0), outputList, arg(1), \"\"), others)]\n[h,if(listContains(userList, self)), CODE:{\n\t[macro(arg(0)):arg(1)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1e7a9e34-40ce-43a9-bfea-a0fdff90406f",
          "commandChecksum": "e018009968ddd1f9ff0a00017f56a8a6",
          "propsChecksum": "45578f307d38d6a70a310df43b6dc1f8"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 311,
        "label": "findDuplicates",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h:'']\n[h:\tallToks\t\t\t= json.sort(getTokenNames(\"json\",json.set(\"{}\", \"layer\", json.append(\"\", \"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\"))),\"N+\")]\n[h:'']\n[h:hasDuplicates\t= if(json.equals(allToks,json.sort(json.unique(allToks))),0,1)]\n[h:duplicates\t= \"\"]\n\n[h, if(hasDuplicates), CODE: {\n\t[lastTok\t= \"\"]\n\t\n\t[allSplices\t= bot_createSplices(allToks)]\n\t\n\t[foreach(tokList,allSplices), CODE: {\n\t\t[foreach(tok,tokList), CODE: {\n\t\t\t[if(lastTok == tok): duplicates = listAppend(duplicates,tok)]\n\t\t\t[lastTok = tok]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\t[output = strformat(\"Found duplicates: %{duplicates}\")]\n''\n};{\n\t[output = strformat(\"No duplicate token names\")]\n''\n}]\n\n[h:macro.return = duplicates]\n[h:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2f79cc3c-68eb-48a3-8812-ac382c24610f",
          "commandChecksum": "e074defc6e4a5328e9e9785177efbadf",
          "propsChecksum": "7e4e85ae4e7baa4bfa25816c8233430a"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "16",
        "includeLabel": false,
        "sortBy": "16",
        "index": 312,
        "label": "getGridSize",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:macro.return = json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3b56afc3-a799-4469-93af-55393637eb27",
          "commandChecksum": "8747e2582d486b9273242a0981f05ba5",
          "propsChecksum": "6fcc3b0d1aef95178e5650302f141c1d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "20b",
        "includeLabel": false,
        "sortBy": "20b",
        "index": 313,
        "label": "getNewImage",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[token(arg(1)): macro.return = getTokenImage(arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1514c7fc-0c37-411a-b756-ff8c35037345",
          "commandChecksum": "4a860226f19b5679f27c9d7328bbc979",
          "propsChecksum": "30f8e412bdfb85d56dbee19ffe53d998"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 314,
        "label": "getPath",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h,if(argCount() > 2): me = arg(2); me\t= getSelected()]\n[h:switchToken(me)]\n\n[h,if(argCount() > 1): units = arg(1); units = 1]\n[h:switchToken(me)]\n\n[h,if(argCount() > 0): pathType = arg(0); pathType\t= 0]\n[h,if(pathType), CODE:{\n\t[pathFeet\t\t= if(isPC(), \"blue feet\", \"red feet\")]\n\t[pathFeet\t\t= if(getOwnerOnlyVisible(), \"purple feet\", pathFeet)]\n\t[directionLst\t= \"0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y\"]\n\t[facingLst\t\t= \"none, -90,90,0,180,45,-135,135,-45\"]\n\t[doLastStep\t\t= 0]\n\t[baseMapName\t= getLibProperty('baseMapName','lib:EventMacros')]\n\t[feetSize\t\t= getSize()]\n};{\n\t[doLastStep\t\t= 1]\n}]\n\n[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]\n\n[h, if(pathType == 3): path = \"[]\"]\n[h:assert(!json.isEmpty(path) || pathType==3, \"Token has not last path\",0)]\n\n[h,if(units): gs = bot_getGridSize() ; gs = 1]\n\n[h,if(json.length(path)), CODE:{\n\t['']\n\t[firstStep\t= json.get(path, 0)]\n\t[path\t\t= json.remove(path, 0)]\n\t[x\t\t\t= json.get(firstStep, \"x\")]\n\t[y\t\t\t= json.get(firstStep, \"y\")]\n\t[direction\t= \"\"]\n\t[wp\t\t\t= \"\"]\n\t[point\t\t= \"{}\"]\n};{}]\n\n[h: skipCount\t= 0]\n[h, switch(feetSize):\n\tcase \"Large\":\t\tsizeCount = 1;\n\tcase \"Huge\":\t\tsizeCount = 2;\n\tcase \"Gargantuan\":\tsizeCount = 3;\n\tcase \"Colossal\":\tsizeCount = 4;\n\tdefault:\t\t\tsizeCount = 0\n]\n\n[h,foreach(step, path), CODE:{\n\t[nx\t\t\t= json.get(step, \"x\")]\n\t[ny\t\t\t= json.get(step, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\n\t\n\t\t\n\t[if(pathType), CODE:{\n\t\t\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[angle = 0] \n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[h: skip = pathType]\n\t[if (sizeCount > skipCount), CODE:{\n\t\t[skip = 0]\n\t\t[skipCount = skipCount + 1]\n\t};{\n\t\t[skipCount = 0]\n\t}]\n\t\n\t[if (direction != ndirection || skip), CODE:{\n\t\t\n\t\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t\t[wp\t\t= json.append(wp, point)]\n\t\t[skipCount = 0]\n\t};{}] \n\n\t[x\t\t\t= nx]\n\t[y\t\t\t= ny]\n\t[direction\t= ndirection]\n}]\n\n[h, if(json.length(path) > 0 && doLastStep), CODE:{\n\t\n\t[lastStep\t= json.get(path, -1,-1)]\n\t[nx\t\t\t= json.get(lastStep, \"x\")]\n\t[ny\t\t\t= json.get(lastStep, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\n\t[if(pathType), CODE:{\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t[wp\t\t= json.append(wp, point)]\n};{}]\n\n[h, if(pathType), CODE:{\n\t\n\n\t[if(pathType != 2), CODE:{\n\t\t\n\t\t[currentFeet = getTokens(\",\", json.set(\"{}\", \"layer\", \"OBJECT\", \"setStates\", \"pathFeet\"))]\n\t\t\n\t\t[if(listFind(currentFeet, \"red feet\")!=-1):\t\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"red feet\")]\n\t\t[if(listFind(currentFeet, \"blue feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"blue feet\")]\n\t\t[if(listFind(currentFeet, \"purple feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"purple feet\")]\n\t\t[foreach(feet, currentFeet): removeToken(feet)]\n\t};{}]\n\t\n\t[if(pathType != 3), CODE:{\n\t\t\n\t\t[foreach(p, wp,\"<br>\"): copyToken(pathFeet, 1, baseMapName, json.set(p, \"useDistance\", units, \"layer\", \"OBJECT\", \"name\", \"w42.bot.feet\", \"size\", feetSize))]\n\t};{}]\n\t[macro.return\t= \"\"]\n};{\n\t\n\t[macro.return\t= wp]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "16a1c352-8c2e-4aba-9488-64ccc6469464",
          "commandChecksum": "709d7e4256893a40dbd311ccb7b9df6e",
          "propsChecksum": "04b0a9599ab09acb81abcb59dfeb1de9"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 315,
        "label": "getTokensPath",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h,if(argCount() > 2): me = arg(2); me\t= getSelected()]\n[h:switchToken(me)]\n\n[h,if(argCount() > 1): units = arg(1); units = 1]\n[h:switchToken(me)]\n\n[h,if(argCount() > 0): showPath = arg(0); showPath\t= 0]\n[h,if(showPath), CODE:{\n\t[pathFeet\t\t= if(isPC(), \"blue feet\", \"red feet\")]\n\t[directionLst\t= \"0X0Y,0X1Y,0X-1Y,1X0Y,-1X0Y,1X-1Y,-1X1Y,-1X-1Y,1X1Y\"]\n\t[facingLst\t\t= \"none, -90,90,0,180,45,-135,135,-45\"]\n\t[doLastStep\t\t= 0]\n\t[baseMapName\t= getLibProperty('baseMapName','lib:EventMacros')]\n\n};{\n\t[doLastStep\t\t= 1]\n}]\n\n[h,if(argCount() > 3): path = arg(3); path = getLastPath(units)]\n\n[h, if(showPath == 3): path = \"[]\"]\n[h:assert(!json.isEmpty(path) || showPath==3, \"Token has not last path\",0)]\n\n[h,if(units): gs = bot_getGridSize() ; gs = 1]\n\n[h,if(json.length(path)), CODE:{\n\t['']\n\t[firstStep\t= json.get(path, 0)]\n\t[path\t\t\t= json.remove(path, 0)]\n\t[x\t\t\t= json.get(firstStep, \"x\")]\n\t[y\t\t\t= json.get(firstStep, \"y\")]\n\t[direction\t= \"\"]\n\t[wp\t\t\t= \"\"]\n\t[point\t\t= \"{}\"]\n};{}]\n\n[h,foreach(step, path), CODE:{\n\t[nx\t\t\t= json.get(step, \"x\")]\n\t[ny\t\t\t= json.get(step, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\n\t\n\t\t\n\t[if(showPath), CODE:{\n\t\t\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[if (direction != ndirection || showPath), CODE:{\n\t\t\n\t\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t\t[wp\t\t= json.append(wp, point)]\n\t};{}] \n\n\t[x\t\t\t= nx]\n\t[y\t\t\t= ny]\n\t[direction\t= ndirection]\n}]\n\n[h, if(json.length(path) > 0 && doLastStep), CODE:{\n\t\n\t[lastStep\t= json.get(path, -1,-1)]\n\t[nx\t\t\t= json.get(lastStep, \"x\")]\n\t[ny\t\t\t= json.get(lastStep, \"y\")]\n\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\n\t[if(showPath), CODE:{\n\t\t[ndirection\t= strformat(\"%sX%sY\", (nx-x)/gs, (ny-y)/gs)]\n\t\t[ndir\t\t= listFind(directionLst, ndirection)]\n\t\t[if(ndir > 0): angle = listGet(facingLst, ndir) ; broadcast(\"unknown or no move: \"+ndirection)]\n\t\t[point\t\t= json.set(point, \"facing\", angle)]\n\t};{}]\n\t\n\t[point\t= json.set(point, \"x\", x, \"y\", y)]\n\t[wp\t\t= json.append(wp, point)]\n};{}]\n\n[h, if(showPath), CODE:{\n\t\n\n\t[if(showPath != 2), CODE:{\n\t\t\n\t\t[currentFeet = getTokens(\",\", json.set(\"{}\", \"layer\", \"OBJECT\", \"setStates\", \"pathFeet\"))]\n\t\t\n\t\t[if(listFind(currentFeet, \"red feet\")!=-1):\t\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"red feet\")]\n\t\t[if(listFind(currentFeet, \"blue feet\")!=-1):\tcurrentFeet = listDelete(currentFeet, listFind(currentFeet, \"blue feet\")]\n\t\t[foreach(feet, currentFeet): removeToken(feet)]\n\t};{}]\n\t\n\t[if(showPath != 3), CODE:{\n\t\t\n\t\t[foreach(p, wp,\"<br>\"): copyToken(pathFeet, 1, baseMapName, json.set(p, \"useDistance\", units, \"layer\", \"OBJECT\", \"name\", \"w42.bot.feet\"))]\n\t};{}]\n\t[macro.return\t= \"\"]\n};{\n\t\n\t[macro.return\t= wp]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0c936366-f2e2-45cc-a57b-d28621440201",
          "commandChecksum": "c4359ae1becedf4f295d507aa45853db",
          "propsChecksum": "54a8c1ecff839665c6a3605cca1186f1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 316,
        "label": "gotoMap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:map\t= arg(0)]\n[h:cPad\t= arg(1)]\n\n[bot_chkSounds(\"self\",1)] \n[h:setCurrentMap(map)]\n[bot_chkSounds(listGet(getOwned(),0), getCurrentMapName(), 0)] \n\n[h,if(argCount() > 1 && cPad != \"\"):comPad = \"centreOnMePad \" + cPad ; comPad = \"centreOnMePad\"]\n\n[h,if(findToken(comPad) != \"\"): goto(getTokenX(0,comPad),getTokenY(0,comPad))]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array)",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fa2ec5e7-95f0-4254-b5fc-52d6f47bdabf",
          "commandChecksum": "4aa8b8d8e1e80547543ab78fd17d5405",
          "propsChecksum": "cb04a20171853f231f58164ebba7aa0b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "20b",
        "includeLabel": false,
        "sortBy": "20b",
        "index": 317,
        "label": "gotoToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[gotoMap\t= arg(0)]\n[tok\t\t= arg(1)]\n[copyTok\t= arg(2)]\n[X\t\t\t= arg(3)]\n[Y\t\t\t= arg(4)]\n\n[currentMap\t= getCurrentMapName()]\n\n\n\n\n[if(copyTok == 0), CODE:{\n\t[abort(input(\n\t\t\"junk|<html>You have selected <b>\"+tok+\"<\/b>. What do you want to do<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"copyTok|<html>Nothing, COPY \"+tok+\" to current location, MOVE \"+tok+\" to current location, \"+if(gotoMap != currentMap, \"go to \"+gotoMap+\" and\",\"\")+\" SELECT \"+tok+\", DELETE \"+tok+\" (confirm), DELETE \"+tok+\" (no confirm)|Pick one|RADIO|\"\n\t))]\n}; {}]\n\n\n[if(copyTok == 1):\tcopyToken(tok, 1, gotoMap, json.set(\"{}\", \"useDistance\", 0, \"x\", X, \"y\", Y))]\n\n\n[if(copyTok == 2), CODE:{\n\t[if(gotoMap != currentMap):\tmoveTokenFromMap(tok, gotoMap, X, Y, 100) ; moveToken(X,Y,0,tok)]\n}; {}]\n\n\n[if(copyTok == 3), CODE:{\n\t[if(gotoMap != currentMap):setCurrentMap(gotoMap)]\n\t[selectTokens(tok)]\n\t[goto(tok)]\n\t[layer\t= getLayer(tok)]\n\t[if(layer != \"TOKEN\"): broadcast(strformat(\"%{tok} is on the %{layer} layer\"))]\n}; {}]\n\n\n[if(copyTok == 4), CODE:{\n\t[Warning = \"Press OK to delete: <b>\"+tok+\"<\/b>, else press cancel\"]\n\t[pause(\"Warning\")]\n}; {}]\n\n\n[if(copyTok == 4 || copyTok == 5), CODE:{\n\t[if(gotoMap != currentMap):setCurrentMap(gotoMap)]\n\t[removeToken(tok)]\n\t[if(gotoMap != currentMap):setCurrentMap(currentMap)]\n\t[broadCast(tok+\" has been deleted from map: \"+gotoMap)]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8435a02d-34ce-4017-91d0-6671583a197e",
          "commandChecksum": "ca59704139aaeb71d0b27df5aba859aa",
          "propsChecksum": "be1a28e6febf17596878ddb3f3cc7d5c"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 318,
        "label": "ids2Names",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:tokNames = \"\"]\n[h,foreach(tok,arg(0)): tokNames = listAppend(tokNames, getName(tok))]\n[r:tokNames]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0b771990-2a5f-4010-a3d8-8528992130d7",
          "commandChecksum": "45487f232ab40a82c36b4925b63b7362",
          "propsChecksum": "b97322e741cb19423e412a7283ba28c5"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 319,
        "label": "ids2NamesArray",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:array\t= replace(arg(0), '(\")([^,]+)(\")', '\"[r:getName('\\$2')]\"')]\n[h:macro.return = json.evaluate(replace(array, \"'\", \"'\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "48a8226b-4b98-4ba0-92d7-7dd3400a4289",
          "commandChecksum": "6b47f196b7cddcf663814de561b00274",
          "propsChecksum": "88c564890560b5f7001fb6bab5ad8833"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 320,
        "label": "inStr",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[H: '']\n[r, if(arg(1)==\"\"):\"\"; getFindCount(strfind(arg(0), arg(1)))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b67c6b84-33f5-49a9-8fc8-c462347da447",
          "commandChecksum": "c04d5f7d861d358b9f21c0217cb2a870",
          "propsChecksum": "c31ac301c1e4e99657e42be91426608d"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 321,
        "label": "pause",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[ toolkit.DebugVariableCount = argCount() ]\n[ toolkit.DebugVariableArray = macro.args ]\n[ toolkit.DebugInputParameter = \".|<html>\" +\n    \"<table cellspacing='2' cellpadding='0' style='background-color:#595751'>\" +\n    \"<tr><td>\" +\n    \"<table width='300px' cellspacing='0' cellpadding='2' style='background-color:#FAF9F5; '>\" +\n    \"%{toolkit.DebugVariableRows}<\/table><\/td><\/tr><\/html>\" +\n    \"|Debugger|LABEL|SPAN=TRUE\"\n]\n[ toolkit.DebugVariableRow = \"<tr %{toolkit.DebugVariableRowStyle}><td>\" +\n    \"<b>%{toolkit.DebugVariableName}<\/b><\/td><td>%{toolkit.DebugVariableContent}\" +\n    \"<\/td><\/tr>\"\n]\n[ toolkit.DebugVariableRows = \"<tr style='background-color:#E0DDD5; font-size:1.1em; '><td><b>Variable<\/b><\/td><td><b>Value<\/b><\/td><\/tr>\" ]\n[ count( toolkit.DebugVariableCount ), code:\n{\n    [ toolkit.DebugVariableRowStyle = \"\" ]\n    [ toolkit.DebugVariableName = json.get( toolkit.DebugVariableArray, roll.count ) ]\n    [ toolkit.DebugVariableContent = eval( toolkit.DebugVariableName ) ]    [H: '']\n    [ if( floor( roll.count/2 ) == roll.count/2 ), code:\n    {\n        [ toolkit.DebugVariableRowStyle = \"style='background-color:#EDECE8; '\" ]\n    } ]\n    [ toolkit.DebugVariableRows = toolkit.DebugVariableRows +\n        strformat( toolkit.DebugVariableRow )\n    ]\n} ]\n[ if( toolkit.DebugVariableCount == 0 ), code:\n{\n    [ toolkit.DebugVariableRows = \"<tr><td style='font-size: 1.4em' align='center'><b>Pause<\/b><\/td><\/tr>\" ]\n} ]\n\n[ toolkit.DebugBreak = input( strformat( toolkit.DebugInputParameter ) )]\n[ abort( toolkit.DebugBreak ) ] \n[h:'']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0bbfcc95-ae83-4265-b802-e124918870e0",
          "commandChecksum": "230221ef56b23b7e707b31e83a058f4f",
          "propsChecksum": "3007039ba951e286026e59c8df411e81"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "18",
        "includeLabel": false,
        "sortBy": "18",
        "index": 322,
        "label": "ppc2GridCoord",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(argCount() > 1): gs = arg(1) ; gs\t= bot_getGridSize()]\n[h:macro.return = round(arg(0)/gs)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ed42332f-afd3-419b-a3de-52ae636db6c3",
          "commandChecksum": "ef627b2ba374ea1cb16c88586abc59e8",
          "propsChecksum": "444b4f9f145d3518796f0095034ccebf"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "18",
        "includeLabel": false,
        "sortBy": "18",
        "index": 323,
        "label": "round2Grid",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[if(argCount() > 1): gs = arg(1) ; gs\t= bot_getGridSize()]\n[h:macro.return = gs*round((arg(0)/gs))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "abb44f1d-2652-40ba-97fc-dc4444c152c6",
          "commandChecksum": "f08095b0afa3df15bded6ca7c5dfae56",
          "propsChecksum": "ac1bcbecb150298740a05145e8dfb9c8"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "red",
        "group": "20a",
        "includeLabel": false,
        "sortBy": "20a",
        "index": 324,
        "label": "seekToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h:'']\n[h:lastSettings\t= getLibProperty(\"seekTokensLastSettings\", \"Lib:EventMacros\")]\n[h,if(lastSettings == \"\"): lastSettings = \"findTok=0 ; showImage=0 ; showName=1 ; showLayer=0 ; copyTok=0 ; libTok=0 ; doTokenLayer=1 ; doObjectLayer=1 ; doHiddenLayer=1 ; doBackgroundLayer=1 ; \"]\n[h:varsFromStrProp(lastSettings)]\n\n[h:'']\n\n[h,if(argCount()>0), CODE:{\n\t[\t\t\t\t\t returnArg\t\t= arg(0)]\n\t[h,if(argCount()>1): findTok\t\t= arg(1) ; findTok\t\t= \"\"]\n\t[h,if(argCount()>2): chosenLayers\t= arg(2) ; chosenLayers = '[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]']\n\t[if(string(chosenLayers) == \"\"): chosenLayers = '[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]']\n\t[h,if(argCount()>3): mapList\t\t= arg(3) ; mapList\t\t= getCurrentMapName()]\n\t[h,if(argCount()>4): libTok\t\t\t= arg(4) ; libTok\t\t= 0]\n\t[h,if(argCount()>5): jsonOutput\t\t= arg(5) ; jsonOutput\t= 0] \n\n\t[numMaps\t= listCount(mapList)]\n\t[if(numMaps > 1 && !jsonOutput): returnValue= \"{}\" ; returnValue= \"\" ]\n\t[showName\t= 1]\n\t[showImage\t= 0]\n\t[showLayer\t= 0]\n}; {\n\t[mapList\t= \"\"]\n\t[returnArg\t= 0]\n}]\n\n[h, if(mapList == \"\"), CODE:{\n\t[h:mapList\t\t= getAllMapNames()]\n\t\n\t[h:baseMapName\t= getLibProperty(\"baseMapName\",\"lib:EventMacros\")]\n\t[h:mapList\t\t= listAppend(baseMapName, listDelete(mapList, listFind(mapList, baseMapName)))]\n}; {}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:resultTxt\t= \"<hml><table border=1><tr><td><b>MAP<\/b><\/td><td><b>FOUND<\/b><\/td><\/tr><tr>\"]\n[h:me = getSelected()]\n[h, if(listCount(me) == 1), CODE:{\n\t[switchToken(me)]\n\t[h: X = getTokenX(0)]\n\t[h: Y = getTokenY(0)]\n\t[H: PrimePC\t= getName() ]\n}; {\n\t[h: X = 0]\n\t[h: Y = 0]\n\t[H: PrimePC\t= \"\"]\n}]\n\n[h:inputStr\t\t= \"[]\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Find tokens which names have the following search string<\/html>|<html>The token will show up in the results when the<br>search string matches ANY part of the token name|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"findTok|\"+findTok+\"|Enter search string\")]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>In search results<\/html>|<html>The search results will be shown in a frame.<br>When you check all three boxes the result will<br>look like <u>Picture<\/u> <u>Token name<\/u>(<u>token layer<\/u>)|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"showImage|\"+showImage+\"|Show token image|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"showName|\"+showName+\"|Show token name|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"showLayer|\"+showLayer+\"|Show layer|CHECK\")]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>LIB:Tokens (search string is ignored for these)<\/html>|<html>Lib:Tokens can only be found through a special macro<br>and are thus dealt with seperately. An additional <br>feature for lib:Tokens is to find the duplicates only.<br>For the find duplicates note the following: <br>- Only ONE duplicate is shown. This to prevent you <br>from accidentily deleting both. <br>- When you delete one token the results are NOT <br>UPDATED. So on the frame it appears the token is still<br>there even though its not. If you run this macro again<br>you will see the update. <br>|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"libTok|No: only 'normal' tokens, Yes: BOTH normal and lib:Tokens, Yes: ONLY lib:Tokens, Yes: ONLY DUPLICATE lib:Tokens|Find lib:Tokens|RADIO|SELECT=\"+libTok)]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>Check layers to look on<\/html>|<html>The result will only show tokens that are on the layers you check here.|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"doTokenLayer|\"+doTokenLayer+\"|Token Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doHiddenLayer|\"+doHiddenLayer+\"|Hidden Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doObjectLayer|\"+doObjectLayer+\"|Object Layer|CHECK\")]\n[h:inputStr\t\t= json.append(inputStr, \"doBackgroundLayer|\"+doBackgroundLayer+\"|Background Layer|CHECK\")]\n\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>The results will be presented as macrolinks<\/html>|<html>Macrolinks look like hyperlinks. However when<br>you click on them you do not open a page, but<br>activate a macro. Here you can choose WHICH<br>macro to activate.<br>|LABEL|SPAN=TRUE\")]\n[h:inputStr\t\t= json.append(inputStr, \"copyTok|decide when you click, copy token to current location, move token to current location, go to map and select token, DELETE token (with confirmation), DELETE token (WITHOUT confirmation)|Click on link will|RADIO|SELECT=\"+copyTok)]\n\n[h:'']\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>If you summon the token(s), do this to: <\/b><\/html>|<html>The Token will be summoned to a CELL coordinate on the<br>current map. Per default this is 0,0. If you look at the<br>bottom right corner you see the coordinates of the cell<br>your cursor was last on the map. You can enter these<br>coordinates into the below boxes. Alternatively you can<br>select a token before you run this and the coords of the<br>position of the selected token will be entered instead.|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, \"X|\"+X+\"|give X coordinates\")]\n[h:inputStr \t= json.append(inputStr, \"Y|\"+Y+\"|give Y coordintates\")]\n\n[h:'']\n[h, if(PrimePC != \"\"):inputStr\t\t= json.append(inputStr,\"junk|\"+X+\",\"+Y+\"|<html><b>Location of \"+PrimePC+\"<\/b>|LABEL\")]\n\n[h:'']\n[H: inputStr\t= json.evaluate(inputStr)]\n[h:'']\n[H, if(!returnArg): abort(input(json.toList(inputStr,\"##\")))]\n\n[h:'']\n[h:assert(showImage+showName+showLayer, \"Check at least one of the Show Image, Name, Layer boxes\",0)]\n[h:assert(doTokenLayer+doObjectLayer+doHiddenLayer+doBackgroundLayer, \"Check at least one of the (Token, Hidden, Object, Background) layer boxes\",0)]\n\n\n[h,if(findTok == \"\"): findTok = \"(?!,).\"]\n[h:regex\t\t= strformat(\"(?i)([^,]*(%{findTok})[^,]*)\")]\n[h,if(!returnArg): result = \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{currentMap}", "%{tok}", "%{copyTok}", "%{X}", "%{Y}"]'>\"+if(showImage, \"<img src=%s><\/img>\", \"\")+if(showName, \"%{tok}\", \"\")+if(showLayer, \" (%s)\", \"\")+\"<\/a>\" ; result = \"%{tok}\"]\n\n[h, if(!returnArg), CODE:{\n\t['']\n\t[chosenLayers = \"[]\"]\n\t[if(doTokenLayer):\t\tchosenLayers = json.append(chosenLayers, \"TOKEN\")]\n\t[if(doHiddenLayer):\t\tchosenLayers = json.append(chosenLayers, \"HIDDEN\")]\n\t[if(doObjectLayer):\t\tchosenLayers = json.append(chosenLayers, \"OBJECT\")]\n\t[if(doBackgroundLayer):\tchosenLayers = json.append(chosenLayers, \"BACKGROUND\")]\n};{}]\n[h:layers\t\t= json.set(\"{}\", \"layer\", chosenLayers) ]\n\n[h:'']\n[h, if(libTok):\tlibTokens = listSort(json.fields(json.get(getInfo(\"client\"),\"library tokens\")),\"N+\") ; libTokens = \"\"]\n[h: libFoundList\t\t= \"\"]\n\n[h,foreach(currentMap,mapList,\"\"), CODE: {\n\t[if(currentMap != getCurrentMapName()): setCurrentMap(currentMap)]\n\t[if(libTok < 2): allToks = listSort(getTokenNames(\",\",layers),\"N+\") ; allToks = \"\"]\n\t\n\t[h: allToks\t=  replace(allToks, \"\\\\s*([\\\\,\\\\s])\\\\s*\",\"\\$1\")]\n\n\t[resultList\t= \"\"]\n\t[id\t\t\t= strfind(allToks, regex)]\n\t[numFound\t= getFindCount(id)]\n\t[if(numFound > 1000), CODE:{\n\t\t[message\t= strformat(\"Found: %{numFound} results on map %{currentMap}. Only showing the first 1000 results\")]\n\t\t[numFound\t= 1000]\n\t\t[pause(\"message\")]\n\t}; {}]\n\t[count(numFound), CODE:{\n\t\t[tok\t\t= getGroup(id, roll.count+1, 0)]\n\t\t[resultList\t= listAppend(resultList, strformat(result, bot_getNewImage(30, tok), getLayer(tok)))]\n\t}]\n\t\n\t[libResultList = \"\"]\n\t[foreach(tok, libTokens), CODE:{\n\t\t[found\t= if(findToken(tok) != \"\", 1, 0)]\n\t\t[if(found && libTok == 3):\t\t\t\t\tduplicate\t\t\t= if(listContains(libFoundList, tok),1,0) ; duplicate = 0]\n\t\t[if(found && libTok == 3):\t\t\t\t\tlibFoundList\t\t= listAppend(libFoundList, tok)]\n\t\t[if(duplicate || (found && libTok < 3)):\tlibResultList\t\t= listAppend(libResultList,\t\tstrformat(result, bot_getNewImage(30,tok), getLayer(tok)))]\n\t\t['if(found):pause(\"found\", \"tok\", \"libTokens\",\"duplicate\",\"libResultList\",\"libTok\")']\n\t}]\n\t\n\t[if(libResultList != \"\"): resultList\t= listAppend(resultList, libResultList)]\n\n\t[if(!returnArg): \n\t\tresultTxt\t= resultTxt + \"<td><b>\" + currentMap + \":<\/b><\/td><td>\" + if(listCount(resultList), resultList, 'none found')+\"<\/td><\/tr>\"\n\t; \n\t\treturnValue\t= if(numMaps > 1 || jsonOutput, json.set(returnValue, currentMap, resultList), resultList)\n\t]\n}]\n[h,if(oldMap != getCurrentMapName()): setCurrentMap(oldMap)]\n\n[h:resultTxt\t= resultTxt + \"<\/table><\/html>\"]\n\n[h,if(copyTok == 0):\texecuteText = strformat(\"a <b>POP-UP<\/b> will appear asking you whether you want to Copy, Move or Select the corresponding token. When moved or copied, it will be to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 1):\texecuteText = strformat(\"the corresponding token will be <b>COPIED<\/b> to this map (%{oldMap}), to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 2):\texecuteText = strformat(\"the corresponding token will <b>MOVED<\/b> from its current location to this map, to coord:(%{X},%{Y})\"+if(PrimePC != \"\", \"(%{PrimePC})\", \"\"))]\n[h,if(copyTok == 3):\texecuteText = \"you will switch to the map where the token is at and the token will be selected\"]\n\n[h:output = \"When you click on one of the macrolinks  <u>\"+executeText+\"<\/u><br><br>\"+resultTxt]\n\t\n[r, if(!returnArg && bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Looking for: \"+ findTok,\"width=400; height=400; input=1\"):{[r:output]}]\n};{}]\n\n[r, if(!returnArg && !bot_isFullScreen()), CODE:{\n\t[r,frame(\"Looking for: \"+ findTok,\"width=400; height=400; \"):{[r:output]}]\n};{}]\n\n[h:'']\n[h:setLibProperty(\"seekTokensLastSettings\", strPropFromVars(\"findTok, showImage, showName, showLayer, copyTok, libTok, doTokenLayer, doObjectLayer, doHiddenLayer, doBackgroundLayer\",\"UNSUFFIXED\"), \"Lib:EventMacros\")]\n\n[h, if(returnArg):\tmacro.return = returnValue]",
        "maxWidth": "",
        "tooltip": "<html>This macro searches ALL maps and ALL tokens and<br>return those tokens of which the first part of <br>their name matches with the entered search string<br><b>Pop-ups on first use",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8a95de14-2c52-4756-b1aa-68331db70c08",
          "commandChecksum": "d04fa77347b680410f4f599d4f9e895b",
          "propsChecksum": "e84cc4251adf19b9ec0426f862fe8be7"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 325,
        "label": "showHTML",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:output = arg(0)]\n\n[h: htmlResult = replace(output, \"<\", \"<\")]\n[h: htmlResult = replace(htmlResult, \"<table\", \"<br><table\")]\n[h: htmlResult = replace(htmlResult, \"</table>\", \"<br></table><br>\")]\n\n[h: htmlResult = replace(htmlResult, \"<tr\", \"<br><tr\")]\n[h: htmlResult = replace(htmlResult, \"</tr>\", \"<br></tr><br>\")]\n\n[h: htmlResult = replace(htmlResult, \"<td\", \"<br><td\")]\n[h: htmlResult = replace(htmlResult, \"</td\", \"<br></td\")]\n\n[frame(\"displayHTML\"):{\n\t<pre>\n\t\t[r: htmlResult]\n\t<\/pre>\n}]\n\n[frame(\"displayHTMLResult\"):{\n\t[r: output]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e7d9e09e-6bfb-41fc-a64a-1fd80fa4ac32",
          "commandChecksum": "6881a0d430b542746984a2089eb8509c",
          "propsChecksum": "afeef7c9c482b76d3f1bde1508fc5a85"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "18",
        "includeLabel": false,
        "sortBy": "18",
        "index": 326,
        "label": "snapAngle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:switchToken(arg(0))]\n[h,if(getTokenFacing() == \"\"): setTokenFacing(-90)]\n[h,if(argCount()>1): corners\t= arg(1); corners\t= 8]\n[h,if(argCount()>2): align\t\t= arg(2); align\t\t= 1]\n\n[h:cornerDivider = round(360/corners)]\n[h:angle = round( (getTokenFacing()) / cornerDivider ) * cornerDivider]\n\n[h, if(align): setTokenFacing(angle)]\n\n[h:macro.return = angle]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "829c14d0-712d-43f2-93a2-039728b59b8f",
          "commandChecksum": "2d9f1262a895167cac92a765f04781b8",
          "propsChecksum": "6e3659fd314e34502d99169b02909004"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18",
        "includeLabel": false,
        "sortBy": "18",
        "index": 327,
        "label": "snapToGrid",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[moveToken(round(getTokenX(1,arg(0))/json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\"),0), round(getTokenY(1,arg(0))/json.get(json.get(getInfo(\"map\"),\"grid\"),\"size\"),0), 0, arg(0))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4e774f5f-3288-4cb5-8b16-4d83940e4c0c",
          "commandChecksum": "2237ae7059d79db7cea019cd7e0b10fc",
          "propsChecksum": "055ffbca4b00d7857192488d7b196951"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 328,
        "label": "sortTokByProp",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:sortKey\t= arg(0)]\n[h,if(argCount() > 1): order\t= arg(1) ; order\t= \"ascending\"]\n[h,if(argCount() > 2): tokens\t= arg(2) ; tokens\t= getSelected()]\n\n\n[h: array = \"\"]\n[h, foreach(id, tokens): array = json.append(array, json.set(\"\", \"id\", id, \"sortKey\", getProperty(sortKey, id)))]\n\n\n[h:array\t= json.sort(array, order, \"sortKey\")]\n\n\n[h:resultArray\t= \"\"]\n[h, foreach(item, array): resultArray = json.append(resultArray, json.get(item, \"id\"))]\n\n\n[h: macro.return = resultArray]",
        "maxWidth": "",
        "tooltip": "This macro executes the macro on ALL clients. Feed it macro@lib:token, args (json array), players, output to",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7e0e372d-73b0-407f-8193-9bac2cbeb313",
          "commandChecksum": "60f79fa416b0dba78a3b9a67a1dcf38e",
          "propsChecksum": "55b5736f0e10d00982bafc2b448eb2cd"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "19",
        "includeLabel": false,
        "sortBy": "19",
        "index": 330,
        "label": "travelAngle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:x1 = arg(0)]\n[h:y1 = arg(1)]\n[h:x2 = arg(2)]\n[h:y2 = arg(3)]\n\n[h, if(argCount()>4):option = arg(4) ; option = 0]\n\n[h:dx = x2 - x1]\n[h:dy = y2 - y1]\n\n[h, if(dx), CODE:{\n\t\n\t\n\t[diagonal = abs(dy/dx)]\n\t[if(diagonal < 0.414214):dy = 0]\n\t[if(diagonal > 2.414214):dx = 0]\n}; {}]\n\n\n[dxl = min(1, max(dx, -1)) + 1]\n[dyl = min(1, max(dy, -1)) + 1]\n\n\n[h:'pause(\"x1\",\"y1\",\"x2\",\"y2\",\"dx\",\"dy\",\"diagonal\",\"dxl\",\"dyl\")']\n[h,if(option):\n\tmacro.return = listGet(\"North West,West,South West,North,NONE,South,North East,East,South East\", 3 * dxl + dyl)\n;\n\tmacro.return = listGet(\"135, 180, -135, 90, 0, -90, 45, 0, -45\", 3 * dxl + dyl)\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "11d351d8-7351-4096-88e5-cc191199a344",
          "commandChecksum": "418a66b198c0744e9469ebe69351aaf0",
          "propsChecksum": "4a73ace8fb61acaabc1a83ca34175267"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 331,
        "label": "createTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[frame(\"List builder\", \"width = 250; height = 400; temporary = 1\"): {\n\t<html>\n\t<head>\n\t\t<title>Create BoT Table<\/title>\n\t\t<meta name = \"input\" content = \"true\">\n <\/head>\n\t<body>\n\t\t<form method = \"json\" name = \"TableInput\" action = \"[r:macroLinkText('text2Table@Lib:onTokenMove')]\">\n\t\t\t<input type = \"hidden\" name = \"show\" value = 0> <\/input>\n\t\t\t<table>\n\t\t\t\t<tr><th align = \"left\"><label for = \"Name\">Paste List here (straight from excel):<\/label><\/th><\/tr>\n\t\t\t\tKeep in mind this does NOT create an MT table but a more extensive BoT table. See manual for more info\n\t\t\t\t<tr><td><textarea rows = \"10\" cols = \"500\" name = 'TextBox' ><\/textarea><\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<table>\n\t\t\t\t<tr><td colspan=\"2\" width=\"5%\"><b>Title of the table:<\/b><\/td><\/tr>\n\t\t\t\t<tr><td colspan=\"2\"><input type = \"text\" name = \"Title\": size = \"50\"> <\/input><\/td><\/tr>\n\t\t\t\t<tr><td width=\"5%\"><input type = \"checkbox\" name = \"show\" value = 1> <\/input> <\/td><td width=\"95%\">Edit table afterwards<\/td><\/tr>\n\t\t\t<\/table>\n\t\t\t<br>\n\t\t\t<input type = \"submit\" name = \"Save\" value = \"Save\"> <\/input>\n\t\t<\/form>\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4fe517d7-9bc8-4ddf-9d3e-8f6d8455ab2d",
          "commandChecksum": "4c4ae9a4a4656c41b0d5fce1d9c3b869",
          "propsChecksum": "6ffd1aa9855b13894d596555ad5cab15"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 332,
        "label": "deleteTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:shortTblNames\t= bot_listBoTTables()]\n\n[h:abort(input(\"shortTblName|\"+shortTblNames+\"|Choose a table|RADIO|SELECT\t= 0 VALUE=STRING\"))]\n\n[h:resetProperty(\"tbl.\"+shortTblName, \"lib:EventMacros\")]\n[h:broadcast(strformat(\"Table <b>%{shortTblName}<\/b> has been deleted\"))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2b5da3a5-483c-42b3-95b4-c6028d9aad2f",
          "commandChecksum": "06385de3735753acba15eb690efae19b",
          "propsChecksum": "b2fcc277145f75e2e7920ae994210b6d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6",
        "includeLabel": false,
        "sortBy": "6",
        "index": 333,
        "label": "getColumns",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[macro.return\t= decode(json.fields(json.get(getLibProperty(\"tbl.\"+arg(0), \"Lib:EventMacros\"), listGet(bot_getRows(arg(0)),1))))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7f209dab-be45-4c6e-871d-f34b8101e8d1",
          "commandChecksum": "e178d806d365c7cd6864ccaac143d400",
          "propsChecksum": "b999aedddef8e58154d183ecb86307fa"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 334,
        "label": "getRows",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[macro.return\t= decode(json.fields(getLibProperty(\"tbl.\"+arg(0), \"Lib:EventMacros\")))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "35f53c5c-aa1a-46e9-a342-e86cde77ed4f",
          "commandChecksum": "39b2d88ce928dcfae3c47ea67a0bc639",
          "propsChecksum": "acd4544517a68926825f0d58e21fac52"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 335,
        "label": "json.pappend",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[assert(argCount()\t== 3, \"json.pset requires three arguments (JSONVariable, JSONPath, Value)\", 0)]\n[jV\t\t= arg(0)]\n[path\t= trim(arg(1))]\n[val\t= arg(2)]\n\n[path\t= replace(\"path\\\", \"\\\\\\\", \"/\")]\n[path\t= if(substring(path, 0, 1) == \"/\", substring(path, 1), path)]\n\n[if(listCount(path, \"/\") <= 1), CODE: {\n\t[output\t\t= json.append(jV, val)]\n};{\n\t[fld\t\t= listGet(path, 0, \"/\")]\n\t[newPath\t= substring(path, length(fld)+1)]\n\t[assert(fld != \"\", \"Invalid path \" + path, 0)]\n\t[newjV\t\t= json.get(jV, fld)]\n\t\n\t[output\t\t= json.set(jV, fld, json.pappend( newjV, newPath, val))]\n}]\n\n[macro.return = output]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85e0b005-2206-4669-83e8-353703582d12",
          "commandChecksum": "3a3f97062bf9736dac63c301bd50a2c5",
          "propsChecksum": "04f0e719b163d55fe09b23c83cb115b1"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 336,
        "label": "json.paths",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[assert(argCount() > 0, \"json.paths requires a single argument ( JSONVariable )\", 0)]\n[val\t= arg(0)]\n[if(argCount() > 1): prefix\t= arg(1) ; prefix\t= \"\"]\n[paths\t= \"[]\"]\n[if(json.type(val) != \"UNKNOWN\"), foreach(p, json.fields(val)), CODE: {\n\t[obj\t= json.get(val, p)]\n\t[if(json.type(obj)\t== \"UNKNOWN\"), CODE : {\n\t\t[paths\t\t= json.append(paths, prefix + \"/\" + p)]\n\t};{\n\t\t[newPrefix\t= prefix + \"/\" + p]\n\t\t[paths\t\t= json.union(paths, json.paths(obj, newPrefix))]\n\t}] \n}]\n\n[macro.return\t= json.sort(paths)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "25bb001b-27ef-455a-842f-b75ceac12b88",
          "commandChecksum": "6cdde44249ec4e66b43cc958c8da8335",
          "propsChecksum": "8474c4a34fc550fa4c600b25dfd06776"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 337,
        "label": "json.pget",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[assert(argCount()\t== 2, \"json.pget requires two arguments (JSONVariable, JSONPath)\", 0)]\n[val\t= arg(0)]\n[path\t= arg(1)]\n[foreach(fld, path, \"\", \"/\"), CODE:{ \n\t[if(fld != \"\"), CODE: {\n\t\t[if(json.type(val)\t== \"OBJECT\"): assert(json.contains(val, fld), \"Invalid path ( \" + fld + \" )\", 0)]\n\t\t[if(json.type(val)\t== \"ARRAY\"): aT\t= if( fld > (json.length(val) - 1), 0, 1)]\n\t\t[if(json.type(val)\t== \"ARRAY\"): assert( aT, \"Invalid path index ( \" + fld + \" )\", 0)]\n\t\t[val\t= json.get(val, fld)]\n\t};{}]\n}]\n\n[macro.return\t= val]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ec2f538b-b5c7-4192-8305-52860d7dc922",
          "commandChecksum": "aa8560a34100b21c7371db88dd4565af",
          "propsChecksum": "0a6462c2e919167459867ea0fdd9ffb3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 338,
        "label": "json.pset",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[assert(argCount()\t== 3, \"json.pset requires three arguments (JSONVariable, JSONPath, Value)\", 0)]\n[jV\t\t= arg(0)]\n[path\t= arg(1)]\n[val\t= arg(2)]\n[path\t= if(substring(path, 0, 1)\t== \"/\", substring(path, 1), path)]\n[if(listCount(path, \"/\") == 1), CODE: {\n\t[output\t\t= json.set(jV, path, val)]\n};{\n\t[fld\t\t= listGet(path, 0, \"/\")]\n\t[newPath\t= substring(path, length(fld)+1)]\n\t[assert(fld != \"\", \"Invalid path \" + path, 0)]\n\t[newjV\t\t= json.get(jV, fld)]\n\t[output\t\t= json.set(jV, fld, json.pset( newjV, newPath, val))]\n}]\n[macro.return\t= output]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c8d74095-edcc-4976-bdf2-87e3acbefa00",
          "commandChecksum": "3cd8a5f6f91f51bf11b567ff366ffc3f",
          "propsChecksum": "cae5e156ea40e73a16f117a6176785ea"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "8",
        "includeLabel": false,
        "sortBy": "8",
        "index": 339,
        "label": "listBoTTables",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:fullTblNames \t= listSort(getMatchingLibProperties(\"tbl\\\\..*\", \"Lib:EventMacros\"),\"A+\")]\n[h:shortTblNames\t= \"\"]\n[h, foreach(item, fullTblNames): shortTblNames\t= listAppend(shortTblNames,substring(item,4))]\n[h:assert(shortTblNames != \"\", \"There are currently no tables stored on lib:EventMacros\", 0)]\n[h:macro.return\t\t= shortTblNames]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8055362a-2231-4967-85ae-5d8f851eb429",
          "commandChecksum": "6b165cd405f88549560b3eb034712ea7",
          "propsChecksum": "502f8db900cdb81ad33576708f33cbd9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 340,
        "label": "listMTTables",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:macro.return\t\t= json.toList(json.sort(json.get(getInfo(\"campaign\"), \"tables\")))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7451cdbe-99b6-488b-b41e-8e17bb924ebe",
          "commandChecksum": "f093a43e1e1ded5eeef2918860dc682b",
          "propsChecksum": "ee2f8680fd7fb21d71ff926adad142af"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 341,
        "label": "processTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:debug\t\t\t= 0]\n\n[h:result\t\t\t= macro.args]\n[h:assert(json.type(result) == \"OBJECT\",\"processTable received an erronous table. Most likely this is because you used double quotes in one of the fields.\",0)]\n[h:origResult\t\t= result]\n[h:result\t\t\t= encode(result)]\n[h:result\t\t\t= replace(result, \"%7B\", \"{\")]\n[h:result\t\t\t= replace(result, \"%7D\", \"}\")]\n[h:result\t\t\t= replace(result, \"%3A\", \":\")]\n[h:result\t\t\t= replace(result, '%22', '\"')]\n[h:result\t\t\t= replace(result, '%2C', ',')]\n[h:result\t\t\t= replace(result, '%40', '@')]\n\n[h:shortTblName\t\t= json.get(origResult, \"shortTblName\")]\n[h:choice\t\t\t= json.get(origResult, \"button\")]\n[h:tableColumnSize\t= json.get(origResult, \"tableColumnSize\")]\n\n\n[h:rebuild\t\t\t= 0]\n[h:addRow\t\t\t= 0]\n[h:addColumn\t\t= 0]\n[h,switch(choice), CODE:\n\tcase \"Save\":{ \n\t\t \n\t};\n\tcase \"Reset to last save\":{\n\t\t[bot_showTable(shortTblName)]\n\t\t[abort(0)]\n\t};\n\tcase \"Save & Close\":{\n\t\t[closeFrame(\"Table Editor\")]\n\t};\n\tcase \"<- Column ->\":{\n\t\t[tableColumnSize = tableColumnSize + 1]\t\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"-> Column <-\":{\n\t\t[tableColumnSize = tableColumnSize - 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"Add Row\":{\n\t\t[addRow\t\t= 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tcase \"Add Column\":{\n\t\t[addColumn\t= 1]\n\t\t[rebuild\t= 1]\t\t\t\t\t\t\t\n\t};\n\tdefault:{\n\t\t[abort(0)]\n\t};\n]\n\n[h,if(choice == \"close\" || choice == \"submit change & close\"): closeFrame(\"Table Editor\")]\n[h:assert(choice != \"close\", \"Changes have been discarded\", 0)]\n\n\n\n[h:tmpResult\t\t= result]\n[h:columns\t\t\t= \"\"]\n[h:rows\t\t\t\t= \"\"]\n\n[h,foreach(item, result), CODE:{\n\t[if(startsWith(item, \"@\")), CODE:{\n\t\t\n\t\t\n\t\t[value\t= json.get(result, item)]\n\t\t[item\t= substring(item,1)]\n\t\t\n\t\t[if(value != item): tmpResult = replace(tmpResult, '@'+item+'\"', '@'+value+'\"')]\n\t\t\n\t\t[columns\t= listAppend(columns, value)]\n\t}]\n\n\t[if(endsWith(item, \"@\")), CODE:{\n\t\t\n\t\t\n\t\t[value\t= json.get(result, item)]\n\t\t[item\t= substring(item,0,length(item)-1)]\n\t\t\n\t\t[if(value != item): tmpResult = replace(tmpResult, '\"'+item+'@', '\"'+value+'@')]\n\t\t\n\t\t[rows\t\t= listAppend(rows, value)]\n\t}]\n}]\n[h:result\t\t\t= tmpResult]\n[h,if(addColumn):\tcolumns\t= listAppend(columns, encode(\"<new column>\"))]\n[h,if(addRow):\t\trows\t= listAppend(rows, encode(\"<new row>\"))]\n\n\n[h:table\t= json.set(\"{}\", \"tableColumnSize\", tableColumnSize)]\n[h,foreach(rowName, rows), CODE:{\n\t\n\t\n\t[row\t= \"{}\"]\n\t[h,foreach(columnName, columns): row = json.set(row, columnName, json.get(result, rowName+\"@\"+columnName)))]\n\t[table\t= json.set(table, rowName, row)]\n\t['pause(\"rowName\",\"rows\",\"row\",\"result\",\"columns\")']\n}]\n\n[h,if(debug == 1), code:{\n\t\n\t[bot_debugInfo(\"result,table\",0,1,0, getMacroName(), getMacroLocation())]\n\t[r,frame(\"Debug\", \"width=100; height=100; temporary=1\"): {\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n\t\t[r:json.indent(table)]\n\t}]\n\t[h:where = getMacroName()]\n\t[h:pause(\"shortTblName\", \"where\", \"rows\", \"columns\")]\n};{}]\n\n\n[h:setLibProperty(\"tbl.\"+shortTblName, table, \"Lib:EventMacros\")]\n[h,if(rebuild || debug): bot_showTable(shortTblName)]\n[h:broadcast(\"Table is updated!\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ad230213-6949-4788-9568-0d68ba6f7c0b",
          "commandChecksum": "948fd5bd1b8284fe7d8c1ee6877d5c7d",
          "propsChecksum": "d79f68a5db205a054c45e2c2dc8646ac"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 342,
        "label": "searchRow",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[while(!done), CODE:{\n\t[row\t\t= listGet(rows, roll.count)]\n\t[pause(\"row\")]\n\t[if(indexOf(row,\"-\")+1), CODE:{\n\t\t[location\t= indexOf(row,\"-\")]\n\t\t[start\t\t= number(substring(row, 0, location))]\n\t\t[end \t\t= number(substring(row, location + 1, length(row)))]\n\t\t[if(roll >= start && roll <= end): resultRow = row]\n\t''\n\t};{\n\t\t[if(roll == row): resultRow = row]\n\t''\n\t}]\n\t[if(roll.count >= rowCount || resultRow != \"\"): done = 1]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "392fb113-b597-4571-b924-250785f79366",
          "commandChecksum": "0ddd36a7abe519070ae89525c81d44f3",
          "propsChecksum": "3d25df4895faee13dcd199ba6fe33b7d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 343,
        "label": "setTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n[h:assert(argCount() == 4, \"setTable requires EXACTLY 3 paramters: tableName, columnName, rowName, value\",0)]\n[h:shortTblName\t= arg(0)]\n[h:column\t\t= arg(1)]\n[h:row\t\t\t= arg(2)]\n[h:value\t\t= encode(arg(3))]\n\n[h:table\t\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n[h:rows\t\t\t= decode(json.fields(table))]\n[h,if(listContains(rows, \"tableColumnSize\")): rows = listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n[h:assert(listContains(rows,row), strformat(\"Cannot find the row <b>%{row}<\/b> in the table: <b>%{shortTblName}<b>. Available rows are: <b>%{rows}<\/b>\"),0)]\n[h:columns\t\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n[h:assert(listContains(columns,column), strformat(\"Cannot find the column <b>%{column}<\/b> in the table: <b>%{shortTblName}<\/b>. Available column are: <b>%{columns}<\/b>\"),0)]\n\n[h:encColumn\t= encode(column)]\n[h:encRow\t\t= encode(row)]\n\n[h:tmpRow\t\t= json.get(table, encRow)]\n[h:tmpRow\t\t= json.set(tmpRow, encColumn, value)]\n[h:table\t\t= json.set(table, encRow, tmpRow)]\n\n[h:table\t\t= setLibProperty(\"tbl.\"+shortTblName, table, \"Lib:EventMacros\")]\n\n[bot_setTable(\"tiny\", 'name', 6, \"tom\")]\n\n<pre>\n[r:table\t\t= getLibProperty(\"tbl.tiny\", \"Lib:EventMacros\")]\n[r:rows\t\t\t= decode(json.fields(table))]\n[r:columns\t\t= decode(json.fields(json.get(table, listGet(rows,0))))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0a429b5d-73c3-482d-b283-89e4ca77efe4",
          "commandChecksum": "1207dafa5ccb7964f8cb7ac3a4013f68",
          "propsChecksum": "aa3ac63440a1199de633bd60418da304"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 344,
        "label": "showTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:debug = 0]\n\n[h,if(argCount()): \n\tshortTblName = arg(0) \n; \n\tabort(input(\n\t\t\"shortTblName|\"+bot_listBoTTables()+\"|Show which table|RADIO|VALUE=STRING\"\n\t))\n]\n[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\n\n[h,if(debug == 1), code:{\n\t[r,frame(\"Debug\", \"width=100; height=100; temporary=1\"): {\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n\t\t[r:json.indent(table)]\n\t}]\n\t[h:pause(\"shortTblName\")]\n};{}]\n\n\n[h,if(json.contains(table, \"tableColumnSize\")), CODE:{\n\t[size\t= json.get(table, \"tableColumnSize\")]\n\t[table\t= json.remove(table, \"tableColumnSize\")]\n};{\n\t[size\t= 10]\n}]\n\n[h:encRows\t\t= json.fields(table)]\n[h:encColumns\t= json.fields(json.get(table, listGet(encRows,0)))]\n\n\n[h:headerRow\t= \"<td align='center'><b>Index<\/b><\/td>\"]\n[h,foreach(encColumn, encColumns), CODE:{\n\t[column\t\t= decode(encColumn)]\n\t[headerRow\t= headerRow + strformat(\"<td><b><input type='text' name='@%{column}' value='%{column}' size='%{size}'><\/b><\/td>\")]\n}]\n\n[h:processorLink\t= macroLinkText('processTable@Lib:onTokenMove', 'none')]\n[h:htmlStr\t\t\t=\tstrformat(\"\n\t<form action='%{processorLink}' method='json' >\n\t<input type='hidden' name='shortTblName' value='%{shortTblName}'>\n\t<input type='hidden' name='tableColumnSize' value='%{size}'>\n\t<input type='submit' name='button' value='Save'>\n\t<input type='submit' name='button' value='Reset to last save'>\n\t<input type='submit' name='button' value='Save & Close'>\n\t<input type='submit' name='button' value='<- Column ->'>\n\t<input type='submit' name='button' value='-> Column <-'>\n\t<input type='submit' name='button' value='Add Row'>\n\t<input type='submit' name='button' value='Add Column'>\n\t<table cellpadding='0' cellspacing='0'><tr>%{headerRow}<\/tr>\n\")]\n\n[h,if(debug == 1), code:{\n\t['bot_debugInfo(\"htmlStr\",1,0,0)']\n};{}]\n\n[h,foreach(encIndex,encRows), CODE:{\n\t[nRow\t\t= roll.count]\n\t[index\t\t= decode(encIndex)]\n\t[encRow\t\t= json.get(table, encIndex)]\n\t[htmlRow\t= strformat(\"<td><input type='text' name='%{index}@' value='%{index}' size='%{size}'><\/td>\")]\n\t[foreach(encColumn, encRow), CODE:{\n\t\t[nColumn\t= roll.count]\n\t\t[column\t\t= decode(encColumn)]\n\t\t[value\t\t= decode(json.get(encRow, encColumn))]\n\t\t[htmlRow\t= strformat(\"%{htmlRow}<td><input type='text' name='%{index}@%{column}' value='%{value}' size='%{size}'><\/td>\")]\n\t}]\n\t[htmlStr\t= strformat(\"%{htmlStr}<tr>%{htmlRow}<\/tr>\")]\n}]\n\n[h:htmlStr\t=\tstrformat(\"%{htmlStr}\n\t<\/table>\n\t<input type='submit' name='button' value='Save'>\n\t<input type='submit' name='button' value='Reset to last save'>\n\t<input type='submit' name='button' value='Save & Close'>\n\t<input type='submit' name='button' value='<- Column ->'>\n\t<input type='submit' name='button' value='-> Column <-'> \n\t<\/form>\n<br>\n<b>Da Rules<\/b>: <br>\nWhen I'm talking about column/row *names* I means the entries in the first column (==Index ==row names) and the top row (== column names). When I'm talking about *values* thats the rest. Every value is referred (found) by its corresponding column and row name.<br>\n- do NOT use the 'single quotes' in the table. Everything should still work, but they will be removed. <br>\n- do NOT use '@' for column or row names. I use this in the code as seperator, so funky stuff will happen if you're using it too. It should be ok to use it inside values, just not in the names. <br>\n- every column and row MUST have a unique name <br>\n- thus the 'add row/column' macro will only work once until you renamed the newly created column/row.<br>\n- everything you enter is encoded and then stored in a json object. This *Should* result in a quite robust table allowing for many characters. I have not tested them all, although I'm fairly certain that it will break on 'non-printable character' (e.g. the apostrophe's in Word).<br>\n\")]\n[h:'bot_showHTML(htmlStr)']\n\n[r,frame(\"Table Editor\", \"width=100; height=100; temporary=1\"): {\n\t[r:htmlStr]\n\t[r,if(debug == 1), code:{\n\t\t<b>DEBUG INFO<\/b>\n\t\t<pre>\n[r:json.indent(table)]\n\t};{}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85e3bafd-12d6-414f-b9e2-c822cecb2ab9",
          "commandChecksum": "8484b92d5e1f397fe17fb51e70a7e81d",
          "propsChecksum": "fd5d36fc71e82a8bc8183c906f013b55"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "9",
        "includeLabel": false,
        "sortBy": "9",
        "index": 345,
        "label": "table",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n[h, if(argCount() > 0): shortTblName= arg(0);\tshortTblName= \"\"]\n[h, if(argCount() > 1): column\t\t= arg(1);\tcolumn\t\t= 0]\n[h, if(argCount() > 2): roll\t\t= arg(2);\troll\t\t= \"random\"]\n\n[if(shortTblName == \"\"), CODE:{\n\t\n\t[shortTblNames\t= bot_listBoTTables()]\n\t[abort(input(\"shortTblName|\"+shortTblNames+\"|Choose a table|RADIO|SELECT=0 VALUE=STRING\"))]\n\n\t[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\t[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n\t[h:rows\t\t= decode(json.fields(table))]\n\t[h, if(listContains(rows, \"tableColumnSize\")):rows\t\t= listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n\t[h:columns\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n\n\t[abort(input(\n\t\t\"column|\"+columns+\"|Choose column|RADIO|SELECT=0 VALUE=STRING\",\n\t\t\"row|\"+rows+\"|Choose row|RADIO|SELECT=0 VALUE=STRING\"\n\t))]\n''\n};{\n\t[h:table\t= getLibProperty(\"tbl.\"+shortTblName, \"Lib:EventMacros\")]\n\t[h:assert(json.type(table)==\"OBJECT\", strformat(\"Cannot find the table <b>%{shortTblName}<\/b> on lib:EventMacros\"),0)]\n\t[h:rows\t\t= decode(json.fields(table))]\n\t[h, if(listContains(rows, \"tableColumnSize\")):rows\t\t= listDelete(rows, listFind(rows, \"tableColumnSize\"))]\n\t[h:columns\t= decode(json.fields(json.get(table, listGet(rows,0))))]\n\t[h,if(isNumber(column)): column\t= listGet(columns, column)]\n\n\t[h,if(isNumber(roll) || roll == \"random\"),CODE:{\n\t\t\n\t\t[rowCount\t= listCount(rows)]\n\t\t[lastRow\t= listGet(rows, rowCount-1)]\n\t\t[if(indexOf(lastRow,\"-\")+1): end\t= substring(lastRow, indexOf(lastRow,\"-\") + 1, length(lastRow)) ; end = lastRow]\n\t\t[if(isNumber(end)), CODE:{\n\t\t\t[end\t\t\t= number(end)]\n\t\t\t[numericRows\t= 1]\n\t\t''\n\t\t};{\n\t\t\t[end\t\t\t= listCount(rows)]\n\t\t\t[numericRows\t= 0]\n\t\t''\n\t\t}]\n\t\t\n\t\t\n\t\t[roll\t= if(roll == \"random\",roll(1, end),roll)]\n\t\t\n\t\t[if(numericRows), CODE:{\n\t\t\t[resultRow\t= \"\"]\n\t\t\t[done\t\t= 0]\n\t\t\t\n\t\t\t[bot_searchRow()]\n\t\t''\n\t\t};{\n\t\t\t\n\t\t\t[row\t= listGet(rows, roll-1)]\n\t\t''\n\t\t}]\n\t''\n\t};{\n\t\t\n\t\t[row\t= roll]\n\t''\n\t}]\n''\n}]\n[pause(\"column\", \"row\")]\n[macro.return\t= decode(json.pget(table,encode(row)+\"/\"+encode(column)))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0c66f0d1-ff8b-45c4-a69a-fcdbed51318a",
          "commandChecksum": "bbbe13e60ab82667f8232e7db61229f4",
          "propsChecksum": "4273a9a979b20051fe5fba6348f428c2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 346,
        "label": "text2Table",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h: args \t= macro.args]\n[h: Title \t= json.get(args, \"Title\")]\n[h: show \t= json.get(args, \"show\")]\n[h: text \t= encode(json.get(args, \"TextBox\"))]\n\n[delim\t \t= \"%09\"]\n[lb \t\t= \"%0A\"]\n\n[jTable\t\t= \"{}\"]\n[row\t\t= \"\"]\n[rowName\t= \"\"]\n\n[rows\t\t= json.fromList( text , lb )]\n[nRows\t\t= json.length( rows )]\n\n\n[line.txt\t= json.get( rows , 0 )]\t\t\t\t\t\t\n[headerRow\t= json.fromList( line.txt , delim )]\t\t\n[tableName\t= json.get( headerRow, 0 )]\n[nCols\t\t= json.length( headerRow )]\t\t\t\t\t\n[rows\t\t= json.remove( rows , 0 )]\t\t\t\t\t\n\n\n[h, FOREACH( rowText , rows ), CODE: {\n\t[rowText\t= listAppend(rowText, \"tmp\", delim)]\t\t\n\t[row\t\t= json.fromList( rowText , delim )]\t\t\t\n\t[row\t\t= json.remove( row, nCols)]\t\t\t\t\t\n\t[jRow\t\t= \"{}\" ]\n\t[FOR( i , 0 , nCols ), CODE: {\n\t\t[item \t\t= json.get( row , i )]\t\t\t\t\t\n\t\t[column\t\t= json.get( headerRow , i )]\t\t\t\n\n\t\t\n\t\t[if( i == 0 ): rowName = item ; jRow = json.set( jRow , column, item )]\n\t}]\n\t[jTable\t\t= json.set( jTable , rowName , jRow )]\n}]\n\n[h:setLibProperty(\"tbl.\"+Title, jTable, \"Lib:EventMacros\")]\n[h,if(show):bot_showTable(Title)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "04681253-9e8d-4076-83ef-9f927752ee00",
          "commandChecksum": "d8441f20af2a64a0ca9e218630eed568",
          "propsChecksum": "d7d40ae5eff5aacfec599d5d351a426a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 347,
        "label": "deferToggleDoor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\t\n\t[choice\t\t\t= getProperty(\"w42.bot.choice\", me)]\n\n\t\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t\n\t[varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n\n\t\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t\t[if(choice==\"crack\"):\tendPos\t= bot_getTokenFacing(me) + direction*crackOpenAngle]\n\t\t[if(choice==\"close\"):\tabort(0)] \n\t\t\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[startPos \t\t= bot_getTokenFacing(me)]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t\n\t\t[if(choice==\"crack\"):\tendPos\t\t= startPos + direction*crackOpenAngle]\n\t\t[if(choice==\"open\"):\tendPos\t\t= totalOpenAngle]\n\t\t[if(choice==\"close\"):\tdirection\t= -1*direction]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n\n\n\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, getTokenX(1), getTokenY(1))]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t\t[if(choice==\"crack\"):\tendPos\t= startPos + direction*crackOpenDistance]\n\t\t[if(choice==\"close\"):\tabort(0)] \n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, getTokenX(1), getTokenY(1))]\n\n\t\t[if(choice==\"crack\"):\tendPos\t= startPos + direction*crackOpenDistance]\n\t\t[if(choice==\"open\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t\t[if(choice==\"close\"):\tdirection\t= -1*direction]\n\n\t\t\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n\n\n\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3b6a0391-8962-4c8d-8fc2-302e6fd6b6d2",
          "commandChecksum": "8c853fbcbdbb181298684e20888b2f98",
          "propsChecksum": "561711e9e91c0df04415e171a97b0433"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "7",
        "includeLabel": false,
        "sortBy": "7",
        "index": 348,
        "label": "isDoorClosed",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h,if(argCount() > 0):\tmainDoor\t= arg(0) ; mainDoor\t= currentToken()]\n\n[h:switchToken(mainDoor)]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h,if(openMethod < 2):\n\tisClosed \t\t= if(bot_getTokenFacing(mainDoor) == closedAngle, 1, 0)\n; \n\tisClosed \t\t= if(getTokenX(1) == closedDoorX && getTokenY(1) == closedDoorY , 1, 0)\n]\n\n[r:macro.return = isClosed]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dd8696f5-83fc-4d9c-a5a0-484bf04e072f",
          "commandChecksum": "c0c46100b16e50929aa598a2a5240521",
          "propsChecksum": "66c178c68aaf046fa6f1de62e0d05892"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 349,
        "label": "setDoor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n stepSize=0;\n halfStepSize=0;\n crackStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpendistance=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n')]\n\n\n[h:varsFromStrProp(initList)]\n\n\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n\n[h: abort(input(\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\t\"crackOpenAngle|\"+crackOpenAngle+\"|How many degrees does the door turn when opening it a bit (to peek)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"crackOpendistance|\"+crackOpendistance+\"|How much does the door slide away a bit (to take a peek, also in distance per cell)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\"\n))]\n\n\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, openDistance\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n\n\n\n\n\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t\n\t\t[stepSize\t\t=  openAngle/(animateTime+1)]\n\t\t[crackStepSize\t= 10/(animateTime+1)]\n\t\t[halfStepSize\t= 45/(animateTime+1)]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t\n\t\t[stepSize\t\t= openDistance/(animateTime+1)]\n\t\t[crackStepSize\t= (openDistance/10)/(animateTime+1)]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\", \"closedDoorX=\"+getTokenX(1,doubleDoorName)+\";closedDoorY=\"+getTokenY(1,doubleDoorName))]\n\n\t\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t\n\t[h:setState(\"Locked\",isLocked)]\n\n\t\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpendistance, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6c301b29-6f0d-4fa1-90e5-260e08fbccc2",
          "commandChecksum": "2648174f634c9d8e8a060be9c479247d",
          "propsChecksum": "5555637e9b9e22fa703ad3b311bfc344"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 351,
        "label": "toggleDoor",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n[h:crack\t\t\t\t= getStrProp(getProperty(\"w42.bot.doorData\", mainDoor),\"crackOpenDistance\")]\n[h,if(crack==\"\"): crackOpenDistance=0]\n\n\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n[if(crackOpenAngle+crackOpenDistance > 1), CODE:{\n\t[choices\t= \"Do nothing, Crack the door open (further), Open the door all the way, close the door\"]\n\t[propList\t= \"nothing,crack,open,close\"]\n\t\n\t[abort(input(\n\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\"choice|\"+choices+\"|You...|RADIO|VALUE=STRING\"\n\t))]\n\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t\n\t[assert(choice != \"nothing\",\"you do nothing\",0)]\n}; {\n\t[choice = \"normal\"]\n}]\n\n[h:setProperty(\"w42.bot.choice\", choice, mainDoor)]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "03fd6d74-1321-4adc-9ec6-d5c66ad077ee",
          "commandChecksum": "8566b9d75c7439b3d7987b28511ca326",
          "propsChecksum": "5d585dee8566716e93dac77429cd91e8"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 352,
        "label": "toggleDoors",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'!']\n\n[h:'']\n[h:tokens\t= getTokenNames(\",\",'{\"layer\":\"OBJECT\"}')]\n[h:me\t\t= getSelectedNames()]\n[h:showClosestOnly\t= if(!isGM() || me != \"\", 1, 0)]\n[h, if(showClosestOnly):assert(listCount(me) == 1, \"Make sure (only) one token is selected\",0)]\n[h:Doors\t= \"\"]\n[h, foreach(tok, tokens),CODE:{\n\t[if(startsWith(tok, \"Door \") && getProperty(\"w42.bot.doorData\", tok)!=\"\" && !endsWith(tok, \"a\")): Doors = listAppend(Doors, tok)]\n}]\n\n[h: assert(Doors != \"\",\"There are no doors set on the object layer of this map\",0)]\n\n[h:Doors = listSort(Doors, \"N+\")]\n\n[h:'']\n[h:iDoors\t\t\t\t= \"\"]\n[h:descriptionsDoors\t= \"\"]\n[h:playerDoors\t\t\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t[id\t\t\t\t\t= substring(door, 5)]\n\t[description\t\t= getStrProp(getProperty(\"w42.bot.doorData\",door),\"description\")]\n\t[iDoors\t\t\t\t= listAppend(iDoors, id)]\n\t[varsFromStrProp(getProperty(\"w42.bot.doorData\", door))]\n\t\n\t[if(showClosestOnly), CODE:{\n\t\t[proximity\t\t= getStrProp(getProperty(\"w42.bot.doorData\",door),\"proximity\")]\n\t\t[distance\t\t= getDistance(me, 1, door)]\n\t\t[descriptionsDoors\t= listAppend(descriptionsDoors, strformat(\"(%{id}) %{description}\"))]\n\t\t[if((distance <= proximity || proximity == 0) && getVisible(door)): playerDoors\t\t= listAppend(playerDoors, door)]\n\t};{\n\t\t[descriptionsDoors\t= listAppend(descriptionsDoors, strformat(\"(%{id}) %{description}\"))]\n\t}]\n}]\n\n[h,if(showClosestOnly): usableDoors = playerDoors; usableDoors = Doors]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Toggle Doors - (name of the door) Description given<\/b><br><\/html>|-|LABEL|SPAN=TRUE\"]\n[h,if(usableDoors == \"\"):inputStr\t= listAppend(inputStr, \"junk|<html><b><font color=red>\"+if(showClosestOnly, \"You are too far from any door to open\", \"There are no doors on this map\")+\"<\/font><\/b><br><\/html>|-|LABEL|SPAN=TRUE\", \"@\")]\n\n[h,foreach(door, Doors), if(listContains(usableDoors, door)), CODE:{\n\t\t[newStr = \"door\" + roll.count + \"|0|\" + listGet(descriptionsDoors, roll.count) + \"|CHECK\"]\n\t\t[inputStr = listAppend(inputStr, newStr,\"##\")]\n};{\n\t\t[eval(\"door\" + roll.count + \"=0\")]\n}]\n\n[h:'']\n[h: abort(input(inputStr))]\n\n[h:'']\n[h,foreach(door, Doors), CODE:{\n\t['if(eval(\"door\" + roll.count)):bot_toggleDoor(listGet(iDoors, roll.count))']\n\t[if(eval(\"door\" + roll.count)):execLink(macroLinkText(\"toggleDoor@lib:onTokenMove\",\"none\",listGet(iDoors, roll.count)),1)]\n}]\n[h:'!']",
        "maxWidth": "",
        "tooltip": "<html>This will show a pop-up with all the initialized doors<br>on the OBJECT LAYER. Here you can select which to open/close",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4fb6af11-6c7b-4907-8588-9be2739c99d1",
          "commandChecksum": "195393c506631066126f64ea687e7033",
          "propsChecksum": "bb54808fef7d847d73df4cc442744755"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 353,
        "label": "doShadowPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me\t\t\t= arg(0)]\n[h:event\t\t= arg(1)]\n[h:padName\t\t= arg(2)]\n\n\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n[h:switchToken(me)]\n\n\n[h:sName\t\t= if(bot_inStr(padName, \"Ground\"), \"Floor\", \"Ground\")]\n[h:id\t\t\t= getGroup(strfind(padName,\"ShadowPad ([^\\\\s]+)\"),1,1)]\n[h:sPadname\t\t= strformat(\"ShadowPad %{id} %{sName}\")]\n\n\n[h:pActive\t\t= if(isNumber(getProperty(\"w42.bot.Active\", padName)),getProperty(\"w42.bot.Active\", padName),0)]\n[h:sActive\t\t= if(isNumber(getProperty(\"w42.bot.Active\", sPadName)),getProperty(\"w42.bot.Active\", sPadName),0)]\n\n\n[h,if(sActive == 1): sTokList\t= getProperty(\"w42.bot.onPad\", sPadName) ; sTokList = \"\"]\n\n\n[h:tokList\t\t= \"\"]\n\n[h,if(event == \"movedOn\"), CODE:{\n\t\n\t[pTokList\t= getProperty(\"w42.bot.onPad\", padName)]\n\t[if(!listContains(pTokList, me)): pTokList\t= listAppend(pTokList, me)]\n\t[setProperty(\"w42.bot.onPad\", pTokList, padName)]\n\t[setProperty(\"w42.bot.Active\", 1, padName)]\n};{}]\t\n\n[h,if(event == \"movedOff\"), CODE:{\n\n\t[pTokList\t= getProperty(\"w42.bot.onPad\", padName)]\n\t[pTokList\t= listDelete(pTokList, listFind(pTokList, me))]\n\t[setProperty(\"w42.bot.onPad\", pTokList, padName)]\n\t\n\t[if(pTokList == \"\"):setProperty(\"w42.bot.Active\", 0, padName)]\n\t\n\t\n\t[if(pActive && sActive): bot_removeShadow(me)]\n\t[if(pTokList == \"\" && pActive && sActive), CODE:{\n\t\t\n\t\t[foreach(tok, sTokList): bot_removeShadow(tok)]\n\t};{}]\n\t\n\t[if(pTokList != \"\" && pActive && sActive), CODE:{\n\t\t\n\t\t[viewingPlayers\t= \"[]\"]\n\t\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\t[foreach(tok, tokList), if(isOwnedByAll(tok)): \n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getAllPlayerNames(\"json\")) \n\t\t\t;\n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getOwners(\"json\",tok))\n\t\t]\n\t\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\t[foreach(tok, tokList): setOwner(viewingPlayers, tok+\" shadow\")]\n\t};{}]\n};{}]\t\n\n[h, if( event == \"movedOn\" && sActive), CODE:{\n\t\n\t\n\t[tokList\t= listAppend(pTokList,sTokList)]\n\t\n\t[if(pActive), CODE:{\n\t\t\n\t\t\n\t\t[others\t\t= getOwners(\"json\", listGet(sTokList, 0)+\" shadow\")]\n\t\t[if(isOwnedByAll(me)): \n\t\t\tviewingPlayers = json.union(others, getAllPlayerNames(\"json\")) \n\t\t;  \n\t\t\tviewingPlayers = json.union(others, getOwners(\"json\",me)) \n\t\t]\n\t\t\n\t\t\n\t\t[tokList\t= listDelete(tokList, listFind(tokList, me))]\n\t\t[foreach(tok, tokList): setOwner(viewingPlayers, tok+\" shadow\")]\n\t\t\n\t\t[tokList\t= me]\n\t};{\n\t\t\n\t\t[viewingPlayers\t= \"[]\"]\n\t\t[foreach(tok, tokList), if(isOwnedByAll(tok)): \n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getAllPlayerNames(\"json\"))\n\t\t\t;\n\t\t\t\tviewingPlayers = json.union(viewingPlayers, getOwners(\"json\",tok))\n\t\t]\n\t}]\n\t\n\t\n\t\n\t[foreach(tok, tokList), CODE:{\n\t\t\n\t\t[isVisible\t= getOwnerOnlyVisible(tok)]\n\t\t[hasHalo\t= getHalo(tok)]\n\t\t[owners\t\t= getOwners(\"json\", tok)]\n\t\t\n\t\t\n\t\t[altShadow\t= if(findToken(tok+\" shadow\") !=\"\", 1, 0)]\n\n\t\t\n\t\t[newTok\t\t= if(altShadow , tok+\" shadow\", tok)]\n\t\t[setProperty(\"w42.bot.isShadowToken\", 1, newTok)]\n\t\t[setOwnerOnlyVisible(1, newTok)]\n\t\t[setHalo(\"black\", newTok)]\n\t\t[setOwner(viewingPlayers, newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.doNotDelete\", 1, newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.x\", getTokenX(1, newTok), newTok)]\n\t\t[if(altShadow): setProperty(\"w42.bot.y\", getTokenY(1, newTok), newTok)]\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t[bot_shadowCoords(tok, !altShadow)]\n\t\t\n\t\t\n\t\t[sizeList = \"Fine,Diminutive,Tiny,Small,Medium,Large,Huge,Gargantuan,Colossal\"]\n\t\t[size = if(getSize(tok) == \"\" || getSize(tok) == \"Fine\", \"Diminutive\", getSize(tok))]\n\t\t[pause(\"size\",\"altShadow\")]\n\t\t[if(!altShadow): copyToken(tok,1, \"\", json.set(\"{}\", \"name\", tok+\" shadow\", \"layer\", if(canSelectShadowTok, \"TOKEN\", \"OBJECT\"), \"x\", x, \"y\", y,\"useDistance\",1, \"size\", listGet(sizeList, listFind(sizeList,size)-1)))]\n\t\t\n\t\t\n\t\t[setOwnerOnlyVisible(isVisible, tok)]\n\t\t[setHalo(hasHalo, tok)]\n\t\t[setOwner(owners, tok)]\n\t\t[resetProperty(\"w42.bot.isShadowToken\", tok)]\n\t}]\n};{}]\n\n\n[h,if( (event == \"movedRemain\" || event == \"movedReturn\") && sActive), CODE:{\n\t[tokList\t= listAppend(getProperty(\"w42.bot.onPad\", padName), getProperty(\"w42.bot.onPad\", sPadName))]\n\t[foreach(tok, tokList):bot_shadowCoords(tok)]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "bd2c84e9-3f1a-49e6-9647-41d7769c1eda",
          "commandChecksum": "55cdaabbd77eb35428984adfd7ec629c",
          "propsChecksum": "afc17a5f5c6f7ca27ddd32fbc11ea1ce"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 354,
        "label": "removeShadow",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[tok\t= arg(0)+\" shadow\"]\n[if(getProperty(\"w42.bot.doNotDelete\", tok) == 1), CODE:{\n\t[moveToken(getProperty(\"w42.bot.x\", tok), getProperty(\"w42.bot.y\", tok), 1, tok)]\n};{\n\t[removeToken(tok)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5c364596-b08d-42fa-bc03-6d8ffc15fae6",
          "commandChecksum": "216265446b359df2d50717fc208710df",
          "propsChecksum": "3da3e22653e997fabdae31e4479e1ce8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 355,
        "label": "setReference",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me = getSelectedNames()]\n\n[h:assert(listCount(me)==1,\"Please select (only) one reference token\",0)]\n[h:assert(bot_inStr(me, \" Floor\")||bot_inStr(me, \" Ground\"),\"This token misses the Ground or Floor suffix\",0)]\n[h:switchToken(me)]\n\n[h:isFloor\t\t= if(bot_inStr(me, \" Floor\"), 1,0)]\n[h:reference\t= substring(me, 0, indexOf(me, if(isFloor, \" Floor\", \" Ground\")))]\n[h:sMe\t\t\t= reference + if(isFloor, \" Ground\", \" Floor\")]\n[h:assert(findToken(sMe) != \"\", sMe+\" token not found. Create that one first\",0)]\n\n[H: '']\n[h:bot_getValidTokens(1, json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")), 0, \"ShadowPad \")]\n[h:allList\t= replace(allList, \" Floor\", \"\")]\n[h:allList\t= replace(allList, \" Ground\", \"\")]\n[h:allList\t= json.toList(json.unique(json.fromList(allList)))]\n\n[h:abort(input(\"choice|\"+allList+\"|Link to which shadow pads?|LIST|VALUE=STRING\"))]\n\n[h:padNameG = choice + \" Ground\"]\n[h:padNameF = choice + \" Floor\"]\n\n[h:setProperty(\"w42.bot.referenceTok\", reference, padNameG)]\n[h:setProperty(\"w42.bot.referenceTok\", reference, padNameF)]\n\n[H: '']\n[h:setProperty(\"w42.bot.onPad\", \"\", padNameG)]\n[h:setProperty(\"w42.bot.onPad\", \"\", padNameF)]\n[h:setProperty(\"w42.bot.Active\", \"\", padNameG)]\n[h:setProperty(\"w42.bot.Active\", \"\", padNameF)]\n\n[h:broadcast(strformat(\"%{reference} has been linked to %{choice}\"))]",
        "maxWidth": "",
        "tooltip": "<html>This macro is used to setup the <b>Shadow pads.<\/b><br> To sync the movement of the shadow token to the real token two reference tokens are required.<br> <br> To set this up do the following:<br> 1. create two tokens with the same name where one has the suffix '",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6b0032d4-a26a-4465-8382-4baa17b28bd5",
          "commandChecksum": "91995a0b5536d8606f12b9baa0f450f1",
          "propsChecksum": "8df39898f03147ead23e643c44d15dd0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "32",
        "includeLabel": false,
        "sortBy": "32",
        "index": 356,
        "label": "shadowCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[switchToken(arg(0))]\n\n[if(argCount() > 1): returnCoords = arg(1); returnCoords = 0]\n\n[referenceToken\t= getProperty(\"w42.bot.referenceTok\", padName)]\n[shadow\t\t\t= token.name + ' shadow']\n\n\n[whereAmI    \t= if( (abs(getTokenX() - getTokenX(1, referenceToken + ' Ground')) + abs(getTokenY() - getTokenY(1, referenceToken + ' Ground'))) < (abs(getTokenX() - getTokenX(1, referenceToken + ' Floor')) + abs(getTokenY() - getTokenY(1, referenceToken + ' Floor'))) , -1, 1 )]\n\n\n[if(returnCoords), CODE:{\n\t\n\t[x\t= getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') )]\n\t[y\t= getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') )]\n};{\n\t[moveToken( getTokenX(1) + whereAmI*( getTokenX(1, referenceToken + ' Ground') - getTokenX(1, referenceToken + ' Floor') ), getTokenY(1) + whereAmI*( getTokenY(1, referenceToken + ' Ground') - getTokenY(1, referenceToken + ' Floor') ), 1, shadow)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e83732cc-023b-4fc1-b837-03c7f96397f0",
          "commandChecksum": "13e28e4624fbb9c3b45e0d6448630d2e",
          "propsChecksum": "a2b6c448130bf1c829e6afa36163916f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "16",
        "includeLabel": false,
        "sortBy": "16",
        "index": 357,
        "label": "formatTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[seconds\t\t= arg(0)/1000]\n[if(argCount()>1): useHTML = arg(1) ; useHTML = 1]\n\n[minutes\t\t= floor(seconds/60)]\n[seconds\t\t= seconds - minutes*60]\n\n[hours\t\t\t= floor(minutes/60)]\n[minutes\t\t= minutes - hours*60]\n\n[macro.return\t= if(hours, hours+if(useHTML,\"<b>h<\/b>\",\" hours \"),\"\") + if(minutes, minutes+if(useHTML,\"<b>m<\/b>\",\" minutes \"),\"\") + seconds+if(useHTML,\"<b>s<\/b>\",\" seconds \")]",
        "maxWidth": "",
        "tooltip": "Total amount of time passed since the timer was started",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a4a6dc41-312b-4286-8582-db41de66b481",
          "commandChecksum": "ddf7f60b3bae074a082e93434c742647",
          "propsChecksum": "0c12616ffa526eb30937eb25762481de"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 358,
        "label": "pauseTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n[h:setLibProperty(\"w42.bot.pauseTime\", time, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 1, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7a128a76-5a05-46f4-bba9-9e04db10a761",
          "commandChecksum": "105bcb10076b6e989468602d0825fa61",
          "propsChecksum": "908af8ef8e14fb6ed8d06d7e82b738d8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 359,
        "label": "resetTimer",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[setLibProperty('w42.bot.lastTime'+arg(0), json.get(getInfo(\"client\"),\"timeInMs\"), 'lib:EventMacros')]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9e4f41ae-a441-4867-bc8e-305dd819f1e6",
          "commandChecksum": "156795b403f4f16aba1794a72b39af3c",
          "propsChecksum": "c850ef4e219b3b69da86281b687d3c9d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "13",
        "includeLabel": false,
        "sortBy": "13",
        "index": 360,
        "label": "resumeTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:pausedTime\t= getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")]\n[h:time\t\t\t= json.get(getInfo(\"client\"), \"timeInMs\") - pausedTime]\n[h:pauseTime\t= getLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\")]\n[h:stoppedTime\t= max(0,time - pauseTime)]\n[h:pausedTime\t= pausedTime + stoppedTime]\n[h:setLibProperty(\"w42.bot.pausedTime\", pausedTime, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 0, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d9e42852-9778-4881-816f-9a5348d99cc1",
          "commandChecksum": "c1f119412cb3f20672d8f0a4ffe7bc90",
          "propsChecksum": "6461a327663c170d286149476c8de2f8"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 361,
        "label": "startTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:time\t= json.get(getInfo(\"client\"), \"timeInMs\")]\n[h:setLibProperty(\"w42.bot.startTime\", time, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.subTime\", time, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"w42.bot.pausedTime\", 0, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.pauseTime\", 0, \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.timeIsPaused\", 0, \"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>start the timer<br>to reset just run startTime again",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "cf0c5c39-0a62-4e7e-8891-53e9f1b11046",
          "commandChecksum": "a1024e696257705e321eccbe5cf6ae3d",
          "propsChecksum": "e237ebca2158b88a9fb1a730d2e1b41f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "14",
        "includeLabel": false,
        "sortBy": "14",
        "index": 362,
        "label": "subTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n\n[h:subTime\t\t= getLibProperty(\"w42.bot.subTime\", \"lib:EventMacros\")]\n[h:setLibProperty(\"w42.bot.subTime\", time, \"lib:EventMacros\")]\n[h:resultTime\t= time - subTime]\n[h,if(makeUp): resultTime = bot_formatTime(resultTime)]\n[h:macro.return\t= resultTime]",
        "maxWidth": "",
        "tooltip": "<html>get a subtime, which is the period that has passed since the start or the last subtime (which ever is later)<br>pass 1 as parameter to get formatted time",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "44881832-f539-4203-8955-c2374d1e17dd",
          "commandChecksum": "c74ab467f6b55e595d36ed47e14bef74",
          "propsChecksum": "a25a67bcf1fdeeb2a5ddc7bd2074f5a5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "red",
        "group": "Util - Timer",
        "includeLabel": false,
        "sortBy": "Util - Timer",
        "index": 363,
        "label": "timeOut",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h: lastRun\t\t\t= getLibProperty('w42.bot.lastTime'+arg(0),'lib:EventMacros')]\n[h,if(lastRun == \"\"):lastRun = 0]\n[h: currentTime \t= json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: timeLockDelay\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n\n[h: macro.return\t= if(currentTime < lastRun - timeLockDelay || currentTime > lastRun + timeLockDelay, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "78d09807-21f9-4317-8454-d32f76608d3a",
          "commandChecksum": "a20f49c6e578c38e2a237a2b88bc3ce8",
          "propsChecksum": "21a327d71e8430667b7f5a79837ecae3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "15",
        "includeLabel": false,
        "sortBy": "15",
        "index": 364,
        "label": "totalTime",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[if(argCount() > 0): makeUp = arg(0) ; makeUp = 0]\n[h:time\t\t\t= if(\tgetLibProperty(\"w42.bot.timeIsPaused\", \"lib:EventMacros\"), \n\t\t\t\t\t\tgetLibProperty(\"w42.bot.pauseTime\", \"lib:EventMacros\") , \n\t\t\t\t\t\tjson.get(getInfo(\"client\"), \"timeInMs\") - getLibProperty(\"w42.bot.pausedTime\", \"lib:EventMacros\")\n)]\n[h:startTime\t= getLibProperty(\"w42.bot.startTime\", \"lib:EventMacros\")]\n\n[h:resultTime\t= time - startTime]\n[h,if(makeUp): resultTime = bot_formatTime(resultTime)]\n[h:macro.return\t= resultTime]",
        "maxWidth": "",
        "tooltip": "<html>Total amount of time passed since the timer was started<br>pass 1 as parameter to get formatted time<br>note that totaltime does NOT reset the timer",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "868c71b5-d2e0-464e-b8dd-c8cf6e4c4979",
          "commandChecksum": "ddca7bad8be6cd3a2669620a98ac5d88",
          "propsChecksum": "c53f7ebdf3a120a242a255b85335db3d"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "d. Nildiks Frames",
        "includeLabel": false,
        "sortBy": "d. Nildiks Frames",
        "index": 365,
        "label": "frameClose",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h: numArgs\t= argCount()]\n[h, if(numArgs>0):\tframeNr\t= arg(0); frameNr\t= 1]\n[h, count(4):\t\tset(  \"frame\"+(roll.count + 5) , tableImage(\"frames\",frameNr * 10 + roll.count + 6)  )]\n\n[h:macro.return\t= \"\n\t\t\t<\/td>\n\t\t\t<td style='background-image: url(\" + frame5 + \"); background-repeat: repeat; font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t\t<tr>\n\t\t\t<td \" + table(\"frames\", frameNr*10+7) + \" background=\" + frame6 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td  background=\" + frame7 + if(frameNr==0,\" style='padding-bottom: 10px; font-size:1px''>\n\t\t\t\t<input type='text' size=30>\n\t\t\t<\/td>\", \" style='font-size:1px'><\/td>\") + \"\n\t\t\t<td background=\" + frame8 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t<\/table>\n\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "54e71f3c-9790-483d-ab54-7c14a35e008e",
          "commandChecksum": "f7b0e9ce778f79b50f83167e6557733f",
          "propsChecksum": "a82c418053733d2593c3d8ccec2c8ee0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "d. Nildiks Frames",
        "includeLabel": false,
        "sortBy": "d. Nildiks Frames",
        "index": 366,
        "label": "frameOpen",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:numArgs\t= argCount()]\n[h,if(numArgs > 0):\tframeNr\t\t= arg(0) ; frameNr\t\t= 1] \n[h,if(numArgs > 1):\ttitle\t\t= arg(1) ; title\t\t= \"\"] \n[h,if(numArgs > 2):\ttitleColor\t= arg(2) ; titleColor\t= \"black\"]\n[h,count(5):\t\tset(  \"frame\"+roll.count , tableImage(\"frames\",frameNr * 10 + roll.count + 1)  )]\n\n\n[h:noTitleList\t= \"0,2,3,4,5,6,7,8,14,15,16\"]\n[h:noTitle\t\t= listContains(noTitleList, frameNr)]\n[h:htmlTitle\t= \"<h3 align=center><font titleColor=\" + titleColor + \">\" + title + \"<\/font><\/H3>\"]\n\n[h:macro.return\t= \"\n\t<table border='0'  cellspacing='0' cellpadding='0'  width='100%'  align='center'>\n\t\t<tr>\n\t\t\t<td \" + table(\"frames\", frameNr*10+1) + \" background=\" + frame0 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td  background = \"+frame1+\" style='font-size:1px'>\n\t\t\t\"+ if(title == \"\" || noTitle, \"\", htmlTitle) +\"<\/td>\n\t\t\t<td  \"+table(\"frames\", frameNr*10+3)+\" background=\" + frame2 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t<\/tr>\n\t\t<tr>\n\t\t\t<td background=\" + frame3 + \" style='font-size:1px'>\n\t\t\t<\/td>\n\t\t\t<td background=\" + frame4 + \">\" +\n\t\t\tif(title != \"\" && noTitle, htmlTitle,\"\")\n]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "99131128-8b54-4fbe-a663-a80eda548ba4",
          "commandChecksum": "014d6fcd9cf25693e75c82bd9d0ac83c",
          "propsChecksum": "dd2d1402e554bb124c93e517b00e80d4"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "0",
        "includeLabel": false,
        "sortBy": "0",
        "index": 367,
        "label": "frameOverview",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[frame(\"Nildiks Frames\", \"width=600; height=800\"): {\n\t<html><head><title>Whisper<\/title><\/head><body>\n\n\n\t[h:nFrame = 0]\n\t\n\t[r,count(14), code:{\n\t\t[R: bot_frameOpen(nFrame)]\n\t\t<table cellpadding='10' width='100%' border='0'>\n\t\t\t<tr><td>\n\t\t\t<font color=\"white\">this is frame number: [r:nFrame]<\/font.\n\t\t\t\n\t\t\n\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t\t[R:bot_frameClose(nFrame)]\n\t\t[h:nFrame = nFrame+1]\n\t}]\n\t<\/body><\/html>\n}]\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7c7bbc42-a8ea-401d-b520-183b1043fa7d",
          "commandChecksum": "d5b395b69949bfc2b34bd8a1a3485d1f",
          "propsChecksum": "9092e13ea2aa3b148cf9d1d682104823"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "purple",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 368,
        "label": "getCircleCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[drawToken\t= arg(2)]\n\n\n[h:libCoords\t= \"lib:EventMacros\"]\n[h:updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n[H:tX\t\t\t= getTokenX(0, me)]\n[H:tY\t\t\t= getTokenY(0, me)]\n[draw\t\t\t= if(drawToken == \"\", 0, 1)]\n\n\n[h:fullFillRange= if(draw, 1000, 10)]\n\n[h:XCoords\t\t= getLibProperty(\"circleXrange\"+range, libCoords)]\n\n[h,if(  json.type(XCoords) != \"ARRAY\" ), CODE:{\n\t[XCoords\t= \"[]\"]\n\t[YCoords\t= \"[]\"]\n\t\n\n\t[h,for(i,-range, range+1, 1), CODE:{\n\t\t[x\t= abs(i)]\n\t\t[for(j,-range, range+1, 1), CODE:{\n\t\t\t[y\t\t= abs(j)]\n\t\t\t[step\t= (x+y) - ceil( min(x,y) /2)]\n\t\t\t[if(step <= range && range <= fullFillRange), CODE:{\n\t\t\t\t[XCoords\t= json.append(XCoords, i)]\n\t\t\t\t[YCoords\t= json.append(YCoords, j)]\n\t\t\t\t''\n\t\t\t};{\n\t\t\t\t[if(step == range && range > fullFillRange), CODE:{\n\t\t\t\t\t[XCoords\t= json.append(XCoords, i)]\n\t\t\t\t\t[YCoords\t= json.append(YCoords, j)]\n\t\t\t\t''\n\t\t\t\t};{}]\n\t\t\t''\n\t\t\t}]\n\t\t''\n\t\t}]\n\t''\n\t}] \n\t\n\t[setLibProperty(\"circleXrange\"+range, XCoords, libCoords)]\n\t[setLibProperty(\"circleYrange\"+range, YCoords, libCoords)]\n''\n};{\n\t[YCoords\t= getLibProperty(\"circleYrange\"+range, libCoords)]\n''\n}]\n\n\n[h,if(!range), CODE:{\n\t[XCoords\t= \"[0]\"]\n\t[YCoords\t= \"[0]\"]\n};{}]\n\n[h:i\t\t= 0]\n[h, if(draw), CODE:{\n\t\n\t[copies\t= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, \"x\", \"[r:tX + json.get(XCoords,i)]\", \"y\", \"[r:tY + json.get(YCoords,i)][h:i=i+1]\")))]\n\t[macro.return\t= copies]\n};{\n\t\n\t[coords\t\t= \"[]\"]\n\t[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set(\"{}\",\"x\",tX+json.get(XCoords, i) ,\"y\",tY+json.get(YCoords, i) )  )]\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "66b28449-9347-4280-a607-e4017d664693",
          "commandChecksum": "bb1237afc3710de709851b0ee56f6022",
          "propsChecksum": "26ff783e5f831d1dc8301a7b3c215c20"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 369,
        "label": "getConeCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[x1\t\t\t= arg(1)]\n[y1\t\t\t= arg(2)]\n[x2\t\t\t= arg(3)]\n[y2\t\t\t= arg(4)]\n\n[xc\t\t\t= getTokenX(0,me)]\n[yc\t\t\t= getTokenY(0,me)]\n\n\n[if(!bot_isClockWise (xc,yc,x1,y1,x2,y2)), CODE:{\n\t[xt\t= x1]\n\t[yt\t= y1]\n\t[x1\t= x2]\n\t[y1\t= y2]\n\t[x2\t= xt]\n\t[y2\t= yt]\n}]\n\n[centre\t\t\t= json.set(\"{}\",\"x\",xc,\"y\",yc)]\n[checked\t\t= json.append(\"[]\",centre)]\n[coneCoords\t\t= checked]\n[oldConeCoords\t= coneCoords]\n[toCheck\t\t= bot_getNeighbourXY(centre)]\n[stop\t\t\t= 0]\n\n\n[lineCoords\t\t= bot_getLineCoords (xc, yc, x1, y1)]\n[lineCoords\t\t= json.union(lineCoords, bot_getLineCoords (xc, yc, x2, y2))]\n\n[bot_startTime()]\n\n[while(!stop), CODE:{\n\t\n\t\n\t[foreach(coord, toCheck), CODE:{\n\t\t[onCone\t= json.contains(lineCoords, coord) + bot_pointInCone(json.get(coord, \"x\"), json.get(coord, \"y\"), me, x1,y1,  x2,y2)]\n\t\t[if(onCone): coneCoords = json.append(coneCoords, coord)]\n\t}]\n\t[checked\t\t= json.union(checked, toCheck)]\n\n\t\n\t\n\t[newCoords\t\t= json.difference(coneCoords, oldConeCoords)]\n\t[toCheck\t\t= \"[]\"]\n\t[foreach(coord, coneCoords), CODE:{\n\t\t[newCoords\t= bot_getNeighbourXY(coord)]\n\t\t[toCheck\t= json.union(toCheck, newCoords)]\n\t}]\n\t\n\t\n\t[toCheck\t\t= json.difference(json.unique(toCheck), checked)]\n\t[oldConeCoords\t= coneCoords]\n\t[if(json.isEmpty(toCheck)): stop=1]\n}]\n[broadcast(\"Process took: \"+bot_totalTime(1))]\n[h:macro.return\t= coneCoords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "077b55a6-ea05-43bc-86b9-2796a72df20b",
          "commandChecksum": "961e93392a1902904e1410297936aa56",
          "propsChecksum": "d4f90e733bc87a9b9a457b959b28a2e6"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "fuchsia",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 370,
        "label": "getLineCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[x0\t\t= arg(0)]\n[y0\t\t= arg(1)]\n[x1\t\t= arg(2)]\n[y1\t\t= arg(3)]\n\n[if(argCount() > 4):\trel\t= arg(4) ; rel = 0]\n\n[dx\t\t= abs(x1-x0)]\n[dy\t\t= abs(y1-y0)]\n[sx\t\t= if(x0 < x1, 1, -1)]\n[sy\t\t= if(y0 < y1, 1, -1)]\n[err\t= dx - dy]\n[relX\t= rel*x0]\n[relY\t= rel*y0]\n\n[stop\t= 0]\n[coords\t= \"[]\"]\n\n[while (!stop), CODE:{\n\t[coord\t= json.set(\"{}\",\"x\",x0-relX,\"y\",y0-relY))]\n\t[coords\t= json.append(coords,coord)]\n\n\t[if(x0 == x1 && y0 == y1): stop = 1]\n\t[e2\t= 2 * err]\n\n\t[if(e2 > -dy), CODE:{\n\t\t[err\t= err - dy]\n\t\t[x0\t\t= x0 + sx]\n\t};{}]\n\n\t[if(e2 < dx), CODE:{\n\t\t[err\t= err + dx]\n\t\t[y0\t\t= y0 + sy ]\n\t};{}]\n}]\n\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "249bdd69-16f9-4692-990f-52571ace5022",
          "commandChecksum": "8bb20ba50ac4749c9c1c002571ec0f27",
          "propsChecksum": "a5d6d2d9c17dbd111c4cfedad43ad6b0"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "green",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 371,
        "label": "getSquareCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[x1\t\t= arg(0)]\n[y1\t\t= arg(1)]\n[x2\t\t= arg(2)+1]\n[y2\t\t= arg(3)+1]\n\n[coords\t= \"[]\"]\n\n[for(x,x1,x2),CODE:{\n\t[for(y,y1,y2): coords\t= json.append(coords, json.set(\"{}\",\"x\",x,\"y\",y)  )]\n}]\n\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e977e45f-499c-460b-b42e-a6bd41dc6c0b",
          "commandChecksum": "0b06f3271b911d378a1ac406d76daaf9",
          "propsChecksum": "8caf7a43cf78f1542d9c27dd9fc135a3"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "50",
        "includeLabel": false,
        "sortBy": "50",
        "index": 372,
        "label": "getTriangleCoords",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[x1\t= arg(0)]\n[y1\t= arg(1)]\n[x2\t= arg(2)]\n[y2\t= arg(3)]\n[x3\t= arg(4)]\n[y3\t= arg(5)]\n[rel\t= arg(6)]\n\n[xMin\t= min(x1,x2,x3)]\n[yMin\t= min(y1,y2,y3)]\n[xMax\t= max(x1,x2,x3)]\n[yMax\t= max(y1,y2,y3)]\n\n[coords\t= \"[]\"]\n\n[for(x,xMin,xMax), CODE:{\n\t[for(y,yMin,yMax), CODE:{\n\t\t[if(bot_pointInTriangle(x,y,x1,y1,x2,y2,x3,y3,0)): coords\t= json.append(coords,json.set(\"{}\",\"x\",x,\"y\",y))]\n\t}]\n}]\n[macro.return\t= coords]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "210fa03d-7007-412d-bd12-e971841fa26e",
          "commandChecksum": "f0b551138d207a4e708f154b15fab75b",
          "propsChecksum": "badfcedafa66619f1c621400f333a93c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 373,
        "label": "pointInCone",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n\n[h:macro.return\t= if(\n\tbot_isClockWise\t\t(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(3),arg(4),  arg(0),arg(1)) && \n\t!bot_isClockWise\t(getTokenX(0,arg(2)),getTokenY(0,arg(2)),  arg(5),arg(6),  arg(0),arg(1)) && \n\tif(getDistanceToXY(arg(0),arg(1),0,arg(2)) <= getDistanceToXY(arg(3),arg(4),0,arg(2)),1,0), \n\t1, 0\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d2c224ad-fe08-4f48-a081-034efe3c49c7",
          "commandChecksum": "ed5f095659e9c0f3a415c43941ea01b2",
          "propsChecksum": "f910cfdc8982c005b6d63cb2df0437c4"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "50",
        "includeLabel": false,
        "sortBy": "50",
        "index": 374,
        "label": "pointInTriangle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n[h:b2\t= if( (arg(0) - arg(6)) * (arg(5) - arg(7)) -  (arg(4) - arg(6)) * (arg(1) - arg(7)) < 0, 1,0)]\n[macro.return = if(if( (arg(0) - arg(4)) * (arg(3) - arg(5)) -  (arg(2) - arg(4)) * (arg(1) - arg(5)) < 0, 1,0) == b2 && b2 == if( (arg(0) - arg(2)) * (arg(7) - arg(3)) -  (arg(6) - arg(2)) * (arg(1) - arg(3)) < 0, 1,0),1,0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "85c842a1-a582-40f3-b752-7d98926e14f0",
          "commandChecksum": "b968d3fcf75120e576da118c437bd4ea",
          "propsChecksum": "c17a94abd34b32cc9fd0b98ff00f03b5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 375,
        "label": "pointOnCircle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnCircle, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[point\t\t= json.set(\"{}\",\"x\",xp,\"y\",yp)]\n\n[circle\t\t= bot_getCircleCoords (me, range, \"\")]\n[h:macro.return\t= json.contains(circle, point)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "dd5c1bf5-af6d-4bf9-b1c2-1acd9a9fbe1d",
          "commandChecksum": "f4cba48ff3f17a004cb07a818c9b81a2",
          "propsChecksum": "06cf29f2e217e136a1bec183702b0cca"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 376,
        "label": "pointOnCone",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[arc\t= arg(3)/2]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t\n\t\t\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 5:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[arc\t= arg(4)/2]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t\n\t\t\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnCone, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:p1\t\t= bot_pointOnLine\t(xp,yp,  x1,y1,  x2,y2)]\n[h:p2\t\t= bot_pointOnLine\t(xp,yp,  x1,y1,  x3,y3)]\n[h:p3\t\t= bot_pointInCone\t(xp,yp,  me,  x2,y2,  x3,y3)]\n\n[h:macro.return\t= if(p1 || p2 || p3, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e2de6ab5-6823-44a5-814f-8fa800f7f2e4",
          "commandChecksum": "8717ec0d3554433b816de5bcac0f949a",
          "propsChecksum": "3177a88201c606e05b6f0c06a455959b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 377,
        "label": "pointOnLine",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t\t[x2\t\t= x1 + round(range*bot_cos(angle),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(angle),0)]\n\t};\n\tcase 6:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[x1\t\t= arg(2)]\n\t\t[y1\t\t= arg(3)]\n\t\t[x2\t\t= arg(4)]\n\t\t[y2\t\t= arg(5)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnLine, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[point\t\t= json.set(\"{}\",\"x\",xp,\"y\",yp)]\n\n[line\t\t= bot_getLineCoords (x1, y1, x2, y2)]\n\n[h:macro.return\t= json.contains(line, point)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4fdaae54-cad9-4420-bd02-7022c1422b3c",
          "commandChecksum": "4c437989096e06a613e8a0914d69216c",
          "propsChecksum": "7cb202e4e95543a629ec5e9ca2d1391a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 378,
        "label": "pointOnSquare",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t};\n\tcase 4:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t};\n\tdefault:{[assert(0,\"Error in bot_pointOnSquare, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[xc\t\t= getTokenX(0, me)]\n[yc\t\t= getTokenY(0, me)]\n[x1\t\t= xc - range]\n[y1\t\t= yc - range]\n[x2\t\t= xc + range]\n[y2\t\t= yc + range]\n\n[h:macro.return\t= if(\n\txp >= x1 &&\n\typ >= y1 &&\n\txp <= x2 &&\n\typ <= y2, \n\t1, 0\n)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e7da776e-b325-454b-9103-6376cda737a6",
          "commandChecksum": "3bc0d40eced034f25477f27fc8879be1",
          "propsChecksum": "9fc9313e8c1041a8a5811f2dafb7dd64"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "50",
        "includeLabel": false,
        "sortBy": "50",
        "index": 379,
        "label": "pointOnTriangle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[tok\t= arg(0)]\n\t\t[me\t\t= arg(1)]\n\t\t[range\t= arg(2)]\n\t\t[arc\t= arg(3)/2]\n\n\t\t[xp\t\t= getTokenX(0, tok)]\n\t\t[yp\t\t= getTokenY(0, tok)]\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t\n\t\t\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 5:{\n\t\t[xp\t\t= arg(0)]\n\t\t[yp\t\t= arg(1)]\n\t\t[me\t\t= arg(2)]\n\t\t[range\t= arg(3)]\n\t\t[arc\t= arg(4)/2]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t= bot_getTokenFacing(me,2)]\n\n\t\t\n\t\t\n\t\t[arc1\t\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t\t= (angle + arc)*bot_pi()/180]\n\t\t\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n\t\t[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 8:{\n\t\t[xp\t\t\t= arg(0)]\n\t\t[yp\t\t\t= arg(1)]\n\t\t[x1\t\t\t= arg(2)]\n\t\t[y1\t\t\t= arg(3)]\n\t\t[x2\t\t\t= arg(4)]\n\t\t[y2\t\t\t= arg(5)]\n\t\t[x3\t\t\t= arg(6)]\n\t\t[y3\t\t\t= arg(7)]\t\n\t};\n\tdefault:{\n\t\t[assert(0,\"Error in bot_pointOnTriangle, wrong amount of arguments: \"+argCount(),0)]\n\t}\n]\n\n[h:p1\t\t= bot_pointOnLine\t\t(xp,yp,  x1,y1,  x2,y2)]\n[h:p2\t\t= bot_pointOnLine\t\t(xp,yp,  x1,y1,  x3,y3)]\n[h:p3\t\t= bot_pointOnLine\t\t(xp,yp,  x3,y3,  x2,y2)]\n[h:p4\t\t= bot_pointInTriangle\t(xp,yp,  x1,y1,  x2,y2,  x3,y3)]\n\n[h:macro.return\t= if(p1 || p2 || p3 || p4, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f1674595-0c10-4630-9a33-0597fe9fb45d",
          "commandChecksum": "b2fd502379b39a80451b515218a4c5a7",
          "propsChecksum": "a157d47a3e98d1add0df7eef1c3a05e1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 380,
        "label": "selectOnCircle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[toks\t\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3a287038-063e-4da5-a0bb-745dd21c712a",
          "commandChecksum": "90bc3e753bedd101112830f6f33994f0",
          "propsChecksum": "0631298126159b81cf01258e4dcec324"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 381,
        "label": "selectOnCone",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)]\n[toks\t\t= \"\"]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n\n[foreach(tok, allToks), if(bot_pointOnCone(tok, me, range, arc)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f67b4c26-9467-48a4-a591-3a42a5f1ee05",
          "commandChecksum": "079d605c3c4e76a41f7b7a6442d54aa4",
          "propsChecksum": "96db94075fb63dee8ebe0c420b5f0049"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 382,
        "label": "selectOnLine",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[h:assert(argCount() > 2, \"ERROR in selectOnline: wrong number of arguments. Either pass: me,range,sort(=1/0) or me, x2,y2,sort\", 0)]\n\n[if(argCount() == 3), CODE:{\n\t[me\t\t\t= arg(0)]\n\t[range\t\t= arg(1)]\n\t[sort\t\t= arg(2)]\n\t\n\t[x1\t\t\t= getTokenX(0, me)]\n\t[y1\t\t\t= getTokenY(0, me)]\n\t[angle\t\t= bot_getTokenFacing(me,2)*bot_pi()/180]\n\t[x2\t\t\t= x1 + round(range*bot_cos(angle),0)]\n\t[y2\t\t\t= y1 + round(range*bot_sin(angle),0)]\n};{\n\t[me\t\t\t= arg(0)]\n\t[x1\t\t\t= getTokenX(0, me)]\n\t[y1\t\t\t= getTokenY(0, me)]\n\t[x2\t\t\t= arg(1)]\n\t[y2\t\t\t= arg(2)]\n\t[sort\t\t= arg(3)]\n}]\n\n[area\t\t= bot_getLineCoords (x1, y1, x2, y2, 1)]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"area\", json.set(\"{}\", \"token\", me, \"offsets\", area)  )  )]\n\n[if(sort), CODE:{\n\t[tmpArray\t= \"[]\"]\n\t[foreach(tok, allToks): tmpArray\t= json.append(tmpArray,json.set(\"{}\", \"tok\", tok, \"distance\", getDistance(me,0,tok)))]\n\t[tmpArray\t= json.sort(tmpArray,'a','distance')]\n\t[allToks\t= \"\"]\n\t[foreach(obj, tmpArray): allToks\t= listAppend(allToks, json.get(obj, \"tok\"))]\n};{}]\n\n[selectTokens(allToks, 0, \",\")]\n[macro.return\t= allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0d319fc0-3576-486c-a245-f06adce735ad",
          "commandChecksum": "9c3363e52c04c76e67a9033d329efc05",
          "propsChecksum": "b80dc5911f827382497770471a3ed69f"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 383,
        "label": "selectOnSquare",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[toks\t\t= \"\"]\n\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", ceil(sqrt(2*range*range)+range/10) ))  )]\n\n[foreach(tok, allToks), if(bot_pointOnSquare(tok, me, range)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "652abbeb-22b3-4334-a206-e6c7d1b9b1b1",
          "commandChecksum": "c80da99206e2ed8b1a505810b1e1b291",
          "propsChecksum": "04f2a3a976210bff3cf10ae51edb2f7b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "50",
        "includeLabel": false,
        "sortBy": "50",
        "index": 384,
        "label": "selectOnTriangle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)]\n[toks\t\t= \"\"]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"range\", json.set(\"{}\", \"token\", me, \"distancePerCell\", 0, \"upto\", range))  )]\n\n[foreach(tok, allToks), if(bot_pointOnTriangle(tok, me, range, arc)): toks\t= listAppend(toks, tok)]\n\n[selectTokens(toks,0,\",\")]\n[macro.return\t= toks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f6b45dab-4230-4707-86eb-797fbfab85ff",
          "commandChecksum": "15c319a19fa47893f0880ea853a83d50",
          "propsChecksum": "488088f48b157cd8b8fd00aa8a7b774d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 385,
        "label": "selectOnTriangle NEW (but not correct",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)/2]\n\n[angle\t= bot_getTokenFacing(me,2)]\n\n\n\n[arc1\t\t= (angle - arc)*bot_pi()/180]\n[arc2\t\t= (angle + arc)*bot_pi()/180]\n\n[x2\t\t\t= round(range*bot_cos(arc1),0)]\n[y2\t\t\t= round(range*bot_sin(arc1),0)]\n[x3\t\t\t= round(range*bot_cos(arc2),0)]\n[y3\t\t\t= round(range*bot_sin(arc2),0)]\n[area\t\t= bot_getTriangleCoords (0,0,x2,y2,x3,y3)]\n[pause(\"x2\",\"y2\",\"x3\",\"y3\",\"arc1\",\"arc2\",\"area\")]\n\n[allToks\t= getTokens(\",\", json.set(\"{}\", \"area\", json.set(\"{}\", \"token\", me, \"offsets\", area)  )  )]\n[selectTokens(allToks, 0, \",\")]\n[macro.return\t= allToks]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "5ef4bd7e-9bb6-44a9-8fac-1a058552c0cb",
          "commandChecksum": "feb5d490f5345ca66e2ffd4f1ba65760",
          "propsChecksum": "3b4c98e9bcdb3139a54a6f4442c63501"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "purple",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 386,
        "label": "showCircle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n\n[macro.return = bot_getCircleCoords(arg(0), arg(1), arg(2))]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1a2fe72f-83be-49c5-91df-4740217e09b0",
          "commandChecksum": "5107015db19f1b01e0b79e0c2ed5db82",
          "propsChecksum": "43b068763fb5af020a2e0eab8bb3b873"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 387,
        "label": "showCone",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[me\t\t\t= arg(0)]\n[range\t\t= arg(1)]\n[arc\t\t= arg(2)/2]\n[drawToken\t= arg(3)]\n\n[x1\t\t\t= getTokenX(0, me)]\n[y1\t\t\t= getTokenY(0, me)]\n[angle\t\t= bot_getTokenFacing(me,2)]\n[libCoords\t= \"lib:EventMacros\"]\n\n\n\n[arc1\t\t= (angle - arc)*bot_pi()/180]\n[arc2\t\t= (angle + arc)*bot_pi()/180]\n\n[x2\t\t\t= x1 + round(range*bot_cos(arc1),0)]\n[y2\t\t\t= y1 + round(range*bot_sin(arc1),0)]\n[x3\t\t\t= x1 + round(range*bot_cos(arc2),0)]\n[y3\t\t\t= y1 + round(range*bot_sin(arc2),0)]\n\n[XCoords\t= getLibProperty(\"coneXrange_\"+range+\"_\"+angle+\"_\"+arc, libCoords)]\n\n[if(  json.type(XCoords) != \"ARRAY\" ), CODE:{\n\t\n\t[coords\t\t\t= bot_getConeCoords(me,  x2,y2,  x3,y3)]\n\t[XCoords\t\t= \"[]\"]\n\t[YCoords\t\t= \"[]\"]\n\t\n\t[foreach(coord, coords), CODE:{\n\t\t\n\t\t[XCoords\t= json.append(XCoords, json.get(coord, \"x\") - x1)]\n\t\t[YCoords\t= json.append(YCoords, json.get(coord, \"y\") - y1)]\n\t}]\n\t\n\t[setLibProperty(\"coneXrange_\"+range+\"_\"+angle+\"_\"+arc, XCoords, libCoords)]\n\t[setLibProperty(\"coneYrange_\"+range+\"_\"+angle+\"_\"+arc, YCoords, libCoords)]\n};{\n\t\n\t[YCoords\t\t= getLibProperty(\"coneYrange_\"+range+\"_\"+angle+\"_\"+arc, libCoords)]\n}]\n\n[h, if(drawToken != \"\"), CODE:{\n\t\n\t[copies\t\t\t= \"[]\"]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[copies\t\t\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t= copyToken(drawToken, listCount(XCoords), baseMap, json.set(updates, \"x\", \"[r:x1 + json.get(XCoords,i)]\", \"y\", \"[r:y1 + json.get(YCoords,i)][h:i=i+1]\")))]\n\t[broadcast(copies)]\n\t[macro.return\t= copies]\n};{\n\t\n\t[coords\t\t\t= \"[]\"]\n\t[for(i, 0, json.length(XCoords)): coords = json.append(coords,  json.set(\"{}\",\"x\",x1+json.get(XCoords, i) ,\"y\", y1+json.get(YCoords, i) )  )]\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a3425ebe-14b4-4a57-a24a-8bdc3db5e010",
          "commandChecksum": "f3caac004d0fdb178a8c21c714140cbe",
          "propsChecksum": "aae2d865027dd1dee1c33b64d60bc256"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "fuchsia",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 388,
        "label": "showLine",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[me\t\t\t= arg(0)]\n\t\t[range\t\t= arg(1)]\n\t\t[drawToken\t= arg(2)]\n\n\t\t[x1\t\t\t= getTokenX(0, me)]\n\t\t[y1\t\t\t= getTokenY(0, me)]\n\n\t\t[angle\t\t= bot_getTokenFacing(me,2)]\n\t\t\n\t\t\n\t\t[arc\t\t= angle*bot_pi()/180]\n\t\t\n\t\t[x2\t\t\t= x1 + round(range*bot_cos(arc),0)]\n\t\t[y2\t\t\t= y1 + round(range*bot_sin(arc),0)]\n\t};\n\tcase 5:{\n\t\t[x1\t\t\t= arg(0)]\n\t\t[y1\t\t\t= arg(1)]\n\t\t[x2\t\t\t= arg(2)]\n\t\t[y2\t\t\t= arg(3)]\n\t\t[drawToken\t= arg(4)]\n\t};\n\tdefault:{[assert(0,\"Error in showLine, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= bot_getLineCoords(x1,y1,  x2,y2)]\n\n[h, if(drawToken != \"\"), CODE:{\n\t\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68c74b7c-76b7-476d-818f-76f7c1b7130b",
          "commandChecksum": "93f3e20105aed101941ba88f49ecb164",
          "propsChecksum": "e3182044b2c737ec5937a75148cb1b77"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "green",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 389,
        "label": "showSquare",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[switch(argCount()), CODE:\n\tcase 3:{\n\t\t[me\t\t= arg(0)]\n\t\t[range\t= arg(1)]\n\t\t[drawToken\t= arg(2)]\n\n\t\t[xc\t\t= getTokenX(0, me)]\n\t\t[yc\t\t= getTokenY(0, me)]\n\n\t\t[x1\t\t= xc - range]\n\t\t[y1\t\t= yc - range]\n\t\t[x2\t\t= xc + range]\n\t\t[y2\t\t= yc + range]\n\t};\n\tcase 5:{\n\t\t[x1\t\t= arg(0)]\n\t\t[y1\t\t= arg(1)]\n\t\t[x2\t\t= arg(2)]\n\t\t[y2\t\t= arg(3)]\n\t\t[drawToken\t= arg(4)]\n\t};\n\tdefault:{[assert(0,\"Error in showSquare, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= bot_getSquareCoords(x1,y1,  x2,y2)]\n\n[h, if(drawToken != \"\"), CODE:{\n\t\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "17471c58-71a5-4a02-999b-c5b3bee90423",
          "commandChecksum": "c783917afad837cbc909c902ee183dcb",
          "propsChecksum": "3bff565fb250ab0e9575781b2f46e66b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "50",
        "includeLabel": false,
        "sortBy": "50",
        "index": 390,
        "label": "showTriangle",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[switch(argCount()), CODE:\n\tcase 4:{\n\t\t[me\t\t= arg(0)]\n\t\t[range\t= arg(1)]\n\t\t[arc\t= arg(2)/2]\n\t\t[drawToken\t= arg(3)]\n\n\t\t[x1\t\t= getTokenX(0, me)]\n\t\t[y1\t\t= getTokenY(0, me)]\n\t\t[angle\t\t= bot_getTokenFacing(me,2)]\n\n\t\t\n\t\t\n\t\t[arc1\t= (angle - arc)*bot_pi()/180]\n\t\t[arc2\t= (angle + arc)*bot_pi()/180]\n\t\t\n\t\t[x2\t\t= x1 + round(range*bot_cos(arc1),0)]\n\t\t[y2\t\t= y1 + round(range*bot_sin(arc1),0)]\n\n\t\t[x3\t\t= x1 + round(range*bot_cos(arc2),0)]\n\t\t[y3\t\t= y1 + round(range*bot_sin(arc2),0)]\n\t};\n\tcase 7:{\n\t\t[x1\t\t\t= arg(0)]\n\t\t[y1\t\t\t= arg(1)]\n\t\t[x2\t\t\t= arg(2)]\n\t\t[y2\t\t\t= arg(3)]\n\t\t[x3\t\t\t= arg(4)]\n\t\t[y3\t\t\t= arg(5)]\t\n\t\t[drawToken\t\t= arg(5)]\n\t\t};\n\tdefault:{[assert(0,\"Error in bot_showTriangle, wrong amount of arguments: \"+argCount(),0)]}\n]\n\n[h:coords\t= json.union(\n\tbot_getTriangleCoords( x1,y1,  x2,y2,  x3,y3 ),\n\tbot_getLineCoords(x1,y1,  x2,y2) ), \n\tbot_getLineCoords(x1,y1,  x3,y3) ),\n\tbot_getLineCoords(x3,y3,  x2,y2) )\n]\n\n[h, if(drawToken != \"\"), CODE:{\n\t\n\t[copies\t\t\t= \"[]\"]\n\t[h:baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")][h:copies\t= \"\"]\n\t[updates\t\t= json.set(\"{}\", \"layer\", \"BACKGROUND\", \"useDistance\", 0, \"facing\", \"[r:(1d4-1) * 90]\")]\n\t[i\t\t\t\t= 0]\n\t[copies\t\t\t= copyToken(drawToken, json.length(coords), baseMap, json.set(updates, \"x\", \"[r:json.get(json.get(coords,i),'x')]\", \"y\", \"[r:json.get(json.get(coords,i),'y')][h:i=i+1]\") )]\n\t[macro.return\t= copies]\n};{\n\t\n\t[macro.return\t= coords]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3f212ac4-fb9a-492f-82ae-09a2f340fdef",
          "commandChecksum": "fc3f51d33278c4d4764a8817bf6ffffb",
          "propsChecksum": "ab7ae17f9b45390dd4df32e5d613ac47"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "12a. Geofunctions - support",
        "includeLabel": false,
        "sortBy": "12a. Geofunctions - support",
        "index": 391,
        "label": "getNeighbourXY",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[x\t\t= json.get(arg(0), \"x\")]\n[y\t\t= json.get(arg(0), \"y\")]\n\n[h:macro.return\t= '[\n\t{\"x\":'+(x-1)+',\"y\":'+(y-1)+'},\n\t{\"x\":'+(x  )+',\"y\":'+(y-1)+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y-1)+'},\n\t\n\t{\"x\":'+(x-1)+',\"y\":'+(y  )+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y  )+'},\n\t\n\t{\"x\":'+(x-1)+',\"y\":'+(y+1)+'},\n\t{\"x\":'+(x  )+',\"y\":'+(y+1)+'},\n\t{\"x\":'+(x+1)+',\"y\":'+(y+1)+'}\n]']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "aa485340-5f62-48fe-8216-16bf198e8626",
          "commandChecksum": "8e0122a9adb84a63f0cca4860b09a835",
          "propsChecksum": "3bd27efc798340c353eb77217c7e18f1"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "26",
        "includeLabel": false,
        "sortBy": "26",
        "index": 395,
        "label": "getValidTokens",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[H: '']\n\n[h,if(argCount() > 0): useCurrentMap\t= arg(0); useCurrentMap\t= 0]\n[h,if(argCount() > 1): conditions\t\t= arg(1); conditions\t= \"{}\"]\n[h,if(argCount() > 2): use_None\t\t\t= arg(2); use_None\t\t= 1]\n[h,if(argCount() > 3): startsWithTxt\t= lower(arg(3)); startsWithTxt\t= \"\"]\n\n[h:baseMapName\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:assert(listContains(getAllMapNames(),baseMapName), \"Uknown map: '\"+baseMapName+\"' Set the correct BASE map value in the settings macro of the Bag of Tricks macro panel\",0)]\n[h,if(use_None): noneImageId = getImage('image:none')]\n[h, if(!useCurrentMap):setCurrentMap(baseMapName)]\n\n[h:pcPropType\t\t= getLibProperty(\"summonPcPropType\",\"lib:EventMacros\")]\n[h:npcPropType\t\t= getLibProperty(\"summonNpcPropType\",\"lib:EventMacros\")]\n[h:propTypesList\t= getLibProperty(\"summonPropTypesList\",\"lib:EventMacros\")]\n[h:specialList\t\t= getLibProperty(\"summonSpecialList\",\"lib:EventMacros\")]\n[h:tokenList \t\t= listSort(getTokenNames(\",\",conditions),\"N\")]\n\n[h,if(startsWithTxt != \"\"), CODE:{\n\t\n\t[newTokenList\t= \"\"]\n\t[foreach(tok, tokenList): newTokenList = if(startsWith(lower(tok), startsWithTxt), listAppend(newTokenList, tok), newTokenList)]\n\t[tokenList\t\t= newTokenList]\n}; {}]\n\n[h:'']\n[h:tmpList = \"\"]\n[h, foreach(item, specialList), CODE:{\n\t[if(findToken(item) != \"\"), CODE:{\n\t\t[if(getLayer(item) == 'TOKEN'): tmpList = listAppend(tmpList, item)]\n\t}; {}]\n}]\n[h: specialList \t= tmpList]\n\n[h:pcList\t\t\t= \"\"]\n[h:npcList\t\t\t= \"\"]\n[h:charList\t\t\t= \"\"]\n[h:allList\t\t\t= \"\"]\n[h,foreach(propType, propTypesList): set(propType+\"List\",\"\")]\n\n[h:fancyPcList\t\t= \"\"]\n[h:fancyNpcList\t\t= \"\"]\n[h:fancyCharList\t= \"\"]\n[h:fancyAllList\t\t= \"\"]\n[h,foreach(propType, propTypesList): set(\"fancy\"+propType+\"List\",\"\")]\n[h:fancySpecialList\t= \"\"]\n[h:specialNumber\t=0]\n\n[H,FOREACH(tok, tokenList), CODE:{\n\t[pc \t\t\t= if(getPropertyType(tok) == pcPropType && isPC(tok),1 ,0)]\n\t[npc \t\t\t= if(getPropertyType(tok) == npcPropType && isNPC(tok),1 ,0)]\n\t\n\t[isPC = isPC(tok)]\n\t[isNPC = isNPC(tok)]\n\t\n\t[foreach(propType, propTypesList):set(propType, if(getPropertyType(tok) == propType, 1, 0))]\n\t[special\t\t= listContains(specialList,  tok)]\n\n\t[if(pc), CODE:{\n\t\t[pcList\t\t= listAppend(pcList, tok)]\n\t\t[token(tok): fancyPcList = listAppend(fancyPcList, tok + getTokenImage(60))]\n\t\t[charList\t= listAppend(charList, tok)]\n\t\t[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]\n\t}; {}]\n\t[if(npc), CODE:{\n\t\t[npcList\t= listAppend(npcList, tok)]\n\t\t[token(tok): fancyNpcList = listAppend(fancyNpcList, tok + getTokenImage(60))]\n\t\t[charList\t= listAppend(charList, tok)]\n\t\t[token(tok): fancyCharList = listAppend(fancyCharList, tok + getTokenImage(60))]\n\t}; {}]\n\t[foreach(propType, propTypesList), CODE:{\n\t\t[tmpEval\t= eval(propType)]\t\t\n\t\t[if(tmpEval): set(propType+\"List\", listAppend(eval(propType+\"List\"), tok))]\n\t\t[if(tmpEval), token(tok): set(\"fancy\"+propType+\"List\", listAppend(eval(\"fancy\"+propType+\"List\"), tok + getTokenImage(60)))]\n\t}]\n\t[if(special), CODE:{\n\t\t[token(tok): fancySpecialList = listAppend(fancySpecialList, tok + getTokenImage(60))]\n\t}; {}]\n\t\n\t[allList\t\t= listAppend(allList, tok)]\n\t[token(tok): fancyAllList = listAppend(fancyAllList, tok + getTokenImage(60))]\n\n}]\n\n[h,if(use_None), CODE:{\n\t[pcList\t\t= if(pcList \t!= \"\", listAppend(\"none\", pcList), \"none\")]\n\t[npcList\t= if(npcList\t!= \"\", listAppend(\"none\", npcList), \"none\")]\n\t[charList\t= if(charList\t!= \"\", listAppend(\"none\", charList), \"none\")]\n\t[allList\t= if(allList \t!= \"\", listAppend(\"none\", allList), \"none\")]\n\n\t[if(fancyPcList == \"\"):\t\tfancyPcList\t\t= \"none\" + noneImageId ; fancyPcList\t= listAppend(\"none\" + noneImageId, fancyPcList)]\n\t[if(fancyNpcList == \"\"):\tfancyNpcList\t= \"none\" + noneImageId ; fancyNpcList\t= listAppend(\"none\" + noneImageId, fancyNpcList)]\n\t[if(fancyCharList == \"\"):\tfancyCharList\t= \"none\" + noneImageId ; fancyCharList\t= listAppend(\"none\" + noneImageId, fancyCharList)]\n\t[if(fancyAllList == \"\"):\tfancyAllList\t= \"none\" + noneImageId ; fancyAllList\t= listAppend(\"none\" + noneImageId, fancyAllList)]\n\n\t[foreach(propType, propTypesList), CODE:{\n\t\t[set(propType+\"List\", listAppend(\"none\", eval(propType+\"List\")))]\n\t\t[set(\"fancy\"+propType+\"List\", if(eval(\"fancy\"+propType+\"List\") == \"\", \"none\" + noneImageId , listAppend(\"none\" + noneImageId, eval(\"fancy\"+propType+\"List\"))))]\n\t}]\n\n\t[specialList\t= listAppend(\"none\", specialList)]\n\t[if(fancySpecialList == \"\"): fancySpecialList\t= \"none\" + noneImageId ; fancySpecialList\t= listAppend(\"none\" + noneImageId, fancySpecialList)]\n}; {\n\t[h,foreach(propType, propTypesList), CODE:{\n\t\t[set(propType+\"List\", eval(propType+\"List\"))]\n\t\t[set(\"fancy\"+propType+\"List\", eval(\"fancy\"+propType+\"List\")]\n\t}]\n}]\n\n[h, if(!useCurrentMap):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7046bd4c-84c0-4400-b70c-f3dea6979b2a",
          "commandChecksum": "dabe3d6b94b61b26c8d51852796c493b",
          "propsChecksum": "6ca65feed914914d026bebd39571ca58"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "teal",
        "group": "23",
        "includeLabel": false,
        "sortBy": "23",
        "index": 396,
        "label": "embarkation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'']\n[h:ok\t\t\t= 0]\n\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"w42.Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'']\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h:'']\n\n[h:'']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:' ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[H:nX = \"-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1,\t\t-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1\"]\n[h:ny = \"-1,\t-1,\t-1,\t\t0,\t0,\t\t1,\t1,\t1,\t\t-2,\t-2,\t-2,\t\t0,\t0,\t\t2,\t2,\t2\"]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX+listGet(nX, roll.count), meY+listGet(nY, roll.count),0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1+listGet(nX, roll.count),vpcuY+1+listGet(nY, roll.count),0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"w42.Passengers\", newEmbarkedList, me)]\n[h:setProperty(\"w42.embarkToggle\",if(listCount(newEmbarkedList)>0, 1, \"\"), me)]\n\n\n[h: bot_message(\"Embarkation done\", \"Embarkation done\", \"#063404\", bot_ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1458d795-bf64-4504-9d70-541171073ac6",
          "commandChecksum": "3e34a5f074d3b4bfa11122fd27382689",
          "propsChecksum": "de1b79c0d1a348df73175f8b8c1eefc2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 397,
        "label": "mapTeleport",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\t\n\t\n[h:varsFromStrProp(arg(0))]\n[bot_playPadSound(padName, tok)]\t\n\n[newMap \t\t\t= getProperty(\"w42.bot.pairedMap\", padName)]\n[oldMap \t\t\t= getCurrentMapName()]\n[startCentreX \t\t= getTokenX(0, padName)]\n[startCentreY \t\t= getTokenY(0, padName)]\n[if(doSwitchInterMap ==2), CODE:{\n\t\n\t\n\t[endCentreX \t= getProperty(\"w42.bot.otherPadX\", padName)]\n\t[endCentreY \t= getProperty(\"w42.bot.otherPadY\", padName)]\n\t[endGridSize\t= getProperty(\"w42.bot.otherPadG\", padName)]\n\t[w2\t\t\t\t= getProperty(\"w42.bot.otherPadW\", padName)]\n\t[h2\t\t\t\t= getProperty(\"w42.bot.otherPadH\", padName)]\n};{\n\t[setCurrentMap(newMap)]\n\t\n\t[tmpPadName\t\t= if(startsWith(padName, \"InterJump\"), replace(padName, \"Jump\", \"Drop\"), padName)]\n\t[endCentreX \t= getTokenX(0, tmpPadName)]\n\t[endCentreY \t= getTokenY(0, tmpPadName)]\n\t[w2\t\t\t\t= bot_ppc2GridCoord(getTokenWidth(tmpPadName))]\n\t[h2\t\t\t\t= bot_ppc2GridCoord(getTokenHeight(tmpPadName))]\n\t[setCurrentMap(oldMap)]\n}]\n\n[CurrentX\t= getTokenX(0, tok)]\n[CurrentY\t= getTokenY(0, tok)]\n[CurrentGS\t= bot_getGridSize()]\n\n[h,if(doScaleTeleport), CODE:{\n\t\n\t[w1\t\t= bot_ppc2GridCoord(getTokenWidth(padName))]\n\t[h1\t\t= bot_ppc2GridCoord(getTokenHeight(padName))]\n\n\t[wc\t\t= w2/w1]\n\t[hc\t\t= h2/h1]\n\t[if(CurrentX == startCentreX + w1 - CurrentGS): \n\t\tNewX\t= endCentreX + w2 - endGridSize \n\t; \n\t\tNewX\t= round(wc*(CurrentX - startCentreX) + endCentreX)\n\t]\n\t[if(CurrentY == startCentreY + h1 - CurrentGS): \n\t\tNewY\t= endCentreY + h2 - endGridSize \n\t; \n\t\tNewY\t= round(hc*(CurrentY - startCentreY) + endCentreY)\n\t]\n};{\n\t[NewX\t= CurrentX - startCentreX + endCentreX]\n\t[NewY\t= CurrentY - startCentreY + endCentreY]\n}]\n\n\n['NewX\t= round(NewX/endGridSize)']\n['NewY\t= round(NewY/endGridSize)']\n['pause(\"w1\",\"h1\",\"w2\",\"h2\",\"wc\",\"hc\",\"NewX\",\"NewY\",\"CurrentX\",\"startCentreX\",\"endCentreX\",\"CurrentY\",\"startCentreY\",\"endCentreY\")']\n\n[Token(tok): w42.bot.init = getInitiative()]\n\n\n[h, if(hasProperty(\"w42.bot.onRoof\", tok)): bot_roofSwap(0, tok, getProperty(\"w42.bot.onRoof\", tok), if(bot_inStr(getProperty(\"w42.bot.onRoof\", tok), \"roof\"),1,0))]\n\n\n[h, if(eventMacroPreInterTeleport != \"<none>\"), CODE:{\n\t[macro(eventMacroPreInterTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap\", \"UNSUFFIXED\"))]\n}; {}]\n\n[bot_chkSounds(tok, oldMap, 1, pathPadList)] \n[moveTokenToMap(tok, newMap, NewX, NewY, 100)]\n\n[if(doSwitchInterMap != 2), CODE:{\n\t[setCurrentMap(newMap)]\n\t[if(isNumber(w42.bot.init)), CODE:{\n\t\t[Token(tok): addToInitiative()]\n\t\t[Token(tok): setInitiative(w42.bot.init)]\n\t}; {}]\n\t[goto(currentToken())]\n\t[selectTokens(tok)]\n\t[exposeFOW()]\n};{}]\n\n\n[h, if(eventMacroPostInterTeleport != \"<none>\"), CODE:{\n\t[macro(eventMacroPostInterTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap\", \"UNSUFFIXED\"))]\n}; {}]\n\n[if(doSwitchInterMap == 0), CODE:{\n\t[bot_chkSounds(tok, newMap, 0)] \n\t[abort(doAbort)]\n}]\n\n[if(doSwitchInterMap != 2):setCurrentMap(oldMap)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9d46216c-b16a-4bdf-bdd3-0955421d95b1",
          "commandChecksum": "a891b3601556c98884f1d9b5b83397ec",
          "propsChecksum": "63066789f2206dad5c41ac76ded1f693"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 398,
        "label": "roofSwap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:inHouse\t\t= arg(0)]\n[h:me\t\t\t= arg(1)]\n[h:roofName\t\t= arg(2)]\n[h:showHalo\t\t= arg(3)]\n[h,if(argCount()>4): roofHaloColor\t= arg(4)]\n\n[h:switchToken(roofName)]\n[h:useAltImage\t= getLibProperty(\"useAltImage\",\"lib:EventMacros\")]\n\n[H, if(inHouse), code: {\n\t[assert(if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0), \"You will need to install the Bag of Tricks Image Tables first before you can use this option. See the how to install on the the forum\",0)]\n\t[nameList\t= getProperty(\"w42.bot.tokens.onHouse\")]\n\t[if(useAltImage && getTokenHandout() != \"\"): noRoofImg\t= getTokenHandout(); noRoofImg\t= tblImage(\"tbl_Image\",1)]\n\t[roofImg\t= getTokenImage()]\n\n\t[if(nameList == \"\"), CODE:{\n\t\t[xtmp = getTokenWidth()]\n\t\t[ytmp = getTokenHeight()]\n\t\t[setTokenImage(noRoofImg)]\n\t\t[setTokenWidth(xtmp)]\n\t\t[setTokenHeight(ytmp)]\n\t\t[if(showHalo):setHalo(roofHaloColor)]\n\t\t[setProperty(\"w42.bot.layer.original\", getLayer())]\n\t\t[setProperty(\"w42.bot.x.original\", xtmp)]\n\t\t[setProperty(\"w42.bot.y.original\", ytmp)]\n\t\t[setLayer(\"BACKGROUND\")]\n\t}]\n\t\n\t[if(roofImg != noRoofImg):setProperty(\"w42.bot.image.original\", roofImg)]\n\t[if(!listContains(nameList, me)): nameList\t= listAppend(nameList, me)]\n\t[setProperty(\"w42.bot.tokens.onHouse\",nameList)]\n\t\n\t[setProperty(\"w42.bot.onRoof\",roofName, me)]\n}; {\n\t[nameList\t= getProperty(\"w42.bot.tokens.onHouse\")]\n\t[if(listContains(nameList, me)): nameList\t= listDelete(nameList, listFind(nameList,me))]\n\t[setProperty(\"w42.bot.tokens.onHouse\",nameList)]\n\t\n\t[resetProperty(\"w42.bot.onRoof\", me)]\n\n\t[if(nameList == \"\"), CODE:{\n\t\t[xtmp = getProperty(\"w42.bot.x.original\")]\n\t\t[ytmp = getProperty(\"w42.bot.y.original\")]\n\t\t[setTokenImage(getProperty(\"w42.bot.image.original\"))]\n\t\t[setTokenWidth(xtmp)]\n\t\t[setTokenHeight(ytmp)]\n\t\t\n\t\t[if(showHalo):setHalo(\"None\")]\n\t\t[setLayer(getProperty(\"w42.bot.layer.original\"))]\n\t};{}]\n}]\n\n[if(getProperty(\"w42.bot.vblBgScale\") != \"\"): bot_setVBLRoof(roofName, inHouse)]\n\n[h:'pause(\"nameList\", \"me\", \"roofName\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8c854301-82ca-46ea-8e2a-b999fef8ee0a",
          "commandChecksum": "de74228d5da8d6be2e9b11cb610ff2e5",
          "propsChecksum": "6ccecb893276c07142d947c1ef282a03"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 399,
        "label": "setRoof",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: ' ']\n\n[h:roof\t\t\t\t= getName(getSelected())]\n[h:assert(listCount(roof)==1,\"Make sure (only) one token is selected\",0)]\n[h:assert(startsWith(roof, \"Roof \"),\"Make sure the 'roof' is called 'Roof <number>'\",0)]\n[h:switchToken(roof)]\n[h:tmpDoors\t\t\t= getProperty(\"w42.bot.Doors\", roof)]\n\n\n[h: oldAddVBL = if(hasProperty(\"w42.bot.vblSetup\"), 1, 0)]\n\n\n[h:vblSupport\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n\n\n[h:tokens\t\t\t= getTokenNames(\",\",'{\"layer\":\"OBJECT\"}')]\n[h:Doors\t\t\t= \"\"]\n[h, foreach(tok, tokens),CODE:{\n\t[if(startsWith(tok, \"Door \") && getProperty(\"w42.bot.doorData\", tok)): Doors\t= listAppend(Doors, tok)]\n}]\n[h:Doors\t\t\t= listSort(Doors, \"N+\")]\n\n\n[h:iDoors\t\t\t= \"\"]\n[h:desciptionsDoors\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t\t[id\t\t\t\t\t= substring(door, 5)]\n\t\t[iDoors\t\t\t\t= listAppend(iDoors, id)]\n\t\t[h,if(hasProperty(\"description\", door)): description\t= getProperty(\"description\", door); description\t= \"\"]\n\t\t[desciptionsDoors\t= listAppend(desciptionsDoors, strformat(\"(%{id}) %{description}\"))]\n}]\n\n\n[H: \t\t\t\tinputStr \t= \"[]\"]\n[h,if(vblSupport):\tinputStr\t= json.append(inputStr, \"junk|<html><b>Apply VBL<\/b> - this will store the current VBL of the building<br>and replace it by a Cross VBL. As soon as a token moves onto the roof<br>The cross VBL will be swapped by the stored building VBL. <\/html>|-|LABEL|SPAN=TRUE\")]\n[h,if(vblSupport):\tinputStr\t= json.append(inputStr, \"addVBL|\"+oldAddVBL+\"|Apply VBL Cross|CHECK\") ; addVBL = 0]\n[h, if(Doors != \"\"):inputStr\t= json.append(inputStr, \"junk|<html><b>Link doors<\/b> - set the entry/exit doors for this roof. This will<br>prevent a token from moving onto the roof by NOT using the door.<br>A token can only enter the building by first moving over one of the<br>selected door tokens.<\/html>|-|LABEL|SPAN=TRUE\")]\n[h,foreach(door, Doors), CODE:{\n\t\t[\t\t\tnewStr\t\t= \"door\" + roll.count + \"|\"+listContains(tmpDoors,door)+\"|\" + listGet(desciptionsDoors, roll.count) + \"|CHECK\"]\n\t\t[\t\t\tinputStr\t= json.append(inputStr, newStr)]\n}]\n\n\n[H: inputStr = json.evaluate(inputStr)]\n \n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[h:tmpDoors\t\t= \"\"]\n[h,foreach(door, Doors), CODE:{\n\t[if(eval(\"door\" + roll.count)):tmpDoors\t= listAppend(tmpDoors, door)]\n}]\n[h:setProperty(\"w42.bot.Doors\", tmpDoors, roof)]\n\n\n[h, if(addVBL && oldAddVBL != addVBL), CODE:{\n\t[vblSetup\t= strformat(\n\t\t\"applyVBL=1; VBLType=0; scaleX=100; scaleY=100; offsetX=0; offsetY=0; thickness=1; fill=0; scale=1; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;\"\n\t)]\n\n\t\n\t[setProperty(\"w42.bot.vblSetup\", vblSetup, roof)]\n\t[bot_createVBL(roof)]\n\t\n\t[bot_setVBLRoof(roof, 0)]\n}]\n\n\n[h, if(!addVBL && oldAddVBL != addVBL), CODE:{\n\t\n\t[bot_setVBLRoof(roof, 1)]\n\t\n\t[bot_removeVBL(roof)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "700eeeb4-9337-4043-8e58-87d1a9343001",
          "commandChecksum": "9d16f9c7060670b88de34daffffda086",
          "propsChecksum": "94ccdbbf123b76b0615ed04de986c51c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 400,
        "label": "setVBLRoof",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[debug = 0]\n\n[me\t\t\t\t= arg(0)]\n[tokenOnRoof\t= arg(1)]\n\n[if(tokenOnRoof), CODE:{\n\t\n\t\n\t[bot_drawBgVBL(me)]\t\n};{\n\t\n\t\n\t[rectVBL\t= getProperty(\"w42.bot.rectVBL\")]\n\t[eraseVBL(rectVBL)]\n\n\t\n\t[h,if(debug == 1), CODE:{\n\t\t[bot_debugInfo(\"me, tokenOnRoof, rectVBL\",0,1,0, getMacroName(), getMacroLocation())]\n\t};{}]\n\n\t\n\t[bot_drawFgVBL(me, 0)]\n}]\n\n[selectTokens(getTokens(\",\", '{ pc:1 }'),1,\",\")]\n[exposeFOW()]\n[deselectTokens()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e8ee2cc1-0bab-44ed-97b7-527acfb80745",
          "commandChecksum": "c0ec70b18fc9adb935e2f651c328858b",
          "propsChecksum": "e7bcdfc4e79b858048a6a81fc40f8d25"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 401,
        "label": "teleport",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:varsFromStrProp(arg(0))]\n[bot_playPadSound(padName, tok)]\t\n\n[h, Token(tok):CurrentX \t= getTokenX(1)]\n[h, Token(tok):CurrentY \t= getTokenY(1)]\n\n[h,if(doScaleTeleport), CODE:{\n\t[gs\t\t= bot_getGridSize()]\n\t[w1\t\t= bot_round2Grid(getTokenWidth(padName),gs)]\n\t[h1\t\t= bot_round2Grid(getTokenHeight(padName),gs)]\n\t[w2\t\t= bot_round2Grid(getTokenWidth(teleportEndName),gs)]\n\t[h2\t\t= bot_round2Grid(getTokenHeight(teleportEndName),gs)]\n\n\t[wc\t\t= w2/w1]\n\t[hc\t\t= h2/h1]\n\t[if(bot_round2Grid(CurrentX,gs) == bot_round2Grid(startCentreX,gs) + w1 - gs): NewX\t= endCentreX + w2 - gs ; NewX = round(wc*(CurrentX - startCentreX) + endCentreX)]\n\t[if(bot_round2Grid(CurrentY,gs) == bot_round2Grid(startCentreY,gs) + h1 - gs): NewY\t= endCentreY + h2 - gs ; NewY = round(hc*(CurrentY - startCentreY) + endCentreY)]\n};{\n\t[NewX\t= CurrentX + endCentreX - startCentreX]\n\t[NewY\t= CurrentY + endCentreY - startCentreY]\n}]\n\n[h,if(!isSnapToGrid(tok)),CODE:{\n\t\n\n\t[gs\t\t= bot_getGridSize()]\n\t[NewX\t= round(NewX/gs)*gs]\n\t[NewY\t= round(NewY/gs)*gs]\n};{}]\n\n\t['pause(\"w1\",\"h1\",\"w2\",\"h2\",\"wc\",\"hc\",\"NewX\",\"NewY\",\"CurrentX\",\"startCentreX\",\"endCentreX\",\"CurrentY\",\"startCentreY\",\"endCentreY\")']\n\n\n[h, if(eventPreMacroTeleport != \"<none>\"), CODE:{\n\t[macro(eventPreMacroTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY\", \"UNSUFFIXED\"))]\n}; {}]\n\n\n[h, if(hasProperty(\"w42.bot.onRoof\", tok)): \n\tbot_roofSwap(0, tok, getProperty(\"w42.bot.onRoof\", tok), if(bot_inStr(getProperty(\"w42.bot.onRoof\", tok), \"roof\"),1,0))\n]\n\n[h, Token(tok):moveToken(NewX, Newy , 1 )]\n[h:selectTokens(tok)]\n[h:exposeFOW()]\n[h:bot_chkSounds(tok, getCurrentMapName(), 0)] \n\n\n[h, if(eventPostMacroTeleport != \"<none>\"), CODE:{\n\t[macro(eventPostMacroTeleport+\"@Lib:EventMacros\"): json.append(\"\", strPropFromVars(\"tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY\", \"UNSUFFIXED\"))]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2ed513c3-df1f-467d-aa1f-08c8741995e0",
          "commandChecksum": "fdf6d0b3b0a96077fb4032117d44c58f",
          "propsChecksum": "b7f7e1685c7ccbc24538daee22b00022"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 405,
        "label": "showDescription",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:assert(listCount(getSelected())==1,\"Make sure (only) one 'Adventure Scenario' token is selected\",0)]\n[h:switchToken(getSelected())]\n\n[h: textBox\t\t= getGMNotes()]\n[h: textBox\t\t= encode(textBox)]\n[h: handout\t\t= getTokenHandout()]\n[h: portrait\t= getTokenPortrait()]\n\n[h: height\t\t= 500]\n\n[h, if(isGM()), code:{\n\t[textBox\t= replace(textBox,\"%C3%B1\",\"%26ntilde%26semi%3B\")]\t\n\t[textBox\t= replace(textBox,\"%C3%91\",\"%26Ntilde%26semi%3B\")]\t\n\t[textBox\t= replace(textBox,\"%C3%A1\",\"a\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%A9\",\"e\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%AD\",\"i\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%B3\",\"o\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%BA\",\"u\")]\t\t\t\t\t\n\n\t[textBox\t= replace(textBox,\"%E2%80%99\",\"@apostrophe@\")]\t\t\n\n\t[textBox\t= replace(textBox,\"%C3%81\",\"A\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%89\",\"E\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%8D\",\"I\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%93\",\"O\")]\t\t\t\t\t\n\t[textBox\t= replace(textBox,\"%C3%9A\",\"U\")]\t\t\t\t\t\n\t\n\t[textBox\t= replace(textBox,\"%0A\" ,\"%3Cp+align%3Djustify+style%3D%22text-indent%3A20%22%3E\")]\n\t[textBox\t= decode(textBox)]\n\t\n\t[textBox\t= replace(textBox,\"<title>\", \"[h:title='\")]\n\t[textBox\t= replace(textBox,\"<\/title>\", \" '] \")]\n\n\t[textBox\t= replace(textBox,\"<infolink>\", \"[h:infolink='\")]\n\t[textBox\t= replace(textBox,\"<\/infolink>\", \"'][r: macrolink(if(title=='' , 'Info link' , title), 'showInfoLink@lib:OnTokenMove' , 'all',json.append('',title, infolink))](Click to show) [h: title='']\")]\n\n\t[textBox\t= replace(textBox,\"<share>\", \"[h:share='\")]\n\t[textBox\t= replace(textBox,\"<\/share>\", \"']<table border=1 width=100% bgcolor=silver><tr><td border=0>[r: share]<br>[h: linkText = if(title == '', 'Share text', 'Share text: '+title)][r: macrolink(linkText, 'sendMacroChat@lib:OnTokenMove' , 'all',json.append('',title, share))]<\/table>[h: title='']\")]\n\t\n\t[textBox\t= replace(textBox,\"<image>\", \"[h: image=\")]\n\t[textBox\t= replace(textBox,\"<\/image>\", \"]<img src=[r:image]-100><\/img><br>[h: linkText = if(title == '', 'Share image', 'Share image: '+title)][r: macrolink(linkText, 'sendMacroChat@lib:OnTokenMove' , 'all' , json.append('',title,image,\"+height+\"))][h: title='']\")] \n\t\n\t[if(handout\t!= \"\" || portrait\t!= \"\")\t: suffix\t= \"<table align=center border=1><tr>\" ; suffix\t= \"\"]\n\t[if(handout\t!= \"\")\t\t\t\t\t\t: suffix\t= suffix + \"<td align=center>Handout:<br>\" + macrolink(\"<img src=\" + handout\t+ \"-100><\/img>\", 'sendMacroChat@lib:OnTokenMove', 'all', json.append('',\"Share Handout\",handout,height)\t)]\n\t[if(portrait != \"\")\t\t\t\t\t\t: suffix\t= suffix + \"<td align=center>Portrait:<br>\" + macrolink(\"<img src=\" + portrait\t+ \"-100><\/img>\", 'sendMacroChat@lib:OnTokenMove', 'all', json.append('',\"Share Portrait\",portrait,height))]\n\t[if(handout\t!= \"\" || portrait\t!= \"\")\t: textBox\t= suffix + \"<\/tr><\/table>\" + textBox]\n\n\t\n\t['broadcast(replace(textBox, \"<\",\"<br><\"))']\n\n\t[textBox\t= '[frame (\"Location Information\"):{' + bot_frameOpen(4) +  replace(textBox,\"@apostrophe@\",\"\") + bot_frameClose(4) + '}]']\n\t[execMacro(\"[h: title='']\" + textBox)]\n};{\n\t[assert(handout\t!= \"\", \"The token \"+token.name+\" has no (handout) image to show\",0)]\n\t[macro(\"shareIMG@lib:OnTokenMove\"):json.append('',title,handout,height)]\n}]",
        "maxWidth": "",
        "tooltip": "Copy to campaign panel",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e59d51ec-725e-4e91-94ed-619c77d54cca",
          "commandChecksum": "201e7194168d6f22b99fccad98c69ee3",
          "propsChecksum": "280706e5c9e8663b30dab3aa90109a18"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "7a. Event Area Macros",
        "index": 406,
        "label": "defineArea",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:stateList = getTokenStates()]\n[h,if(listContains(stateList, \"Special Area\")): selectedState = listFind(stateList, \"Special Area\") ; selectedState = 0]\n[h:abort(input(\n\t'junk|<html><b>DEFINE EVENT AREA<\/b><\/html>|-|LABEL|SPAN=TRUE',\n\t'areaName|<enter name of area>|<html><span title=\"<html>Here you can enter the name of the area to which the<br>coords will be linked. Use alphanumeric characters only<\/html>\">Name of Area<\/html><\/span><\/html>',\n\t'junk|<html><b>Choose one of the below two methods:<br>____________________________________________________<br>Method 1: Use coords of tokens on map<\/b><br><\/html>|-|LABEL|SPAN=TRUE',\n\t'areaState|'+stateList+'|<html><span title=\"<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any state you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.<\/html>\">Name of Token State<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+selectedState,\n\t'areaLayer|TOKEN, OBJECT, HIDDEN, BACKGROUND|<html><span title=\"<html>This is part of the first method. The macro will look<br>for ALL tokens that meet ALL the conditions you set here<br>and will use their coordinates to define the area.<br>You can use any layer you like. After this macro is<br>done the tokens are no longer needed and you can<br>delete them if you wish to do so.<\/html>\">Name of layer<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT=0',\n\t'deleteTokens|0|<html><span title=\"<html>Note that if you choose NOT to delete them, then the<br>only way to remove them is to manually delete them.<br>Or run this macro again and then check this box.<\/html>\">Delete tokens when done<\/html><\/span><\/html>|CHECK',\n\t'junk|<html>____________________________________________________<br><b>Method 2: Use coords of lastpath of a token<\/b><br><i>Checking the checkbox will result in method 2<\/i><br><\/html>|-|LABEL|SPAN=TRUE',\n\t'useLastPath|0|<html><span title=\"<html>The other method is using the last path of a token.<br>For this you can drag a token over the area you wish<br>to mark. You can use the space bar to set waypoints.<br>Note that if you go twice over one cell that the coord<br>will only be stored once. Also note that you can later<br>edit this area by using the <i>Show Area<\/i> macro,<br>move, add, remove the areaTokens and then redefine the<br>area using the other method.<br><br><b>When you check this checkbox it will ignore the other method!<\/b><\/html>\">Use the last path of a token<\/html><\/span><\/html>|CHECK',\n\t'lastPathName|<Token Name>|<html><span title=\"<html>Enter the name of the token of which the last<br>path you wish to use<\/html>\">If checked give name of token<\/html><\/span><\/html>'\n))]\n\n[h,if(useLastPath), CODE:{\n\t[assert(findToken(lastPathName)!=\"\", \"Can't find: \"+lastPathName,0)]\n\t[token(lastPathName):area = getLastPath(0)]\n}; {\n\t[conditions\t\t= json.set(\"{}\",\"layer\",areaLayer,\"setStates\",areaState)]\n\t[tokList\t\t= getTokens(\",\",conditions)]\n\t[assert(listCount(tokList)>0, \"No tokens have been found that match your criteria. Check whether the LAYER and the NAME are correct\", 0)]\n\t[if(deleteTokens): bot_removeTokens(tokList)]\n\t\n\t[splices\t\t= bot_createSplices(tokList)]\n\t\n\t\n\t[area\t\t\t= \"[]\"]\n\t[h, foreach(splice, splices, \"\"), code: {\n\t\t[foreach(tok, splice, \"\"):  area = json.append(area, \"{'x':\"+getTokenX(1,tok)+\",'y':\"+getTokenY(1,tok)+\"}\")]\n\t}]\n}]\n\n\n[h:area\t\t\t\t\t= json.unique(area)]\n\n[h:mapName\t\t\t\t= getCurrentMapName()]\n[h:storedAreas\t\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n\n\n[h, if(json.type(storedAreas) == \"UNKNOWN\"): storedAreas = \"{}\"]\n\n[h,if(json.contains(storedAreas, mapName)): thisMapAreas = json.get(storedAreas, mapName) ; thisMapAreas = \"{}\"]\n[h:thisMapAreas\t\t\t= json.set(thisMapAreas, areaName, area)]\n[h:storedAreas\t\t\t= json.set(storedAreas, mapName, thisMapAreas)]\n[h:setLibProperty(\"storedAreas\", storedAreas, \"Lib:EventMacros\")]\n\n\n[h:broadcast(\"The Area: \"+areaName+\" has been defined.<br> The coordinates are:<br>\"+json.indent(area,2))]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can define an Event Area which you then can link to an event macro, to be triggered when a token moves over this area.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "883d6f1b-c03a-4a9a-adca-a1a9c636891e",
          "commandChecksum": "aa9162e02e0c80af89811362e1e26f41",
          "propsChecksum": "601dba9839a6dd566e4fe62b61e42b1a"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "7a. Event Area Macros",
        "index": 407,
        "label": "fillArea",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n\n[h:bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n\n[h: index = listFind(allList, \"Area Marker\")]\n[h, if(index != -1), CODE:{\n\t[allList\t\t= listDelete(allList,index)]\n\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n}; {}]\n\n\n[h:selToks = getSelectedNames()]\n[h:assert(listCount(selToks)<=2, \"Make sure you have maximum two tokens selected\",0)]\n[h,if(selToks != \"\"), CODE:{\n\t[me\t= listGet(selToks,0)]\n\t[x1 = getTokenX(0,me)]\n\t[y1 = getTokenY(0,me)]\n\t[if(listCount(selToks) == 2), CODE:{\n\t\t[me2\t= listGet(selToks,1)]\n\t\t[x2\t\t= getTokenX(0,me2)]\n\t\t[y2\t\t= getTokenY(0,me2)]\n\t\t[xC\t\t= min(x1,x2)]\n\t\t[yC\t\t= min(y1,y2)]\n\t\t[xL \t= max(x1,x2) - xC+1]\n\t\t[yL \t= max(y1,y2) - yC+1]\n\t};{\n\t\t[xC\t\t= x1]\n\t\t[yC\t\t= y1]\n\t\t[xL \t= 10]\n\t\t[yL \t= 10]\n\t}]\n\t[allList\t\t= listAppend(me, allList)]\n\t[token(me): fancyAllList = listAppend(me + getTokenImage(60), fancyAllList)]\n}; {\n\t[xC\t= 0]\n\t[yC\t= 0]\n\t[xL = 10]\n\t[yL = 10]\n}] \n\n[h:inputStr\t\t= \"[]\"]\n[h:inputStr\t\t= json.append(inputStr, \"junk|<html><b>FILL AREA<\/b><br>This macro fills a predefined area with tokens<br>This functions works differently depending on the selected tokens:<br><b>No tokens selected<\/b>: a list of area tokens will appear from which you can pick.<br><b>One token selected<\/b>: the selected token will be added to the top of the list AND<br>its coordinates are used for the upper left corner.<br><b>Two tokens selected: <\/b> same as one token but now the width and length of the area<br>is also pre set, derived from the coordinates of the lower right selected token<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr \t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Token|LIST|ICON=TRUE ICONSIZE=30\")]\n[h:inputStr\t\t= json.append(inputStr, \"layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING\")]\n[h:inputStr\t\t= json.append(inputStr, \"xC|\"+xC+\"|X coord of upper left corner\")]\n[h:inputStr\t\t= json.append(inputStr, \"yC|\"+yC+\"|Y coord of upper left corner\")]\n[h:inputStr\t\t= json.append(inputStr, \"xL|\"+xL+\"|How many cells right\")]\n[h:inputStr\t\t= json.append(inputStr, \"yL|\"+yL+\"|How many cells down\")]\n\n\n\n[H: inputStr = json.evaluate(inputStr)]\n\n[H:abort(input(json.toList(inputStr,\"##\")))]\n\n\n\n[h:areaToken\t= listGet(allList, areaTok)]\n[h,if(me != \"\" && areaTok == 0): baseMapName\t= getCurrentMapName()]\n[h:areaToks\t\t= \"\"]\n[h,for(x, xC, xC+xL), CODE: {\n\t[h,for(y, yC, yC+yL):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set(\"{}\",\"useDistance\", 0, \"layer\", layer, \"x\", x, \"y\", y)))]\n}]\n[h:broadcast(\"<br><b>Overlay tokens have been placed<\/b>\")]\n[h,if(me != \"\"): selectTokens(json.fromList(selToks),0,\"json\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro fills a predefined area with tokens<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4e7336bc-f3c0-430d-bb7f-3a45011499fc",
          "commandChecksum": "f2c6a647cba5023ca3ca93f8afdd812d",
          "propsChecksum": "50078b13bf9dc5b44b0c78005b5cf006"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "7a. Event Area Macros",
        "index": 408,
        "label": "showArea",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n\n\n\n[h:mapName\t\t\t= getCurrentMapName()]\n[h:storedAreas\t\t= getLibProperty(\"storedAreas\", \"Lib:EventMacros\")]\n[h:showAreaTokens\t= getLibProperty(\"showAreaTokens\", \"Lib:EventMacros\")]\n[h,if(json.type(showAreaTokens) == \"UNKNOWN\"): showAreaTokens = \"{}\"]\n[h, if(!json.contains(showAreaTokens, mapName)):thisMapAreaTokens = \"{}\"; thisMapAreaTokens = json.get(showAreaTokens, mapName)]\n\n[h:assert(json.contains(storedAreas, mapName), \"This map contains no predefined areas\",0)]\n[h:thisMapAreas\t\t= json.get(storedAreas, mapName)]\n[h:thisMapAreaNames\t= listSort(json.fields(thisMapAreas),\"N+\")]\n\n\n[h:inputStr\t\t\t= \"[]\"]\n[h:shownAreas\t\t= json.fields(thisMapAreaTokens)]\n\n[h:bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n\n[h: index = listFind(allList, \"Area Marker\")]\n[h, if(index != -1), CODE:{\n\t[allList\t\t= listDelete(allList,index)]\n\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n}; {}]\n\n[h,if(listCount(thisMapAreaNames)), CODE:{\n\t[inputStr\t\t= json.append(inputStr, \"junk|<html><b>(Un)Check areas to (Un)Show them on the map<\/b><\/html>|<html>Here you can show or remove special areas with the use of overlay tokens OR you can delete areas.<br>If you check one or more areas then those area will be filled with overlay tokens which you can<br>choose from the drop down box. These overlay tokens will be copied on layer you can select from<br>the other drop down box. Areas that are already checked (and thus shown on the map) remain <br>unchanged. So only CHANGES in the checkboxes will be processed. The exception for this is the <br>deletion checkbox. If you check that one, then ALL THE CHECKED AREAS will be deleted.<br><br>Note that the overlay list is created from ALL token on the BASE map which name starts with <i>'Area '<\/i><br>(note the space). So you can add your own by simply dropping overlay tokens on the BASE map and<br>renaming them such that they start with <i>'Area '<\/i><br><br><b>IMPORTANT NOTE:<\/b><br>When you UNCHECK an area (thus effectively REMOVE the overlay tokens), make sure that the<br><u><i>Impersonated<\/i><\/u> panel IS CLOSED. Due to a bug in MT it will take EXTREMELY long (minutes)<br>to remove these tokens when that panel is open.|LABEL|SPAN=TRUE\")]\n\t[foreach(area, thisMapAreaNames): inputStr = json.append(inputStr, \"area\"+roll.count+\"|\"+if(listContains(shownAreas, area),1,0)+\"|\"+area+\"|CHECK\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|______________________________________________|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"layer|Token, Object, Hidden, Background|Layer|LIST|SELECT=3 VALUE=STRING\")]\n\t[inputStr \t\t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Overlay|LIST|ICON=TRUE ICONSIZE=30\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|______________________________________________|-|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"junk|<html><b>OR Delete checked areas<\/b><br>When you check the delete box then the all the areas<br>you have selected (checked) as well will be deleted.<\/html>|<html>When you check this checkbox, ALL THE CHECKED AREAS will be removed|LABEL|SPAN=TRUE\")]\n\t[inputStr\t\t= json.append(inputStr, \"deleteArea|0|Delete|CHECK\")]\n}; {\n\t[broadcast(\"<html><b>No special areas found on map<\/b><\/html>\")]\n\t[abort(0)]\n}]\n\n\n\n[H: inputStr\t= json.evaluate(inputStr)]\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n\n[h:chosenAreas\t= \"\"]\n[h,foreach(areaName, thisMapAreaNames), if(eval(\"area\"+roll.count)): chosenAreas = listAppend(chosenAreas, areaName)]\n\n[h:areaToken\t= listGet(allList, areaTok)]\n\n[h,if(deleteArea), CODE:{\n\t[foreach(areaName, chosenAreas),CODE:{\n\t\t[thisMapAreas\t= json.remove(thisMapAreas, areaName)]\n\t\t[storedAreas\t= json.set(storedAreas, mapName, thisMapAreas)]\n\t\t[setLibProperty(\"storedAreas\", storedAreas, \"Lib:EventMacros\")]\n\n\t\t\n\t\t[linkedAreas\t= getLibProperty(\"linkedAreas\", \"Lib:EventMacros\")]\n\t\t[thisMapLinks\t= json.get(linkedAreas, mapName)]\n\t\t[if(json.type(thisMapLinks) == \"OBJECT\"):\tthisMapLinks\t= json.remove(thisMapLinks, areaName)]\n\n\t\t[thisMapLimits\t= json.get(linkedAreas, mapName+\".W42.Limit\")]<br>\n\t\t[if(json.type(thisMapLimits) == \"OBJECT\"):\tthisMapLimits\t= json.remove(thisMapLimits, areaName)]\n\n\t\t[linkedAreas\t= json.set(linkedAreas, mapName, thisMapLinks, mapName+\".W42.Limit\", thisMapLimits)]\n\t\t[setLibProperty(\"linkedAreas\", linkedAreas, \"Lib:EventMacros\")]\n\n\t\t\n\t\t[areaToks\t\t\t= json.get(thisMapAreaTokens, areaName)]\n\t\t\n\t\t[thisMapAreaTokens\t= json.remove(thisMapAreaTokens, areaName)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t\n\t\t[broadcast(\"The store area: \"+areaName+\" has been removed.\")]\n\t}]\n}; {}]\n\n[h,foreach(areaName, thisMapAreaNames), if(!deleteArea), CODE:{\n\t\n\t[if(listContains(shownAreas, areaName) && !listContains(chosenAreas, areaName)), CODE:{\n\t\t[areaToks\t\t\t= json.get(thisMapAreaTokens, areaName)]\n\t\t\n\t\t[areaIsShown = findToken(listGet(areaToks,0))]\n\t\t[if(areaIsShown != \"\"):\tbot_removeTokens(areaToks)]\n\t\t\n\t\t\n\t\t[thisMapAreaTokens\t= json.remove(thisMapAreaTokens, areaName)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t[broadcast(\"<br><b>Overlay tokens of area: \"+areaName+\" have been removed<\/b>\")]\n\t''\n\t}]\n\n\t\n\t\n\t[if(!listContains(shownAreas, areaName) && listContains(chosenAreas, areaName)), CODE:{\n\t\t[area = json.get(thisMapAreas, areaName)]\n\t\t[assert(!json.isEmpty(area), \"that area contains no coordinates\",0)]\n\t\t\n\t\t[broadcast(\"Area coordinates are: \"+json.indent(area,2))]\n\n\t\t\n\t\t\n\t\t[splices\t\t\t= bot_createSplices(area)]\n\n\t\t\n\t\t[areaToks\t= \"\"]\n\t\t\n\t\t[foreach(splice, splices, \"\"), CODE: {\n\t\t\t[foreach(coord, splice, \"\"):  areaToks = listAppend(areaToks, copyToken(areaToken, 1, baseMapName, json.set(coord,\"useDistance\", 1, \"layer\", layer)))]\n\t\t''\n\t\t}]\n\n\t\t[thisMapAreaTokens\t= json.set(thisMapAreaTokens, areaName, areaToks)]\n\t\t[showAreaTokens\t\t= json.set(showAreaTokens, mapName, thisMapAreaTokens)]\n\t\t\n\t\t[setLibProperty(\"showAreaTokens\", showAreaTokens, \"Lib:EventMacros\")]\n\t\t[broadcast(\"<br><b>Overlay tokens for area \"+areaName+\" have been placed<\/b>\")]\n\t''\n\t}]\n''\t\n}]",
        "maxWidth": "",
        "tooltip": "<html>This macro shows predefined areas by putting token in the cells that are part of the Area.<br>When you run this macro again the tokens are removed again.<br><br>Hence this macro can be used to change pre defined area. To do this first run this macro<br>for the area you wish to change. The map will then be filled with tokens. Then move these<br>tokens around, delete them, copy them until youre happy. Then run <i>Define Area<\/i> and<br>enter a name for the new Area (can be the same as the original in which case it will be<br>overwritten) and click ok. A new Area is now defined. Finally you can run Show Area again<br>to remove the tokens. Note that is you created new tokens that these will NOT be removed by<br>this macro.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "06fd181f-eb97-449f-8fef-83bffb911ea1",
          "commandChecksum": "f69153724b5abd824a18c6580d6b8314",
          "propsChecksum": "a919efb76c1031805ba35bc0c0075d08"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "7a. Event Area Macros",
        "includeLabel": false,
        "sortBy": "7a. Event Area Macros",
        "index": 409,
        "label": "toggleAreaDraw",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:toggles\t= getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:drawArea\t= getStrProp(toggles, \"drawArea\")]\n\n[h,if(drawArea), CODE:{\n\t\n\n\t[drawArea\t\t= 0]\n\t[toggles\t\t= setStrProp(toggles, \"drawArea\", drawArea)]\n\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n\t[setLibProperty(\"drawTokenMap\", \"\", \"lib:EventMacros\")]\n\t[broadcast(\"<font color=red>TOKEN DRAWING IS TURNED OFF\")]\n};{\n\t\n\n\t\n\t\n\t[bot_getValidTokens(0, \"{}\", 0, \"Area \")]\n\t[me = getSelected()]\n\t\n\t[index = listFind(allList, \"Area Marker\")]\n\t[if(index != -1), CODE:{\n\t\t[allList\t\t= listDelete(allList,index)]\n\t\t[allList\t\t= listAppend(\"Area Marker\",allList)]\n\t\t[fancyIt\t\t= listGet(fancyAllList, index)]\n\t\t[fancyAllList\t= listDelete(fancyAllList,index)]\n\t\t[fancyAllList\t= listAppend(fancyIt,fancyAllList)]\n\t}; {}]\n\t\n\t\n\t[selTok = listGet(getSelectedNames(),0)]\n\t[if(selTok != \"\"), CODE:{\n\t\t[allList\t\t= listAppend(selTok, allList)]\n\t\t[token(selTok): fancyAllList = listAppend(selTok + getTokenImage(60), fancyAllList)]\n\t};{}]\n\t\n\t[inputStr\t\t= json.append(\"[]\", \"junk|<html><b>Pick token which will be used to draw<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[inputStr \t\t= json.append(inputStr, \"areaTok|\" + fancyAllList + \"|Overlay|LIST|ICON=TRUE ICONSIZE=30\")]\n\n\t\n\t\n\t[inputStr = json.evaluate(inputStr)]\n\t\n\t[abort(input(json.toList(inputStr,\"##\")))]\n\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[drawTokenName\t= listGet(allList, areaTok)]\n\t[if(me!=\"\"), CODE:{\n\t\t[x\t= getTokenX(0,listGet(me,0))]\n\t\t[y\t= getTokenY(0,listGet(me,0))]\n\t};{\n\t\t[x\t= 0]\n\t\t[y\t= 0]\n\t}]\n\t[if(findToken(drawTokenName)==\"\"):copyToken(drawTokenName,1,baseMap,strformat('{\"x\":%{x},\"y\":%{y}}'))]\n\t\n\t[drawTokenMap\t= if(areaTok || selTok == \"\", baseMap, getCurrentMapName())]\n\n\t[drawArea\t= 1]\n\t[toggles\t= setStrProp(toggles, \"drawArea\", drawArea)]\n\t[setLibProperty(\"drawTokenName\", drawTokenName, \"lib:EventMacros\")]\n\t[setLibProperty(\"drawTokenMap\", drawTokenMap, \"lib:EventMacros\")]\n\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n\t[broadcast(\"<font color=red>TOKEN DRAWING IS TURNED ON, CLICK THE TOGGLE MACRO AGAIN TO TURN IT OFF<\/font><br>This means that ANY token you drag over the map will leave a trail of 'drawing tokens' in its trail\")]\n}]\n\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]",
        "maxWidth": "",
        "tooltip": "<html>This macro will turn on 'token drawing'. You can select a token to be drawn. When you ove ANY token on the map then the chosen token will be copied in its path",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fe2358c1-341d-4edd-b7b1-ee69fac2c143",
          "commandChecksum": "3732bd8feab902f6e5768982a8a3b574",
          "propsChecksum": "20eb1d3c038ad6d930b9fda8320def20"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 410,
        "label": "isClockWise BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n[x1\t= arg(2) - arg(0)]\n[y1\t= arg(3) - arg(1)]\n[x2\t= arg(4) - arg(0)]\n[y2\t= arg(5) - arg(1)]\n\n[macro.return\t= if(-x1*y2 + y1*x2 > 0,0,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "328cf613-def8-4670-9667-db9018259086",
          "commandChecksum": "56f154dc2acb7e239160be917a7ba487",
          "propsChecksum": "d93c780b0abf1e1f0fc154ec457251e7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "99",
        "includeLabel": false,
        "sortBy": "99",
        "index": 411,
        "label": "pointInCone BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n[me\t\t\t= arg(0)]\n[x1\t\t\t= arg(1)]\n[y1\t\t\t= arg(2)]\n[x2\t\t\t= arg(3)]\n[y2\t\t\t= arg(4)]\n[xp\t\t\t= arg(5)]\n[yp\t\t\t= arg(6)]\n\n[xc\t\t\t= getTokenX(0,me)]\n[yc\t\t\t= getTokenY(0,me)]\n[distance\t= getDistanceToXY(xp,yp,0,me)]\n[r\t\t\t= getDistanceToXY(x1,y1,0,me)]\n\n[CW\t\t\t= bot_isClockWise\t(xc,yc,  x1,y1,  xp,yp)]\n[CCW\t\t= !bot_isClockWise\t(xc,yc,  x2,y2,  xp,yp)]\n[IR\t\t\t= if(distance <= r,1,0)]\n\n\n[h:macro.return\t= if(CW && CCW && IR, 1, 0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b26a6313-3648-4fe0-8dcc-96947f805c43",
          "commandChecksum": "4ae0e2de1593ca9a6b5f9f3ea04e175d",
          "propsChecksum": "17d27d01b37b99a2a436ac760fdfbb30"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 412,
        "label": "manualText",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:hasTbl\t= json.contains(json.get(getInfo(\"campaign\"),\"tables\"), \"tbl_Image\")]\n[h, if(hasTbl):pointerImg\t= tableImage('tbl_Image',30) ; pointerImg\t= \"\"]\n[h:hasTbl\t= json.contains(json.get(getInfo(\"campaign\"),\"tables\"), \"tbl_Image\")]\n[h, if(hasTbl):bookImg\t\t= tableImage('tbl_Image',26) ; bookImg\t\t= \"\"]\n\n[h:output = \"\n<font color=red><b><u>ON TOKEN MOVE MANUAL<\/u><\/b><br><\/font>\n<br>\nA first and foremost rule that applies to ALL SPECIAL PADS: DO NOT ROTATE THE TOKENS!! Of course if they're square or round it does not matter, but if they're rectangles you cannot rotate them as the 'footprint' will remain unrotated. So you CAN RESIZE but you CANNOT ROTATE<br>\n<br>\n<b><u>Big change between version 9 and 10: Pits and Traps have been replaces by EventPads.<\/u><\/b><br>\nI've written a conversion tool (Convert Trap/Pits - ONLY on the lib:OnTokenMove, NOT in the BoT-macro panel) to convert campaign files created in version 9 or earlier, which make use of the Pits and Traps. \nYou will only need to run this macro once for the whole campaign file. \nIn addition you will need to rewrite the code for the Pit macros a bit, as the passed on arguments differ and the 'Trapped' state is no longer required. \nFinally you need to move ALL macros you created for pits and traps to the new lib:MacroEvents token. <br><br>\n\n<font color=red><b><u>UPGRADING TO A NEW VERSION<\/u><\/b><br><\/font>\nWith the addition of the lib:EventMacros you no longer need to redo all your settings nor need to move or copy paste any personal event macros that you created on that lib. All *your* settings are stored on lib:Eventmacros. So when you upgrade a version you ONLY need to do 2 things:<br>\n1. replace the lib:OntokenMove for the new one (delete first, then drag the new one on your map)<br>\n2. run settings once!<br>\nNote that when you run the settings that its possible that you get some *errors* in the form of input request for strange variables. These are the new settings that have been added but obviously not yet set on *your* lib:eventMacros. You only need to click 'ok' (depending on the update this can be many clicks) and then the settings menu will eventually pop-up. Always check the settings (they should not have changed) and then finally click ok. If you *did* get the input requests then very likely you will notice that there are more settings available. If you only only clicked 'ok' during the input requests, then they all should be turned off by default.<br>\nTHAT'S IT!<br>\n<b>If you upgrade from version 13x or lower<\/b> then you will also need to update the table (see implementation section). It is also prudent to update the lib:EventMacros (for the latter its enough to update the macros, but if you have none of you own I would advise to simply update the entire lib).<br>\n<br>\n<font color=red><b><u>IMPLEMENTATION<\/u><\/b><br><\/font>\nBelow you can find a general and rough guide for implementing the BoT. A more detailed and up to date version can be found <a href = 'https://forums.rptools.net/viewtopic.php?p=274498#p274498'>here<\/a>.<br>\nThe necessary bare actions needed to get this thing on the road, I've put in <b>(parenthesis)<\/b> for which feature this step is required:<br>\n- If you just dropped the .rptok file onto a map, run onCampaignLoad first (though if you're reading this you likely did<br>\n- <b>(Summon Tokens) (=macro):<\/b> Drag the image_none.png to the base map.<br>\n- <b>(Roof & Foliage):<\/b> Load .mttable file from the special tokens into the tables panel<br>\n- <b>(Canopy):<\/b> Make sure there is a map called 'BASE' (either rename the map or change this in the Settings)<br>\n- <b>(Alt. Init. Token):<\/b> Drag the lib:Coords.rptok token onto (BASE) map<br>\n- <b>(EventPads):<\/b> Requires a lib:EventMacros token with at least one macro on it. <br>\n- <b>(Token Door Switches):<\/b> Create 'isButton' state:<br>\n  * Click on an existing state first (you can only add a state if you select one first ?!?)<br>\n  * Change name to 'isButton'<br>\n  * Change type to Image, you can load the 'State.isButton.png' as state image.<br>\n  * Click add and close<br>\n  * Also Create 'Locked' state. Show To: GM Only, Type: Image, you can load the 'State.Locked.png' as state image.<br>\n  * Drag the Lever.rptok file onto the 'BASE' map. MAKE SURE YOU HAVE CREATED THE ISBUTTON STATE <B>BEFORE<\/B> YOU DRAG THIS TOKEN ONTO THE MAP<br>\n- <b>(Path Tracking):<\/b> Create 'pathFeet' state (image State.pathFeet.png)<br>\n- <b>(Event Areas):<\/b> Create 'Special Area' state (image State.Special Area.png)<br>\n- Select the lib:onTokenMove and Drag the '(drag to) Campaign Macros' which you want to use to the Campaign panel (though its enough to only drag the 'Bag of Tricks Macro' macro).<br>\n- Run the 'Settings' macro, here you can exclude maps from the initialization (checked) check if these are set right.<br>\nOff you go.<br>\n<br>\n<font color=red><b><u>REPORTED MISHAPS<\/u><\/b><br><\/font>\n<b>GENERAL REMARK:<\/b> note that YOU CAN ONLY HAVE ONE <font color=#FF0000><b>'ONTOKENMOVE' MACRO<\/b><\/font> IN YOUR CAMPAIGN. So if you e.g. create a backup of the old lib token, you will have 2!! One on the backup lib and one on the new one. Stuff will go haywire!! (actually you *can* have two ontokenmove macros within a campaign, but they will both be activated on the event, which very likely will have unpredictable results. In short: its bad practice)<br>\n<b>THE PADS DON'T WORK:<\/b> There can be several reasons: <br>\n1. the onTokenMove event is turned off. This can be checked by checking te name in group 2. on the lib:OntokenMove: if it says #onTokenMove its turned off. Hit the 'Turn On Token Move Event On/Off' macro. <br>\n2. you just dragged the libs onto your map and you forgot to run onCampaignLoad (or save and reload the campaign file)<br>\n3. you forgot to run the settings. <br>\n4. 'visible to players' is turned off. Double click on token --> config --> check the checkbox on the right 'visible to players' <br>\n <b>ERROR:<\/b> if you get an error '<b><font color=#FF0000>Error executing movedOverToken: the token name or id {1} is unknown.<\/font><\/b>' this means that the code is looking for a token that is not on the map. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>\n <b>ERROR:<\/b> if you use a interteleport and on destination you're asked for coordX and coordY then you the two paired interteleports do NOT have the same name/number. Run the 'Initialize Pads' again from the camapaign panel and look through the report.<br>\n<b>ISSUE:<\/b> when snap to grid is turned of and you try to teleport more than 2 tokens that overlap, the teleport MIGHT not work.<br>\n<b>ERROR: Can't find map '1' (or any other number).<\/b> If you name your maps 01, 02 or 001, 002, etc. then in the code MT script will transform these 'numbers' into real numbers: 1,2,etc and those maps do not exist. So make sure that the map name cannot be recognized as a number OR be making it an actual number. So 1,2,3 would work and 01m, 02m, etc. also.<br>\n5. there is a lib:Coords token on the map (white token with blue cross hairs). This appears when using alt.init.map. When you change the map you'll need to run both this macro on that map AND Initialize Pads. If you no longer wish to make use of the alternative method, you'll need to delete the lib:Coords from that map. Note that there is also a lib:Coords on the BASE map. This one is not used. Only the ones where the map name is after the 'lib:coords ' are in use. <br>\n<br>\n<font color=red><b><u>INITIALIZE MAPS AND ALT.INIT.MAPS<\/u><\/b><br><\/font>\nWhen you start using the special pads (described here below). You'll need to initialize the campaign file so the BoT 'knows' that they're there. To do this you need to run Initialize Maps. <b><u>Everytime you add, delete or rename a special pad, you will need to run this again<\/u><\/b>. You can however move the tokens (on the same map) anywhere you like. The only thing that initialize maps does is seek and log all the special pads so the on token move event can quickly access them.<br>\nThere is an alternative to this: alt.init.map. This macro works fundamentally different. It actually maps the coordinates of all the special pads on the map. Then when moving over the map the on token move event can check whether you intersected with an area where a special pad is situated. This means that you'll need to run this macro everytime you create, delete, rename AND move a special pad!! \nThe advantage of this method is the fact that when you have a LOT (> 100) special pads e.g. a forest with 'Canopy' tokens then its faster then the traditional method. However it IS slow to initialize (can take 10's of minutes) and it IS generally slower then the initialize maps method.<br>\nWhen using this method you'll notice that a 'lib:Coords <mapname>' is created on the map. On this lib all the spec. pads coords for that map are stored. AS LONG AS THAT TOKEN IS ON THAT MAP IT TAKES PRECEDENCE OVER THE GENERAL INITALIZE MAPS METHOD. As soon as you delete it, then the 'normal' method will be used again. <br>\nNotes:<br>\n- When using interPads (teleport between maps) on a lib:coords map you need to run both initalize maps and alt.init.maps. As alt.init.maps only works for that map and does not check to which other interPad the interPad is linked. <br>\n- In the settings there is a tab to turn off 'initialize maps' for certain maps (again e.g. a forest) this will speed up the initailize method method when you exclude maps which make use of alt.init.maps. Do however keep in mind that when you turn it off, interPads to and from that map won't work!<br>\n<br>\n<font color=red><b><u>SPECIAL TOKENS<\/u><\/b><br><\/font>\nThis drop-in runs different macros whenever a token moves over a 'special' pad. The following special pads are supported:<br>\n- InterPad n<br>\n- PadStart n<br>\n- PadEnd n<br>\n<br>\n- InterPadBorder n<br>\n- PadStartBorder n<br>\n- PadEndBorder n<br>\n<br>\n- InterJump n<br>\n- InterDrop n<br>\n- PadJump n<br>\n- PadDrop n<br>\n<br>\n- InterJumpBorder n<br>\n- InterDropBorder n<br>\n- PadJumpBorder n<br>\n- PadDropBorder n<br>\n<br>\n- AssignPad [group] [index]<br>\n- EventPad n<br>\n- Canopy n<br>\n- Foliage n<br>\n- Roof n<br>\n- Linked n1 [Special Pad] n2<br>\n- Linked n1 Bridge n2 (i.c.w. Roof, Foliage or Canopy)<br>\n- MappedPad n<br>\n- ShadowPad n Ground & ShadowPad n Floor<br>\n- Ward n<br>\n<br>\nWhere 'n' is a identifier (1,2,3, etc. but with version 26 anything is allowed, so 'Sea', 'Yet another level', 'are you sure' etc. is also possible). This means that these token names are reserved. Should you use such a token nonetheless than this likely will show up in the error report from the 'initialize pads' macro. <br>\n[group] and [index] will be explained later with Assignpads<br>\nAs mentioned, ANY identifier is allowed as long as its unique for that token. Originally this was restricted to numbers only. If you want this back then there is a setting: 'settings > general > Numeric Id for special pads only' that you can check. This way only special pads with a numeric identifier are initialized. Do note however that 'Linked' pads (see below) will not work!! <br>\n<br>\n<b><u>The rules:<\/b><\/u><br>\n<b>In general<\/b>: If you want to use special pads just name a token e.g. 'Ward 1' (without the ''). Name the next 'Ward 2' etc (the numbers do not need to be contiguous). The Initialize map macro will check for duplicates and these will show up in the error report.<br>\n<br>\n<b>PadStart and Padend<\/b>: these are used to teleport a token from one to another a token on 'PadStart 1' will be teleported to 'PadEnd 1' and vice versa. So to pair two teleports (start and end) they need to have the same number.<br>\n<br>\n<b>PadJump and PadDrop<\/b>: these work exactly the same as PadStart and PadEnd, save the fact that it only works one way: PadJump --> PadDrop, not the other way round. These you can typically use for doors where the interior map of e.g. a house is situated somewhere else, this way a token can step through a door and appear on the interior map, similar the other way round, to exit a building you are teleported back to the 'outside' map<br>\n<br>\n<b>InterPad<\/b>: Note that for earlier users that the name has changed, it now starts with a capital letter!<br> These work the same as PadStart and PadEnd only they have the same name and are on different maps. So InterPad 1 on 'Grasslands' and Interpad 1 on 'Plains' are connected to eachother.<br>\n<br>\n<b>InterJump and InterDrop<\/b>: these work exactly the same as PadJump and PadDrop only these you use to teleport between maps, just like the interPad<br>\n<br>\n<b>PadStartBorder, PadEndBorder, InterPadBorder<\/b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to make certain that players are teleported to another section when they move over/into a certain section. Note that these work two way, so if tokens keep moving on them they get send to and back. The Jump/Drop versions below can be used to prevent that.<br>\n<br>\n<b>PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder<\/b>: These work exactly the same as the ones without 'Border' at the end with the subtle difference that these are also activated when you move OVER the token, where with the other teleports you need to step ONTO the token. These can typically be used to divide larger maps into pieces and divide them over several maps then when a token walk over the 'border' its automatically transferred to the next map. By splitting these up into one way tokens you won't have the issue that when a token walk ONTO the border (and is thus transported) and then moves OVER the border its transported back again. The token actually will need to take a step 'back' (onto another one way telport back, if you put it there) before its transported.\n<br><br>\n\n<b>AssignPad<\/b>: AssignPad: These are teleport tokens to which you can assign ONE token. This token will be teleported as soon as the assign pad event is executed. Hence there are two supporting macros:<br>\n-  'Assign Tokens to Pads' and <br>\n- 'Execute AssignPads'. <br>\n<br>\nTo set these up you need tokens called 'AssignedPad Group Index'. Where 'Group' and 'Index' can by anything alphanumeric (so 1,2,3, etc and a,b,c,d, etc. and NOT ',<>?! etc. ) Some examples AssignedPad Red 1, AssignedPad Red 2, AssignedPad Alpha Jim, AssignedPad Alpha Tom. You can also leave out the group: AssignedPad 1, AssignedPad 2. <br>\n<br>\nThe advantage of groups is that the assign and execute macro menus will have a tab per group so you can more easily assign tokens and you can choose more easily to execute certain groups instead of all the pads.<br>\nIf you want to execute the teleportation without any interface, e.g. as part of an event then you can use the following line of code to do this:<br>\n[h:bot_execAssignPads(1)]<br>\nIts also possible to execute only one group (e.g. 'Red') as follows:<br>\n[h:bot_execAssignPads(1, 'Red')]<br>\n<br>\n<i><u>Notes:<\/u><\/i><br>\n- You do NOT need to run 'initialize pads' for these tokens to work<br>\n- You DO need to run 'assign tokens to pads' before these tokens work<br>\n- Make sure that there are no double or trailing spaces in the name e.g. 'AsssignPad..Attack.5.' (replaced ' ' with '.' for illustration) will generate an error.<br>\n- When you execute, you can turn off entire groups in the first tab, you do NOT need to turn of the checks for those pads individually in there corresponding tab.<br>\n- ALL the tokens need to be on the same map. Interteleport is NOT possible.<br>\n<br>\n\n<b>EventPad<\/b>: These tokens are triggered on certain events, which you can set prior to using them. To set an EventPad simply select one (or more) and click on the 'Set Event Pad'. This will pop up an input screen where you can link any macro that is placed on the lib:EventsMacros token and in addition you can set the token to trigger this macro for one or more of the following events:<br>\n- When a token is moved onto the EventPad<br>\n- When a token is moved off the EventPad<br>\n- When a token is moved over the EventPad<br>\n- When a token on the EventPad is moved but then placed back at its original spot (zero move). Note that Zero move event is turned off per default in the settings, so to make use of this event you will first need to turn it on globally in the settings. <br>\n- When a token on the EventPad is moved, waypoints are used, but the move ends back on the EventPad<br>\n- When a token on the EventPad is moved but remains on the EventPad (e.g. one step left on a big pad)<br>\nI have left the original Pit and Trap pad on the map (but converted) so you can still check out how these macros work. The 'reset Pit' (to reset the picture for the opened pit) macro still works.<br>\n<br>\n\n<b>Roof<\/b>: Any token called Roof n,will disappear and leave a red outline (halo) when a token moves over it and reappear when moved away from it.<br>\nYou can also choose to 'set' a roof with the corresponding button. When you do this you will get a list of doors (if any) which you can check. When you do this the token can only move in or out of the building (roof) through an OPEN door. It is thus vital that its actually an entry (so a door that is on the edge of the roof) and it will only work for doors that have been 'set'. This because you need to open the door before you can enter and an 'open' door can only be detected when its actually 'set'.<br>\n<b>Note that the 'warded roofs' only ward players, not gm's!!<\/b><br>\n<br>\nAn additional feature available from b90+ is 'apply VBL'. When this is checked the current VBL of the building beneath the roof is stored (on the roof token) and the VBL is replaced with a VBL Cross. This VBL Cross will be swapped with the building VBL as soon as a token moves onto the roof. \n<br>Note that this only works AFTER the maps has been 'initialized'<br>\n<br>\n\n<b>Foliage<\/b>: Same function as roof, only without the red outline (halo).<br>\n<br>\n<b>Canopy<\/b>: Same function as Foliage, only a tree trunk will appear in its place (see below for more info).<br>\n<br>\n<b>Linked<\/b>: Linked pads work for Foliage, Canopy and Roofs (you can mix them). When they are linked all are activated if one is activated (see below for more info). Additionally they can be used for bridges.<br>\n<br>\n<b>Linked Bridge<\/b>: Linked Bridge pads are linked pads but the when a token first moves over the bridge token and then over the e.g. linked Roof, the roof is NOT activated (<a href = 'http://bit.ly/1f5wn6X'>see video tutorial<\/a>).<br>\n<br>\n<b>ShadowPad<\/b>: Typically used for two floor maps on one MT map where the upper floor can look out to the ground floor, e.g. loft in a barn. When token on seperate levels step onto these pads a 'shadow token' is created on the other floor.<br>See below for more info.<br>\n<br>\n<b>MappedPad<\/b>: These are teleport tokens which you can map. When creating these pads, after initializing you'll get a pop-up where you can map the start destinations<br>\n<br>\n<b>Ward<\/b>: Any token called Ward n will prevent a token to be moved on. It will simply return the token to the original spot<br>\n\n<br>\n<b><u>THE TELEPORT TOKENS NAME SYNTAX EXPLAINED<\/u><\/b><br>\nHere a short description of where to think of for which names:<br>\n- 'start'/'end' means TWO WAY teleport<br>\n- 'jump'/'drop' means ONE WAY teleport, where 'jump' teleports and 'drop' not<br>\n- 'inter' means between maps, these tokens are linked by having the SAME name, while e.g. 'start'/'end' (always on the same map) are linked by DIFFERENT names.<br>\n- 'border' means that the teleport is activated not only when you step ONTO but also when you MOVE OVER the pad. Withouth the 'Border' they are ONLY activated when THE MOVE ENDS ON THE PAD.<br>\nAll the pads are linked by their number!! so a 'PadStart 3' will be linked with 'Padend 3' and an 'InterJump 2' on one map will be linked to a 'InterJump 2' on another map. <br>\n<br>\n<b><u>ADVANCED STUFF ROOF AND FOLIAGE<\/u><\/b><br>\nFirst let me explain how the roof and foliage work: in the tables there is an image stored that is completely transparent. When a token moves over either a roof or foliage token the 'roof' or 'foliage' image is removed and stored somewhere else on the token and the transparent image is placed instead of it. This way it looks like the foliage or roof dissapears. The advantage of the table is that that image can be retrieved always, no matter on which map you are. You can however also choose to do this differently by retrieving the image not from the table but from the handout section of the token itself. This has two advantages:<br>\n1. You don't need to load the tabel <br>\n2. You can use ANY picture. <br>\nTo show this I've prepped the two trees.<br>\nThe left tree (Foliage 1) has a seperate token beneath it of a trunk, when you move over it, the foliage will dissapear and you'll see the trunk token. <br>\nThe right tree (Foliage 2) is a single token (so no trunk beneath it), so when you move over that tree you'll see nothing. However if you look at the token properties you'll notice an image with a trunk in the token handout section.<br>\n<br>\nNow in the settings you can choose the setting 'Use alternative transparent iamge for foliage', checking this option, will first check the token handout of a token and if it finds an image it will swap it for the foliage image. If not, then it will take the picture from the table. <br>\nWhat you'll see happening now is that the left tree still dissapears, but the right tree will grow semi transparent and a trunk will appear. <br> This method will allow you to create 'special' tokens if you like. <br>\n<br>\n<b><u>CANOPY<\/u><\/b><br>\n<b>Requirements<\/b><br>\n- A Map in the campaign file called 'BASE' (you can change this required map name in the settings.)<br>\n- Images of tree trunks on that map on the OBJECT layer, which start their name with 'Trunk...'<br>\n- Note that the images replace the whole image of the canopy, this means that just an image of a tree trunk will be stretched over the full area of the Canopy image. Therefore you need to edit the trunk image so that a lot of transparent space surrounds it. Have a look in the example campaign to see what I mean. Typically the canopy is 20x the size (diameter) of the trunk, so if e.g. the trunk is 10px wide then the total span of the image must be 200x200 px. (with at the centre a 10x10px trunk image).,\n<b>Usage:<\/b><br>\nThe tree trunk images need to 'set' first. To do this run the 'choose trunks' macro, this macro will check the 'BASE' (or another map if you changed the settings) map for tokens on the object layer that start their name with 'Trunk...' and will provide a check list from which you can choose which trunks should be used and whic not<br>\nCanopy works in the same way as 'Foliage' with one important difference. When you initialize Canopy, the Canopy token handout is checked and when its empty an image of a tree trunk is put there. When you a pc or npc token moves over the canopy token, the canopy image is swapped for a tree trunk image.The tree trunk is randomly selected from the 'set' trunks from the 'choose trunk' macro.<br>\n<br>\n<b>Draw VBL<\/b><br>\nThis operation will only work when you have the 'Support VBL' setting turned on in the general settings. When you click on it, it wil automatically draw a Vision Blocking Layer cross over all trunks of the Canopy pads. The cross will have the size of 1 square. <br>\n<br>\n<b>Useful Stuff to Know about Canopy, Trunks and Trees<\/b><br>\n- Trunks are usually between 10 and 70 cm (that is 4 inch upto 2ft 4 inch)<br>\n- Canopy is typically 20x the size of the trunk so a 10cm trunk has a canopy of 2m (=+/- 2yards) and one of 70cm is 14m. <br>\n- The height of the tree = the width of the canopy (roughly)<br>\n- Typical spreading of trees in a forest is 5m (so on average 5 meters/yards between trees). The variance is actually very small but if you take into account thin or thick forest this can range between 3 and 7m<br>\n<br>\n\n<b><u>LINKED SPECIAL PADS (Roof, Canopy, Foliage & Bridge)<\/u><\/b><br>\n<b>Requirements<\/b><br>\nThe following setting: 'settings > general > Numeric Id for special pads only' must be UNCHECKED!.<br>\n<br>\nThe special pads Roof, Canopy and Foliage can be linked. When linked, they are ALL triggered when a token moves onto one of them. They will remain 'triggered' until no token is positioned on any of them.<br>\nTo link 2 or more tokens is very simple. Just add 'Linked n' to the front of the token name. 'n' here is the indentifier for the linked tokens. E.g. 'Linked 1' or 'Linked Forest' can be used as identifier. Just make sure that the entire identifier is ONE word (so no spaces), e.g. 'Linked A Forest' will generate an error.<br>\n<br>\nA special type in de linked tokens are 'bridges'. When a bridge is linked in the set of roofs then the roofs are NOT activated when the token ALSO moves over the bridge token.  <a href = 'http://bit.ly/1f5wn6X'>There is a video tutorial that better shows this.<\/a>\n<br>\n<b>Example:<\/b> lets take a map with the following tokens<br>\n- 'Linked 1 Canopy 1' <br>\n- 'Linked 1 Canopy 2'<br>\n- 'Linked Houses Roof 1'<br>\n- 'Linked Houses Foliage 3'<br>\n- 'Linked Houses Canopy NextToHouse'<br>\n- 'Linked 2 Roof 1' <br>\n- 'Linked 2 Bridge 1'<br>\n\nAfter initialization you will have three linked groups. The 'Linked 1' and 'Linked Houses' group. Now when a token moves over 'Linked 1 Canopy 1' (L1C1) then that image of that pad will be swapped for a tree trunk. At the same time the same will be done for 'Linked 1 Canopy 2' (L1C2). Should you now also move a token on L1C2 and then remove the first token from L1C1, then both pads remain 'activated'. Only after all tokens have moved off both L1C1 and L1C2 will they be de-activated.<br>\nAs you can see from the second linked group 'Linked Houses', you can use ANY identifier you like as long as it does not contain any spaces (' '). <br>\nFinally the Linked 2 group. If you drag a token over Bridge 1 and drop it onto roof 1, then the roof does NOT disappear!. If however you drag a token onto roof 1 WITHOUT moving it first over Bridge 1, then the roof DOES disappear!<br>\n<br>\n\n<b><u>SHADOWPADS <\/u><\/b><br>\n<b>Requirements<\/b><br>\n- Two ShadowPads with the same identifier and one with the ' Ground' suffix and the other with the ' Floor' suffix.<br>\n- Two Reference tokens with equal names and the the suffixes ' Ground and ' Floor'.<br>\nShadow pads link two floors of a building to eachother. When a token moves over a ShadowPad on one floor it will 'cast a shadow' on the ShadowPad on the other floor.<br>\nThe reference tokens are use to align the position of the real and shadow token. The ShadowPads are used to create or remove the shadow tokens. ShadowPads will be activated as soon as one or more tokens are standing on BOTH pads.<br>\nTypically you will put the ShadowPads on the background layer and set the size to freesize then size and place them as you wish. You check off 'visible' so the players won't see the pad.<br>\n<br>\nFor the reference tokens you need to do the following:<br>\n1. create two tokens with the same name where one has the suffix ' Ground' and the other ' Floor'<br>\ne.g. 'Stairs to Ground' and 'Stairs to Floor' or 'Reference Ground' and 'Reference Floor' etc. Only use alphanumerical characters and do NOT use the words 'Floor' or 'Ground' inside the name of the token. So do NOT do e.g.: 'The "Grounds" Ground' 'The "Grounds" Floor'<br>\n2. Make sure that the reference tokens are snapped to grid and medium sized.<br>\n3. Place one of the tokens on the ground floor and one on the first floor. Make sure that their position is aligned e.g. place both in the upper left corner of the room or in the exact centre etc. Just keep in mind that if you e.g. place the real token just below the reference token, that the shadow token will also be just below the (other) reference token.<br>\nYou can place them on any layer (so also the hidden) and you can set them to Visible to players or not.<br>\n4. Then select one of the reference tokens and hit the 'Set Reference' macro. Select the shadow pads to which it should be linked and hit ok.<br>\n<br>\nThe tricky part here is that the shadow pads will check to which reference token the real token is closest to<br>\nand assume it belongs to THAT reference token. So make sure that the real token is always closest to one<br>\nreference token on one of the maps. The safest method is by placing the reference tokens in the centre of both<br>\nmaps.<br>\n<br>\nTo clarify: envision two floors created in maptool adjacent to eachother. So on the left you have the ground <br>\nfloor and on the right you have the first floor. Now place both reference tokens in the upper LEFT corner of<br>\nboth floors. Then place the Player token in the upper RIGHT corner of the GROUND floor (left map). In that case <br>\nthe player token will be closer to the reference token on the FIRST floor (right map). In this case the shadow<br>\npads will thus assume that the player token is on the FIRST floor (e.g. apparently floating outside).<br>\n<br>\n<font color=red><b><u>EVENT BUTTONS<\/u><\/b><br><\/font>\nEvent buttons are tokens that, when selected by a user, activate a macro. Here you can think of simply posting a message in the chat, to moving all user to another map. <br>\n<br>\n<b><u>CREATING EVENT BUTTONS<\/u><\/b><br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group: 'Event Button Macros', containing the code that is activated when the button, e.g. 'Switch To Map' (This is something you will need to do yourself, but I have added two example macro on the lib.)<br>\n2. Select the button (any token on the token layer will do) to which that macro should apply e.g. 'Move to Fair Haven'<br>\n3. Run the macro 'Set Event Button'<br>\n4. Select 'Switch Map' from the list<br>\n5. In the 'Give Arguments' box enter the arguments as a stringproperty, e.g.'toMap=Fair Haven'<br>\n<br>\nHere it is important that both the the arguments name (toMap) and the arguments (Fair Haven)<br>\ncontain ONLY alphanumeric  characters!<br>\nNote that you can give multiple arguments! Just seperate them with a ;.<br>\nE.g. toMap=Fair Haven;message=Going to Fair Haven;<br>\n<br>\n6. Click OK. Now everything is set up<br>\n<br>\nTo use the buttons you need to run the macro 'Activate Switches'. This is used for door switches<br>\nbut it will also work for the Event Buttons. Now when thats done you will notice a pop-up. You can<br>\nmake this pop-up small, but you cannot close it (else the buttons will not work).<br>\n<br>\nIf you now click on the button 'Switch to Fair Haven' the macro 'Switch Map' is activated.<br>\n<br>\n<font color=red><b><u>EVENT PADS<\/u><\/b><br><\/font>\nEvent pads are tokens that, when a user moves a token on/off/over it, it will activate a macro. Typical use for this is a trap.<br>\nThese pads are quite similar to Event Buttons, with the difference that here you need to make a move action to activate the pad instead of simply selecting the button.<br>\n<br>\n<b><u>CREATING EVENT PADS<\/u><\/b><br>\n<br>\n1. Create a macro on the lib:EventMacros token in the group: 'Event Pad Macros', containing the code that is activated when Event is triggered. For example 'Spear Trap<br>\n2. Select an 'Event token'. This is a token which name starts with 'EventPad ' e.g. 'EventPad 1' or 'EventPad Pit Trap'. This token can be placed on any layer<br>\n3. Run the macro 'Set Event Pad'<br>\n4. Pick an Event macro from the list, e.g. 'Standard Pit'.<br>\n5. Then select the events on which this macro is triggered. (they have tooltips)<br>\n7. Click OK. <br>\n8. Run 'Initialize Maps'<br>\nNow everything is set up<br>\n<br>\nTo activate the pad you must move a token e.g. onto the pad. The macro will be activated if one of the selected events is triggered.<br>\n<br>\n<font color=red><b><u>EVENT AREAS<\/u><\/b><br><\/font>\nEvent areas work roughly the same as Event Tokens. Depending on the movement of the token in respect to the area they trigger a macro. This macro can be a trap a pit or difficult terrain. The difference with the event-tokens is:<br>\n- Event tokens can be moved around (on the same map) without the need to reinitialize<br>\n- Event tokens are images and as images can be influenced more easily, e.g the crack that turns into a pit when you walk over it.<br>\n- Event Areas can be ANY size you like (with a resolution of the grid cells), they can also have holes in them, be seperated all over the map, but they still remain ONE area. <br>\n- Event Areas are significantly faster when going for multiple event areas vs event tokens.<br> \n<a href = 'http://bit.ly/YEhS4a'>also see this video tutorial<\/a><br>\n<br>\n<b><u>CREATING EVENT AREAS<\/u><\/b><br>\n<br>\nTo create an event area you need to do the following:<br>\n1. Define the area (the coordinates it covers)<br>\n2. Assign the area (to an event macro like the pit)<br>\n<br>\n<b>Step 1: Define Area<\/b><br>\nWhat needs to be done is to get cell coordinates inside a json array. To do this there are 2 methods: lastPath and getTokens.<br>\n<i>LastPath method<\/i>: Grab any token with an unique name and (literally) drag it over the map to create a path. You can use the space bar to create waypoint. You can have overlapping paths as the coordinate will only be saved once, BUT you need to do it in ONE go. Once you have the path complete you drop the token:<br>\n- start 'Define Token'<br>\n- select the 'last path' method<br>\n- fill in the name of the token and give a name to the area and click ok. <br>\nNow the area is created. This is a pretty simple and easy way to create an area, but you cannot create two seperate parts.<br>\n<br>\n<i>GetTokens method<\/i>: Again grab any token, but this time with a unique state. (It has to be the ONLY token on THAT map with THAT state). Copy paste this token over the areas you wish to define. If you have e.g. 5 pits that all 5 use the same event macro then you can create these 5 pit areas in one go (effectively they are thus ONE Defined area, covering 5 parts of the map). Once done:<br>\n- start 'Define Token'<br>\n- select the 'Use coords...' method<br>\n- fill in the name of the STATE <br>\n- select the LAYER you put those tokens on <br>\n- give a name to the area and click ok. <br>\nNow the area is created. This is a bit more work, but note that you can first copy paste 5 tokens, then select all 5 and start copy-pasting with that group, rinse and repeat and you can build pretty large areas in no time using this method. <br>\n<br>\nNote that there is a 'Reset Show Area Tokens' option at the bottom, I'll get to this later with the 'Show Area' macro.<br>\n<br>\n<b>Step 2: Assign Area<\/b><br>\nRun the Assign Area macro. Per Area that you created there will be an input section, sorted per map. One input section contains a dropdown box with ALL the macro on the lib:EventMacros, so you will also find e.g. onCampaignLoad, which is not very useful to link. Pick the macro from the list that you created for that area and then select the triggers that actually trigger the macro to be run. Note that all 6 triggers are mutually exclusive (you can NEVER trigger 2 of them in one move). Click ok and you're golden. <br>\n<b>Important Note<\/b> that in order to 'redefine' an area its very useful if the AreaToken has a unique State set to it on the BASE map! For the example campaign I've given it the state 'Special Area'.<br> \n<br>\n<b>Step 3: Show Area (optional)<\/b><br>\nThis will fill the defined area with the overlay tokens which should be located on the BASE map. This servers two purposes.<br>\n1. You can quickly show an overlay using one of the overlay tokens. You can choose e.g. the hidden layer to show it to GM(s) only, or background layer to show to all<br>\n2. If you pick the <i>Area Marker<\/i> token as overlay (if it exists it will be the default choice) then you can rearrange the area (delete, add, move overlay tokens) and then redefine the area.(define and use the same name, this will overwrite the old one). <br>\nAdditionaly this macro can be used to delete areas from the map. Simply check the areas you wish to have removed, check the 'delete' checkbox and click ok.<br>\nMore info about this macro you can find in the tooltips when you run this macro. <br>\n<br>\n<b><u>SPECIAL EVENT AREA: <i>Limit Movement<\/i><\/u><\/b><br>\nWhen assigning and Area to an even macro, there is one macro 'Limit Movement' that differs from the rest. If you Assign the area to THAT macro then it will be run BEFORE ALL THE OTHER CHECKS. The reason is that IF you work with limited movement e.g. 10 steps AND someone walks over difficult terrain (double move cost), but does not realise it and moves her token with 10 steps (actually 20) straight onto a teleport or a trap. Then you would FIRST like to check whether the token could have reached that and THEN trigger that pad. You could probly use it for other ends as well, but this is what its intended for. \nBecause every system is unique, the current macro show you how it works when you move around, you need to adjust the macro to fit your needs. \nNote that the 'Limit Movement' is turned OFF per default in the settings. By setting the value to any numeric value other then 0 you will turn it on. <br>\n<br>\n<font color=red><b><u>ANIMATED DOORS, DOOR SWITCHES AND VBL AUTOMATION<\/u><\/b><br><\/font>\n<b>Parameters<\/b><br>\nTo make use of this functionality you need to create special 'door' tokens, with the following parameters.<br>\n- For rotating doors the length of these tokens needs to be twice the length of the door (for sliding doors this is not necessary). The width is irrelevant. Select a couple of doors in the campaign file to get an idea. <br>\n- The name of the token needs to start with 'Door ' followed by an identifier, usually a number, but can also be a string. <br>\n- In case of a double door, there needs to be a mirrored copy of the 'main' door with the same name ending with 'a'. E.g. if the main door is 'Door 5' then the mirrored copy must be called 'Door 5a'. You only need to setup the main copy.<br>\n- When using the animation feature (that is you've set a timer) make sure that 'snap to grid' is turned off for the door token. <br>\n<br>\nNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>\n<br>\n<b>Setup<\/b><br>\nTo create a single animated door you simply need to select the door and click 'Set Door' and enter the parameters for that door:<br>\n<u>angle closed door<\/u>: When you set the door for the first time, the current angle of the door is automatically picked. Its thus best to put the door in the closed position and then run the setup. If you copy paste a door that has already been set, the set value will be taken. To reset it, make sure this field is empty, click save and run setup again. You will now get the current angle of the door.<br>\n<u>degrees open door<\/u>: The is the amount of degrees the door turns when you open it. Half open would be 45, open would be 90 and wide open is 160 (default)<br>\n<u>open clockwise<\/u>: The way the door turns<br>\n<u>double door<\/u>: If there is another door with the same name as the door you set, but with 'a' at the end (e.g. 'Door 5a') then you can check this. When you open the door, then 'Door 5a' will also open in a mirrored direction<br>\n<u>Description<\/u>: This text will appear in the 'toggle doors' macro<br>\n<u>time (ms)<\/u>: The amount of time it takes for the door to open. 1000 = 1 second. The default is 2000 (2 seconds). If you set the time to 0 then a seperate routine is run instead which simply changes the angle of the door WITHOUT any animation<br>\n<u>Switch<\/u>: When you check this then a Switch Token will appear close to the door, when you click on this token the door will automatically open/close. You can change the image if you like, resize it, move it and even copy paste it if you want multiple switches that correspond with that door (e.g. one on each side). Do keep the switch on the TOKEN layer though (else you can't select it)<br>\n<u>Locked<\/u>: (works only icw Switches) This will set a 'Locked' State on the door. When a player clicks on the switch a message will be send to the chat explaining that the door is locked. To unlock the door simply remove the state (or run 'set door' once again and decheck 'locked')<br>\n<u>Proximity<\/u>: This will check the proximity of player owned tokens close to the switch. The proximity is counted in number of cells. If no player owned tokens are close enough, the door won't open. You can set this to '0' to turn this off. GM's won't be checked, so they can always open the door.<br>\n<br>\n<b>Setup VBL Options (Vision Blocking Layer)<\/b><br>\nThis TAB is only available if you check 'VBL support' in the general settings. And you should only check that if you have a MT version that supports VBL macro's<br>\n<u>Use VBL for door<\/u>: this is the overall setting if you turn this on then toggling the door will also change the VBL of the door. Uncheck will NOT do ANY VBL operations<br>\n<u>Peek ... and Open...<\/u>: when you check none of these options but you have checked the use VBL on doors then toggling the door will default to open the door fully AND do the VBL operation. If you check one of the boxes then it will ALWAYS default to that operation, if you check more then one, you will get a pop-up request when you toggle the door, asking you which of the options you wish to execute. <br>\n<br>\n<b>Note<\/b>: When you have set the door, the name of the door will appear in the GM Notes. So when the door is on the object layer and you click on it while on the token layer, the name of the door will appear!<br>\n<br>\n<b>Rules for Door Image when using VBL !!<\/b><br>\nWhen using VBL the image of the door has to comply to 3 rules!<br>\n1. The ORIGINAL image (so when viewing it in e.g. an image editor and NOT in maptools) has to have the HINGES LEFT and the DOOR KNOB RIGHT<br>\n2. The LENGTH of the entire image has to be TWICE the size of the picture of the door. So when the door covers 1 square, the entire image covers 2 squares. The empty space has to be on the hinges side. So: |o---^-| (where 'o' is the hinge, '^' is the door knob and '|' are the image boundaries.) Check out the VBL map in the BoT campaign file to see what I mean. <br>\n3. If you don't use VBL your door can cover any amount of squares. However the current VBL ONLY works for 1 square door images (thus 2 square image when taking rule 2 into account)<br>\n<br>\n<b>Operating doors<\/b><br>\nThere are several ways to operate a door:<br>\n1. Select the door and run the 'Toggle Door' macro from the campaign panel.<br>\n2. Impersonate the door and enter '[ r:toggleDoor()]' in the chat<br>\n3. Enter '[ r:toggleDoor(5)]' in the chat to operate 'Door 5'<br>\n4. Create a macro on the campaign panel with: '[ r:toggleDoor(5)]' to specifically operate 'Door 5' with a one click button<br>\n5. Run 'Toggle Door<b>s<\/b>' macro from the campaign panel, this will give you a list of doors that have been set up AND are on the OBJECT layer. The ones you select will be animated.<br>\n6. Use a Switch (see above on how to add one). To operate a switch, you must make certain that you have the 'Switch Frame' active! Click on 'Activate Switches' on the campaign panel or the BoT macro panel.<br>\n<br>\n\n<font color=red><b><u>UTILITY MACROS<\/u><\/b><br><\/font>\n<br>\n<b><u>ANIMATE MOVEMENT<\/u><\/b><br>\nWith this function you can choose to use the input panel by selecting a token and clicking 'Animate Move' in the 'Animation' window. However this is a bit cumbersome for e.g. casting a fireball. The 'better' way is by calling the macro directly:<br>\n<br>\n<b>bot_animateToken<\/b><i>(tokenID [,x,y,relative,onImpact(-1:bounce; 0=continue; 1=stop),layer(json.object),vbl(1; 0),delay(ms)])<br><\/i>\n<br>\nIf you give at least the token Id and the x and y coordinates then this function will run automatically with the following 'default' settings: relative=0, onImpact=0, layer='[]', vbl=0, delay=0.<br>\n<br>\n<u>What do these settings mean:<\/u><br>\n<b>- X (#cells)<\/b>: The destination X coord of the token, either absolute or relative to its current position<br>\n<b>- Y (#cells)<\/b>: Dito X, but then Y<br>\n<b>- Delay (ms)<\/b>: The delay per movement made, this is in ms so a value of 1000 means wait 1 second before you move the token again.<br>\n<b>- Relative (1/0)<\/b>: Unchecked: the actual map coordinates are taken for the x and y values and the token is moved to those coordinates. Checked: the relative position of the token is taken and the token is moved x steps in the X direction and y steps in the Y direction. E.g. Relative 3,2 will move the token 3 cells to the right and 2 down<br>\n<b>- onImpact - Bounce (-1)<\/b>: if the token encounters an obstacle it will change its course depending on the angle of impact. Note that there are only 3 trajectories supported: invert X, invert Y and invert Both. An 'obstacle' is defined by the below settings. <br>\n<b>- onImpact - Continue (0)<\/b>: the token is moved to its destination no matter what<br>\n<b>- onImpact - Stop (1)<\/b>: the animation stop as soon as it meets an obstacle<br>\n<b>- Token (and the other) layer(s)<\/b>: 'The 'checked' layers will be searched for obstacles' where the token can run into while its moving<br>\n<b>- Vision Blocking Layer<\/b>: This will take the vision blocking layer into account as well for possible impact. Note however that this works on sight of the token, so if the token has no sight EVERYTING is blocked vision and it will thus not move (it might move backwards a bit due to the code). This also accounts for hardfog, no light, etc. <br>\n<br>\nNote that if you have a Server - Client running, that the server must have <b><i>Strict Token Ownership<\/i><\/b> turned <b>ON<\/b>. If its turned off, then the players clients will see the 'ghosting' effect as well (because this trick makes use of the 'visible to owners only' setting, but if there is no 'strict ownership', everyone is the owner and thus everyone will see the copies as well.). In this case its better to turn off <i>Run animation per client<\/i> off in the settings. Also if you have two instances running on one pc (e.g. for laptop-beamer setup) it might be better to turn this setting off.<br>\n<br>\n<b><u>ANIMATED TEXT<\/u><\/b><br>\nThese are two feature: one is a macro that you can call and use in your own FW or even in the chat: animateText (text[, title, position, html-header, width, height, delay, upper]). The input box can be found in the 'Bag of Tricks macro panel'. When the text animation is activated a frame will pop-up on every attached client pc printing the text. <br>\n<b>- text<\/b>: The text you enter here will be animated in a frame<br>\n<b>- title<\/b>: The title of the frame<br>\n<b>- position<\/b>: The animated will start at the character number you enter here, e.g. 10 means that the first 10 character won't be animated<br>\n<b>- html-header<\/b>: Here you can set some basic make up for the frame itself. If you enter 'Default' it will show a black-green frame with courier font<br>\n<b>- width & height<\/b>: The dimensions of the Frame<br>\n<b>- delay<\/b>: Amount of delay per character printed in ms.<br>\n<b>- upper<\/b>: Print the animated text in UPPER CASE<br>\n<br>\n<b><u>BENCHMARK<\/u><\/b><br>\nThis tool is specifically developed for Maptool macro developers and can be used to test the execution time of several different macro to see which method is the fastests<br>\nSimply create one or more macro in the group 'Benchmark Macros' on lib:EventMacros (there has to be one empty macro called 'Default' in that group as well.). Then hit the Benchmark button on the menu. A form pops-up asking you the amount of iterations including an indication of how long each iteration set roughly takes. <br>\nE.g. 100 (~2 seconds) means that each macro will run 100 times and then the total time is divided by 100 and the time it takes to run Default is deducted from that result. The resulting time is thus the execution time it takes to run that macro one time. <br>\nWhen more then 1 macro is tested, then a comparison result is given with a normalization overview with the fastest as base. This means that if e.g. macro1 takes 2 seconds and macro2 takes 4 seconds that the normalization will show that macro2 takes 2x as much time as to run macro1.<br>\nNote that macro in the 'Benchmark Macros' group which name starts with '@' will be skipped by the benchmark test. This way you can swiftly turn off certain macros for non-testing.<br>\n<br>\n\n<b><u>EMBARKATION (VEHICLES)<\/u><\/b><br>\nThere are two embarkation macros in the menu. Embarkation (in Setup) and Toggle Embark (in Utility). To use these macros a token named VPCU is required on the map where you use these macros.<br>\nThe workings are simple: select a Token (any token) that act as <i>container<\/i> (typically a vehicle like a car). Then click on <i>Embarkation<\/i> a menu will pop-up where you can pick tokens, surrounding the container token. The tokens you select will embark on the container (vehicle).<br>\nThis effectively means that they are moved onto the VPCU token.<br>\nNow you can move the container/vehicle around over the map and at any time you wish to disembark, you can click on <i>Toggle Embark<\/i> in the Utility Menu. This will swiftly place the tokens around the container. Clicking the toggle again, will move the tokens back to the VPCU.<br>\nThus Embarking/Disembarking is done with the toggle button. Changing tokens that are linked to the container is done with the Embarkation macro. Note that thus the Embarkation macro can also be used to embark/disembark tokens (but is a bit of a hassle). <br>\n<br>\n\n<b><u>FORCE SELECTION<\/u><\/b><br>\n(This is an alternative to the full screen toggle but much more demanding. Force selection and Toggle Full Screen mode are NOT related)\nThis is a very specific add-on that most of you likely won't be using, but it can be quite useful. You can run two instances of MT on your pc, connected and both set to gm. When you combine this with 'Always on Top' (a free aplplication with which you can force windows application to remain always 'on top' even if another window is active. This way you can have e.g. your campaign macros and chat window visible while using the full screen modus. The issue however is is that if you use macro's that are set for 'apply to selected token', that the token you happen to have selected on you 'full screen' client (Master), is not necessary selected on your 'show chat and campaign button' client (Slave). Specifically for this reason I've created an extra option into the Bag of Tricks. IF you login to the Master with a slave that has the gm-name <b>forceButtons<\/b> (the Slave must also be GM !!) then when you select a token on the Master it will also be automatically selected on the Slave. This way you ensure that the macros always work as intended. To activate the 'syncing' you will need to first run the <b>Activate Switches<\/b> macro. To summarize:<br>\n- Start GM server (Master)<br>\n- Start another instance of MT and login to the GM Server with username: forceButtons (Slave)<br>\n- on the Master run 'activate switches', a frame should appear, this is used for the onTokenSelectionEvent<br>\n- Start 'Always on Top' (google it and download it)<br>\n- Undock the panels from the slave that you wish to use, including the 'toolbar' <br>\n- Make the Slave map window very small (don't minimize)<br>\n- Lock the Slave's toolbar so its always on top<br>\n- Switch to the Master and set it to full screen. <br>\n- IF you did everything alright then the toolbar should remain on top, when you select that then the undocked windows like campaign and chat will pop up over the full screen map. <br>\n- When you select a token on the Master, it should now also be selected on the Slave. <br>\n<br>\n<b><u>GROUP MOVE & GROUP SELECT<\/u><\/b><br>\nThese are two distinct functions that have nothing to do with eachother. 'Group Move' will move the entire group when one token of that group is moved. 'Group Select' will select all the other tokens of the group when one token is selected. 'Group Move' is useful for e.g. battles with grouped units. 'Group Move' has for this reason also several formation and rotation buttons. These will NOT work for 'Group Select' groups. 'Group Select' is useful when creating maps and you want to group several tokens into one selectable object. <br>\nBoth grouping methods work as follows: select a group of tokens and click on the 'Group (...)' macro. In addition for the 'Group Move' you are asked to enter a name for the group. Don't use any funky characters for the group name like: ,; . 'space' etc. It might break. Another additional option for 'Group Move' will become available if you turn on 'Show group panel on select' in the bot-settings: when you have the 'activate switch' panel turned on (see 'token buttons') then every time you select a token of a 'move group' the 'group macro panel' will pop up, giving you the extra options like rotate clockwise, counterclockwise (both in steps of Free, 45 or 90, see below), spread and contract. To clear a group, simply select one or all the tokens and click 'clear group'.<br>\n<br>\n\n<b><u>INVISIBILITY<\/u><\/b><br>\nThese functions can be turned off or on the in the settings-->toggle tab. It uses <i>visible to owner only (VTOO) function<\/i>. When a token is set to invisible the VTOO is (automatically) turned on. Any token that has <i>See invisibility<\/i> turned on will be added as owner to the invisible token when the invisible token is in range. Any token that has <i>Purge invisibility<\/i> turned on will turn off the VTOO setting as long as its in range. Any token that has <i>Annul invisibility<\/i> turned on will terminate the invisibility permanently (until turned on again) for any token in range. Here the full workings of the required functions and what needs to be done:<br>\nSETTINGS:<br>\nIn the settings under the toggle tab you can find:<br>\n<b>Invisibility<\/b>: check this to make use of this functionality<br>\n<b>Invisibility State<\/b>: you can create any state you like for tokens that are invisible, HOW you name the state e.g. <i>invisible<\/i> is what you need to enter here.<br>\n<b>Purge State<\/b>: you can create any state you like for tokens that can purge invisibility, HOW you name the state e.g. <i>purge_invisible<\/i> is what you need to enter here.<br>\n<b>Annul State<\/b>: you can create any state you like for tokens that can annul invisibility, HOW you name the state e.g. <i>annul_invisible<\/i> is what you need to enter here.<br>\nTo make use of these function you can either run the bot macros directly or implement their corresponding functions in your own macro. They all DO need to be called for their appropriate function\n<table border=1><tr>\n<td><b>Campaign Panel Macro<\/b><\/td><td><b>function<\/b><\/td><td><b>Description<\/b><\/td><\/tr><tr>\n<td>Start Invisibility<\/td><td>\t\t[h:bot_startInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> invisibility.\t\tEffect: tokens get a state and VTOO is turned on.<\/td><\/tr><tr>\n<td>End Invisibility<\/td><td>\t\t[h:bot_endInvisibility([tokenList])]<\/td><td>\t\tturn <b>off<\/b> invisibility.\t\tEffect: state is removed and VTOO is turned off.<\/td><\/tr><tr>\n<td>See Invisibility<\/td><td>\t\t[h:bot_seeInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> see invisibility. \tEffect: tokens get a state. Ownership will be added to all invisible_state tokens in range.\tRequired property: w42.seeInvisRange. \t<\/td><\/tr><tr>\n<td>Saw Invisibility<\/td><td>\t\t[h:bot_sawInvisibility([tokenList])]<\/td><td>\t\tturn <b>off<\/b> see invisibility .\tEffect: state and ownerships are removed.<\/td><\/tr><tr>\n<td>Purge Invisibility<\/td><td>\t\t[h:bot_purgeInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> purge invisibility .\tEffect: tokens get a state and VTOO is turned off for all invisible_state tokens in range.\tRequired property: w42.purgeInvisRange.\t<\/td><\/tr><tr>\n<td>Purged Invisibility<\/td><td>\t[h:bot_purgedInvisibility([tokenList])]<\/td><td>\tturn <b>off<\/b> purge invisibility. Effect: states are removed, VTOO is turned back on for all invisible_state tokens in range (IF they are not purged by another token!).<\/td><\/tr><tr>\n<td>Anul Invisibility<\/td><td>\t\t[h:bot_anulInvisibility([tokenList])]<\/td><td>\t\tturn <b>on<\/b> anul invisibility. \tEffect: tokens get a state. Visibility is ended for all tokens in range.\t\t\t\t\tRequired property: w42.annulInvisRange.\t<\/td><\/tr><tr>\n<td>Annuled Invisibility<\/td><td>\t[h:bot_annuledInvisibility([tokenList])]<\/td><td>\tturn <b>off<\/b> anul invisibility.\tEffect: states are removed. <\/td><\/tr><tr>\n<td colspan=3>These functions you call to turn the specific functionality on or off. By default it applies to the selected token(s), optionally you can give a list of token as argument. When you run the macro from the campaign panel it will run for all selected tokens. All detection macros (see/purge/annul) require a <i>Range<\/i> property. If the property is not set (or not numerical) the the <i>turn on<\/i> macros will show an input pop-up asking for these values. The values entered need to be numerical (e.g. 30).<\/td><\/tr>\n<\/table>\nOther properties that will be created on the tokens when these functions are used are:\nw42.originalOwners: this will store the current owners before any (purge invisibility) owners are added. When invisibility is ended, the original owners will be restored.<br>\nw42.purgeDistance: here the purge invisibility range will be stored.<br>\nw42.inPurgeRange: here all tokens will be stored that are invisible AND within the tokens purge invisibility range.<br>\nw42.purgedBy: here all tokens will be stored that have purge invisibility AND are in range of your token.<br>\n<br>\n<b><u>NILDIKS' ROOM DESCRIPTION MACRO<\/b><\/u>:  <img src='\"+bookImg+\"' alt='Nildiks Room Description'><br>\nThis macro (that has the image of a book) can be used with Nildiks' Room Description Tokens. A 'Description Token' can litterally be ANY token. Although for the sake of recognition its best to use a recognizable image, e.g.: <img src='\"+pointerImg+\"-20' alt='Room Description Token'><br>\nIts purpose is simple: it gives a description of the room, area or encounter.<br>\nTo set up such a 'room description token' do the following:<br>\n1. write everything important of your room, area or encounter in a <u>GM notes<\/u> of a token.<br>\n2. you can enclose text between <share>...</share>. Later, you will be able to share this text to your players<br>\n3. you can enclose a image url or a asset image between <image>...</image>. Later, you will be able to share this image to your players.<br>\n3. you can allways share the images of portrait and handout of this token (these will show up at the top of the location information panel)<br>\n4. you can use html tags to format your text. For example <b>...</b> to use bold or <h1>...</h1> to write titles<br>\n<br>\nWhen the 'Room description token' has all the information, select it, and press the macro button with the picture of an open book. A new frame will be open with all this information nicely presented, formatted and with images and macrolink to share images and text with your players whenever needed.<br>\nIf you share an image to your players, they will be able to zoom in and out on the image.<br>\nYou can create an info token for every room, area or encounter that you have in your map.<br>\n<br>\nOn the 'Example Map of Special Pads' you can find this token: <img src='\"+pointerImg+\"-20' alt='Room Description Token'>.This token is an example of an info token of a dungeon room. You can double click on it to see its notes. You can select it and run the macro to see the description<br>\n<br>\n<b><u>RENUMBER TOKENS<\/u><\/b><br>\nSlightly obsolete macro, this renumbers all the tokens with the same name so there are NO double names and NO gaps in the counting. <br>\n<br>\n<b>ROTATING GROUPS (Group Move only):<\/b>\nGroups can be rotated by selecting one token of the group and then click CW (Clockwise) or CCW (Counter clockwise) after which the group will be rotated. <br>\nThe rotation process knows three different methods:<br>\n- snapped to grid: group will be rotated in increments of 90 degrees<br>\n- unsnapped to grid: group will be rotated in increments of 45 degrees<br>\n- use facing of token (unsnapped only!): when the selected token has a facing set the rest of the tokens will be rotated around that token along the facing angle. This effectively will allow free rotation of the group. <br>\n<br>\nSome notes:<br>\n- This macro makes use of the label field of the token and any current value will get overwritten!!. Changing this value after a group has been set will de-activate group- movement when you move THAT token. The token will still be part of the group and will be moved if another token of the group is moved<br>\n- When you set a group with tokens that already belong to another group, then that ENTIRE other group will be cleared!!. <br>\n- The onTokenMove pads like teleports, events, canopy, etc. will ONLY work for the token that you actually move. <br>\n- Group move will ONLY work when you move ONE token. <br>\n- You can temporarily turn off group movement by togglinh the 'Turn On Token Move Event Macor On/Off'<br>\n- When using the tokenfacing rotation method; the resolution isn't infinite which will result in the tokens formation to become slighly irregular when a lot of this type of rotation is used. Also the CW and CCW buttons will have the same result as the tokens are rotated according to the set facing and not anymore CW or CCW<br>\n- <b>The formation macros (rotate, square, wedge etc.) will also work if you select more then one token which do not belong to a group.<\/b><br>\n<br>\n<b><u>SET VBL STAMP<\/u><\/b><br>\nWith this function you can apply a Vision Blocking Layer (VBL) stamp upon a token. With this stamp you can move, rotate and copy the token and the applied VBL will 'move' with the token. Note that one of the options is 'Current VBL' that means that ALL VBL that is ON the token (so not outside of it) will be stored on the token and set as the VBL 'stamp'. There however a few tricky things which Ill explain here:<br>\n<u>Core thing to know:<\/u> The stamp function fully relies on the onTokenMove event! And that event is ONLY triggered on the TOKEN layer. Also the save VBL function is NOT 100% perfect. A mathematical model will be made of the VBL which most likely will be slightly different then what you applied. <br>\n<br>\nSo what does this mean...:<br>\n1. This 'stamp' function ONLY WORKS ON THE TOKEN LAYER. If you thus want to use if for buildings, do all that what you want to do on the token layer and then when finished, send the token to the background layer.<br>\n2. The first time you store custom VBL on a token, move the token outside the VBL area. Then switch to VBL modus and you'll notice that the 'former' vbl is still there. You can leave or remove that VBL. When I created the code I chose to not remove the former VBL automatically for complex reasons I'm not gonna explain here. After this the VBL will move with your token AND it will remove the VBL where it was. <br>\n3. If you rotate a VBL stamped token, the VBL will rotate AFTER you have moved it a bit. Wiggling the token a bit is enough (to trigger onTokenMove event). <br>\n4a. If you move the VBL stamped token on top of an existing VBL layer: the VBL stamp will be applied on top of the existing VBL.<br>\n4b. If you then move that token outside of the VBL area, the former VBL will be restored!!<br>\nHOWEVER: same rule as above applies: it won't be 100% perfect!<br>\n5. Copy pasting will make the function cry a bit as it gets confused by formerly stored VBL, so things will go a bit weird when you do this. Here a breakdown:<br>\n5a. Make sure that you operate in a VBL free environment (so that you don't accidentily use of overwrite background VBL)<br>\n5b. Create and apply VBL stamp to token as explained<br>\n5c. Copy the token and paste it somewhere away from the original<br>\n5d. Move the copy, again make sure that you move it OUTSIDE the original position. You will notice 2 things: 1. the VBL will be applied to the copy; 2. the VBL will be removed from the original. <br>\n5e. Move the original to restore the VBL. <br>\nRinse and repeat. <br>\n6. When using lots of stamps and you move these around in a complex VBL environment its possible that pieces of VBL are left behind. Theres not much I can do about this as its a limitation of the 'not a 100% perfect copy of the original VBL'. Just keep an eye out for it!\n<br><br>\n<b><u>SCATTER<\/u><\/b><br>\nThis macro was originally created by Craig (one of the MT ancients) and is further developed by me. <br>\nWith this macro you can scatter a couple of tokens within a predefined area. E.g. a token of a tree, scattered 100x in an area of 100x100 cells. <br>\nTo use the scatter macro, just select a couple of tokens you wish to scatter, run the macro, set the parameters and hit the ok button. After a couple of seconds youll find the token scattered over the pre-defined area<br>\n<br><b>Parameters<\/b><br>\n<b>- 'Select a token or object': <\/b>On the map on any layer you can select a number of token  <br>\n<b>- Number of Copies:\t<\/b> The total number of copies of the selected token copied into the designated area<br>\n<b>- Distance (N,W,S,E): <\/b>The distance in cells counting from the selected token (if you have mult. tokens selected, the cells are counted from that each seperate token. So if you have e.g. a Tree and a Bush token selected and north: 100. Then trees are copied upto 100 cells north from the original Tree token and bush tokens are copied upto 100 cells north from the Bush token<br>\n<b>- Spreading:\t\t\t<\/b> The minimal distance between two tokens within the designated area within the designated layer. 0 = No spreading. How does it work exactly: When you set this value to 1 or higher, all the Id's of the tokens that are copied are stored into a list. Then randomly one is picked from that list (lets call it token X. From token X ANY token on the DESIGNATED LAYER withing 'SPREAD' RANGE WILL BE DELETED. The deleted tokens and token X is then removed from the list and another token is randomly selected from the list until the list is empty. Thus: if there are already tokens within the designated area and you don't want them deleted, make sure that the DESIGNATED LAYER is an empty layer (e.g. Hidden). When done you can select all the tokens on the Hidden layer (from the explorer panel) and move them with one click to the layer where you want them.<br>\n<b>- Rotation:\t\t\t<\/b>Here you can choose different rotation settings, depending   <br>\n<b>- Range of Size:\t\t<\/b>If the original tokens are of Medium size then a size range of e.g. 2 will randomly copy new tokens from 2 sizes smaller upto 2 sizes bigger. If you want to work with free size, then select e.g. 5 similar tokens of different sizes and set the 'Range of size' to 'keep original size'<br>\n<b>- Layer:\t\t\t\t<\/b>The designated layer where upon the tokens are copied.<br>\n<b>NOTE:<\/b> When SPREAD is used, the 'weeding' of trees closer in distance then the spread value is done by a defered macro call. This means that you can interact with the map while the process runs. In this case wait for the 'Spread Calculations Done' message. DO NOT CHANGE MAPS (or your pc might explode) also refrain from adding or removing any token from that map until then.<br>\n<i>When multiple tokens are selected:<\/i><br>\n<b>- Number of Tokens (of each / Randomly selected: <\/b>If you select e.g. 2 tokens e.g. a Tree and a Bush and number of copies is set to 10: then 'each' = 10 copies of the Tree and 10 copies of Bush. 'Randomly Selected' = A total of 10 copies randomly selected from the tree and bush, e.g. 3 Trees and 7 Bushes. <br> \n<br>\n<b><u>SEEK TOKEN<\/u><\/b><br>\nSimply enter the first part of the name of a token that you seek and ALL maps will be checked and if the string matches then the token name will be listed for that map. It will also list all the lib:tokens!!<br>\n<br>\n<b><u>SET TOKEN SIZE<\/u><\/b><br>\nThis macro you will need if you want to use alt.init token (so you have > 100 special pads on one map) AND some of these pads are free size. For alt init map to work it needs to know the size of a token, and this is indeterminable when using free size tokens. With this macro you can select all tokens of the same size and set their size in one go.<br>\n<br>\n<b><u>SUMMON TOKEN(S)<\/u><\/b><br>\nThis macro summons a token onto a selected token. For this macro to work you will need to select a token first.<br>\nWhen you start using this macro, make sure you have set it up correctly in the settings. It wil show 5 types of Drop down boxes (DDB): NPC, PC, (N)PC, Property Type and Special. <br>\n- <b>(N)PC<\/b> These three will show (N)PCs, however you need to set the Property types for PCs and NPCs first in the settings<br>\n- <b>Property Type<\/b> For every property type that you list in the settings one DDB will be shown.<br>\n- <b>Special<\/b> Here you can simply give a list of token names that will show up in the last DDB<br><br>\n\n<b><u>SWITCH MAP & centreOnMePad<\/u><\/b><br>\nThis macro shows a list of ALL maps (including hidden). The map you choose will force ALL clients to that map and centre the view on the 'centreOnMePad' if its there. <br>\nAdditionally if you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i> then these will show up as locations<br>\nin this macro (after a 'rescan').<br>\nIn order to rescan: check the checkbox after 're-scan this map' and click ok.<br>\n\n<br>\n<b><u>TABLES<\/u><\/b><br>\nThese utilities consits out of several macros:<br>\n<br>\n<u>In the macro menu:<\/u><br>\n- <b>Create Table<\/b>: this macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns.<br>\n- <b>Show Table<\/b>: this macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values. When you create a table using the above function, you can about feed it anything you like. However when you starte editing it you can no longer use quotes neither single (will be removed) nor double (render an error)<br>\n- <b>Delete Table<\/b>: this macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros<br>\n<br>\n<u>Script/Code functions (these only work for the 'Bag of Tricks' Tables, stored on lib:EventMacros, i.o.w. created by using the above macros):<\/u><br>\n- <b>bot_table()<\/b>: with this function you can retrieve a value from the stored BoT Tables.<br>Usage: bot_table('name of table', optional: 'column', 'row'). Here 'row' can either be an index number or the actual name of the row. Column must always refer to the column name. Leaving them empty will result in a random choice for row and the 1st column for column.<br>\n- <b>bot_listBoTtables()<\/b>: returns a list with the stored BoT Tables.<br>\n- <b>bot_listMTtables()<\/b>: returns a list with the stored Maptool Tables.<br>\n- <b>bot_getRows('table name')<\/b>: returns the row names of the given BoT table<br>\n- <b>bot_getColumns('table name')<\/b>: returns the column names of the given BoT table<br>\n<br>\n<u>In addition the following functions have been added, originally created by Craig, updated by LMarkus001 and slightly tinkered by me.<\/u><br>\n- <b>json.path()<\/b>: returns the nested keys from a json object<br>\n- <b>json.pget()<\/b>: returns the requested value. Usage: json.pget(jsonObject, 'key1/key2/etc')<br>\n- <b>json.pset()<\/b>: sets a value for the given key. Usage: json.pset(jsonObject, 'key1/key2/etc', value)<br>\n<br>\n<b><u>TOGGLE FULL SCREEN MODE<\/u><\/b><br>\nCurrently this mode needs to be toggled (Shortcut key is F2) as there is no way to check whether you are in Full Screen or not (in the next MT build this should be solved). How it works is simple: if you are in full screen (ctrl+alt+enter) you can press F2 to toggle to full screen mode. The BoT menu will also pop in screen. All the relevant screens will show up in dialog, even the last chat message IF you make use of the message function implemented in this FW. To do that you will need to check the 'redefine broadcast' setting in the settings. This results in the broadcast function not only porting to chat but also to a chat dialog. In that case you will always see the last broadcasted message in full screen.<br>\nOne remark: when you click somewhere on the MT map then the dialogs will 'dissapear' (as they are moved to the background). To get them back use alt+tab. <br>\n<br>\n\n<font color=red><b><u>SETTINGS<\/u><\/b><br><\/font>\n<br>\n<b><u>TOGGLES<\/u><\/b><br>\nIn the toggles you can turn certain ontokenmove related features on or off. Turning them on will generally result in (slightly) reduced response time when moving a token.<br>\nAll these settings contain tooltips explaining you what to do<br>\n<br>\n<b><u>VISION BLOCKING TOKEN STAMPS (VBL Stamps)<\/u><\/b><br>\nIn the general settings, after you turn on VBL support you will find in the 'Toggles' tab a 'VBL Stamps' setting. If you check this then ANY token with the LABEL: <i>VBLStamp<\/i> will get a VBL cross drawn over it when you move the token. This VBL cross will move along with the token. <br>\n<br>\n<b><u>GENERAL EVENTS<\/u><\/b><br>\nIn the settings you will find a new tab with a list of events to which you can link your own events. E.g. if you wish to post a message to the screen every time someone teleports saying from where and to where they are teleported: this is the place to do this. <br>\nTo make this work you first need to create an event macro on lib:EventMacro in the group 'Event List Macros'. This can be as simple as a chat message saying: 'You are being teleported'. <br>\nOnce you have created this event you will find it back in the dropdownlists you see in the tab 'General Events'. Simply pick the one at the event and you're done!<br>\n<br>\n<b>Event List Macros<\/b><br>\nWhen creating an event list macro please limit the characters you use in the name of the macro to alphanumeric characters ONLY!!! <br>\n<br>\nFor the onTokenMove and onMultipleTokensMove (both before and after) there is one arguments available, which you can call with: [h:arg(0)]. Depending on which event this will return the following:<br>\n- For onTokenMove both before and after: The token name<br>\n- For onMultipleTokensMove BEFORE: list of moved token ID's. This linked macro will run ONCE<br>\n- For onMultipleTokensMove AFTER: NAME of current token. This linked macro will run FOR EVERY TOKEN INDIVIDUALLY!<br>\n<br>\nFor the teleports there are also a bunch of useful variables locally available. To acces these you need to start your macro with: [h:varsFromStrProp(arg(0))]<br>\nDepending on the even type the following variables will be defined locally:<br>\n<b>teleport<\/b>: tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY<br>\n<b>inter map teleport<\/b>: tok, padName, CurrentX, CurrentY, NewX, NewY, oldMap, newMap<br>\n<b>where:<\/b><br>\n<u>tok<\/u>: The name of the token<br>\n<u>padName<\/u>: Then name of the pad you are teleported from (in case of inter map transport that is also the name of the Pad you are transporte to)<br>\n<u>teleportEndName<\/u>: The name of the pad you are transported to (local map only)<br>\n<u>CurrentX/Y<\/u>: X/Y coord of where the token is transported from<br>\n<u>NewX/Y<\/u>: X/Y coord of where the token is transported to<br>\n<u>oldMap<\/u>: Name of map of where the token is transported from<br>\n<u>newMap<\/u>: Name of map of where the token is transported to<br>\n<br>\n<b>Example Event List Macro:<\/b><br>\n[h:varsFromStrProp(arg(0))]<br>\n[h:bot_animateText(tok+' is being teleported from '+oldMap+' to '+newMap,'Inter map teleport', 0,'default','300','50')]\n\n\"]\n\n\n[h:bot_manFunctionsTxt()]\n\n[h:bot_videoTutorials()]\n\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Manual\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Manual\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "44688b52-3dc4-4029-ad3e-a54bb634952c",
          "commandChecksum": "52a62294b936a28c7c728f54ebda49fa",
          "propsChecksum": "ea119d4d1253e6c1ee25a1d2adca5d58"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "UNDER CONSTRUCTION",
        "includeLabel": false,
        "sortBy": "UNDER CONSTRUCTION",
        "index": 418,
        "label": "codeChecker",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:name\t\t= \"initializePads\"]\n[h:index\t= getMacroIndexes(name, \",\", \"lib:ontokenmove\")]\n[h:macro\t= getMacroProps(index, \"json\", \"lib:ontokenmove\")]\n[h:taText\t= am.test.reformatMacroOutput(macro,\"lib:ontokenmove\")]\n\n[H:am.test.openFrame(\"lib:ontokenmove\",\"Original code\",taText)]\n\n[H:taText\t= replace(taText,\"&\",\"&\")]\n[H:taText\t= replace(taText,\"\\\\\\\\\",\"\\")]\n[H:taText\t= replace(taText,\"/\",\"/\")]\n[H:taText\t= replace(taText,\"[\\$]\",\"$\")]\n[H:taText\t= replace(taText,'\"','@42@')]\n\n[H:taText\t= replace(taText,'\"','@42@')]\n[H:taText\t= replace(taText,\"\t\",\"@43@\")]\n[H:taText\t= replace(taText,\"\",\"@45@\")]\n[H:taText\t= replace(taText,\"<\",\"<\")]\n\n      \n[h:regex\t= \"([(){}\\\\[\\\\];<>:,'\\\\n]|@42@|@43@|@44@|@45@|<|if)+\"]\n[h:result\t= strfind(taText, regex)]\n\n[h:gutStr\t= \"\"]\n[h,count(getFindCount(result),\"\"), CODE:{ \n\t[tmp\t= getGroup(result, roll.count+1, 0)]\n\t[gutStr\t= gutStr + tmp]\n\n}]\n\n[H:gutStr\t= replace(gutStr,'@42@', '\"')]\n[H:gutStr\t= replace(gutStr,'@43@', '\t')]\n[H:gutStr\t= replace(gutStr,'@44@', '')]\n[H:gutStr\t= replace(gutStr,'<', '<')]\n\n[H:am.test.openFrame(\"lib:ontokenmove\",\"gut code\", gutStr)]\n\nok",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d7b7843a-a3b3-4ceb-bd9d-e8b968bc22b3",
          "commandChecksum": "1206e1ab052464dd05b52bd471e3c46f",
          "propsChecksum": "49119375dfe0617bacdd6a820e7ccba3"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 419,
        "label": "Build Option Vars",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:setLibProperty(\"bot.fg.Transportation\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.EventTokenArea\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.UtilityMove\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.UtilityGeneral\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Tables\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Animations\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.MapCreation\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.VBL\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Other\",\"\",\"lib:OnTokenMove\")]\n[h:setLibProperty(\"bot.fg.Functions\",\"\",\"lib:OnTokenMove\")]\n\n\n\n[h:setLibProperty(\"bot.fg.GroupList\",\"bot.fg.Transportation,bot.fg.EventTokenArea,bot.fg.UtilityMove,bot.fg.UtilityGeneral,bot.fg.Tables,bot.fg.Animations,bot.fg.MapCreation,bot.fg.VBL,bot.fg.Other,bot.fg.Functions\",\"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"On Map Teleport pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadStart, PadEnd) every teleport consists out of a starting pad and ending pad (paired pads), if you drop a token on one it will end on the other. You can resize or place them anyway you want, as long as its on the same map.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Between Map Teleport pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Interpad) Any Interpad is automatically paired with the Interpad with the SAME identifier (e.g. '1') on a DIFFERENT map. Again, size and place are completely free, as long as its on two different maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"One way teleports\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadJump, PadDrop, InterJump and InterDrop) Moving onto a 'Jump' token will transport you its paired 'drop' token. And NOT the other way round. The 'Inter' version can be used for transport between maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"One Way Teleport Border pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(PadJumpBorder, PadDropBorder, InterJumpBorder and InterDropBorder) As with the one way teleports The big difference with the 'normal one way teleports' is that the 'border teleport' tokens will teleport a token that moves onto OR OVER the special pad. I've added 8 new tokens to the zip file (4 horizontal and 4 vertical as you must NOT rotate the tokens, because the footprint of the token does NOT rotate). <br>The inter versions can ideally be used for e.g. large maps where you can build seperate sections on seperate MT maps. This will keep the memory use per map low and will give an easy transfer between to sections. <br>The map versions can be used for creating e.g. a closed loop map where the edges of the map are connected. Moving over the edge will automatically transport you to the opposite edge.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Two Way Teleport Border pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(InterPadBorder, PadStartBorder, PadEndBorder) Same as the above one way, but now also two ways teleports.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Transportation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Transportation\", \"Function\",\"Mapped Teleports\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(MappedPad) These pads work similar to the teleport pads, although of these there is only one type of pad and not two like the start and end pad with the 'normal' teleports. When initializing them you'll get a pop-up per map where they exist and here you can set the destination pad. The 'destination' must be a number, so you can if you like also put in forumulas or dice rolls, as long as the result is a number (and as long as a destination pad with that number actually exist).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Transparent Roofs\", \"Type\",\"Token\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Roof) When a token moves onto a building (with a roof) the roof automatically turns transparent (with a red halo) and return opague again when the token moves away from it. For this to work you will need to install the tabel into your framework inside the attached zip file.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Roof VBL Swap\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"in addition to existing Roof swap function, an option is added where you can store the VBL currently on a building and swap it with a VBL cross shape. Hence from the outside players can see the partially and as soon as they enter the building the VBL of the roof is swapped with the VBL of the building.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Warded Roofs\", \"Type\",\"Token/Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Roof) Roofs have now a corresponding 'set roof' macro with which you can assign doors to the roof. If doors are assigned, the Roof automatically becomes a 'warded' area, which you can ONLY enter through the OPEN door. Thus if the door is closed, there is no way a player can move her token onto the roof. If the door is open, a player can ONLY move in the building when it moves her token OVER the door token first.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Foliage\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Foliage) Tokens with these names work exactly as roofs, except there will be NO red halo outline for the transparent version AND you can choose to use a different picture to swap with when you move over it. (on default when you move over them their image is swapped with an transparent image from the tables).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Canopy\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Canopy) Tokens with these names are automatically given an treetrunk as alternative image when a token moves over them.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Warded Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros\", \"Description\",\"(Ward) Tokens that move onto this area are moved back to their original position. They cannot enter the area.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Event Pads\", \"Type\",\"Token/Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Event Macros\", \"Description\",\"(EventPad) These tokens are triggered on certain event e.g. when a token move onto the pad. These events can be set through a 'set event pad' macro. These pads replace the former Pit and Trap pads and allow for a much more versatile use. When the pad is triggered then a macro that you linked to it will run. Extra example is added: trip wire in combination with a net trap (thnx Pinkrose)\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(Canopy, Foliage, Roof) Linked tokens are special pads that are activated simultaneously. If you have two or more tokens that are linked by the same link identifier, e.g. 'Linked 1 Roof 5' and 'Linked 1 Canopy 3' (here the link identifier is '1'), then when one of the tokens is activated (by moving a token on top of it) the other is activated as well.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Bridge Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(i.c.w. Canopy, Foliage, Roof) Bridges are pads that you link with Canopy, Foliage or Roof pads. When you move over a Bridge and then onto a Roof (in one move) then the roof does NOT dissapear (See vid. tutorial for more info).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Linked Tunnel Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof\", \"Description\",\"(i.c.w. Canopy, Foliage, Roof) Tunnels work exactly the same as Bridges albeith the opposite effect. So when moving over a tunnel token the roofs disappear, while moving directly onto a roof they won't.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Shadow Pads\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; ShadowPads\", \"Description\",\"(ShadowPads ) This allows to watch token movement on map A from map B. Typical use is a 2 story building where you can watch the ground floor from the first floor through a gap in the floor (and vice versa). See vid tutorial for more details.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.EventTokenArea\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Event token and area support\", \"Function\",\"Event Areas\", \"Type\",\"Area\", \"Dependencies\",\"State: Special Area; Token: Area Marker\", \"Macro_Group\",\"OnTokenMove; Pad Macros; Teleport &Roof; Event Area Macros\", \"Description\",\"These are Areas you can define (and these can take ANY form, with a resolution of the grid) and depending whether a token moves onto, over, off, etc. it will trigger an event (macro). The best use for these are to define difficult terrain areas which impede the movement of a token. For which the 'Limit Movement' macro in the lib:EventMacros lib is now adapted.<br>Finally one other good thing of these areas: they're FAST! A lot faster then the token method currently in use.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group (Select)\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"Create groups of tokens. When you select one token of the group, all the tokens are automatically selected.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove; Group Move; Group Select\", \"Description\",\"You can combine tokens into one group. When you move ONE token of that group then the whole group moves accordingly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Rotation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"When the group is defined you can use the CW or CCW rotation buttons to rotate the group. For snapped tokens the increment is 90, for unsnapped its 45 and its also possible to select a token from the group and set its facing and then click either CW or CCW, after which the group will be rotated to that direction (unsnapped only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Group Formations\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Group Move; Group Select\", \"Description\",\"For defined groups (or a group of selected tokens) you can set different formation like, square, wedge, line, echelon, spread and compact.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Centre on token\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"A toggle in the settings where you can turn on continuous centre on token. This will force a centre on map for every token moved. (only works for single token move).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Restore FoW (Fog of War)\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"When a player moves a token all the FoW will be restored and only the PC visible areas will be cleared. This function has the extra advantage that the VBL lag bug (game gets very laggy after a while when there is a lot of VBL on the map) is ommitted.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"VBL (Vision Blocking Layer) move check\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This function is created by Aliasmask. It can also be found on his lib:Players. However to make both libs compatible I've added it to the BoT so it can be turned off on lib:Players. This function checks EVERY step of the just-moved-token and checks whether it can see into gridcell its moving into. If not then the movement is halted. This function too has the extra advantage that the VBL lag bug is ommitted.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Path Tracking\", \"Type\",\"Setting\", \"Dependencies\",\"State: pathFeet; Token: red feet, blue feet\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"Added toggle to the settings where you can turn on path tracking. This will show small feet in the grid cells where the last token moved. Red for NPCs and blue for PCs.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Lock Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This is a toggle on the macro panel that will lock down the movement of ALL tokens. Only the gm can move the tokens now. To use simply hit the macro button and hit it again to allow movement again.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Lock Token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"Similar to lock movement, only this works on the individual token. It prevents the token from being moved. Both by player and gm! To use: select one or more token. Click the 'lock token' macro. There is a general toggle in the settings to turn this feature on and off.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityMove\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Move related utily macros\", \"Function\",\"Invisibility Purge\", \"Type\",\"Token\", \"Dependencies\",\"None\", \"Macro_Group\",\"OnTokenMove\", \"Description\",\"This functions can be turned of or on the in the settings-->toggle tab. It uses <i>visible to owner only function<\/i>. When a token is invisible this setting is (automatically) turned on. Any token that has <i>Purge invisibility<\/i> turned on will be added as owner to the invisible when the invisible token is in range. See manual for full instructions.<\/i>\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Set Light\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro whith which you can easily set lights sources on tokens\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Rumbles Dice Box\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: tbl_Image\", \"Macro_Group\",\"Rumbles Dice Box\", \"Description\",\"A frame where you can set a pool of dice that you can roll in one click. I have used Rumbles code and layout as a basis and rewrote most of it. Noteably I've added 'options' so you can fully customize the frame.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Show Token Handout\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that forces a pop-up on ALL clients showing a token handout (gm only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Switch Map\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A macro that forces ALL clients and selected tokens to the chosen map AND forces all views to the centreOnMePad (if its on the map)(gm only).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Seek token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A utility that scans ALL maps and ALL tokens returning a list of all tokens that match the search string. Updated with a wide variety of options, biggest change is showing the results as macro links which allows you to either Copy, Move or Select the token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"bot_debugInfo()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - Documented\", \"Description\",\"A macro that shows all kinds of debug info (primarily for tracking variable values), with several optional settings.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Aliasmasks Disguise macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: Polymorph\", \"Macro_Group\",\"Aliasmak Usedisguise\", \"Description\",\"A macro that allows you to add extra token images to a token, so you can e.g. 'polymorph' during gameplay into something else.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"LMarkus Whisper Frame\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"LMarkus Whispers\", \"Description\",\"A frame where you can whisper (with some text formats) to one or more players without needing to use the /w option. It also includes an impersonation feature so you can speak as another token, without needing to actually impersonate it.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Rumbles Delete Macros utility\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Rumbles Delete Macros utility\", \"Description\",\"A macro that allows you to copy/paste/delete macros from/on a selected token onto another token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Plothos Message Manager uttility\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Plothos Message Manager\", \"Description\",\"A macro that allows you to create and store messages for players.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Event Buttons\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Event Macros\", \"Description\",\"A macro that links an lib:EventMacro macro to a token. When the token is selected, the macro is activated. Usefull for e.g. switching maps.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Benchmark\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro specially developed for macro developers. It can be used to discern the execution time for a certain macro.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Map Diagnosis\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that checks ALL maps and ALL (lib)tokens for potential issues. It checks whether token names contain non-alphanumerical characters and checks the libs for the same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead you to the token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Token Name Cleaner\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"A macro that detects and cleans up characters in token names that are incompatible with the macro system in maptool.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Bubblobills Input String Builder\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Bubblobills Input String Builder\", \"Description\",\"A macro with which you can easily create the code for a complex input string.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Nildiks Fancy Frames\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: frames\", \"Macro_Group\",\"Nildiks Frames\", \"Description\",\"Two macro functions that allow you to show fancy frames around the 'frames' you usually show to the players.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.UtilityGeneral\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Utility macros\", \"Function\",\"Nildiks Room Description Token\", \"Type\",\"Menu Macro\", \"Dependencies\",\"Table: encounters, tbl_Image\", \"Macro_Group\",\"Nildiks Room Description\", \"Description\",\"The Room Description token allows you to easily access a description of the area where the players are AND to easily share texts (e.g. pieces or parchments, treasure etc) and images (of e.g. encounters) with them in one overview\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Create Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro opens a form in which you can copy paste a table straight from excel. Beneath it you can set the title of the table. The checkbox enables you to view the table afterwards and edit it. This is NOT a maptool table but a Bag of Tricks table. It will be stored on lib:EventMacros. The advantage is that its dynamic and it allows multiple columns.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Show Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro shows you a list of available tables. The one you pick is shown in a form in which you can edit the values.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"Delete Table\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"This macro shows you a list of available 'Bag of Tricks' tables that you created using 'Create Table'. The one you pick is will be deleted from lib:EventMacros\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_table()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"With this function you can retrieve a value from the stored BoT Tables. Usage: bot_table('name of table', optional: 'column', 'row', ). Both 'column' and 'row' can either be an index number or the name of the row/column. Leaving them empty will result in a random choice.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_listBoTtables()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns a list with the stored BoT Tables.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_listMTtables()\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns a list with the stored Maptool Tables.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_getRows('table name')\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns the row names of the given BoT table\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Tables\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"BoT Tables\", \"Function\",\"bot_getColumns('table name')\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Tables\", \"Description\",\"Returns the column names of the given BoT table\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated Doors\", \"Type\",\"Menu Macro\", \"Dependencies\",\"State: Locked; Token: DoorLeverToken\", \"Macro_Group\",\"Door Animation\", \"Description\",\"Full functionality to setup animated doors, both single and double, both rotating and sliding. Including support to activate them in at least 5 different ways. \")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"VBL on Doors\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Door Animation\", \"Description\",\"Toggling (open or close) an animated door will give the following options: look through key-hole, look through window, crack door open, open door half way, open door fully. The VBL will be adjusted accordingly\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Token door switches (with proximity check)\", \"Type\",\"Menu Macro\", \"Dependencies\",\"State: isButton\", \"Macro_Group\",\"Door Button\", \"Description\",\"Set up a door with a switch token that corresponds with that door when you click on the switch. Option for the gm to 'Lock' the door, so players can't open it. You can also set a proximity check, that checks whether a token of the player is close enough to open the door.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animate Token Movement Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"A macro and macro button with which you can animate the movement of one or more tokens. See video\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animate Token Movement Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"Same as the macro only in the form of a macro function that you can call inside your own macros.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated text Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"A macro that generates an input screen where you can setup the animated text. This will pop up a frame on every client pc showing a frame where a delayed text is printed in\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Animated text Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Animate Move\", \"Description\",\"Same as the macro only in the form of a macro function that you can call inside your own macros.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Set View Animation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\t\"Use lastpath of selected token to run a screen animation\")]\t\t\t[h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Link View Animations\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\"Link the view animation of selected tokens and store it on one token\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Animations\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Animations\", \"Function\",\"Run View Animation\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\t\t\"Run view animation created for selected token\")]\t\t\t\t\t\t[h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Scatter\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"Select one or more tokens, set an area and a number and copies of the tokens will be randomly scattered accross the preset area. Ideal for e.g. rocks, trees, or a chaos warband.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Building A Forest\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"A macro to build a big forest FAST and have it ready for the Canopy 'Trick'. This is a specialized macro based on the 'Scatter' macro\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Summon tokens\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Summon\", \"Description\",\"A macro with which you can summon tokens from the 'BASE' map onto the current.map . The location you can set by hand or you can summon it onto a selected token.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Fill Area\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"A macro that with which you can quickly fill an area with tokens (also useful for creating special areas).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Draw Order Edit Panel\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Order\", \"Description\",\"With this panel you can edit the draw order of the selected tokens, rotate them individually, random or as a group. It also contains layer and shape dropdown list.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Crowd Movement\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Scatter\", \"Description\",\"An new set of macros that allows you to fill a e.g. Town square with tokens (forming a crowd), which can then 'flee in panic' when the fight goes down.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.MapCreation\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Map Creation macros\", \"Function\",\"Map Editor\", \"Type\",\"Menu Macro/Area\", \"Dependencies\",\"State: editFieldMarker; Token: GridCoordMarker\", \"Macro_Group\",\"Scatter\", \"Description\",\"Two new macro to create a field on the map where its VERY easy to place token, used for map creation. Try it out for more info.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"VBL Stamps on tokens\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"With this macro you can add a VBL layer upon a token that 'moves' with the token. (Its not really ON the token, but erased and redrawn as you move the token). Possible VBL are Square, Rectangle, Line, Regular Polygon. With a bunch of extra options (like offset, scale, fill, etc.).\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Drawable Polygon Stamps\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"In addition to the 'normal' stamps, you can now also save ANY VBL currently over the token as a stamp. So you can draw VBL over a token as you normally draw VBL and the store that VBL as a stamp onto the token. This is particularly usefull for dungeon tiles where you can store the VBL data onto the tile and then copy paste the tile over the map.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Mass VBL\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function will draw VBL on ALL tokens that match a (partial) search string. Its mainly intended for roofs and canopy but options (selection, all, layers) have been added to use it for other purposes. This macro also contains 2 different scaling techniques to apply the VBL onto the token. Finally you can also store the ENTIRE VBL structure and you can use Toggle VBL to turn that on or off\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"Toggle VBL\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function corresponds with Mass VBL. In Mass VBL you can store all the added VBL and with this function you can turn it on or off instantly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.VBL\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"VBL macros\", \"Function\",\"VBL Grenade\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Vision Blocking Layer\", \"Description\",\"This function will erase ALL VBL in a given radius (in grid cells) around one or more selected tokens.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"Force Selection\", \"Type\",\"Other\", \"Dependencies\",\"None\", \"Macro_Group\",\"Door Button\", \"Description\",\"To use with 'Always on Top' application. With this feature you can force a client slave to have the same button selected as you have on the master. Read the manual for more info. Usefull for those that like to use Full Screen Mode but still have a chat window and macros available. (and working)\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"Load Map and Coordinates on Start Up\", \"Type\",\"Setting\", \"Dependencies\",\"None\", \"Macro_Group\",\"Util - General\", \"Description\",\"This feature can be found in the settings, where you can set the map to load on start-up and the coordinates (or token name) on that map to go to.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"AssignedPads Macro\", \"Type\",\"Menu Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Assigned Pads\", \"Description\",\"Teleport pads that are linked to a specific token, can be used for a mass invasion!\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Other\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Other\", \"Function\",\"AssignedPads Function\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Assigned Pads\", \"Description\",\"Same as the macro menu but now on the fly.\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]\n[h:id = \"bot.fg.Functions\"][h:tmpFunctionArray = getLibProperty(id, \"lib:OnTokenMove\")][h:function = json.set(\"{}\",\"Group_Name\", \"Function Macros\", \"Function\",\"Function Macros\", \"Type\",\"Function Macro\", \"Dependencies\",\"None\", \"Macro_Group\",\"Geofunctions Support; Geofunctions; Util - Math; Message; Util - General; Util - Documented\", \"Description\",\"<a href='macro://manFunctionsTxt@Lib:OnTokenMove/none/Impersonated?'>Bot Function Manual (for overview)<\/a>\")][h:tmpFunctionArray = json.append(tmpFunctionArray, function)] [h:setLibProperty(id, tmpFunctionArray, \"lib:OnTokenMove\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "28e9c452-3d59-4386-8754-e03924bcaaa3",
          "commandChecksum": "1a4e655ca4a7c59804eb124527895356",
          "propsChecksum": "b441206445c65439a1f12172a44495b5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 420,
        "label": "optionTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:'']\n\n[h:assert(argCount()==2, getMacroName() + \" Requires 2 arguments, you only gave it: \"+ argCount(),0)]\n\n[h:option.var\t= arg(0)]\n[h:vars\t\t\t= arg(1)] \n[h:option.array\t= getLibProperty(option.var, \"lib:OnTokenMove\")]\n[h:option.first\t= json.get(option.array, 0)]\n[h:allVars\t\t= json.fields(option.first)]\n[h:option.group\t= json.get(option.first, \"Group_Name\")]\n\n\n[h,foreach(var, vars), CODE:{\n\t[assert(listCount(allVars, var),var + \" does not exist\",0)]\n}]\n\n\n[R: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 1pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 1px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n[h:output = styleHTML + \"<html><body>\n\t<font color=red size=5><b>\"+option.group+\" Functions<\/b><\/font><br><br>\n\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Back<\/b><\/a><br>\n\t<br>\n\t<table width='100%'  class='btnformat' valign=top><tr cellpadding='0px'><td class='btnformat'><b>\n\"]\n\n\n[h:header\t= \"\"]\n[h,foreach(var, vars), CODE:{\n\t[header\t= listAppend(header, var, \"<\/b><\/td><td class='btnformat'><b>\")]\n}]\n[h:output = output + header + \"<\/b><\/td><\/tr><tr cellpadding='0px'><td class='btnformat'>\"]\n\n\n[h:content\t= \"\"]\n[h,foreach(item, option.array), CODE:{\n\t[tmpContent\t= \"\"]\n\t[varsFromStrProp(json.toStrProp(item))]\n\t[foreach(var, vars), CODE:{\n\t\t[tmpContent\t= listAppend(tmpContent, eval(var), \"<\/td><td class='btnformat'>\")]\n\t}]\n\t[content\t= listAppend(content, tmpContent, \"<\/td><\/tr><tr cellpadding='0px'><td  class='btnformat'>\")]\n}]\n\n[h:output =  output + content + \"\n\t<\/td><\/tr><\/table>\n\t<br>\n\t<b>Dependencies:<\/b><br>\n\tDependencies are additional things you need to install before you can make use of that particular feature. Note that you can still install the entire feature group even without the dependency installed. You would just not be able to use that specific feature, but you can use all others.\tPossible dependencies are:\n\t<table border=0 valign='top'>\n\t\t<tr><td><i>Tokens<\/i>:<\/td><td>simply drag and drop these onto the same map as where lib:OnTokenMove is.<\/td><\/tr>\n\t\t<tr><td><i>Tables<\/i>:<\/td><td>menu --> window --> tables --> import --> select table --> open.<\/td><\/tr>\n\t\t<tr><td><i>States<\/i>:<\/td><td>menu --> edit --> campaign properties --> states (tab) --> enter name --> browse --> select image --> open --> add --> ok.<\/td><\/tr>\n\t<\/table>\n\tAll files required for the dependencies can be found in the <a href='https://forums.rptools.net/viewtopic.php?p=274503#p274503'><b>the special pads zip file<\/b><\/a> a more extensive explanation on how to install the dependencies can be found <a href='https://forums.rptools.net/viewtopic.php?p=274498#p274498'><b>here<\/b><\/a><br>\n\t<br>\n\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Back<\/b><\/a>\n\t<\/body><\/html>\n\"]\n\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fe2205fd-e7cd-442f-aca7-78b56c008130",
          "commandChecksum": "5235678a4d42a139eb95fe0bebcdc0e4",
          "propsChecksum": "919da6f33fce978ec1ca68cb245b8e76"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 422,
        "label": "featureTable",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:feature.array\t= getLibProperty(\"bot.fg.GroupList\", \"lib:OnTokenMove\")]\n\n[h:feature.Settings\t= getLibProperty(\"w42.bot.fg.GroupSettings\", \"lib:EventMacros\")]\n[h,if(feature.Settings == \"\"), CODE:{\n\t\n\t[setLibProperty(\"w42.bot.fg.GroupSettings\",\"bot.fg.Transportation=0 ; bot.fg.EventTokenArea=0 ; bot.fg.UtilityMove=0 ; bot.fg.UtilityGeneral=0 ; bot.fg.Tables=0 ; bot.fg.Animations=0 ; bot.fg.MapCreation=0 ; bot.fg.VBL=0 ; bot.fg.Other=0 ; bot.fg.Functions=0\",\"lib:EventMacros\")]\n\t[feature.Settings\t= getLibProperty(\"w42.bot.fg.GroupSettings\", \"lib:EventMacros\")]\n};{}]\n\n\n[h:varsFromStrProp(feature.Settings,\"SUFFIXED\")]\n\n\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n\n[h: processorLink = macroLinkText(\"processFeatureForm@Lib:OnTokenMove\", \"none\")]\n[h:output =  strformat(\"%{styleHTML}<html><body><form action=%{processorLink} method='json'>\n<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><b><< Back to the welcome screen<\/b><\/a><br>\n<a href='macro://videoTutorials@Lib:OnTokenMove/none/Impersonated?'><b>< Back to video tutorials<\/b><\/a><br>\n<br>\n<font color=red size=5><b>BOT features<\/b><br><br><\/font>\nBelow you see an overview of 'Feature Groups' which you can turn on (checked) or off (unchecked) at any time. Each group represents a list of features which will become available when you turn those on. 'Show overview' will show you the specific features that belong to that group. Show overview will also give you an overview of what you need to install additionally to make use of those features (dependencies). You can change your choices later by clicking on the the 'BoT Features' button. <br>\n<br>\n<table class='btnformat'><tr><td class='btnformat'>\")]\n\n\n\n[h:'foreach(var, vars), CODE:{\n\t[VAR = \"function\"]\n\t[output\t= listAppend(output, var, \"<\/td><td>\"]\n}']\n\n\n[h:tmpOutput=\"\"]\n[h,foreach(item, feature.array), CODE:{\n\t[option.group\t= json.get(json.get(getLibProperty(item, \"lib:OnTokenMove\"), 0), \"Group_Name\")]\n\t[checked\t= if(eval(item+\"_\"), \"CHECKED\", \"UNCHECKED\")]\n\t[tmpOutput = listAppend(\n\t\ttmpOutput, \n\t\tstrformat(\"\n\t\t\t<input type='hidden' name='%{item}' value=0>\n\t\t\t<input type='checkbox' name='%{item}' value=1 '%{checked}'/>\n\t\t\t<\/td><td class='btnformat'>%{option.group}\n\t\t\t<\/td><td class='btnformat'><input type='submit' name='btn%{item}' value='ShowOverview' />\n\t\t\"),\n\t\t\"<\/td><\/tr><tr><td class='btnformat'>\"\n\t)]\n\t['pause(\"item\", item+\"_\", \"checked\", \"option.group\")']\n}]\n\n[h:output =  strformat(\"%{output}%{tmpOutput}<\/td class='btnformat'><\/tr><\/table><br>\nWhen you hit 'save' the settings window will pop-up. Make sure you hit OK and NOT Cancel. Obviously: if you like you can go through the settings first and change what you want before hitting ok.<br>\n<br>\n<input type='submit' name='btnSaveSettings' value='Save'/><\/form><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "105154a7-8d02-4d16-b61a-bfda2a6ea05e",
          "commandChecksum": "fe9b9f4cb268de6feebeb81c8888a8ed",
          "propsChecksum": "ed9e9f1771cea200feadf3423487bdab"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "maroon",
        "group": "4",
        "includeLabel": false,
        "sortBy": "4",
        "index": 423,
        "label": "processFeatureForm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'broadcast(macro.args)']\n\n[h:args\t\t\t= macro.args]\n[h:strPropVars\t= json.toStrProp(args)]\n[h:argList\t\t= json.fields(args)]\n[h:setLibProperty(\"w42.bot.fg.GroupSettings\", strPropVars, \"lib:EventMacros\")]\n\n[h,if(json.contains(args, \"btnSaveSettings\")), CODE:{\n\t\n\t[bot_updateVirtualMenu()]\n\t[closeFrame(\"Set BoT features\")]\n\t[bot_settings()]\n};{\n\t\n\t\n\t[foreach(arg, argList), CODE:{\n\t\t[if(startsWith(arg, \"btn\")): bot_optionTable(substring(arg,3),\"Function, Description, Dependencies\")]\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "8b7754be-dca5-457e-b7b4-f0d34f6ce679",
          "commandChecksum": "84db1c1441b2541082b7fdb6304ffbe3",
          "propsChecksum": "20284924f939c48677eeb8cecd2d8643"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 425,
        "label": "settings",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[h:assert(isGM(), \"Only a GM can modify the settings\",0)]\n\n\n[h:useAltImage\t\t\t= getLibProperty('useAltImage','lib:EventMacros')]\n[h:checkMapsOCL\t\t\t= getLibProperty('checkMapsOCL','lib:EventMacros')]\n[h:showGroupPanelOnSelect= getLibProperty('showGroupPanelOnSelect','lib:EventMacros')]\n[h:fullScreenBroadcast\t= getLibProperty('fullScreenBroadcast','lib:EventMacros')]\n[h:oldFSB\t\t\t\t= fullScreenBroadcast]\n[h:numericIdOnly\t\t= getLibProperty('numericIdOnly', 'lib:EventMacros')]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n[h:baseMapName\t\t\t= getLibProperty('baseMapName','lib:EventMacros')]\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes','lib:EventMacros')]\n[h:haloColors\t\t\t= 'red,dark gray, yellow, blue, black, white,light gray,teal,none']\n[h:onLineClients\t\t= listInsert(json.toList(bot_nself()),0,\"\")]\n\n\n[h:animationPerClient\t= getLibProperty('animationPerClient','lib:EventMacros')]\n[h:timeLockDelay\t\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n\n[h:summonPcPropType\t\t= getLibProperty('summonPcPropType','lib:EventMacros')]\n[h:summonNpcPropType\t= getLibProperty('summonNpcPropType','lib:EventMacros')]\n[h:summonPropTypesList\t= getLibProperty('summonPropTypesList','lib:EventMacros')]\n[h:summonSpecialList\t= getLibProperty('summonSpecialList','lib:EventMacros')]\n\n\n[h:invisState\t\t\t= getLibProperty('invisState','lib:EventMacros')]\n[h:seeInvisState\t\t= getLibProperty('seeInvisState','lib:EventMacros')]\n[h:purgeInvisState\t\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n[h:annulInvisState\t\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n\n[h:allMaps\t\t\t\t= listSort(getAllMapNames(),\"N+\")]\n\n\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n\n[h:roofHaloColor\t\t= max(0,listFind(haloColors, roofHaloColor))]\n[h:forceSelectClient\t= max(0,listFind(onLineClients, forceSelectClient))]\n\n\n[h:useStartUpMap\t\t= getLibProperty('useStartUpMap','lib:EventMacros')]\n[h:startUpMap\t\t\t= getLibProperty('startUpMap','lib:EventMacros')]\n[h:startUpCoords\t\t= getLibProperty('startUpCoords','lib:EventMacros')]\n[h:useCentreOnMePad\t\t= getLibProperty('useCentreOnMePad','lib:EventMacros')]\n[h:runSwitchForm\t\t= getLibProperty('runSwitchForm','lib:EventMacros')]\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n\n\n[h:libCoordSize\t\t\t= getLibProperty('libCoordSize', 'lib:EventMacros')]\n[h:maxPadsPerRun\t\t= getLibProperty('maxPadsPerRun','lib:EventMacros')]\n[h:maxGroupSelect\t\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:maxOrderSelect\t\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:padNameList \t\t\t= getLibProperty('padNameList', 'lib:EventMacros')]\n\n\n[h:startUpMapList\t\t= getAllMapNames()]\n[h:startUpMapNum\t\t= listFind(startUpMapList,startUpMap)]\n[h:baseMapNum\t\t\t= listFind(startUpMapList,baseMapName)]\n\n\n[h:oldMap\t\t\t\t= getCurrentMapName()]\n\n[h,if(baseMapNum == -1), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|The map with lib:EventMacros does not exist. Pls select the correct one|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n}]\n[h:setCurrentMap(baseMapName)]\n\n[h,if(findToken(\"lib:EventMacros\") == \"\"), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|<html>Lib:EventMacros is NOT on map: <b>'+baseMapName+'<\/b>. Please select the map where Lib:EventMacros is on|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n\t[setCurrentMap(baseMapName)]\n}]\n[h:assert(findToken(\"lib:EventMacros\") != \"\", \"<font color=red>No Lib:EventMacro found on map <b>\"+baseMapName+\"<\/b> please correct this.\",0)]\n[h:macroIDList\t\t= getMacroGroup(\"Event list macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n\n[h:triggerEventList = \"eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport\"]\n[h,foreach(trigger, triggerEventList): set(trigger, listFind(macroNameList, eval(trigger)))]\n\n[h,if(getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')==\"\"):setLibProperty('w42.bot.fg.GroupSettings', \"bot.fg.Transportation=1;btnbot.fg.Transportation=Show?Overview;bot.fg.EventTokenArea=1;bot.fg.UtilityMove=1;bot.fg.UtilityGeneral=1;bot.fg.Tables=1;bot.fg.Animations=1;bot.fg.MapCreation=1;bot.fg.VBL=1;bot.fg.Other=1;bot.fg.Functions=1\", 'lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros'),'suffixed')]\n\n[h:inputStr\t= \"[]\"]\n[h,if(bot.fg.EventTokenArea_ || bot.fg.Transportation_ || bot.fg.UtilityMove_ || bot.fg.Other_ || bot.fg.UtilityGeneral_ || bot.fg.Animations_ || bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>General<\/html>||TAB\")]\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Settings<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useAltImage|'+useAltImage+'|<html><span title=\"<html>When checked, the system will first check whether there is a token handout image on the foliage token. <br>If so it will swap the original image for that one, if not it will grab the table image. <br>Unchecked, the system will automatically grab the tbl image<\/html>\">Use alternative transparent image for foliage<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'checkMapsOCL|'+checkMapsOCL+'|<html><span title=\"<html><b>When checked:<\/b> the system will check all the maps when you load the campaign,<br>to see if they appear in the pad database. This is not a full initialization but it will<br>prevent bug reports after you load the campaign and if any inconsistancies are<br>found it will initialize the campaign file. What you will notice is that MT will<br>quickly flick through all the maps when you load the campaign.<br><b>When unchecked:<\/b> no checks are made so nothing will happend when you load the<br>campaign file.<\/html>\">Check all maps on start up<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doSwitchInterMap|Change to other map, do not change to other map, do not change AND store coords|<html><span title=\"<html><b>Change to other map<\/b>: When using inter map teleport, switch to the map after teleportation<br><b>do not change to other map<\/b>: do NOT switch to destination map after teleportation<br><b>do not change AND store coords<\/b>: when using the do NOT switch map option, the system needs to<br>check the destination pad for the correct coords before sending the token there and then return to<br>the current map. This causes maptool to reload the current map. To prevent this you can use this third<br>option, which will store the coords of both pads on eachother during the <i>initialize pads<\/i> process.<br><b>BUT<\/b> that means that you CANNOT move the interPads without running <i>initialize maps<\/i> again.<\/html>\">Automatically swap to map for interpads<\/html><\/span><\/html>|RADIO|SELECT='+doSwitchInterMap)]\n\t[h,if(bot.fg.Transportation_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doScaleTeleport|'+doScaleTeleport+'|<html><span title=\"<html><b>When checked:<\/b> teleportation will keep track of different size teleports<br>This means that if you move to the lower right corner of a small pad you and up<br>on the lower right corner of a larger pad. <br><b>When unchecked:<\/b>teleportation will be relative to the upper left corner<br>of the teleport. So if you move from the lower right corner of a 4x4 to a 2x2<br>pad, then you will end up 2 squares down and 2 squares right OUTSIDE the 2x2 pad.<br>Mb<NOTE:<\/b> turning this on is tricky! E.g. if you make one of 2 vertical border pads<br>twice as thick as the other, and you move 6 squares over the pad, then you will<br>end up 12 (or 3 depending on the direction) beyond the other teleport!<br><\/html>\">Scale Teleportation<\/html><\/span><\/html>|CHECK')]\n\n\t[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'showGroupPanelOnSelect|'+showGroupPanelOnSelect+'|<html><span title=\"<html>When you select a <i>group<\/i> AND the <i>activate switch panel<\/i> is active<br>automatically show the group macro panel<\/html>\">Show group panel on select<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Other_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'fullScreenBroadcast|'+fullScreenBroadcast+'|<html><span title=\"<html>When you check this then the broadcast function will be redefined. Next to its<br>usual function it will ALSO broadcast to a dialog window called <i>Last Chat<\/i><br>but ONLY when the full screen mode is toggled (see campaign macros or F2). This<br>will result in a dialog popping up in full screen mode showing the last message<br>send to chat, using the broadcast function.<br><b>Important note:<\/b> currently its not possible to check whether a client is in<br>full screen or not, this means that this toggle is set for ALL clients.<\/html>\">Redefine <i>Broadcast<\/i> for full screen mode<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'numericIdOnly|'+numericIdOnly+'|<html><span title=\"<html>When you check this then ONLY special pads like Roof, Ward, PadStart, etc.<br>followed by a number (e.g. 1,2,3) will be identified as a special pad. E.g. <u>Roof 1<\/u><br>is recognized as a special pad and <u>Roof Red Barn<\/u> not. If you UNCHECK this<br>then <u>Roof Barn Red<\/u> WILL be identified as a special pad. As usual <i>linked<\/i> pads<br>require the SAME identifier. So <u>PadStart Sea Level<\/u> will be connected to<br><u>PadEnd Sea Level<\/u> (IF the box is unchecked!)<br><b>Note that Linked Pads will NOT work when this is checked<\/b><\/html>\">Numeric Id for special pads only (disable Links!)<\/html><\/span><\/html>|CHECK')]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'forceRoomShare|Send macro link to chat, Force share on screen, do both|<html><span title=\"<html><b>Send macro link to chat<\/b>: When using Nildiks room description token, <br>when you click on a <i>share<\/i> link, a macro link is sent to the chat that<br>players can click on to open the frame with the shared information.<br><b>Force share on screen<\/b>: Instead of sending a macro link, the<br>information is immediately opened on the screen of the players.<br><b>Both<\/b>: The information is immediately shown on the players screen<br>AND a click-able macro link is sent to the chat.<\/html>\">When sharing a Room Description<\/html><\/span><\/html>|RADIO|SELECT='+forceRoomShare)]\n\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'baseMapName|'+startUpMapList+'|<html><span title=\"<html>The use of the Canopty option requires a BASE map where the treetrunks are situated. per default this Map is called BASE, here you can give it a different name.<\/html>\">Name of BASE Map<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+baseMapNum)]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'excludeLightTypes|'+excludeLightTypes+'|<html><span title=\"<html>Here you can enter one or more light <u>types<\/u> seperated by a comma (,) (e.g.: Generic, D20) that you dont want to show up as a tab in the Set Light Source macro<\/html>\">Exclude Light Types<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'roofHaloColor|'+haloColors+'|<html><span title=\"<html>Here you can set the color of the halo for the Roof special pad<\/html>\">Set Roof halo color<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+roofHaloColor)]\n\t[h,if(bot.fg.UtilityGeneral_)\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'forceSelectClient|'+onLineClients+'|<html><span title=\"<html>If you select a client (player pc) from this list then when a gm selects a token<br>on a map that same token will also be selected on the chosen clients side. This <br>is particularly usefull in a laptop beamer setup where you have one single GM <br>client and one single players client to show the map. <br><br>Note that if a previously set (player) client does not exist when this campaign<br>is loaded then this value will be reset to empty and you need to run settings <br>again to select the client.<\/html>\">Force Token Selection on Client<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+forceSelectClient)]\n\n\t[h,if(bot.fg.Animations_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr,\"junk|<html><b>Animations<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'animationPerClient|'+animationPerClient+'|<html><span title=\"<html>Animations like for the doors and the token movement will have an instance running<br>on eacht seperate client. This because the network connection of the server is<br>usually not fast enough to send updates of the animated object to the clients. This<br>requires a copy of the animated token on each client which is visible to the owner only.<br>This copy is removed from the client as soon as the animation is over.<br><i>Visible to owner only<\/i> will only work if <i>strict token ownership<\/i> is checked<br>for the running server. If its not set, then all the copies of all the clients are<br>visible on all the other clients as well. This will look messy. Hence this option to<br>run the animation on the server only.<br><b>When checked:<\/b> Animations will be played on each client<br><b>When unchecked:<\/b> Animations will be played on the server only<br><\/html>\">Run animations per client<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'timeLockDelay|'+timeLockDelay+'|<html><span title=\"<html>When using the token buttons to open or close doors then the onTokenSelectionEvent is<br>triggered. Unfortunately its triggered more than once. With the effect that the door<br>opens, closes, opens etc. To prevent this Ive created a time-out in which the event is<br>ignored. If this time is too short you will notice the door open-close event triggering<br>multiple times. If you set if to slow then you have to wait that time before you can<br>use the button again. The time is in ms meaning that 1000\t= 1 second. If you encounter<br>the problem of the door animation triggering multiple times when you click the door<br>button then you should set this timer higher, e.g. to 1000. <\/html>\">Time lock delay for token buttons (ms)<\/html><\/span><\/html>')]\n\t}]\n\n\t[h,if(bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr,\"junk|<html><b>Summon Token Macro<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonPcPropType|'+summonPcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of PCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of PCs<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonNpcPropType|'+summonNpcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of NPCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of NPCs<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonPropTypesList|'+summonPropTypesList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will also generate a dropdownbox for any tokenproperty<b><u>type<\/b><\/u> that <br>is listed here<\/html>\">List of Summon Token Property Types<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'summonSpecialList|'+summonSpecialList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will generate a dropdownbox for listed tokenproperties. In addition <br>here you can set Token Names which you want to let appear in a seperate Dropdownbox. <br>Here its used for the special pad names, but it can be used for other purposes<\/html>\">List of Summon Token Special<\/html><\/span><\/html>')]\n\t}]\n}]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>On Campaign Load<\/html>||TAB\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Stuff that happens when you load the campaign<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useStartUpMap|'+useStartUpMap+'|<html><span title=\"<html><b>When checked:<\/b> the below two settings (load map on start up and go to coordinates) will be used.<\/html>\">Use Start Up map and coordinates<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'startUpMap|'+startUpMapList+'|<html><span title=\"<html>Pick here the name that should be loaded on campaign load or when players log in.<\/html>\">Set map to open at start up<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+startUpMapNum)]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'startUpCoords|'+startUpCoords+'|<html><span title=\"<html>Set here the coordinates which the map will be centred on campaign load<br>or when players log in. You can see the coordinates of your cursor on the<br>map in the lower right corner of Maptool. Example (X,Y): <b>5,4<\/b>.<br><br>Alternatively you can also enter a <b>token name<\/b>, however when you do that<br>make sure that the name does not contain any comma(s): <i>,<\/i><\/html>\">Set coordinates to centre map on start up.<\/html><\/span><\/html>')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'useCentreOnMePad|'+useCentreOnMePad+'|<html><span title=\"<html>This setting will override the coordinates unless the CentreOnMePad<br>is not found on the map. When you check this setting then on start up<br>the map will be centred onto this token for all clients.<\/html>\">Centre on CentreOnMePad on start up.<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Animations_ || bot.fg.EventTokenArea_ || bot.fg.Other_ || bot.fg.UtilityMove_)\t:inputStr\t= json.append(inputStr, 'runSwitchForm|'+runSwitchForm+'|<html><span title=\"<html><b>When checked: <\/b>the form that you need to start so door switches work, <br>will start automatically on campaign load .<\/html>\">Start door switches form<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'disableOCLCheck|'+disableOCLCheck+'|<html><span title=\"<html><b>When checked: <\/b>The boT check result* shown in the chat<br>after you have loaded the campaign, will be turned OFF.<br><br>*Thats the red-yellow colored bar called:<br><i>Bag of Tricks - OnCampaignLoad checks<\/i><\/html>\">Disable OCL Checks<\/html><\/span><\/html>|CHECK')]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t[h\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>Exclusions<\/html>||TAB\")]\n\t\t\t\t\t\t\t\t\t\t\t\t[h\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Which maps should be excluded from the Initialization<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\n\t\t\t\t\t\t\t\t\t\t\t\t[H:excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n\t\t\t\t\t\t\t\t\t\t\t\t[H, if(json.isEmpty(excludedMaps)): excludedMaps\t= \"[]\"]\n\t\t\t\t\t\t\t\t\t\t\t\t[h,foreach(map, allMaps), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t[H: isExcluded\t= json.contains(excludedMaps,map)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[H\t:inputStr\t= json.append(inputStr,strformat(\"map%{roll.count}|%{isExcluded}|%{map}|CHECK\"))]\n\t\t\t\t\t\t\t\t\t\t\t\t}]\n}]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Which propertyTYPES should NOT trigger the onTokenMoveEvent<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'excludePropertyTypes|'+excludePropertyTypes+'|<html><span title=\"<html>Here you can enter one or more property types that will NOT trigger the onTokenMoveEvent.<br>Token property types can be set in menu-->edit-->campaign properties-->Token Properties.<br>There you find a list of the token properties for your campaign. Per default you will find the<br> Basic property type there. A property type for a token you can set by double clicking on<br>a token-->config tab-->Properties. That field contains a dropdown menu where you can choose <br>the property type for that token. All the Property Types you list in this field will NOT trigger<br>the event when moved. E.g. if you list SpecialPads here and your drag a token with the SpecialPad<br>property type onto a teleport token, then that token will NOT be teleported.<\/html>\">Exclude Property Types<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>Toggles<\/html>||TAB\")]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can turn off certain checks to speed thing up<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doGroups|'+doGroups+\t\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off group movement<\/html>\">Group movement<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doSnap2Grid|'+doSnap2Grid+\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off Snap To Grid. This is mainly<br>interesting for token move animation where you <br>want the tokens to move smoothly, but also have<br>them snapped to grid. When checked this option<br>will snap the last moved token to grid. This only<br>works when Maptools its Snap To Grid is turn off.<\/html>\">Snap To Grid<\/html><\/span><\/html>|CHECK')]\n[h, if(vblSupport == 1 && bot.fg.VBL_)\t\t\t\t\t:inputStr \t= json.append(inputStr, 'doVBLStamp|'+doVBLStamp+\t'|<html><span title=\"<html>Uncheck to turn off VBL stamps.<br>VBL Stamps are Vision Blocking Layer stamps that work on tokens<br>that have a label set to <i>VBLStamp<\/i>. When a tokens has this<br> word in its label a VBL cross will be drawn over it when it is moved.<br> And that VBL cross will move with the token.<\/html>\">VBL Stamps<\/html><\/span><\/html>|CHECK') ; doVBLStamp\t= 0]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doResetFoW|'+doResetFoW+\t\t\t\t\t'|<html><span title=\"<html>Check to restore ALL Fog of War on every move<\/html>\">Restore FoW<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.VBL_)\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doVBLCheck|'+doVBLCheck+\t\t\t\t\t'|<html><span title=\"<html><i>This feature is developed by Aliasmask.<\/i><br>It does two things:<br><b>1.<\/b> If a token <i>cuts a corner<\/i> of a vision blocking area,<br>then a warning is given and the token is moved to the spot<br>BEFORE the corner was cut.<br> <b>2.<\/b> Because of the path that the token was dragged along<br>would be cleared of the fog of war (FoW) its movement is<br>reset and the macro clears the FoW.<br> The latter has the HUGE advantage that it also is a work<br>around for the (b87) FoW lag issue! If you have individual<br>FoW turned on for tokens then after a while dragging tokens<br>around can become very laggy. This option solves that issue.<br> The disadvantage is that if you move tokens over a large path<br>then it takes considerably longer (in addition to the normal<br>delay this Bag of Tricks introduces). The delay is not<br>noticeable for short distances but becomes e.g. 1 second<br>when you drag a token over 300 squares.<br>  <\/html>\">VBL move check<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doCentreOnTok|'+doCentreOnTok+\t\t\t\t'|<html><span title=\"<html>Check to continuously centre the map on the moving token.<br>Does not work for multiple moving tokens<\/html>\">Centre on token<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'doTriggerOnZeroMove|'+doTriggerOnZeroMove+\t'|<html><span title=\"<html>If you move a token and put it back onto its original spot then,<br>this will trigger the onTokenMoveEvent. If you <b>check<\/b> this box then if<br>a token is standing on a special pad, that pad will be activated.<br><b>Uncheck<\/b> to ignore this zero move.<br><b>Note<\/b> that if you set Waypoints and then return to the original<br>spot, that the token has actually moved and the special pad<br>WILL be activated!<\/html>\">Trigger Pads on zero move<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'doSpecialPads|'+doSpecialPads+\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off the special pads entirely (Check Start and Check Path included).<\/html>\">Check special pads<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doLockMovement|'+doLockMovement+\t\t\t'|<html><span title=\"<html>Check to prevent the movement of locked tokens.<br>You can select a token and toggle the <i>lock movement<\/i><br>macro. When a token is locked this way AND when this setting<br>is turned on, the movement of that tokens will always be <br>reverted. Not even the gm can move the token.<br><\/html>\">Lock movement for locked tokens<\/html><\/span><\/html>|CHECK')]\n[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doFullScreenMode|'+doFullScreenMode+\t\t'|<html><span title=\"<html>b89+: Check to turn on a isFullScreen check.<br>This will automatically switch the BoT macro panel to<br>full screen mode (showing the panel while in full screen)<br>and back to a dockable frame when not in full screen.<\/html>\">Full Screen Mode<\/html><\/span><\/html>|CHECK')]\n[h,if(bot.fg.UtilityMove_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, \"junk|<html><b>___________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'doInvisibility|'+doInvisibility+\t\t\t'|<html><span title=\"<html>This will turn on the invisibility checks on token move<br>It will only trigger for tokens that either have:<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t1. Invisibility State<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t2. See, Purge and/or Annul Invisibility State<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t3. The <i>seeing, purging or annulling<\/i> token has a a corresponding range set as property.<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\t<b>NOTE:<\/b> you can only see the invisibility effects (on a player client) when running a server with <i>STRICT TOKEN OWNERSHIP<\/i> turned on.<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\tThe range set will be the maximum distance at which the invisible token is seen/purged/annuled. If the property does not exist you will be asked<br>\t\t\t\t\t\t\t\t\t\t\t\t\t\tto enter a value when you run the macro for a token. The corresponding properties are: w42.seeInvisRange, w42.purgeInvisRange, w42.annulInvisRange.<\/html>\">Invisibility<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'invisState|'+invisState+\t\t\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state used for Invisibility<\/html>\">Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'seeInvisState|'+seeInvisState+\t\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the name of the state used for seeing invisibility<\/html>\">See Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'purgeInvisState|'+purgeInvisState+\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state name of the used for purging invisibility<\/html>\">Purge Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, 'annulInvisState|'+annulInvisState+\t\t\t'|<html><span title=\"<html>This only works when Invisibility is checked<br>Give the state name of the used for annulling invisibility<\/html>\">Annul Invisibility State<\/html><\/span><\/html>')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t[inputStr\t= json.append(inputStr, \"junk|<html><b>___________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n}]\n[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'doShowPath|Do not Track Path, Track Path, Track Path and delete feet manually|<html><span title=\"<html>When Track Path is turned on, small feet will be placed in the cells over which a token is moved. <br>Red feet for NPCs and Blue feet for PCs.<br><br><b>Do not Track Path:<\/b> its turned off <br><b>Track Path:<\/b> its turned on, only the LAST move is shown<br><b>Track Path and delete feet manually:<\/b> for every move feet will be placed in the path. <br>To remove them from the map use the following command: [bot_getPath(3)]<br><br><b><u>Note that 3 conditions MUST BE MET before you toggle this setting:<\/u><\/b><br>1. the blue and red feet must on the BASE map and NOT on the OBJECT layer<br>2. a state <i>pathFeet<\/i> must be created (the feet must have that state)<br>3. BOTH the <i>impersonation and selection panel<\/i> must be closed (or the removal will be <br>extremely slow)<\/html>\">Show the last moved path<\/html><\/span><\/html>|RADIO|SELECT='+doShowPath)]\n[h,if(bot.fg.EventTokenArea_)\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'canSelectShadowTok|Object Layer, Token Layer, Token Layer and autoselect Main Token|<html><span title=\"<html>When using shadow pads, you can choose the layer where the shadow tokens are placed:<br>- Object layer: shadow token can not be selected (targeted) by players<br>- Token layer: shadow token *can* be selected (targeted) by players<br>- Token layer (autoselect main): when the shadow token is selected the actual token is selected instead.<br>The latter requires the <i>activate switches<\/i> macro to be running.<\/html>\">Where to place Shadow Tokens<\/html><\/span><\/html>|RADIO|SELECT='+canSelectShadowTok)]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{}]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>The following toggles work for altInitMap only!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'doFirstPointPath|'+doFirstPointPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token starts its movement on a special pad<br>e.g.(under) canopy, then the token activates the relevant code.<br>E.g. in case of Canopy if the token moves away far enough then it will restore<br>the Canopy picture. Turning this off will result in this check NOT taking place.<br>So Canopy will dissapear but no longer reappear. Turning this off is usefull when<br>you are not using Canopy, Foliage or Roof pads.<\/html>\">Check Start (Canopy, Foliage or Roof)<\/html><\/span><\/html>|CHECK')]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'doInnerPointsPath|'+doInnerPointsPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token moves over a Ward or EventPad,<br>then the code is activated for that pad encountered. E.g. in case of Ward,<br>the Token is placed on the edge of the ward and the rest of the movement is negated.<br>Turning this off is usefull when you are not using Ward or EventPad pads.<\/html>\">Check Path (Ward, Event)<\/html><\/span><\/html>|CHECK')]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Movement Limiter!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'limitMovement|'+limitMovement+\t\t\t'|<html><span title=\"<html>Here you can set a number or a token property to which token movement is limited during<br>initiative. Entering e.g. <i>4<\/i> means that the max allowed move is 4 cells. Entering<br><i>movement<\/i> will limit the movement of the token to its <i>movement<\/i> property. You<br>can enter any token property you like as long as that token property contains a number.<br>Should a player in this case move her token 5 or more cells, then they will receive a<br>message and the movement will be reset (so the tokens will be returned to its original<br>position). <br><br><b>Note that this feature will NOT work:<\/b><br>- when the user moving the token is a GM<br>- when the number set here is 0<br>- when the token is NOT in the initiative panel<br><br>Also note that this does not prevent someone from moving her token twice!<br><br><b>The macro that handles this is placed on the lib:EventMacros.<\/b> You can edit<br>this macro to better suit your framework. More explanations you can find there.<\/html>\">Limit movement to: (0\t= ignore)<\/html><\/span><\/html>')]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>General Events<\/html>||TAB\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can link an event macro to other events<\/b><br>Note that only the macros from the group:<br>'Event list macros' are in the drop downlists<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME when you move ONE token<\/html>\">Before the Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreMultipleTokenMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME when you move MULTIPLE tokens<\/html>\">Before Multiple Tokens are Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreMultipleTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroOnTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro executes ONLY after a LEGAL move of ONE token.<br>But BEFORE the event macros are executed.<br>This macro will run before any of the OnTokenMove code is executed<\/html>\">When Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroOnMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro executes ONLY after a LEGAL move of MULTIPLE tokens.<br>But  before any events of the special pads are executed<\/html>\">When Multiple Tokens are Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnMultipleTokensMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html>For the coders. The events herabove will be called in the onTokenMove scope.<br>Below will be called in a deferred macro (of onTokenMove) and will thus NOT<br>be in scope of the onTokenMove! The token ID, getLastPath(0) and getLastPath (1)<br>will be passed on as variables.<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro that executes EVERYTIME after a LEGAL move of ONE token.<br>This macro will run after any events of the special pads take place<\/html>\">After Token is Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostTokenMove)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro that executes EVERYTIME after a LEGAL move of MULTIPLE tokens.<br>This macro will run after any events of the special pads take place<\/html>\">After Multiple Tokens are  Moved<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostMultipleTokensMove)]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, \"junk|<html>In the events below a strprop is passed on with contextual variables<br>These can be created using varsFromStrProp(arg(0)) and are as follows:<br>tok, padName, teleportEndName, CurrentX, CurrentY, NewX, NewY<\/html>|-|LABEL|SPAN=TRUE\")]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventPreMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport on the same map occurs.<\/html>\">Before Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPreMacroTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventPostMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport on the same map occurs.<\/html>\">After Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPostMacroTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPreInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport to another map occurs.<\/html>\">Before Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreInterTeleport)]\n\t\t\t\t\t\t\t\t\t\t\t\t\t[h\t:inputStr\t= json.append(inputStr, 'eventMacroPostInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport to another map occurs.<\/html>\">After Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostInterTeleport)]\n}]\n\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.MapCreation_), CODE:{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"tab1|<html><b>System<\/html>||TAB\")]\n\t[h\t\t\t\t\t\t\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, \"junk|<html><b>Here you can set the technical stuff<\/b><br>As a general rule: do not touch unless you <br>know what you are doing<\/html>|-|LABEL|SPAN=TRUE\")]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'libCoordSize|'+libCoordSize+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>Just do not change this value. Its used for the x/y area size of the lib coords<\/html>\">Lib coords size<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'maxPadsPerRun|'+maxPadsPerRun+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>If you have a map with a LOT of special pads on it (> 500) it is likely that<br>Maptool will crash when initializing them all at once. For this reason Ive<br>implemented this setting to break up large numbers of special pads to scan into<br>smaller bits which requires you to run the alternative initializing macro more than once.<br>The maximum supported amount of special tokens on one map is 1000 so the default<br>setting (500) will require you to run the init macro at most twice. <br><br><b>Change this when:<\/b> This number of pads to scan in one run might be too<br>much for older pcs and Maptool might crash. If this is the case lower the setting.<br><\/html>\">Maximum of pads to scan per run<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.UtilityMove_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'maxGroupSelect|'+maxGroupSelect+'|<html><span title=\"<html>This setting is used for the group selection feature, specifically the panel. If a too large selection is made (>1000) MT crashes.<br>In addition the tool will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default<br>is 500 but you can lower (to speed things up) or up (to allow bigger selections) then number to a max of 1000 (at your own risk)<\/html>\">Maximum allowed group selection<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.MapCreation_)\t\t\t\t\t\t\t\t:inputStr\t= json.append(inputStr, 'maxOrderSelect|'+maxOrderSelect+'|<html><span title=\"<html>This setting is used for the order selection panel. If a too large selection is made (roughly over 500) MT crashes. In addition the tool<br>will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default is 200 but you<br>can lower (to speed things up) or up (to allow bigger selections) then number to a max of 500 (at your own risk)<\/html>\">Maximum allowed order selection<\/html><\/span><\/html>')]\n\t[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_)\t:inputStr\t= json.append(inputStr, 'padNameList|'+padNameList+'|<html><span title=\"<html>This is the entire list of special pads. If you remove any of this list then these will not be initialized.<br>If you somehow have messed this up, clear the entire box click OK and then run OCL. <\/html>\">Special Pads List<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n}]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[H: excludedMaps = \"[]\"]\n[h,if(bot.fg.Transportation_ || bot.fg.EventTokenArea_), CODE:{\n\t[foreach(map, allMaps), code: {\n\t\t[if(eval(\"map\"+roll.count)): excludedMaps = json.append(excludedMaps,map)]\n\t}]\n}]\n\n\n[h,if(startUpCoords == 0): startUpCoords = \"0,0\"]\n\n[h,if(!summonPropTypesList): summonPropTypesList = \"\"]\n[h,if(!summonSpecialList): summonSpecialList = \"\"]\n\n\n[h,foreach(trigger, triggerEventList):set(trigger, listGet(macroNameList, eval(trigger)))]\n\n\n[h,if(oldFSB != fullScreenBroadcast):broadcast(\"You have changed the broadcast setting. For this to take effect you will need to RELOAD the campaign. Note that its a bad idea to run oncampaignload in this case, you really need to reload the campaign!\")]\n\n[H:setLibProperty(\"useStartUpMap\",useStartUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpMap\",startUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpCoords\",startUpCoords,\"lib:EventMacros\")]\n[H:setLibProperty(\"useCentreOnMePad\",useCentreOnMePad,\"lib:EventMacros\")]\n[H:setLibProperty(\"runSwitchForm\",runSwitchForm,\"lib:EventMacros\")]\n[H:setLibProperty(\"disableOCLCheck\",disableOCLCheck,\"lib:EventMacros\")]\n\n[H:setLibProperty(\"excludedMaps\",excludedMaps,\"lib:EventMacros\")]\n[h:setLibProperty(\"useAltImage\", useAltImage,\"lib:EventMacros\")]\n[h:setLibProperty(\"checkMapsOCL\", checkMapsOCL,\"lib:EventMacros\")]\n[h:setLibProperty(\"showGroupPanelOnSelect\", showGroupPanelOnSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"fullScreenBroadcast\", fullScreenBroadcast,\"lib:EventMacros\")]\n[h:setLibProperty(\"numericIdOnly\", numericIdOnly, \"lib:EventMacros\")]\n[h:setLibProperty(\"forceRoomShare\", forceRoomShare, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"baseMapName\", baseMapName,\"lib:EventMacros\")]\n[h:setLibProperty(\"excludeLightTypes\",excludeLightTypes, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"animationPerClient\", animationPerClient,\"lib:EventMacros\")]\n[h:setLibProperty(\"timeLockDelay\", timeLockDelay, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"invisState\",invisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"seeInvisState\",seeInvisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"purgeInvisState\",purgeInvisState,\"lib:EventMacros\")]\n[h:setLibProperty(\"annulInvisState\",annulInvisState,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"summonPcPropType\", summonPcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonNpcPropType\", summonNpcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonPropTypesList\", summonPropTypesList,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonSpecialList\", summonSpecialList,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"libCoordSize\", libCoordSize, \"lib:EventMacros\")]\n[h:setLibProperty(\"maxPadsPerRun\", maxPadsPerRun,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxGroupSelect\", maxGroupSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxOrderSelect\", maxOrderSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"padNameList\", padNameList, \"lib:EventMacros\")]\n\n[h:doVBLStamp = if(doVBLStamp && vblSupport, 1, 0)]\n\n\n[h, if(getStrProp(\"toggles\", \"drawArea\") == \"\"), CODE:{\n\t[drawArea\t= 0]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n}]\n\n[h:toggles = strPropFromVars(\"forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doInvisibility, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\nSettings done.",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d83f1cc1-5358-4c4c-8119-6395282322cf",
          "commandChecksum": "cf5d2d21c642f453758c9ac2d185842b",
          "propsChecksum": "b969082bf3087cc1ccc82a2f0803139b"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 427,
        "label": "createMacroButtonsOTMSetup",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'']\n\n[h:'']\n[h:menuButtons\t= getLibProperty(\"bot.fg.MenuButtons\", \"lib:OnTokenMove\")]\n[h:varsFromStrProp(menuButtons)]\n\n[h:tableExists\t= if(listContains(json.toList(json.get(getInfo(\"campaign\"),\"tables\")), \"tbl_Image\"),1,0)]\n[h, if(tableExists): shadow = tblImage(\"tbl_Image\",2) ; shadow = \"\"]\n\n[h: macroGroup\t=\t\"<table width=100% cellpadding=0 cellspacing='1' color='white' bgcolor='black'><td align=center><b>%{groupTitle}<\/b><\/td><\/table>\" + \n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='black'>\" +\n\t\t\t\t\t\"<table width=100% cellpadding=0 cellspacing='1' bgcolor='#e5e5cc'>\" +\n\t\t\t\t\t\"<table width=100%><tr>\"\n]\n[h: macroNewLine\t= \"<\/tr><\/table><table width=100%><tr>\"]\n[h: macroGroupEnd\t= \"<\/tr><\/table><\/table><\/table><\/tr><\/td><tr><\/tr><tr><td>\"]\n\n<html><body bgcolor=\"#e5e5cc\" style=\"font-size:8.5px; text-align:center\">\n<table width=\"100%\" cellpadding=\"0\" cellspacing=\"0\"><tr><td>\n\t<table width=\"100%\"><tr><td bgColor = \"#e5e5cc\" align=\"center\">\n\t\t<span color=\"black\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Setup<\/b>\" ,\"MacroButtonsOTMSetup@this\",\"none\")]<\/span>\n\t\t<\/td><td bgColor = \"#c5c5ac\" align=\"center\">\n\t\t<span color=\"gray\"\tstyle=\"text-decoration:none\">[r:macroLink(\"<b>Utils<\/b>\" ,\"MacroButtonsOTMUtils@this\",\"none\")]<\/span>\n\t<\/td><\/tr><\/table>\n\t<\/td><\/tr><tr><td>\n\n\n\n\n[h:varsFromStrProp(getLibProperty('bot.fg.menuMacroList',  'lib:OnTokenMove'))]\n\n[r, if(listCount(basicsList)), CODE:{\n\t[h:groupTitle\t= \"Basics\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, basicsList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(basicsList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(animationList)), CODE:{\n\t[h:groupTitle\t= \"Animation\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, animationList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(animationList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(soundList)), CODE:{\n\t[h:groupTitle\t= \"Sound\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, soundList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(soundList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(scatterList)), CODE:{\n\t[h:groupTitle\t= \"Scatter & Canopy\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, scatterList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(scatterList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(eventList)), CODE:{\n\t[h:groupTitle\t= \"Event Pads/<font color=#FFFF00>Areas<\/font> (Traps & Pits)\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, eventList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(eventList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(assignList)), CODE:{\n\t[h:groupTitle\t= \"Assign Pads\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, assignList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(assignList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(tablesList)), CODE:{\n\t[h:groupTitle\t= \"Tables\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, tablesList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(tablesList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(mapList)), CODE:{\n\t[h:groupTitle\t= \"Map Editor\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, mapList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(mapList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]\n\n[r, if(listCount(utilsList)), CODE:{\n\t[h:groupTitle\t= \"Utils\"]\n\t[r:strformat(macroGroup)]\n\t[r,foreach(btn, utilsList, \"\"):decode(eval(btn)) + if(odd(roll.count)&&roll.count+1!=listCount(utilsList), macroNewLine, \"\")]\n\t[r:macroGroupEnd]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "02642ea5-2c42-4ad8-b082-ef48be9730fb",
          "commandChecksum": "5c6079f3aef8c04e1feeaef2947fd4ec",
          "propsChecksum": "07b98f72be944f3048b1c2d5d95b297d"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "orange",
        "group": "2",
        "includeLabel": false,
        "sortBy": "2",
        "index": 435,
        "label": "updateVirtualMenu",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n\n\n[h:groupSettings   = getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')]\n[h:varsFromStrProp(groupSettings,'suffixed')]\n\n\n\n\n\n[h:utilAnimationList = '']\n\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Door')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Doors')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'Lock')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'ClearSound')]\n[h, if(bot.fg.MapCreation_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveCrowd')]\n[h, if(bot.fg.MapCreation_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveCrowdP')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'MoveToken')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'AnimateText')]\n[h, if(bot.fg.Animations_):utilAnimationList \t\t= listAppend(utilAnimationList,'runAnimateView')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'ResetPit')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'UnShowAreaUtil')]\n[h, if(bot.fg.EventTokenArea_):utilAnimationList\t= listAppend(utilAnimationList,'ExecuteEvent')]\n[h, if(bot.fg.Other_):utilAnimationList = listAppend(utilAnimationList,'ExecAssignpad')]\n\n[h:utilUtilList = '']\n\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'DiceBox')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SwitchMap')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SeekToken')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'SetLightSource')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'UseDisguise')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ToggleSpecial')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ShowHandout')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'WhisperFrame')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'MessageMngr')]\n[h, if(bot.fg.MapCreation_):utilUtilList = listAppend(utilUtilList,'SetDrawOrder')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'GroupMove')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'UngroupMove')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'Formations')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'ActivateGroup')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'GroupSelect')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'UngroupSelect')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'toggleEmbark')]\n[h, if(bot.fg.MapCreation_):utilUtilList = listAppend(utilUtilList,'SummonTokens')]\n[h, if(bot.fg.VBL_):utilUtilList = listAppend(utilUtilList,'ToggleVBL')]\n[h, if(bot.fg.VBL_):utilUtilList = listAppend(utilUtilList,'VBLGrenade')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'LockMovement')]\n[h, if(bot.fg.UtilityMove_):utilUtilList = listAppend(utilUtilList,'LockToken')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):utilUtilList = listAppend(utilUtilList,'moveEventToggle')]\n[h, if(bot.fg.UtilityGeneral_):utilUtilList = listAppend(utilUtilList,'ShowDescription')]\n\n[h:utilInvisList = '']\n\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'StartInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'EndInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'SeeInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'SawInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'PurgeInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'PurgedInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'AnulInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'AnulledInvis')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'resetRanges')]\n[h, if(bot.fg.UtilityMove_):utilInvisList = listAppend(utilInvisList,'changeElevation')]\n\n\n\n\n\n[h:basicsList = '']\n\n[h, if(1):basicsList = listAppend(basicsList,'Settings')]\n[h, if(1):basicsList = listAppend(basicsList,'BoTFeatures')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):basicsList = listAppend(basicsList,'InitializePads')]\n[h, if(bot.fg.UtilityMove_ || bot.fg.Transportation_ || bot.fg.EventTokenArea_):basicsList = listAppend(basicsList,'AltInitPads')]\n[h, if(1):basicsList = listAppend(basicsList,'Manual')]\n\n[h:animationList = '']\n\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'SetDoor')]\n[h, if(bot.fg.EventTokenArea_):animationList = listAppend(animationList,'SetRoof')]\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'setAnimateView')]\n[h, if(bot.fg.Animations_):animationList = listAppend(animationList,'linkViewAnim')]\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.Other_ || bot.fg.Animations_):animationList = listAppend(animationList,'ActivateSwitches')]\n\n[h:soundList = '']\n\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'ClearSound')]\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'ReplaceSoundURL')]\n[h, if(bot.fg.Animations_):soundList = listAppend(soundList,'SetSound')]\n\n[h:scatterList = '']\n\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'BuildForest')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ChooseTrunks')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'CreateCrowd')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ChooseCrowd')]\n[h, if(bot.fg.MapCreation_):scatterList = listAppend(scatterList,'ScatterTokens')]\n[h, if(bot.fg.VBL_):scatterList = listAppend(scatterList,'MassVBL')]\n\n[h:eventList = '']\n\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'DrawArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'SetEventPad')]\n[h, if(bot.fg.EventTokenArea_ || bot.fg.MapCreation_):eventList = listAppend(eventList,'FillArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'ResetPit')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'DefineArea')]\n[h, if(bot.fg.UtilityGeneral_):eventList = listAppend(eventList,'SetEventButton')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'AssignArea')]\n[h, if(bot.fg.EventTokenArea_):eventList = listAppend(eventList,'UnShowArea')]\n\n[h:assignList = '']\n\n[h, if(bot.fg.Other_):assignList = listAppend(assignList,'AssignTokens')]\n[h, if(bot.fg.Other_):assignList = listAppend(assignList,'Execute')]\n\n[h:tablesList = '']\n\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'CreateTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'ShowTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'DeleteTable')]\n[h, if(bot.fg.Tables_):tablesList = listAppend(tablesList,'CreateMTTable')]\n\n[h:mapList = '']\n\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MapEditor')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'QuitMapEditor')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MovetoHidden')]\n[h, if(bot.fg.MapCreation_):mapList = listAppend(mapList,'MovetoToken')]\n\n[h:utilsList = '']\n\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SeekToken')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetLightSource')]\n[h, if(bot.fg.EventTokenArea_):utilsList = listAppend(utilsList,'SetReference')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Remove20')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetDrawOrder')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'RenumberTokens')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'ToggleSpecial')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'SetTokenSize')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'CopyDelMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'PasteMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'UndoDelMacros')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'FindDuplicates')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'embarkation')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'PadExplorer')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'AutoDisguiseBttn')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'SetVBLStamp')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'MassVBL')]\n[h, if(bot.fg.VBL_):utilsList = listAppend(utilsList,'ToggleVBL')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Deleteprops')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'Benchmark')]\n[h, if(1):utilsList = listAppend(utilsList,'DiagnoseMaps')]\n[h, if(1):utilsList = listAppend(utilsList,'CleanTokNames')]\n[h, if(bot.fg.UtilityGeneral_):utilsList = listAppend(utilsList,'roomDescrHelp')]\n\n[h:menuMacros = strPropFromVars('utilAnimationList,utilUtilList,utilInvisList,basicsList,animationList,soundList,scatterList,eventList,assignList,tablesList,mapList,utilsList','unsuffixed')]\n[h:setLibProperty('bot.fg.menuMacroList', menuMacros, 'lib:OnTokenMove')]",
        "maxWidth": "",
        "tooltip": "this builds the macro menu corresponding to the installation settings",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "6f276ec7-bac3-43c0-947e-95cf9ac0e640",
          "commandChecksum": "097819ec944005e271d0a7e67f865fc5",
          "propsChecksum": "72f63a0e9626d6145c1ce961c92dbeb5"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "red",
        "group": "1a",
        "includeLabel": false,
        "sortBy": "1a",
        "index": 436,
        "label": "diagnoseFeatures",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n\n[h:groupSettings   = getLibProperty('w42.bot.fg.GroupSettings', 'lib:EventMacros')]\n[h:varsFromStrProp(groupSettings,'suffixed')]\n\n\n\n\n[h:diagStateArray = '[]']\n[h, if(bot.fg.Animations_):diagStateArray = json.append(diagStateArray,'isButton')]\n[h, if(bot.fg.Animations_):diagStateArray = json.append(diagStateArray,'Locked')]\n[h, if(bot.fg.UtilityMove_):diagStateArray = json.append(diagStateArray,'pathFeet')]\n[h, if(bot.fg.EventTokenArea_):diagStateArray = json.append(diagStateArray,'Special Area')]\n[h, if(bot.fg.MapCreation_):diagStateArray = json.append(diagStateArray,'Prone')]\n[h, if(bot.fg.MapCreation_):diagStateArray = json.append(diagStateArray,'editFieldMarker')]\n\n[h:diagTokenArray = '[]']\n[h, if(bot.fg.Animations_):diagTokenArray = json.append(diagTokenArray,'DoorLeverToken')]\n[h, if(bot.fg.UtilityMove_):diagTokenArray = json.append(diagTokenArray,'blue feet')]\n[h, if(bot.fg.UtilityMove_):diagTokenArray = json.append(diagTokenArray,'red feet')]\n[h, if(bot.fg.EventTokenArea_):diagTokenArray = json.append(diagTokenArray,'Area Marker')]\n[h, if(bot.fg.MapCreation_):diagTokenArray = json.append(diagTokenArray,'GridCoordMarker')]\n[h, if(bot.fg.UtilityGeneral_):diagTokenArray = json.append(diagTokenArray,'VPCU')]\n\n[h:diagTableArray = '[]']\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'tbl_Image')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'Polymorph')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'encounters')]\n[h, if(bot.fg.UtilityGeneral_):diagTableArray = json.append(diagTableArray,'frames')]\n\n\n[h:diagStateList = '']\n[h, if(bot.fg.Animations_):diagStateList = listAppend(diagStateList,'the switch buttons to operate doors')]\n[h, if(bot.fg.Animations_):diagStateList = listAppend(diagStateList,'doors so the gm can lock them (doors will NOT work without this state)')]\n[h, if(bot.fg.UtilityMove_):diagStateList = listAppend(diagStateList,'path tracking (blue and red feet)')]\n[h, if(bot.fg.EventTokenArea_):diagStateList = listAppend(diagStateList,'creating special areas (like movement limitation)')]\n[h, if(bot.fg.MapCreation_):diagStateList = listAppend(diagStateList,'used for the Crowd utility')]\n[h, if(bot.fg.MapCreation_):diagStateList = listAppend(diagStateList,'used for Map Editor Utility')]\n\n[h:diagTokenList = '']\n[h, if(bot.fg.Animations_):diagTokenList = listAppend(diagTokenList,'the switch buttons to operate doors')]\n[h, if(bot.fg.UtilityMove_):diagTokenList = listAppend(diagTokenList,'path tracking (the PC track)')]\n[h, if(bot.fg.UtilityMove_):diagTokenList = listAppend(diagTokenList,'path tracking (the NPC track)')]\n[h, if(bot.fg.EventTokenArea_):diagTokenList = listAppend(diagTokenList,'creating special areas (like movement limitation)')]\n[h, if(bot.fg.MapCreation_):diagTokenList = listAppend(diagTokenList,'the transparent field tokens required for the Map Editor')]\n[h, if(bot.fg.UtilityGeneral_):diagTokenList = listAppend(diagTokenList,'a token required as placeholder when using the Embarkation macros (vehicles)')]\n\n[h:diagTableList = '']\n[h, if(bot.fg.EventTokenArea_ || bot.fg.UtilityMove_ || bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Roofs - Formations - Dicebox - Room Descriptions')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Aliasmask Polymorph (table is only necessary if you want to access images from that table)')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Nildiks Room Description  (table is only necessary if you want to access images from that table)')]\n[h, if(bot.fg.UtilityGeneral_):diagTableList = listAppend(diagTableList,'Nildiks Fancy Frames and Room Description')]\n\n[h:diagArrays = strPropFromVars('diagStateArray,diagTokenArray,diagTableArray','unsuffixed')]\n[h:diagLists = strPropFromVars('diagStateList ,diagTokenList ,diagTableList','unsuffixed')]\n[h:setLibProperty('bot.fg.diagArrays', diagArrays, 'lib:OnTokenMove')]\n[h:setLibProperty('bot.fg.diagLists', diagLists, 'lib:OnTokenMove')]\n\nDiagnose settings have been updated",
        "maxWidth": "",
        "tooltip": "create DB for dependency check for features",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4b71c4c4-6abf-4c80-955e-f4d690258ae4",
          "commandChecksum": "9696027330441fb671ede1d00cc9ba36",
          "propsChecksum": "c0b048ba019b21a60329e7f7c0741a97"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "10",
        "includeLabel": false,
        "sortBy": "10",
        "index": 437,
        "label": "settings BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[h:assert(isGM(), \"Only a GM can modify the settings\",0)]\n\n\n[h:useAltImage\t\t\t= getLibProperty('useAltImage','lib:EventMacros')]\n[h:checkMapsOCL\t\t\t= getLibProperty('checkMapsOCL','lib:EventMacros')]\n[h:showGroupPanelOnSelect= getLibProperty('showGroupPanelOnSelect','lib:EventMacros')]\n[h:fullScreenBroadcast\t= getLibProperty('fullScreenBroadcast','lib:EventMacros')]\n[h:oldFSB\t\t\t\t= fullScreenBroadcast]\n[h:numericIdOnly\t\t= getLibProperty('numericIdOnly', 'lib:EventMacros')]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n[h:baseMapName\t\t\t= getLibProperty('baseMapName','lib:EventMacros')]\n[h:excludeLightTypes\t= getLibProperty('excludeLightTypes','lib:EventMacros')]\n[h:haloColors\t\t\t= 'red,dark gray, yellow, blue, black, white,light gray,teal,none']\n[h:onLineClients\t\t= listInsert(json.toList(bot_nself()),0,\"\")]\n\n\n[h:animationPerClient\t= getLibProperty('animationPerClient','lib:EventMacros')]\n[h:timeLockDelay\t\t= getLibProperty('timeLockDelay','lib:EventMacros')]\n\n\n[h:summonPcPropType\t\t= getLibProperty('summonPcPropType','lib:EventMacros')]\n[h:summonNpcPropType\t= getLibProperty('summonNpcPropType','lib:EventMacros')]\n[h:summonPropTypesList\t= getLibProperty('summonPropTypesList','lib:EventMacros')]\n[h:summonSpecialList\t= getLibProperty('summonSpecialList','lib:EventMacros')]\n\n\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:varsFromStrProp(getLibProperty('toggles','lib:EventMacros'))]\n\n[h:roofHaloColor\t\t= max(0,listFind(haloColors, roofHaloColor))]\n[h:forceSelectClient\t= max(0,listFind(onLineClients, forceSelectClient))]\n\n\n[h:useStartUpMap\t\t= getLibProperty('useStartUpMap','lib:EventMacros')]\n[h:startUpMap\t\t\t= getLibProperty('startUpMap','lib:EventMacros')]\n[h:startUpCoords\t\t= getLibProperty('startUpCoords','lib:EventMacros')]\n[h:useCentreOnMePad\t\t= getLibProperty('useCentreOnMePad','lib:EventMacros')]\n[h:runSwitchForm\t\t= getLibProperty('runSwitchForm','lib:EventMacros')]\n[h:disableOCLCheck\t\t= getLibProperty('disableOCLCheck','lib:EventMacros')]\n\n\n[h:libCoordSize\t\t\t= getLibProperty('libCoordSize', 'lib:EventMacros')]\n[h:maxPadsPerRun\t\t= getLibProperty('maxPadsPerRun','lib:EventMacros')]\n[h:maxGroupSelect\t\t= getLibProperty('maxGroupSelect','lib:EventMacros')]\n[h:maxOrderSelect\t\t= getLibProperty('maxOrderSelect','lib:EventMacros')]\n[h:padNameList \t\t\t= getLibProperty('padNameList', 'lib:EventMacros')]\n\n\n[h:startUpMapList\t\t= getAllMapNames()]\n[h:startUpMapNum\t\t= listFind(startUpMapList,startUpMap)]\n[h:baseMapNum\t\t\t= listFind(startUpMapList,baseMapName)]\n\n\n[h:oldMap\t\t\t\t= getCurrentMapName()]\n\n[h,if(baseMapNum == -1), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|The map with lib:EventMacros does not exist. Pls select the correct one|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n}]\n[h:setCurrentMap(baseMapName)]\n\n[h,if(findToken(\"lib:EventMacros\") == \"\"), CODE:{\n\t[input('baseMapNum|'+startUpMapList+'|<html>Lib:EventMacros is NOT on map: <b>'+baseMapName+'<\/b>. Please select the map where Lib:EventMacros is on|LIST')]\n\t[baseMapName = listGet(startUpMapList, baseMapNum)]\n\t[setCurrentMap(baseMapName)]\n}]\n[h:assert(findToken(\"lib:EventMacros\") != \"\", \"<font color=red>No Lib:EventMacro found on map <b>\"+baseMapName+\"<\/b> please correct this.\",0)]\n[h:macroIDList\t\t= getMacroGroup(\"Event list macros\", \",\", \"lib:EventMacros\")]\n[h:macroNameList\t= \"<none>\"]\n[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n\n[h:triggerEventList = \"eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport\"]\n[h,foreach(trigger, triggerEventList): set(trigger, listFind(macroNameList, eval(trigger)))]\n\n[h:inputStr\t= json.append(\"\", \"tab1|<html><b>General<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Settings<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'useAltImage|'+useAltImage+'|<html><span title=\"<html>When checked, the system will first check whether there is a token handout image on the foliage token. <br>If so it will swap the original image for that one, if not it will grab the table image. <br>Unchecked, the system will automatically grab the tbl image<\/html>\">Use alternative transparent image for foliage<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'checkMapsOCL|'+checkMapsOCL+'|<html><span title=\"<html><b>When checked:<\/b> the system will check all the maps when you load the campaign,<br>to see if they appear in the pad database. This is not a full initialization but it will<br>prevent bug reports after you load the campaign and if any inconsistancies are<br>found it will initialize the campaign file. What you will notice is that MT will<br>quickly flick through all the maps when you load the campaign.<br><b>When unchecked:<\/b> no checks are made so nothing will happend when you load the<br>campaign file.<\/html>\">Check all maps on start up<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSwitchInterMap|Change to other map, do not change to other map, do not change AND store coords|<html><span title=\"<html><b>Change to other map<\/b>: When using inter map teleport, switch to the map after teleportation<br><b>do not change to other map<\/b>: do NOT switch to destination map after teleportation<br><b>do not change AND store coords<\/b>: when using the do NOT switch map option, the system needs to<br>check the destination pad for the correct coords before sending the token there and then return to<br>the current map. This causes maptool to reload the current map. To prevent this you can use this third<br>option, which will store the coords of both pads on eachother during the <i>initialize pads<\/i> process.<br><b>BUT<\/b> that means that you CANNOT move the interPads without running <i>initialize maps<\/i> again.<\/html>\">Automatically swap to map for interpads<\/html><\/span><\/html>|RADIO|SELECT='+doSwitchInterMap)]\n[h:inputStr\t= json.append(inputStr, 'doScaleTeleport|'+doScaleTeleport+'|<html><span title=\"<html><b>When checked:<\/b> teleportation will keep track of different size teleports<br>This means that if you move to the lower right corner of a small pad you and up<br>on the lower right corner of a larger pad. <br><b>When unchecked:<\/b>teleportation will be relative to the upper left corner<br>of the teleport. So if you move from the lower right corner of a 4x4 to a 2x2<br>pad, then you will end up 2 squares down and 2 squares right OUTSIDE the 2x2 pad.<br>Mb<NOTE:<\/b> turning this on is tricky! E.g. if you make one of 2 vertical border pads<br>twice as thick as the other, and you move 6 squares over the pad, then you will<br>end up 12 (or 3 depending on the direction) beyond the other teleport!<br><\/html>\">Scale Teleportation<\/html><\/span><\/html>|CHECK')]\n\n[h:inputStr = json.append(inputStr, 'showGroupPanelOnSelect|'+showGroupPanelOnSelect+'|<html><span title=\"<html>When you select a <i>group<\/i> AND the <i>activate switch panel<\/i> is active<br>automatically show the group macro panel<\/html>\">Show group panel on select<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'fullScreenBroadcast|'+fullScreenBroadcast+'|<html><span title=\"<html>When you check this then the broadcast function will be redefined. Next to its<br>usual function it will ALSO broadcast to a dialog window called <i>Last Chat<\/i><br>but ONLY when the full screen mode is toggled (see campaign macros or F2). This<br>will result in a dialog popping up in full screen mode showing the last message<br>send to chat, using the broadcast function.<br><b>Important note:<\/b> currently its not possible to check whether a client is in<br>full screen or not, this means that this toggle is set for ALL clients.<\/html>\">Redefine <i>Broadcast<\/i> for full screen mode<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'numericIdOnly|'+numericIdOnly+'|<html><span title=\"<html>When you check this then ONLY special pads like Roof, Ward, PadStart, etc.<br>followed by a number (e.g. 1,2,3) will be identified as a special pad. E.g. <u>Roof 1<\/u><br>is recognized as a special pad and <u>Roof Red Barn<\/u> not. If you UNCHECK this<br>then <u>Roof Barn Red<\/u> WILL be identified as a special pad. As usual <i>linked<\/i> pads<br>require the SAME identifier. So <u>PadStart Sea Level<\/u> will be connected to<br><u>PadEnd Sea Level<\/u> (IF the box is unchecked!)<br><b>Note that Linked Pads will NOT work when this is checked<\/b><\/html>\">Numeric Id for special pads only (disable Links!)<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'forceRoomShare|Send macro link to chat, Force share on screen, do both|<html><span title=\"<html><b>Send macro link to chat<\/b>: When using Nildiks room description token, <br>when you click on a <i>share<\/i> link, a macro link is sent to the chat that<br>players can click on to open the frame with the shared information.<br><b>Force share on screen<\/b>: Instead of sending a macro link, the<br>information is immediately opened on the screen of the players.<br><b>Both<\/b>: The information is immediately shown on the players screen<br>AND a click-able macro link is sent to the chat.<\/html>\">When sharing a Room Description<\/html><\/span><\/html>|RADIO|SELECT='+forceRoomShare)]\n\n[h:inputStr = json.append(inputStr, 'baseMapName|'+startUpMapList+'|<html><span title=\"<html>The use of the Canopty option requires a BASE map where the treetrunks are situated. per default this Map is called BASE, here you can give it a different name.<\/html>\">Name of BASE Map<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+baseMapNum)]\n[h:inputStr = json.append(inputStr, 'excludeLightTypes|'+excludeLightTypes+'|<html><span title=\"<html>Here you can enter one or more light <u>types<\/u> seperated by a comma (,) (e.g.: Generic, D20) that you dont want to show up as a tab in the Set Light Source macro<\/html>\">Exclude Light Types<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'roofHaloColor|'+haloColors+'|<html><span title=\"<html>Here you can set the color of the halo for the Roof special pad<\/html>\">Set Roof halo color<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+roofHaloColor)]\n[h:inputStr = json.append(inputStr, 'forceSelectClient|'+onLineClients+'|<html><span title=\"<html>If you select a client (player pc) from this list then when a gm selects a token<br>on a map that same token will also be selected on the chosen clients side. This <br>is particularly usefull in a laptop beamer setup where you have one single GM <br>client and one single players client to show the map. <br><br>Note that if a previously set (player) client does not exist when this campaign<br>is loaded then this value will be reset to empty and you need to run settings <br>again to select the client.<\/html>\">Force Token Selection on Client<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+forceSelectClient)]\n\n[h:inputStr\t= json.append(inputStr,\"junk|<html><b>Animations<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'animationPerClient|'+animationPerClient+'|<html><span title=\"<html>Animations like for the doors and the token movement will have an instance running<br>on eacht seperate client. This because the network connection of the server is<br>usually not fast enough to send updates of the animated object to the clients. This<br>requires a copy of the animated token on each client which is visible to the owner only.<br>This copy is removed from the client as soon as the animation is over.<br><i>Visible to owner only<\/i> will only work if <i>strict token ownership<\/i> is checked<br>for the running server. If its not set, then all the copies of all the clients are<br>visible on all the other clients as well. This will look messy. Hence this option to<br>run the animation on the server only.<br><b>When checked:<\/b> Animations will be played on each client<br><b>When unchecked:<\/b> Animations will be played on the server only<br><\/html>\">Run animations per client<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'timeLockDelay|'+timeLockDelay+'|<html><span title=\"<html>When using the token buttons to open or close doors then the onTokenSelectionEvent is<br>triggered. Unfortunately its triggered more than once. With the effect that the door<br>opens, closes, opens etc. To prevent this Ive created a time-out in which the event is<br>ignored. If this time is too short you will notice the door open-close event triggering<br>multiple times. If you set if to slow then you have to wait that time before you can<br>use the button again. The time is in ms meaning that 1000 = 1 second. If you encounter<br>the problem of the door animation triggering multiple times when you click the door<br>button then you should set this timer higher, e.g. to 1000. <\/html>\">Time lock delay for token buttons (ms)<\/html><\/span><\/html>')]\n\n[h:inputStr\t= json.append(inputStr,\"junk|<html><b>Summon Token Macro<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'summonPcPropType|'+summonPcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of PCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of PCs<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonNpcPropType|'+summonNpcPropType+'|<html><span title=\"<html>The Summon token macro will show dropdowns of PCs and NPCs, <br>here you can set the the property type of NPCs. Usually this <br>type is called Basic. <\/html>\">Set Property Type of NPCs<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonPropTypesList|'+summonPropTypesList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will also generate a dropdownbox for any tokenproperty<b><u>type<\/b><\/u> that <br>is listed here<\/html>\">List of Summon Token Property Types<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'summonSpecialList|'+summonSpecialList+'|<html><span title=\"<html>Here you can setup the Summon Token macro. Summon token will show dropdowns of <br>(n)pcs and will generate a dropdownbox for listed tokenproperties. In addition <br>here you can set Token Names which you want to let appear in a seperate Dropdownbox. <br>Here its used for the special pad names, but it can be used for other purposes<\/html>\">List of Summon Token Special<\/html><\/span><\/html>')]\n\n\n\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>On Campaign Load<\/html>||TAB\")]\n[h:inputStr\t= json.append(inputStr, \"junk|<html><b>Stuff that happens when you load the campaign<\/b><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'useStartUpMap|'+useStartUpMap+'|<html><span title=\"<html><b>When checked:<\/b> the below two settings (load map on start up and go to coordinates) will be used.<\/html>\">Use Start Up map and coordinates<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'startUpMap|'+startUpMapList+'|<html><span title=\"<html>Pick here the name that should be loaded on campaign load or when players log in.<\/html>\">Set map to open at start up<\/html><\/span><\/html>|LIST|VALUE=STRING SELECT='+startUpMapNum)]\n[h:inputStr = json.append(inputStr, 'startUpCoords|'+startUpCoords+'|<html><span title=\"<html>Set here the coordinates which the map will be centred on campaign load<br>or when players log in. You can see the coordinates of your cursor on the<br>map in the lower right corner of Maptool. Example (X,Y): <b>5,4<\/b>.<br><br>Alternatively you can also enter a <b>token name<\/b>, however when you do that<br>make sure that the name does not contain any comma(s): <i>,<\/i><\/html>\">Set coordinates to centre map on start up.<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'useCentreOnMePad|'+useCentreOnMePad+'|<html><span title=\"<html>This setting will override the coordinates unless the CentreOnMePad<br>is not found on the map. When you check this setting then on start up<br>the map will be centred onto this token for all clients.<\/html>\">Centre on CentreOnMePad on start up.<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'runSwitchForm|'+runSwitchForm+'|<html><span title=\"<html><b>When checked: <\/b>the form that you need to start so door switches work, <br>will start automatically on campaign load .<\/html>\">Start door switches form<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'disableOCLCheck|'+disableOCLCheck+'|<html><span title=\"<html><b>When checked: <\/b>The boT check result* shown in the chat<br>after you have loaded the campaign, will be turned OFF.<br><br>*Thats the red-yellow colored bar called:<br><i>Bag of Tricks - OnCampaignLoad checks<\/i><\/html>\">Disable OCL Checks<\/html><\/span><\/html>|CHECK')]\n\n\n\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>Exclusions<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Which maps should be excluded from the Initialization<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:allMaps\t= listSort(getAllMapNames(),\"N+\")]\n[H:excludedMaps\t= getLibProperty(\"excludedMaps\",\"lib:EventMacros\")]\n[H, if(json.isEmpty(excludedMaps)): excludedMaps = \"[]\"]\n[h,foreach(map, allMaps), CODE:{\n\t[H: isExcluded\t= json.contains(excludedMaps,map)]\n\t[H: inputStr\t= json.append(inputStr,strformat(\"map%{roll.count}|%{isExcluded}|%{map}|CHECK\"))]\n}]\n\n\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Which propertyTYPES should NOT trigger the onTokenMoveEvent<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'excludePropertyTypes|'+excludePropertyTypes+'|<html><span title=\"<html>Here you can enter one or more property types that will NOT trigger the onTokenMoveEvent.<br>Token property types can be set in menu-->edit-->campaign properties-->Token Properties.<br>There you find a list of the token properties for your campaign. Per default you will find the<br> Basic property type there. A property type for a token you can set by double clicking on<br>a token-->config tab-->Properties. That field contains a dropdown menu where you can choose <br>the property type for that token. All the Property Types you list in this field will NOT trigger<br>the event when moved. E.g. if you list SpecialPads here and your drag a token with the SpecialPad<br>property type onto a teleport token, then that token will NOT be teleported.<\/html>\">Exclude Property Types<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>Toggles<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can turn off certain checks to speed thing up<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'doGroups|'+doGroups+\t\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off group movement<\/html>\">Group movement<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSnap2Grid|'+doSnap2Grid+\t\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off Snap To Grid. This is mainly<br>interesting for token move animation where you <br>want the tokens to move smoothly, but also have<br>them snapped to grid. When checked this option<br>will snap the last moved token to grid. This only<br>works when Maptools its Snap To Grid is turn off.<\/html>\">Snap To Grid<\/html><\/span><\/html>|CHECK')]\n[h, if(vblSupport == 1):inputStr \t= json.append(inputStr, 'doVBLStamp|'+doVBLStamp+\t'|<html><span title=\"<html>Uncheck to turn off VBL stamps.<br>VBL Stamps are Vision Blocking Layer stamps that work on tokens<br>that have a label set to <i>VBLStamp<\/i>. When a tokens has this<br> word in its label a VBL cross will be drawn over it when it is moved.<br> And that VBL cross will move with the token.<\/html>\">VBL Stamps<\/html><\/span><\/html>|CHECK') ; doVBLStamp = 0]\n[h:inputStr = json.append(inputStr, 'doResetFoW|'+doResetFoW+\t\t\t\t\t'|<html><span title=\"<html>Check to restore ALL Fog of War on every move<\/html>\">Restore FoW<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doVBLCheck|'+doVBLCheck+\t\t\t\t\t'|<html><span title=\"<html><i>This feature is developed by Aliasmask.<\/i><br>It does two things:<br><b>1.<\/b> If a token <i>cuts a corner<\/i> of a vision blocking area,<br>then a warning is given and the token is moved to the spot<br>BEFORE the corner was cut.<br> <b>2.<\/b> Because of the path that the token was dragged along<br>would be cleared of the fog of war (FoW) its movement is<br>reset and the macro clears the FoW.<br> The latter has the HUGE advantage that it also is a work<br>around for the (b87) FoW lag issue! If you have individual<br>FoW turned on for tokens then after a while dragging tokens<br>around can become very laggy. This option solves that issue.<br> The disadvantage is that if you move tokens over a large path<br>then it takes considerably longer (in addition to the normal<br>delay this Bag of Tricks introduces). The delay is not<br>noticeable for short distances but becomes e.g. 1 second<br>when you drag a token over 300 squares.<br>  <\/html>\">VBL move check<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doCentreOnTok|'+doCentreOnTok+\t\t\t\t'|<html><span title=\"<html>Check to continuously centre the map on the moving token.<br>Does not work for multiple moving tokens<\/html>\">Centre on token<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doTriggerOnZeroMove|'+doTriggerOnZeroMove+\t'|<html><span title=\"<html>If you move a token and put it back onto its original spot then,<br>this will trigger the onTokenMoveEvent. If you <b>check<\/b> this box then if<br>a token is standing on a special pad, that pad will be activated.<br><b>Uncheck<\/b> to ignore this zero move.<br><b>Note<\/b> that if you set Waypoints and then return to the original<br>spot, that the token has actually moved and the special pad<br>WILL be activated!<\/html>\">Trigger Pads on zero move<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doSpecialPads|'+doSpecialPads+\t\t\t\t'|<html><span title=\"<html>Uncheck to turn off the special pads entirely (Check Start and Check Path included).<\/html>\">Check special pads<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doLockMovement|'+doLockMovement+\t\t\t'|<html><span title=\"<html>Check to prevent the movement of locked tokens.<br>You can select a token and toggle the <i>lock movement<\/i><br>macro. When a token is locked this way AND when this setting<br>is turned on, the movement of that tokens will always be <br>reverted. Not even the gm can move the token.<br><\/html>\">Lock movement for locked tokens<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doFullScreenMode|'+doFullScreenMode+\t\t'|<html><span title=\"<html>b89+: Check to turn on a isFullScreen check.<br>This will automatically switch the BoT macro panel to<br>full screen mode (showing the panel while in full screen)<br>and back to a dockable frame when not in full screen.<\/html>\">Full Screen Mode<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doShowPath|Do not Track Path, Track Path, Track Path and delete feet manually|<html><span title=\"<html>When Track Path is turned on, small feet will be placed in the cells over which a token is moved. <br>Red feet for NPCs and Blue feet for PCs.<br><br><b>Do not Track Path:<\/b> its turned off <br><b>Track Path:<\/b> its turned on, only the LAST move is shown<br><b>Track Path and delete feet manually:<\/b> for every move feet will be placed in the path. <br>To remove them from the map use the following command: [bot_getPath(3)]<br><br><b><u>Note that 3 conditions MUST BE MET before you toggle this setting:<\/u><\/b><br>1. the blue and red feet must on the BASE map and NOT on the OBJECT layer<br>2. a state <i>pathFeet<\/i> must be created (the feet must have that state)<br>3. BOTH the <i>impersonation and selection panel<\/i> must be closed (or the removal will be <br>extremely slow)<\/html>\">Show the last moved path<\/html><\/span><\/html>|RADIO|SELECT='+doShowPath)]\n[h:inputStr = json.append(inputStr, 'canSelectShadowTok|Object Layer, Token Layer, Token Layer and autoselect Main Token|<html><span title=\"<html>When using shadow pads, you can choose the layer where the shadow tokens are placed:<br>- Object layer: shadow token can not be selected (targeted) by players<br>- Token layer: shadow token *can* be selected (targeted) by players<br>- Token layer (autoselect main): when the shadow token is selected the actual token is selected instead.<br>The latter requires the <i>activate switches<\/i> macro to be running.<\/html>\">Where to place Shadow Tokens<\/html><\/span><\/html>|RADIO|SELECT='+canSelectShadowTok)]\n\n[h:inputStr = json.append(inputStr, \"junk|<html><b>The following toggles work for altInitMap only!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'doFirstPointPath|'+doFirstPointPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token starts its movement on a special pad<br>e.g.(under) canopy, then the token activates the relevant code.<br>E.g. in case of Canopy if the token moves away far enough then it will restore<br>the Canopy picture. Turning this off will result in this check NOT taking place.<br>So Canopy will dissapear but no longer reappear. Turning this off is usefull when<br>you are not using Canopy, Foliage or Roof pads.<\/html>\">Check Start (Canopy, Foliage or Roof)<\/html><\/span><\/html>|CHECK')]\n[h:inputStr = json.append(inputStr, 'doInnerPointsPath|'+doInnerPointsPath+\t'|<html><span title=\"<html>This concerns the special pads. If a token moves over a Ward or EventPad,<br>then the code is activated for that pad encountered. E.g. in case of Ward,<br>the Token is placed on the edge of the ward and the rest of the movement is negated.<br>Turning this off is usefull when you are not using Ward or EventPad pads.<\/html>\">Check Path (Ward, Event)<\/html><\/span><\/html>|CHECK')]\n\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Movement Limiter!<br><\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'limitMovement|'+limitMovement+\t\t\t'|<html><span title=\"<html>Here you can set a number or a token property to which token movement is limited during<br>initiative. Entering e.g. <i>4<\/i> means that the max allowed move is 4 cells. Entering<br><i>movement<\/i> will limit the movement of the token to its <i>movement<\/i> property. You<br>can enter any token property you like as long as that token property contains a number.<br>Should a player in this case move her token 5 or more cells, then they will receive a<br>message and the movement will be reset (so the tokens will be returned to its original<br>position). <br><br><b>Note that this feature will NOT work:<\/b><br>- when the user moving the token is a GM<br>- when the number set here is 0<br>- when the token is NOT in the initiative panel<br><br>Also note that this does not prevent someone from moving her token twice!<br><br><b>The macro that handles this is placed on the lib:EventMacros.<\/b> You can edit<br>this macro to better suit your framework. More explanations you can find there.<\/html>\">Limit movement to: (0 = ignore)<\/html><\/span><\/html>')]\n\n\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>General Events<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can link an event macro to other events<\/b><br>Note that only the macros from the group:<br>'Event list macros' are in the drop downlists<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'eventMacroPreTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnTokenMove event macro is executed.<br>This macro will run before any of the OnTokenMove code is executed<\/html>\">Pre On Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPreMultipleTokenMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME AFTER<br>initialization but BEFORE the OnMultipleTokenMove event macro is executed.<br>This macro will run before any of the OnMultipleTokenMove code is executed<\/html>\">Pre On Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreMultipleTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroOnTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run before any events of the special pads take place<\/html>\">On Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroOnMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run before any events of the special pads take place<\/html>\">On Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroOnMultipleTokensMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostTokenMove|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME ONE token moves.<br>This macro will run after any events of the special pads take place<\/html>\">After Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostTokenMove)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostMultipleTokensMove|'\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro THAT ALWAYS executes EVERYTIME MULTIPLE tokens are moved.<br>This macro will run after any events of the special pads take place<\/html>\">After Multiple Token Move<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostMultipleTokensMove)]\n[h:inputStr = json.append(inputStr, 'eventPreMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport on the same map occurs.<\/html>\">Before Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPreMacroTeleport)]\n[h:inputStr = json.append(inputStr, 'eventPostMacroTeleport|'\t\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport on the same map occurs.<\/html>\">After Teleport on same map<\/html><\/span><\/html>|LIST|SELECT='+eventPostMacroTeleport)]\n[h:inputStr = json.append(inputStr, 'eventMacroPreInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute BEFORE a teleport to another map occurs.<\/html>\">Before Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPreInterTeleport)]\n[h:inputStr = json.append(inputStr, 'eventMacroPostInterTeleport|'\t\t\t+macroNameList+'|<html><span title=\"<html><b>Select an event macro to execute AFTER a teleport to another map occurs.<\/html>\">After Teleport to other map<\/html><\/span><\/html>|LIST|SELECT='+eventMacroPostInterTeleport)]\n\n\n[h:inputStr = json.append(inputStr, \"tab1|<html><b>System<\/html>||TAB\")]\n[h:inputStr = json.append(inputStr, \"junk|<html><b>Here you can set the technical stuff<\/b><br>As a general rule: do not touch unless you <br>know what you are doing<\/html>|-|LABEL|SPAN=TRUE\")]\n[h:inputStr = json.append(inputStr, 'libCoordSize|'+libCoordSize+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>Just do not change this value. Its used for the x/y area size of the lib coords<\/html>\">Lib coords size<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxPadsPerRun|'+maxPadsPerRun+'|<html><span title=\"<html>This setting is used for the alternative initialize map pads macro for a map<br>If you have a map with a LOT of special pads on it (> 500) it is likely that<br>Maptool will crash when initializing them all at once. For this reason Ive<br>implemented this setting to break up large numbers of special pads to scan into<br>smaller bits which requires you to run the alternative initializing macro more than once.<br>The maximum supported amount of special tokens on one map is 1000 so the default<br>setting (500) will require you to run the init macro at most twice. <br><br><b>Change this when:<\/b> This number of pads to scan in one run might be too<br>much for older pcs and Maptool might crash. If this is the case lower the setting.<br><\/html>\">Maximum of pads to scan per run<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxGroupSelect|'+maxGroupSelect+'|<html><span title=\"<html>This setting is used for the group selection feature, specifically the panel. If a too large selection is made (>1000) MT crashes.<br>In addition the tool will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default<br>is 500 but you can lower (to speed things up) or up (to allow bigger selections) then number to a max of 1000 (at your own risk)<\/html>\">Maximum allowed group selection<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'maxOrderSelect|'+maxOrderSelect+'|<html><span title=\"<html>This setting is used for the order selection panel. If a too large selection is made (roughly over 500) MT crashes. In addition the tool<br>will become terribly slow when many are selected. To make sure this is no issue a max limit is set. The default is 200 but you<br>can lower (to speed things up) or up (to allow bigger selections) then number to a max of 500 (at your own risk)<\/html>\">Maximum allowed order selection<\/html><\/span><\/html>')]\n[h:inputStr = json.append(inputStr, 'padNameList|'+padNameList+'|<html><span title=\"<html>This is the entire list of special pads. If you remove any of this list then these will not be initialized.<br>If you somehow have messed this up, clear the entire box click OK and then run OCL. <\/html>\">Special Pads List<\/html><\/span><\/html>|TEXT|WIDTH=30')]\n\n\n[H: abort(input(json.toList(inputStr,\"##\")))]\n\n\n[H: excludedMaps = \"[]\"]\n[h, foreach(map, allMaps), code: {\n\t[H, if(eval(\"map\"+roll.count)): excludedMaps = json.append(excludedMaps,map)]\n}]\n\n\n[h,if(startUpCoords == 0): startUpCoords = \"0,0\"]\n\n[h,if(!summonPropTypesList): summonPropTypesList = \"\"]\n[h,if(!summonSpecialList): summonSpecialList = \"\"]\n\n\n[h,foreach(trigger, triggerEventList):set(trigger, listGet(macroNameList, eval(trigger)))]\n\n\n[h,if(oldFSB != fullScreenBroadcast):broadcast(\"You have changed the broadcast setting. For this to take effect you will need to RELOAD the campaign. Note that its a bad idea to run oncampaignload in this case, you really need to reload the campaign!\")]\n\n[H:setLibProperty(\"useStartUpMap\",useStartUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpMap\",startUpMap,\"lib:EventMacros\")]\n[H:setLibProperty(\"startUpCoords\",startUpCoords,\"lib:EventMacros\")]\n[H:setLibProperty(\"useCentreOnMePad\",useCentreOnMePad,\"lib:EventMacros\")]\n[H:setLibProperty(\"runSwitchForm\",runSwitchForm,\"lib:EventMacros\")]\n[H:setLibProperty(\"disableOCLCheck\",disableOCLCheck,\"lib:EventMacros\")]\n\n[H:setLibProperty(\"excludedMaps\",excludedMaps,\"lib:EventMacros\")]\n[h:setLibProperty(\"useAltImage\", useAltImage,\"lib:EventMacros\")]\n[h:setLibProperty(\"checkMapsOCL\", checkMapsOCL,\"lib:EventMacros\")]\n[h:setLibProperty(\"showGroupPanelOnSelect\", showGroupPanelOnSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"fullScreenBroadcast\", fullScreenBroadcast,\"lib:EventMacros\")]\n[h:setLibProperty(\"numericIdOnly\", numericIdOnly, \"lib:EventMacros\")]\n[h:setLibProperty(\"forceRoomShare\", forceRoomShare, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"baseMapName\", baseMapName,\"lib:EventMacros\")]\n[h:setLibProperty(\"excludeLightTypes\",excludeLightTypes, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"animationPerClient\", animationPerClient,\"lib:EventMacros\")]\n[h:setLibProperty(\"timeLockDelay\", timeLockDelay, \"lib:EventMacros\")]\n\n[h:setLibProperty(\"summonPcPropType\", summonPcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonNpcPropType\", summonNpcPropType,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonPropTypesList\", summonPropTypesList,\"lib:EventMacros\")]\n[h:setLibProperty(\"summonSpecialList\", summonSpecialList,\"lib:EventMacros\")]\n\n[h:setLibProperty(\"libCoordSize\", libCoordSize, \"lib:EventMacros\")]\n[h:setLibProperty(\"maxPadsPerRun\", maxPadsPerRun,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxGroupSelect\", maxGroupSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"maxOrderSelect\", maxOrderSelect,\"lib:EventMacros\")]\n[h:setLibProperty(\"padNameList\", padNameList, \"lib:EventMacros\")]\n\n[h:doVBLStamp = if(doVBLStamp && vblSupport, 1, 0)]\n\n\n[h, if(getStrProp(\"toggles\", \"drawArea\") == \"\"), CODE:{\n\t[drawArea\t= 0]\n\t[setLibProperty(\"tmpDraWArea\", \"[]\", \"lib:EventMacros\")]\n}]\n\n[h:toggles = strPropFromVars(\"forceSelectClient,roofHaloColor, doSwitchInterMap,doScaleTeleport,doGroups,doSnap2Grid,doVBLStamp,doResetFoW,doVBLCheck,doTriggerOnZeroMove,doCentreOnTok, doLockMovement, doFullScreenMode, doShowPath, canSelectShadowTok, doSpecialPads, doFirstPointPath, doInnerPointsPath, limitMovement, eventMacroPreTokenMove, eventMacroPreMultipleTokenMove, eventMacroOnTokenMove, eventMacroOnMultipleTokensMove, eventPreMacroTeleport, eventPostMacroTeleport, eventMacroPreInterTeleport, eventMacroPostInterTeleport, eventMacroPostTokenMove, eventMacroPostMultipleTokensMove,movementLock,excludePropertyTypes,drawArea\", \"UNSUFFIXED\")]\n[h:setLibProperty(\"toggles\", toggles,\"lib:EventMacros\")]\nSettings done.",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1ac4babb-94c7-495a-9e9b-3c4f334367e9",
          "commandChecksum": "c0831de99314e67fc7b58577d8885878",
          "propsChecksum": "9df64a236a2ad9837db5a3a15ff60cac"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "maroon",
        "group": "1",
        "includeLabel": false,
        "sortBy": "1",
        "index": 438,
        "label": "welcomeInit",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n\n[h:output\t=  strformat(\"%{styleHTML}<html><body><font color=red size=5><b>Welcome<\/b><br><br><\/font><table class='btnformat'><tr><td class='btnformat'>\")]\n\n[h:output\t= output + \"\n<b>Bag of Tricks Features<\/b><br>\nWelcome to the Bag of Tricks. It appears that this is the first time you use it within this campaign file<br>\nTo get you started, click on the link below, this will pop-up the BoT feature list, from which you can choose which features you would like to use of the BoT. Simply check the checkboxes in front of the features you want. <br>\n<br>\n<b>Campaign Panel<\/b><br>\nWhen you select the 'lib:OnTokenMove' token and you look at the 'Selection' Panel, you will see numerous macros. At the top you will see '(drag to) Campaign Macros'. This group of macros you can drag directly to either a token or the campaign panel. This way you can use a certain feature at the click of a button. Please note that if you have not all features turned on, certain macros might not work (but thats easy to find out). The top macro is 'Bag of Tricks Macros'. This specific macro will open a menu with all the relevant macros corresponding with the features you have turned on. So you can always choose to just use that macro only. You can do this after you have chosen the features you want.<br>\n<br>\n<a href='macro://videoTutorials@Lib:OnTokenMove/none/Impersonated?'><b>Overview of BoT Video Tutorials ><\/b><\/a><br>\n<br>\n<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'><b>Continue to choose features to install >><\/b><\/a><br>\n\"]\n[h:output\t= strformat(\"%{output}<\/td class='btnformat'><\/tr><\/table><br><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2e76298a-95da-4c51-917e-4e331e25709f",
          "commandChecksum": "6aeb51a9063e80ea5d23651bf7e887d2",
          "propsChecksum": "23e119210d85ff11860e4c92f473db13"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "3",
        "includeLabel": false,
        "sortBy": "3",
        "index": 440,
        "label": "BoT Features",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,macro(\"featureTable@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html>Change the installed BoT features.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7d35fba3-6408-4297-afe9-7f045ffae54f",
          "commandChecksum": "45fd77762c15d28c6c16e8b4e66738b5",
          "propsChecksum": "2531ba10c2f1040ac7605d62b8ddee4e"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.1 Experimental Shit",
        "includeLabel": false,
        "sortBy": "0.1 Experimental Shit",
        "index": 441,
        "label": "followMe",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n[tok\t\t= arg(0)]\n[lastPath\t= arg(1)]\n[lastCoord\t= json.get(json.get(lastPath,-1,-1),0)]\n\n\n['ids\t\t= getTokenNames(\",\", json.set(\"{}\", \"setStates\", \"pathFeet\", \"layer\", \"Background\", \"range\", json.set(\"{}\", \"token\", tok, \"distancePerCell\", 0, \"upto\", 2)))']\n[ids\t\t= getTokenNames(\"json\", json.set(\"{}\", \"setStates\", \"pathFeet\", \"layer\", \"Background\"))]\n[foreach(id, ids): removeToken(id)]\n\n\n[varsFromStrProp(json.toStrProp(lastCoord))]\n[gs\t\t\t= bot_getGridSize()]\n[x\t\t\t= x/gs]\n[y\t\t\t= y/gs]\n\n\n[numTiles\t= 2]\n[tileSize\t= 6]\n[coordSet\t= \"[]\"]\n[for(xt, x-numTiles*tileSize, x+numTiles*tileSize+1, tileSize), CODE:{\n\t[for(yt, y-numTiles*tileSize, y+numTiles*tileSize+1, tileSize):coordSet = json.append(coordSet, json.set(\"{}\", \"x\",xt,\"y\",yt, \"useDistance\", 0, \"layer\", \"Background\"))]\n}]\n\n\n[bgTiles\t= \"[]\"]\n[foreach(coord, coordSet): bgTiles\t= json.append(bgTiles, copyToken(\"Tile\", 1, \"Follow Me Tiles\", coord))]\n\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9e4d2ff8-021e-40ef-baa9-f45b9670d25c",
          "commandChecksum": "979d08e484f4337c8c1099c56a1b57db",
          "propsChecksum": "fd96fbcb6f519ca5ab7185d8a9e8cbff"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 470,
        "label": "seeInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\n[h,foreach(tok, toks), code:{\n\t[range = getProperty(\"w42.seeInvisRange\", tok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the 'see invisibility' range for <b>\"+tok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|See Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.seeInvisRange\", range, tok)]\n\t}]\n\t[setState(seeInvisState,1,tok)]\n\t\n\t[setProperty(\"w42.inSeeRange\", \"[]\", tok)]\n\t\n\t[bot_checkInvisibility()]\n\t[broadcast(\"See invisibility range for <b>\" + tok + \"<\/b> is set to: \" + range, bot_ownergm(tok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "1ce4c83d-2ed5-4221-9938-d89a8746cf51",
          "commandChecksum": "754afa44bb778e1cd4881657178f77b1",
          "propsChecksum": "38526a02cf7c90db83852a83ab16d9cd"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "21",
        "includeLabel": false,
        "sortBy": "21",
        "index": 471,
        "label": "sawInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(seeInvisState,0,meTok)]\n\t\n\t[seeing\t= getProperty(\"w42.inSeeRange\", meTok)]\n\t[foreach(tok, seeing), CODE: {\n\t\t[onMap = findToken(tok)]\n\n\t\t[h, if(onMap != \"\"): owners = json.difference(getOwners(\"json\",tok),\tjson.difference(getOwners(\"json\",meTok), getProperty(\"w42.originalOwners\", tok)))]\n\t\t[h, if(onMap != \"\"): setOwner(owners, tok)]\n\t\t\n\t}]\n\t\n\t['pause(\"owners\")']\n\t\n\t[setProperty(\"w42.inSeeRange\", \"[]\", meTok)]\n\t[broadcast(\"See Invisibility is turned off for <b>\" + getName(meTok), bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "b9dc137e-7e9f-4204-b3d0-4413624ca654",
          "commandChecksum": "8e6148dc7a391d20174a39818e76ff97",
          "propsChecksum": "a822d486fbfad86edf8954087a8d44cb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "30",
        "includeLabel": false,
        "sortBy": "30",
        "index": 472,
        "label": "purgeInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\n[h,foreach(tok, toks), code:{\n\t[range = getProperty(\"w42.purgeInvisRange\", tok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the Purge Invisibility Range for <b>\"+tok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|Purge Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.purgeInvisRange\", range, tok)]\n\t}]\n\t[setState(purgeInvisState,1,tok)]\n\t\n\t[setProperty(\"w42.inPurgeRange\", \"[]\", tok)]\n\t\n\t[bot_checkInvisibility()]\n\t[broadcast(\"Purge invisibility range for <b>\" + tok + \"<\/b> is set to: \" + range, bot_ownergm(tok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "e1217738-0636-4d55-9215-c88d7e2e73e2",
          "commandChecksum": "4495a93844b6e23d93b279744f1c9db7",
          "propsChecksum": "9480a23258d74c7704c8f7cecfb17aa1"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "31",
        "includeLabel": false,
        "sortBy": "31",
        "index": 473,
        "label": "purgedInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(purgeInvisState,0,meTok)]\n\t\n\t[purging\t= getProperty(\"w42.inPurgeRange\", meTok)]\n\t[foreach(tok, purging), CODE: {\n\t\t[purging\t= json.difference(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok))]\n\t\t\n\t\t[if(json.isEmpty(purging)): setOwnerOnlyVisible(1, tok)]\n\t\t\n\t\t[purging\t= setProperty(\"w42.purgedBy\", purging, tok)]\n\t}]\n\t[setProperty(\"w42.inPurgeRange\", \"[]\", meTok)]\n\t[broadcast(\"Invisibility Purge is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "650d939a-66c8-4a16-851c-c5e14ac4e98d",
          "commandChecksum": "5dc407e7ede5d48490c3cecc9842c27e",
          "propsChecksum": "2dac4b926cd9b2700ba46c864d969be6"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "40",
        "includeLabel": false,
        "sortBy": "40",
        "index": 474,
        "label": "anulInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[range = getProperty(\"w42.annulInvisRange\", meTok)]\n\t[if(!isNumber(range) ), CODE:{\n\t\t[abort(input(\n\t\t\t\"junk|<html>Set the Annul Invisibility Range for <b>\"+meTok+\"<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\t\"range|0|Annul Invisibility Range\"\n\t\t))]\n\t\t[setProperty(\"w42.annulInvisRange\", range, meTok)]\n\t}]\n\t\n\t[setState(annulInvisState,1,meTok)]\n\t\n\t[bot_checkInvisibility()]\n\t[broadcast(\"Annnul invisibility range for <b>\" + meTok + \"<\/b> is set to: \" + range, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "5c3a8199-79cb-48f3-877f-8d0fe703202c",
          "commandChecksum": "c9e5c8397430ac0f9cb61648dcca05b1",
          "propsChecksum": "1d855386bb2cacc466af2710565c5275"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "41",
        "includeLabel": false,
        "sortBy": "41",
        "index": 475,
        "label": "anulledInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t[setState(annulInvisState,0,meTok)]\n\t[broadcast(\"Annul Invisibility is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "Yes I know, its 'Anulled' but that didn't fit on one line...",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "c94fb530-4899-4ed3-b6e2-5e3516198280",
          "commandChecksum": "49e1c1f9f5ec2773ae43680ae2c48b78",
          "propsChecksum": "8c22713c2e18b982271218060d027eeb"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "60",
        "includeLabel": false,
        "sortBy": "60",
        "index": 476,
        "label": "checkInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n[h:seeInvisState\t= getLibProperty('seeInvisState','lib:EventMacros')]\n[h:purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n[h:annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\n\n[h,if(argCount()): meTok = arg(0); meTok = listGet(getSelectedNames(), 0)]\n\t\n[h,if(getState(invisState, meTok)), CODE:{\n\t\n\t[seeingToks\t\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", seeInvisState)))]\n\t[purgingToks\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", purgeInvisState)))]\n\t[annulingToks\t= getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", annulInvisState)))]\n\n\t\n\t[seeingToks\t\t= json.difference(seeingToks, json.append(\"[]\",meTok))]\n\t[purgingToks\t= json.difference(purgingToks, json.append(\"[]\",meTok))]\n\t[annulingToks\t= json.difference(annulingToks, json.append(\"[]\",meTok))]\n\n\t[currentOwners\t= getOwners(\"json\", meTok)]\n\t[addedOwners\t= \"[]\"]\n\n\t\n\t[shadowTok\t\t= findToken(getName(meTok) + \"(invis)\")]\n\t[assert(shadowTok != \"\", \"Shadow token does not (yet?) exist\",0)]\n\t[units\t\t\t= 0]\n\t[moveToken(getTokenX(units, meTok), getTokenY(units, meTok), units, shadowTok)]\n\n\t\n\t\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", seeInvisState))), json.append(\"[]\",meTok))]\n\n\t[foreach(tok, allToks), CODE:{\n\t\t['broadcast(getName(tok) + \" can see me!\")']\n\t\t[range\t\t\t= getProperty(\"w42.seeInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t\n\t\t['cst\t\t\t= json.length(json.merge(canSeeToken(meTok, tok),canSeeToken(tok, meTok)))']\n\t\t[cst\t\t\t= isVisible(getTokenX(1,meTok), getTokenY(1,meTok), tok)]\n\t\t\n\t\t['pause(\"distance\",\"range\",\"cst\")']\n\t\t[if(distance <= range && cst): addedOwners\t= json.union( addedOwners, getOwners(\"json\", tok) )]\n\t\t[if(distance <= range): setProperty(\"w42.inSeeRange\", json.union(getProperty(\"w42.inSeeRange\", tok), json.append(\"[]\",shadowTok)), tok)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t setProperty(\"w42.inSeeRange\", json.difference(getProperty(\"w42.inSeeRange\", tok), json.append(\"[]\",shadowTok)), tok)\n\t\t]\n\t}]\n\t\n\t[setOwner(json.union(getProperty(\"w42.originalOwners\", shadowTok), addedOwners), shadowTok)]\n\t['pause(\"allToks\",\"currentOwners\",\"seeing\",\"meTok\",\"range\",\"distance\")']\n\n\n\t\n\t\n\t\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", purgeInvisState))), json.append(\"[]\",meTok))]\n\t\n\t[setOwnerOnlyVisible(1, shadowTok)]\n\t\n\t[purgedBy\t= \"[]\"]\n\t[foreach(tok, allToks), CODE:{\n\t\t[range\t\t\t= getProperty(\"w42.purgeInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range): setOwnerOnlyVisible(0, meTok)]\n\t\t[if(distance <= range): purgedBy = json.append(purgedBy,tok)]\n\t\t[if(distance <= range): setProperty(\"w42.inPurgeRange\", json.union(getProperty(\"w42.inPurgeRange\", tok), json.append(\"[]\",meTok)), tok)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\t\t setProperty(\"w42.inPurgeRange\", json.difference(getProperty(\"w42.inPurgeRange\", tok), json.append(\"[]\",meTok)), tok)\n\t\t]\n\t}]\n\t[if(json.isEmpty(purgedBy)): setOwnerOnlyVisible(1, meTok)]\n\t[setProperty(\"w42.purgedBy\", purgedBy, meTok)]\n\n\n\n\t\n\t\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\",\"setStates\", json.append(\"\", annulInvisState))), json.append(\"[]\",meTok))]\n\t\n\t[foreach(tok, allToks), CODE:{\n\t\t[range\t\t\t= getProperty(\"w42.annulInvisRange\",tok)]\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range):bot_endInvisibility(meTok)]\n\t}]\n}]\n\n\t\n[h,if(getState(seeInvisState, meTok)), CODE:{\n\t\n\t[range\t\t\t= getProperty(\"w42.seeInvisRange\", meTok)]\n\t[allToks\t\t= json.difference(getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState))), json.append(\"[]\",meTok))]\n\t\n\t\n\t['pause(\"allToks\",\"invisState\",\"range\")']\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t\n\t\t['cst\t\t\t= json.length(json.merge(canSeeToken(meTok, tok),canSeeToken(tok, meTok)))']\n\t\t[cst\t\t\t= isVisible(getTokenX(1,tok), getTokenY(1,tok), meTok)]\n\n\t\t['pause(\"meTok\",\"range\",\"allToks\",\"invisState\",\"cst\")']\n\t\t\n\t\t\n\t\t\n\t\t[shadowTok = getName(tok)+\"(invis)\"]\n\t\t[if(distance <= range && cst): \n\t\t\tsetOwner(json.union(getOwners(\"json\", shadowTok), getOwners(\"json\",meTok)),shadowTok)\n\t\t;\n\t\t\tsetOwner(\n\t\t\t\tjson.difference(\n\t\t\t\t\tgetOwners(\"json\",shadowTok),\n\t\t\t\t\tjson.difference( \n\t\t\t\t\t\tgetOwners(\"json\",meTok), \n\t\t\t\t\t\tgetProperty(\"w42.originalOwners\", tok)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t,shadowTok)\n\t\t]\n\t\t[if(distance <= range && cst): setProperty(\"w42.inSeeRange\", json.union(getProperty(\"w42.inSeeRange\", meTok), json.append(\"[]\",shadowTok)), meTok)]\n\t}]\n}]\n\n\t\n[h,if(getState(purgeInvisState, meTok)), CODE:{\n\t\n\t[inPurgeRange\t= getProperty(\"w42.inPurgeRange\", meTok)]\n\t[range\t\t\t= getProperty(\"w42.purgeInvisRange\", meTok)]\n\t[allToks\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState)))]\n\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t\n\t\t['pause(\"allToks\",\"distance\",\"range\")']\n\t\t[if(distance <= range), CODE:{\n\t\t\t[setOwnerOnlyVisible(0, tok)]\n\t\t\t\n\t\t\t[setProperty(\"w42.purgedBy\", json.union(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok)), tok)]\n\t\t\t[setProperty(\"w42.inPurgeRange\", json.union(getProperty(\"w42.inPurgeRange\", meTok), json.append(\"[]\",tok)), meTok)]\n\t\t\t\n\t\t''\t\n\t\t};{\n\t\t\t\n\t\t\t[purging\t= json.difference(getProperty(\"w42.purgedBy\", tok), json.append(\"[]\",meTok))]\n\t\t\t[setProperty(\"w42.inPurgeRange\", json.difference(getProperty(\"w42.inPurgeRange\", meTok), json.append(\"[]\",tok)), meTok)]\n\t\t\t\n\t\t\t[if(json.isEmpty(purging)): setOwnerOnlyVisible(1, tok)]\n\t\t\t\n\t\t\t[setProperty(\"w42.purgedBy\", purging, tok)]\n\t\t\t['pause()']\n\t\t''\n\t\t}]\n\t''\n\t}]\n''\n};{''}]\n\n\t\n[h,if(getState(annulInvisState, meTok)), CODE:{\n\t\n\t[range\t\t\t= getProperty(\"w42.annulInvisRange\", meTok)]\n\t[allToks\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", \"['TOKEN']\", \"setStates\", json.append(\"[]\", invisState)))]\n\t\n\t[foreach(tok, allToks), CODE:{\n\t\t[distance\t\t= bot_getRangedDistance(tok, meTok)]\n\t\t[if(distance <= range):bot_endInvisibility(tok)]\n\t}]\n}]\n\n[h:'broadcast(\"<b>this function is under construction. Turn off: Invisibility in the BOT settings (toggles tab)<\/b>\")']",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "44eb4a5f-4119-419a-8e46-e39c319e0f2c",
          "commandChecksum": "36c3232a29320a47465a6ec6c05bce29",
          "propsChecksum": "9aaeb5f45d71e8270670932a80fa288f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "20",
        "includeLabel": false,
        "sortBy": "20",
        "index": 477,
        "label": "deferHover",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'abort(0)']\n\n[h:coords\t\t= macro.args]\n[h,if(json.length(coords)==0): abort(0)]\n\n\n[h:var = arg(0)]\n[h:varsFromStrProp(var)]\n\n[h:'pause(\"var\",\"x1\",\"y1\",\"x2\",\"y2\",\"pS\",\"d\")']\n[h:setViewArea(x1, y1, x2, y2, pS)]\n[h:coords\t\t= json.remove(coords,0)]\n[h,if(d > 0 ): bot_delay(d)]\n\n[h:'bot_debugInfo(\"coords, coord,x,y\")']\n[h:link\t\t\t= macroLinkText(\"deferHover@Lib:OnTokenMove\", \"none\", coords)]\n[h:execLink(link,1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "07c3a5fc-6c60-40aa-8ac1-17167fe9e9bb",
          "commandChecksum": "ebf3a8209015ebbd947cf20d51d2f14b",
          "propsChecksum": "52f21388174033759e2380b35702ad51"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "12",
        "includeLabel": false,
        "sortBy": "12",
        "index": 480,
        "label": "runAnimateView",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:me\t\t\t= getSelectedNames()]\n[h:assert(listCount(me)==1,\"Make sure (only) one token is selected before you run this macro\",0)]\n[h:switchToken(me)]\n\n[h:coords\t= getProperty(\"w42.viewAnimationCoords\")] \n[h:assert(json.type(coords)!=\"UNKNOWN\", \"There are no animation coords stored on this token run 'Set Animated View' for this token first\",0)]\n\n\n[h:'']\n[h:bot_execAllPlayers(\"deferHover@Lib:OnTokenMove\", coords)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "11230c4f-5675-4bbd-be3b-ac9b2efa1ecb",
          "commandChecksum": "a4f4bf93db39be6aa656010fcace4dd7",
          "propsChecksum": "572c783a7e81a7e439313af082f9da6d"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "11",
        "includeLabel": false,
        "sortBy": "11",
        "index": 483,
        "label": "linkViewAnimations",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:nToks\t\t= listCount(toks)]\n[h:assert(nToks > 1,\"Make more than one token is selected before you run this macro\",0)]\n\n\n[h:inputStr\t\t= \"[]\"]\n[H:inputStr \t= json.append(inputStr,\"junk|<html>\nThis function will link the animate view of all the selected tokens. <br>\nHere you can give the order in which the view animations should be shown.<br>\nThe lowest number will be shown first, then the next, etc.<br><br>\nNotes:<br>\n- The token where you store the linked tokens on will loose its<br>\noriginal animation coordinates (they get overwritten with the total animation)<br>\n- If no order has been previously set, the first encountered number (if any)<br> \nin the token name will be used. If there is no number, the order is set to 0<br>\n<br><\/html>|-|LABEL|SPAN=TRUE\")]\n\n[h: i = 0]\n[h,foreach(tok,toks), CODE:{\n\t[assert(json.type(getProperty(\"w42.viewAnimationCoords\", tok))!=\"UNKNOWN\", \"There are no animation coords store on token: \"+ tok + \" deselect it and run this macro again OR run Set Animate View for this token first\",0)]\n\t[n\t\t\t= getProperty(\"w42.animationOrder\", tok)]\n\t[if(n==\"\"), CODE:{\n\t\t\n\t\t[id\t\t= strfind(tok,\"(\\\\d+)\")]\n\t\t[if(getFindCount(id)): n = getGroup(id, 1, 0) ; n = 0]\n\t};{}]\n\t[set(\"n\"+i, if(isNumber(n), n, 0))]\n\t[string\t\t= \"n\"+i+\"|\"+ eval(\"n\"+i) +\"|\"+tok]\n\t[inputStr\t= json.append(inputStr, string)]\n\t[i\t\t\t= i+ 1]\n}]\n\n[H:inputStr \t= json.append(inputStr,\"junk|<html>______________________________________________________<\/html>|-|LABEL|SPAN=TRUE\")]\n[H: inputStr\t= json.append(inputStr, \"storeToken|<enter name>|Token name to store linked coords on\")]\n\n[H: inputStr\t= json.evaluate(inputStr)]\n\n[H: hasInput\t= abort(input(json.toList(inputStr,\"##\")))]\n\n[h:coordArray\t= \"[]\"]\n[h,count(nToks):coordArray\t=  json.append(coordArray,\"nothing\")]\n\n[h,foreach(tok,toks), CODE:{\n\t[n\t\t\t\t= eval(\"n\"+roll.count)]\n\t[assert(n<nToks,\"You've entered a too high order number. The highest number cannot exceed the number of tokens -1. E.g. if you want to link 3 tokens, use the numbers 0,1 and 2 to set the order\",0)]\n\t[setProperty(\"w42.animationOrder\", n, tok)]\n\t[coords\t\t\t= getProperty(\"w42.viewAnimationCoords\", tok)]\n\t[coordArray\t\t= json.set(coordArray, n, coords)]\n}]\n\n[h:linkedCoords\t= \"[]\"]\n[h,foreach(array,coordArray): linkedCoords = json.merge(linkedCoords, array)]\n\n\n[h:'broadcast(replace(linkedCoords, \",\", \",<br>\"))']\n[h:setProperty(\"w42.viewAnimationCoords\", linkedCoords, storeToken)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "326a2cd3-5c4e-4d72-91ad-b1b45557b354",
          "commandChecksum": "07bea171a786018711509e5a4ef3f2a4",
          "propsChecksum": "3be723a5a33865585910cda2b320eccb"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "60",
        "includeLabel": true,
        "sortBy": "60",
        "index": 484,
        "label": "Set View Animation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_setAnimateView()]",
        "maxWidth": "",
        "tooltip": "<html> Use lastpath of selected token to run a screen animation",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "380fa75c-77cc-437d-a7ae-9d0aa410088c",
          "commandChecksum": "e2b628b508d49827fade2049a3424126",
          "propsChecksum": "cd0817122dc5c5b7e68e06e641620f24"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "60a",
        "includeLabel": true,
        "sortBy": "60a",
        "index": 485,
        "label": "Link View Animations",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_linkViewAnimations()]",
        "maxWidth": "",
        "tooltip": "<html> Link the view animation of selected tokens and store it on one token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "98ce8bfd-031d-4467-96cf-b0352ebf24fa",
          "commandChecksum": "020f995fb52530177b276067c95d1cc4",
          "propsChecksum": "ebfe05694b8c83a031fd235ed02f83ee"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "yellow",
        "group": "60b",
        "includeLabel": true,
        "sortBy": "60b",
        "index": 486,
        "label": "Run View Animation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_runAnimateView()]",
        "maxWidth": "",
        "tooltip": "Run view animation created for selected token",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e53424ed-9960-44fb-8959-d60ab21da3ff",
          "commandChecksum": "29cc55f3c385b1c798ae5bd75379e13a",
          "propsChecksum": "2787a5aa102d791d45485f0e794dc3a3"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115",
        "includeLabel": false,
        "sortBy": "115",
        "index": 487,
        "label": "Start Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_startInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c815b93d-29c4-4d44-9ef5-bb9afa5ec98b",
          "commandChecksum": "83dd0c424c9a9ce7536194b595fc240d",
          "propsChecksum": "7bf00251a8ed2ae99e9b1e6d817e5421"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115a",
        "includeLabel": false,
        "sortBy": "115a",
        "index": 488,
        "label": "End Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_endInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "3666686f-09a9-41a9-8fbe-0b4e8ff77747",
          "commandChecksum": "930ae149672c441e37b2f23047e107cf",
          "propsChecksum": "e8eda6557eaaa4c6320be7bb601e3449"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115b",
        "includeLabel": false,
        "sortBy": "115b",
        "index": 489,
        "label": "See Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_seeInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4e026ac7-931b-47f4-b7dd-d06bd29d807f",
          "commandChecksum": "995bd812fa28b0a4c706971bcf1b32a2",
          "propsChecksum": "3a6436ab3bd1e1c4932cb8b301752868"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115c",
        "includeLabel": false,
        "sortBy": "115c",
        "index": 490,
        "label": "Saw Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_sawInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "edd3363f-5697-47e1-bc1f-7f2668e4fa93",
          "commandChecksum": "3e5ede72aecc196a876719a77d4b8d0e",
          "propsChecksum": "cf43aa9594caf1bf46d521954addf373"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115e",
        "includeLabel": false,
        "sortBy": "115e",
        "index": 491,
        "label": "Purge Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_purgeInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "91b98874-9ccd-48c0-92d7-52549de816ab",
          "commandChecksum": "935fabc62aedb9975473bc4ed3f837dd",
          "propsChecksum": "5d2ed12a1ad32f611597ed76a3330a89"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115f",
        "includeLabel": false,
        "sortBy": "115f",
        "index": 492,
        "label": "Purged Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_purgedInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ecd353fc-ec7d-47cc-b1b6-8c6f09fc09d1",
          "commandChecksum": "e30ab69328ec6b2311acb98a8dd22d1b",
          "propsChecksum": "ff6e74232ffc4f106907c594bc0c5802"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115g",
        "includeLabel": false,
        "sortBy": "115g",
        "index": 493,
        "label": "Anul Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_anulInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "d53698e3-9cae-4ede-943f-0c7791953da6",
          "commandChecksum": "09307f150bb9b271d8302cd1adc91f23",
          "propsChecksum": "fc1133a8770295924466ed0dfd6c2740"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "115h",
        "includeLabel": false,
        "sortBy": "115h",
        "index": 494,
        "label": "Anulled Invisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_anulledInvisibility()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9fc1ae73-4ffe-4870-b891-70904fb7fdf0",
          "commandChecksum": "9f4bf70ad153a40ec1a7372b28465b96",
          "propsChecksum": "ce034ca4a18b68900ce961957181e4ae"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "51",
        "includeLabel": false,
        "sortBy": "51",
        "index": 496,
        "label": "ownergm",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = getLibProperty(\"gmNames\", \"lib:EventMacros\")]\n};{\n\t[h,if(isOwnedByAll(tok)):\t\n\t\tmacro.return = getAllPlayerNames() \n\t; \n\t\tmacro.return = json.union(getOwners(\"json\",tok), getLibProperty(\"gmNames\", \"lib:EventMacros\"))\n\t]\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b4339e61-b937-4ffe-be92-16bb443f691a",
          "commandChecksum": "4ecc738e994738d78c8f9ca5fdcfab20",
          "propsChecksum": "7c3c16e616dcb1e17dbba982cc0a7685"
        }
      },
            {
        "autoExecute": true,
        "color": "orange",
        "fontColor": "black",
        "group": "54",
        "includeLabel": false,
        "sortBy": "54",
        "index": 497,
        "label": "nowner",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h,if(argCount()): tok\t= arg(0) ; tok = currentToken()]\n[h,if(tok == \"\"), CODE:{\n\t\t[macro.return = getAllPlayerNames(\"json\")]\n};{\n\t[if(isOwnedByAll(tok)):\t\n\t\tmacro.return = []\n\t; \n\t\tmacro.return = json.difference(getAllPlayerNames(\"json\"), getOwners(\"json\",tok))\n\t]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "34606d37-bcb6-4890-a68b-0b2c12fa9fe3",
          "commandChecksum": "aaecfc4cecc6304d01051635503276b5",
          "propsChecksum": "7e0352711035abf7c585f6537e26f613"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "black",
        "group": "22",
        "includeLabel": false,
        "sortBy": "22",
        "index": 498,
        "label": "getTokCDistance",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h:'']\n\n[h:assert(argCount()==5, \"ERROR: getTokenCornerDistance requires exactly 5 parameter, amount given: \" + argCount(),0)]\n\n\n[h:gs\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n[h:upc\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"units per cell\")]\n\n[r1\t= getTokenX(1, arg(0))]\n[r2\t= if(indexOf( lower(arg(1)),\"right\")+1, getTokenWidth(arg(0)), 0) ]\n[r3\t= getTokenX(1, arg(2))]\n[r4\t= if(indexOf( lower(arg(3)),\"right\")+1, getTokenWidth(arg(2)), 0)]\n[r5\t= if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==1, upc, 1)]\n[broadcast(r1 + \"<br>\" +r2 + \"<br>\" +r3 + \"<br>\" +r4 + \"<br>\" +r5 + \"<br>\" )]\n\n[h:dx\t= \n\tround(\n\t\tabs(\n\t\t\tgetTokenX(1, arg(0)) + \n\t\t\tif(indexOf( lower(arg(1)),\"right\")+1, getTokenWidth(arg(0)), 0) \n\t\t\t\t- \n\t\t\tgetTokenX(1, arg(2)) - \n\t\t\tif(indexOf( lower(arg(3)),\"right\")+1, getTokenWidth(arg(2)), 0)\n\t\t) / if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==2, upc, 1),0\n\t)\n]\n\n[h:dy\t= \n\tround(\n\t\tabs(\n\t\t\tgetTokenY(1, arg(0)) + \n\t\t\tif(indexOf( lower(arg(1)),\"bottom\")+1, getTokenHeight(arg(0)), 0) \n\t\t\t\t- \n\t\t\tgetTokenY(1, arg(2)) - \n\t\t\tif(indexOf( lower(arg(3)),\"bottom\")+1, getTokenHeight(arg(2)), 0)\n\t\t) / if(arg(4)==0 || arg(4)==2, gs, 1) * if(arg(4)==2, upc, 1),0\n\t)\n]\n\n[h:macro.return =\tjson.set(\"{}\", \"dx\", dx, \"dy\", dy)]",
        "maxWidth": "",
        "tooltip": "<html> getTokenCornerDistance(\"Dragon\", \"Bottom_left\", \"Elf\", \"Top_Right\", 0) <br> returns json with 'dx' and 'dy",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "45783be3-1dc9-438f-89d3-555972decb59",
          "commandChecksum": "9bfd8c7a095848b7c4134fd4dfc50546",
          "propsChecksum": "59332f4f28bcdf48dac106baa18bfdae"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "5",
        "includeLabel": false,
        "sortBy": "5",
        "index": 499,
        "label": "cycleDisguise",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:'']\n\n\n[h:toks\t\t\t= getSelectedNames()]\n[h:assert(listCount(toks)==1, \"Make sure (only) one token is selected\",0)]\n[h:switchToken(toks)]\n\n[h:currentImage = getImage(toks)]\n[h:disguises\t= getProperty(\"am.bot.disguise\")]\n[h,if(json.isEmpty(disguises)): disguises\t= json.append(\"[]\", currentImage)]\n\n[h:i\t\t\t= json.indexOf(disguises, currentImage)]\n[h:l=json.length(disguises)]\n[h:nexti\t\t= mod(i+1,json.length(disguises))]\n[h:image\t\t= json.get(disguises, nexti)]\n[h:setTokenImage(image)]",
        "maxWidth": "",
        "tooltip": "<html> - Clicking the <i>Cycle Disguise<\/i> button will cycle through the stored images on this token.<\/html> ",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "833ea1c2-3ca1-4973-be64-cefa4983b344",
          "commandChecksum": "54138d99ac07c66f0ab50085dfb3664a",
          "propsChecksum": "07cefbaa541e63d494a1f0e1e947ce4e"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "25",
        "includeLabel": false,
        "sortBy": "25",
        "index": 501,
        "label": "summonToken",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: '']\n[H: '']\n[h:me = getSelected()]\n[h:assert(listCount(me) <= 1, \"Make sure only one token is selected\",0)]\n[h, if(listCount(me) == 1), CODE:{\n\t[switchToken(me)]\n\t[h: X = getTokenX(0)]\n\t[h: Y = getTokenY(0)]\n\t[H: PrimePC\t= getName() ]\n}; {\n\t[h: X = 0]\n\t[h: Y = 0]\n\t[H: PrimePC\t= \"\"]\n}]\n\n[h, if(argCount() > 0): useCurrentMap = arg(0); useCurrentMap = 0]\n[h, if(argCount() > 1): conditions = arg(1); conditions = \"{}\"]\n\n[H: '']\n[h: bot_getValidTokens(useCurrentMap, conditions)]\n\n[H: '']\n[h:inputStr\t\t= \"junk|<html><b>Summon Token<\/b> - More token types can be added from the Settings macro<\/html>|-|LABEL|SPAN=TRUE\"]\n[h,if(listCount(fancyPCList)\t> 1):\tinputStr = listAppend(inputStr, \"pcNumber | \" \t+ fancyPCList\t+ \" | PC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t\t; pcNumber\t\t= 0]\n[h,if(listCount(fancyNPCList)\t> 1):\tinputStr = listAppend(inputStr, \"npcNumber | \" \t+ fancyNPCList\t+ \" | NPC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; npcNumber\t\t= 0]\n[h,if(listCount(fancyCharList)\t> 1):\tinputStr = listAppend(inputStr, \"charNumber | \"\t+ fancyCharList\t+ \" | (N)PC | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; charNumber\t= 0]\n[h,if(listCount(fancyAllList)\t> 1):\tinputStr = listAppend(inputStr, \"allNumber | \" \t+ fancyAllList\t+ \" | ALL | LIST | ICON=TRUE  ICONSIZE=30\", '@')\t; allNumber\t\t= 0]\n\n[h, foreach(propType, propTypesList), CODE:{\n\t[fancyList\t= eval(\"fancy\"+propType+\"List\")]\n\t[if(listCount(fancyList)\t> 1):\tinputStr = listAppend(inputStr, propType + \"Number | \" + fancyList + \" | \"+propType+\" | LIST | ICON=TRUE  ICONSIZE=30\", '@') ; set(propType + \"Number\", 0)]\n}]\n[h, if(listCount(fancySpecialList) > 1):inputStr \t= listAppend(inputStr, \"specialNumber | \" \t+ fancySpecialList\t+ \" | Special | LIST | ICON=TRUE  ICONSIZE=30\", '@')]\n\n[h:'']\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Number of each selected token to summon:<\/b><\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"bot_amount|1|give amount\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"bot_spread|0|Spread summoned tokens|CHECK\", '@')]\n\n[h:'']\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html><b>Summon Token(s) to:<\/b><\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr\t\t= listAppend(inputStr,\"junk|<html>If you select a token before you run this macro then its<br>coords will be used here<\/html>|-|LABEL|SPAN=TRUE\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"X|\"+X+\"|X-coordinate to place token\", '@')]\n[h:inputStr \t= listAppend(inputStr, \"Y|\"+Y+\"|Y-coordinate to place token\", '@')]\n\n[h:'']\n[h, if(PrimePC != \"\"):inputStr\t\t= listAppend(inputStr,\"junk|\"+X+\",\"+Y+\"|<html><b>Location of \"+PrimePC+\"<\/b>|LABEL\", '@')]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h: updates = json.set(\"{}\", \"useDistance\", 0)]\n[h: updates = json.set(updates, \"x\", X+1)]\n[h: updates = json.set(updates, \"y\", Y)]\n\n[h:summonedList = json.append(\"\",me)]\n\n[r,if(pcNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(pcList, pcNumber), bot_amount, baseMapName, updates))]\n[r,if(npcNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(npcList, npcNumber), bot_amount, baseMapName, updates))]\n[r,if(charNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(charList, charNumber), bot_amount, baseMapName, updates))]\n[r,if(allNumber):\t\tsummonedList = json.merge(summonedList, copyToken(listGet(allList, allNumber), bot_amount, baseMapName, updates))]\n[r, foreach(propType, propTypesList, \"\"), CODE:{\n\t[r,if(eval(propType+\"Number\")):\tsummonedList = json.merge(summonedList, copyToken(listGet(eval(propType+\"List\"), eval(propType+\"Number\")), bot_amount, baseMapName, updates))]\n}]\n\n[r,if(specialNumber):\tsummonedList = json.merge(summonedList, copyToken(listGet(specialList, specialNumber), bot_amount, baseMapName, updates))]\n\n[h, if(bot_spread), CODE:{\n\t[selectTokens(summonedList, 1, \"json\")]\n\t[msg = \"This message is needed to spread the tokens\"]\n\t[pause(\"msg\")]\n\t[bot_formationSquare()]\n}; {}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "304f6be2-0da4-43c2-8bde-259733572d41",
          "commandChecksum": "a24c6e3250f54997450fd38bb56e5454",
          "propsChecksum": "99d2d5ae271afeba6314e798848be872"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "16. Animate Move",
        "index": 502,
        "label": "Embarkation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:timeOut()]\n[h:'']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'']\n[h:ok\t\t\t= 0]\n\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'']\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h:'']\n\n[h:'']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:' ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX,meY,0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1,vpcuY+1,0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"Passengers\", newEmbarkedList, me)]\n\n\n[h: message(\"Embarkation done\", \"Embarkation done\", \"#063404\", ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1204f009-6754-4a6f-90b1-c6025d7f1aa0",
          "commandChecksum": "301a312514d201f95e6a95c5a0e87fce",
          "propsChecksum": "bc6b53ff410e689d2d7cfbd02c694fdd"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "23",
        "index": 587,
        "label": "Embarkation",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[r:bot_embarkation()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can move (N)PC tokens inside a vehicle.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a5e5ad91-eb8d-462f-acff-0688775134d8",
          "commandChecksum": "2dd3e081596b1132d19a7426602d7ef9",
          "propsChecksum": "b4082e1367860c4d750a0bff9237195c"
        }
      },
            {
        "autoExecute": true,
        "color": "cyan",
        "fontColor": "teal",
        "group": "15. Summon",
        "includeLabel": false,
        "sortBy": "15. Summon",
        "index": 503,
        "label": "toggleEmbark",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'']\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:currPassengers\t= getProperty(\"w42.Passengers\", me)]\n[h:embarkToggle\t\t= getProperty(\"w42.embarkToggle\", me)]\n[h:assert(listCount(currPassengers)>0,\"There are no passengers on this vehicle\",0)]\n[h:assert(isNumber(embarkToggle), \"This vehicle is not (correctly) initiated\",0)]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n\n[H:nX = \"-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1,\t\t-1,\t0,\t1,\t\t-1,\t1,\t\t-1,\t0,\t1\"]\n[h:ny = \"-1,\t-1,\t-1,\t\t0,\t0,\t\t1,\t1,\t1,\t\t-2,\t-2,\t-2,\t\t0,\t0,\t\t2,\t2,\t2\"]\n\n[if(embarkToggle), CODE:{\n\t\n\t[foreach(embarked, currPassengers):moveToken(meX+listGet(nX, roll.count), meY+listGet(nY, roll.count),0,embarked)]\n};{\n\t\n\t[foreach(toEmbark, currPassengers):moveToken(vpcuX+1+listGet(nX, roll.count),vpcuY+1+listGet(nY, roll.count),0,toEmbark )]\n}]\n\n[h:setProperty(\"w42.embarkToggle\",1 - embarkToggle, me)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "af8e9f49-d726-40ae-9004-8fe200626962",
          "commandChecksum": "6ce62d7694d6538ede3d05fc280f22f8",
          "propsChecksum": "243aadce0524a7f61175575978aa1f91"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 505,
        "label": "Toggle Embark",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[r:bot_toggleEmbark()]",
        "maxWidth": "",
        "tooltip": "<html>IF PCs are embarked on a vehicle you can quickly (dis)embark them<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e586e703-fcb4-4d3d-b3b6-d6b04a9e0007",
          "commandChecksum": "32621cfd11a158c9e5250ffcf6e62c0f",
          "propsChecksum": "153bf047d40b7ff3961491fbd6476b84"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "e. Nildiks Room Descriptions",
        "index": 508,
        "label": "sendMacroChat",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:'']\n[h: arguments\t\t\t= macro.args]\n[h: title\t\t\t\t= json.get(arguments,0)]\n[h:forceRoomShare\t\t= getLibProperty('forceRoomShare', 'lib:EventMacros')]\n\n[r, if(forceRoomShare != 1), CODE:{\n\t[r, if(json.length(arguments)\t> 2), CODE:{\n\t\t[h,if(title==\"\"): title = \"Click to view image...\" ; title = \"Click to view image: \" + title ]\n\t\t[r: macroLink(title, \"shareIMG@lib:OnTokenMove\", \"none\", arguments)]\t\n\t};{\n\t\t[h,if(title==\"\"): title = \"Click to view description...\" ; title = \"Click to view description: \" + title ]\n\t\t[r: macroLink(title, \"shareTXT@lib:OnTokenMove\", \"none\", arguments)]\n\t}]\n};{}]\n\n[h, if(forceRoomShare), CODE:{\n\t[if(json.length(arguments)\t> 2), CODE:{\n\t\t[bot_execAllPlayers(\"shareIMG@lib:OnTokenMove\", arguments)]\n\t};{\n\t\t[bot_execAllPlayers(\"shareTXT@lib:OnTokenMove\", arguments)]\n\t}]\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b2ded4ac-7553-4ca0-a5b6-52c80129d0e9",
          "commandChecksum": "7baad8a53a23cdb2290f012f5c98f363",
          "propsChecksum": "09e93375304f5d0dafcef9b8d6acb877"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "e. Nildiks Room Descriptions",
        "index": 509,
        "label": "shareIMG",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:'']\n[h: arguments\t= macro.args]\n[h: title\t\t= json.get(arguments, 0)]\n[h,if(title==\"\"): title = \"Shared image\"]\n[h: image\t\t= json.get(arguments, 1)]\n[h: height\t\t= json.get(arguments, 2)]\n\n['pause(\"title\", \"image\", \"height\")']\n\n[h: background\t= tableImage(\"tbl_Image\",27)]\n[h: style\t\t= \"font-family:'Footlight MT Light'; margin:20;  font-size:11px  ;   background-image: url(\" + background + \")\"]\n[h: zoomIn\t\t= \"<img src=\" + tableImage(\"tbl_Image\",28) + \" border='0' alt='Zoom in on image'><\/img>\"]\n[h: zoomOut\t\t= \"<img src=\" + tableImage(\"tbl_Image\",29) + \" border='0' alt='Zoom out on image'><\/img>\"]\n\n[frame(title):{\n\t<html>\n\t<body style=\"[r:style]\">\n\t[r: bot_frameOpen(6)]\n\t\t[if(!startsWith(image, \"http\")), CODE:{\n\t\t\t\n\t\t\t<table align=\"center\"  border=\"0\"><tr>\n\t\t\t\t<td align=\"center\" border=\"1\" width=\"40px\" bgcolor=\"silver\" style=\"border-style:outset; margin:2 0 2 2\">\t\n\t\t\t\t\t[r: macrolink(zoomIn,\"shareIMG@lib:OntokenMove\",\"none\",json.append(title, image, height+100))]\n\t\t\t\t<\/td>\n\t\t\t\t<td align=\"center\" border=\"1\" width=\"40px\" bgcolor=\"silver\" style=\"border-style:outset; margin:2 0 2 2\">\n\t\t\t\t\t[r: macrolink(zoomOut,\"shareIMG@lib:OntokenMove\",\"none\",json.append(title, image, height-100))]\n\t\t\t\t<\/td>\n\t\t\t<\/tr><\/table>\n\t\t};{}]\n\t\t<table border=\"3\" align=\"center\">\n\t\t\t<tr><td border=\"1\">\n\t\t\t\t<img src=[r: image]-[r: height]><\/img>\n\t\t\t<\/td><\/tr>\n\t\t<\/table>\n\t[r: bot_frameClose(6)]\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a97763c0-6bd4-4b3f-b4f7-bc174c4c052a",
          "commandChecksum": "7bdf4b9b56b72fa088e19bf87c91cdbc",
          "propsChecksum": "3d21811ceba4042c962f6798fe8bd1d5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "e. Nildiks Room Descriptions",
        "index": 510,
        "label": "shareTXT",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:'']\n[h: title\t\t= \tjson.get(macro.args,0)]\n[h,if(title==\"\"): title = \"Shared text\"]\n\n[h: text\t\t= \tjson.get(macro.args,1)]\n[h: background\t= \ttableImage(\"tbl_Image\",27)]\n[h: initiate\t= \t\"font-family:'Footlight MT Light'; font-size:11px; margin:20; background-image: url(\" + background + \")\"]\n\n[frame(title):{\n\t<html>\n\t<body style\t= \"[r:initiate]\">\n\t[r: bot_frameOpen(3)]\n\t\t<table hspace=\"20\" vspace=\"20\"><tr><td>\n\t\t\t[r: text]\n\t\t<\/td><\/tr><\/table>\n\t[r: bot_frameClose(3)]\n\t<\/body>\n\t<\/html>\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "93b08f1d-4ae6-4267-b971-600f739967de",
          "commandChecksum": "e3cdfafad69d484e657c74e46edb2efd",
          "propsChecksum": "9348f9736976d7d401f7d5c378dab3bf"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "e. Nildiks Room Descriptions",
        "index": 511,
        "label": "showInfoLink",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:title = json.get(macro.args,0)]\n[h,if(title==\"\"): title = \"Info Link\"]\n[h:infoLink = json.get(macro.args,1)]\n\n[frame(title):{\n\t[r: bot_frameOpen(4)]\n\t[r: infoLink]\n\t[r: bot_frameClose(4)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "57125f8d-f578-4487-baab-6bfc4fd997db",
          "commandChecksum": "a3a7c347bd9d293e0ede5203f9c1681c",
          "propsChecksum": "2d56425363be3c0ac811be3c3f3524c3"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "e. Nildiks Room Descriptions",
        "includeLabel": false,
        "sortBy": "e. Nildiks Room Descriptions",
        "index": 512,
        "label": "roomDescrHelp",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[frame (\"ROOM DESCRIPTOR REFERENCE\"):{\n\t[r:bot_frameOpen(4)]\n\t<b>NILDIKS ROOM DESCRIPTOR - HELP<\/b>\n\t<br>\n\t<b>CORE<\/b><br>\n\tWhen you select a token (ANY token) and then click on the book image in the BoT menu (utils tab) then a window will pop-up showing the text that is in the <b>GM notes<\/b> section of that token.<br>\n\tNext to that it will show the POTRAIT and HANDOUT images for that token as a link. Clicking on those will share that image with the players<br>\n\t<br>\n\t<b>SPECIAL FEAUTRES<\/b><br>\n\tIn addition to the text shown you can add a couple of special features by adding tags around the text. The available tags are:<br>\n\t<br>\n\t<b><share><\/b>Any text between these tags can be shared with players by clicking on the link that will appear at the bottom of this text.<b></share><\/b><br>\n\t<br>\n\t<b><image><\/b>tableImage(\"encounters\",1)<b></image><\/b><br>\n\tBasically any function/macro that returns the asset link of the image can be put between those tags.<br>\n\t<br>\n\t<b><infolink><\/b>Any text here will appear in a separate pop-up window when you click on the link (the name of the link will be the title text.<b></infolink><\/b><br>\n\t<br>\n\t<b><title><\/b>Title of the tagged link (either share, image or infolink). This must be placed in front of the tag you use, the use if <b>optional<\/b>.<b></title><\/b><br>\n\t<br>\n\t<b>COMMON HTML TAGS<\/b><br>\n\t<b><h1><\/b>Header type 1<b></h1><\/b> (or h2, h3, etc.)<br>\n\t<b><b>bold</b><\/b><br>\n\t<b><i><\/b><i>italic<\/i><b></i><\/b><br>\n\t<b><u><\/b><u>underline<\/u><b></u><\/b><br>\n\t<b><a href=http://www.d20srd.org/srd/monsters/kobold.htm><\/b>kobold stats (web link)<b></a><\/b><br>\n\t<br>\n\t<b>COPY PASTE SECTION<\/b><br>\n\tBelow tags you can copy paste straight into your own text for quick use.<br>\n\t<br>\n\t<u>SPECIAL<\/u><br>\n\t\t<title></title>\t\t<br>\n\t\t<infolink></infolink>\t<br>\n\t\t<share></share>\t\t<br>\n\t\t<image></image>\t\t<br>\n\t<br>\n\t<u>HTML<\/u><br>\n\t\t<h1></h1>\t\t\t\t<br>\n\t\t<b></b>\t\t\t\t<br>\n\t\t<i></i>\t\t\t\t<br>\n\t\t<u></u>\t\t\t\t<br>\n\t\t<a href=http://><a></a>\t\t<br>\t\n\t<br>\n\t<u>GRAB IMAGE<\/u><br>\n\t\ttblImage(\"tblName\",1)<br>\n\t\tgetTokenHandout()<br>\n\t\tgetTokenPortrait()<br>\n\t\tgetImage('image:Dragon')\t\t(map independent)<br>\n\t\tgetImage('dragon')\t\t\t(current map only)<br>\n\t\tgetStateImage('dead')<br>\n\t\n\t[r:bot_frameClose(4)]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "02c949b9-fb04-4820-9daa-4ccf02d4afcb",
          "commandChecksum": "7b82b0aa1933b9cf4fcb4256f3d1c677",
          "propsChecksum": "d31809e56ddc60fb9b3fa9795b7f8106"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "All BoT Macros with Images (Smol)",
        "index": 513,
        "label": "<image src=\" asset://1badb8f7d4e390d6c9c058f49c90c744\"><\/image>",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"roomDescrHelp@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "fc5e4199-8010-4f1b-a60c-0b77e90583c5",
          "commandChecksum": "ecca08a65c5e4c196fe65875acb781bd",
          "propsChecksum": "078ba33f57b4dc9a0e2a068bf5b8897f"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "0.2 LOGGING",
        "index": 516,
        "label": "ALL Logging",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: lname = json.get(logger,\"name\")]\n   [h: log.setLevel(lname,\"DEBUG\")]\n}]",
        "maxWidth": "",
        "tooltip": "<html>DO NOT USE. Its will break things<br>\nThis will turn on ALL logging in the console\n<\/html3",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "68b16d95-0568-48ef-b28a-d1718bd20613",
          "commandChecksum": "8b3e18daa1a76a239b2b2c0833217d73",
          "propsChecksum": "5d3987ad8ebc130750b7116e5c8857d8"
        }
      },
            {
        "autoExecute": true,
        "color": "red",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "0.2 LOGGING",
        "index": 518,
        "label": "NO Logging",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: lname = json.get(logger,\"name\")]\n   [h: log.setLevel(lname,\"INFO\")]\n}]",
        "maxWidth": "",
        "tooltip": "turns off ALL logging!",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1133eb0f-b8b9-4892-83e4-d6bb9d618e57",
          "commandChecksum": "da214dcb96223c118e664a85503a8b8a",
          "propsChecksum": "83a1bd02fb3ff449828f7a528a6f3a58"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "0.2 LOGGING",
        "index": 519,
        "label": "Macro Logging",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h: level = \"DEBUG\"]\n[H: lname = \"net.rptools.maptool.client.MapToolLineParser\"]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.<br>\"]\n[h: log.setLevel(lname,level)]\n\n[h: level = \"DEBUG\"]\n[H: lname = \"net.rptools.maptool.client.VariableResolver \"]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.\"]\n[h: log.setLevel(lname,level)]\n",
        "maxWidth": "",
        "tooltip": "Turns on macro logging in the log file and the console",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e133fecc-29bb-4d5e-b24b-364db1fba447",
          "commandChecksum": "3a98e9baec45116c56dc96326a501d00",
          "propsChecksum": "8ba4ea2d9da7f41e4f4dcab6dbfa9817"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.2 LOGGING",
        "includeLabel": false,
        "sortBy": "0.2 LOGGING",
        "index": 520,
        "label": "Set Logging",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: loggers = json.sort(log.getLoggers(),\"a\",\"name\")]\n[h: loggerList = \"\"]\n[h, FOREACH(logger, loggers), CODE: {\n    [h: loggerList = listAppend(loggerList,json.get(logger,\"name\"))]\n}]\n[h:status=input(\n    \"junkVar|Select a Logger and Level||LABEL|SPAN=TRUE\",\n    \"lname|\"+loggerList+\"|Logger|LIST|VALUE=STRING\",\n    \"level|DEBUG,INFO,WARN,ERROR,FATAL|Level|LIST|VALUE=STRING\")]\n[h:abort(status)]\n[r: \"Setting <i><b>\" + lname + \"<\/b><\/i> to <b>\" + level + \"<\/b>.\"]\n[h: log.setLevel(lname,level)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0feed6be-4b6e-4cda-a238-0f6da55b4c74",
          "commandChecksum": "facab8ae54bb73b9736c2b7558a6e1f2",
          "propsChecksum": "5d414ccaf24b1a1c6a7ea57afbd0319c"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 524,
        "label": "CoMScan",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "\n[h:result = replace(json.indent(bot_seekToken(1,\"centreOnMePad\",'[\"TOKEN\", \"HIDDEN\", \"OBJECT\", \"BACKGROUND\"]', getAllMapNames(),0,1),2),\"centreOnMePad\", \"\")]\n\n\n[h:newResult = \"[]\"]\n\n\n[h,foreach(map, result), CODE:{\n\t[locations = json.get(result, map)]\n\t[newResult = json.append(newResult, json.set(\"{}\", \"map\", map, \"spot\", \"\"))]\n\t[foreach(spot, locations),if(spot != \"\"), CODE:{\n\t\t[newResult = json.append(newResult, json.set(\"{}\", \"map\", map, \"spot\", \" \" + spot))]\n}]\n\n}]\n\n[h:setLibProperty(\"centreOnMepads\", json.sort(newResult,\"spot\", \"map\"), \"lib:EventMacros\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ab310451-0f3a-4bad-adca-bde671071b2b",
          "commandChecksum": "9c14084585a36403c1ad565e9fa34761",
          "propsChecksum": "7562a96b6c0580aba5706ca5a772cd30"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 525,
        "label": "switchMap",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n\n[h:mapList\t\t= listSort(getAllMapNames(),\"N+\")]\n[h:comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t\n\n[h:locationList = \"\"]\n[h,foreach(location, comLocations,\"<br>\"), CODE:{\n\t[map\t\t\t= json.get(location, \"map\")]\n\t[spot\t\t\t= json.get(location, \"spot\")]\n\t[if(!listContains(mapList, map)), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[assert(0,\"error encountere, maplist needs to be updated, please run again\",0)]\n\t}]\n\t[locationList\t= listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:allPlayers\t= getAllPlayerNames()]\n\n[h,if(argCount() > 0): newMap\t= arg(0) ; newMap\t= oldMap]\n[h:assert(listFind(mapList, newMap) != -1, \"The map \"+arg(0)+\" does not exist\",0)]\n\n[h,if(argCount() > 1), CODE:{\n\t\n\t[userList\t\t= arg(1)]\n\t[if(userList == 1): userList = getAllPlayerNames()]\n\n\t\n\t[playerList = \"\"]\n\n\t[FOREACH(player, userList), if(listContains(allPlayers, player)): playerList = listAppend(playerList, player) ; broadcast(\"The player: \"+player+\" does not exist!\")]\n\t[selCount\t\t= 0]\n''\n};{\n\t\n\t\n\t[if(listFind(locationList, oldMap) == -1), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t\n\t\t[locationList = \"\"]\n\t\t[foreach(location, comLocations,\"<br>\"), CODE:{\n\t\t\t[map = json.get(location, \"map\")]\n\t\t\t[spot = json.get(location, \"spot\")]\n\t\t\t[locationList = listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t[newMap\t\t= listFind(locationList, newMap)]\n\t[userList\t= allPlayers]\n\t[selected\t= getSelectedNames()]\n\t[selCount\t= listCount(selected)]\n\n\n\t\n\t[\t\t\t\t\t\t\tinputStr = \"junk|Force Selected Players to Map|-|LABEL|SPAN=TRUE\"]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"newMap|\"+locationList+\"|Select map|RADIO| SELECT=\"+newMap,\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"selCount|1|Move selected token(s)?|CHECK\",\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"junk|(\"+selected+\")<br>|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Select Players|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[FOREACH(player, userList):\tinputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Res-scan all maps for new locations<br>|When checked this macro will scan ALL maps looking for<br>tokens that are called <i>centrOnMePad Some Location Name<\/i><br>and adds <i>Some Location Name<\/i> to the above list of locations<br>when you choose that location the map will be centred around<br><i>that<\/i> pad. Obviously <i>Some Location Name<\/i> can be any<br>alphanumerical string you like!|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"rescan|0|Re-scan|CHECK\",\"@\")]\n\n\t\n\t[abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\t\n\t\n\t[playerList = \"\"]\n\t[FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t''\n\t}]\n''\n}]\n\n\n[h:newLocation = json.get(comLocations, newMap)]\n[h:newMap = json.get(newLocation, \"map\")]\n[h:newLoc = json.get(newLocation, \"spot\")]\n[h:comPad = \"centreOnMePad\" + newLoc]\n\n\n[h:setCurrentMap(newMap)]\n[h,if(findToken(comPad)!=\"\"), CODE:{\n\t[X = getTokenX(0, comPad)]\n\t[Y = getTokenY(0, comPad)]\n};{\n\t[X = 0]\n\t[Y = 0]\n}]\n\n[h,if(rescan): bot_CoMScan()]\t\n\n[h, if(selCount == 1), CODE: {\n\t[FOREACH(tok, selected),if(oldMap != newMap), CODE:{\n\t\t[moveTokenFromMap(tok, oldMap, X+roll.count, Y)]\n\t};{\n\t\t[moveToken(X+roll.count, Y, 0, tok)]\n\t}]\n};{}]\n\n[h:setCurrentMap(oldMap)]\n\n[h:bot_execAllPlayers(\"gotoMap@lib:OnTokenMove\",json.append(\"[]\",newMap,newLoc), playerList)]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br>\n<br>\nIf you select tokens before you use this macro, then the option will be added to move<br>\nthe selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br>\nIf you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i><br>\nthen these will show up as location in this macro (after a 'rescan').<br>\n<br>\nIf there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "599c95d8-711a-4283-8616-22366e594bfb",
          "commandChecksum": "34baab7aad409671057d0d7760630b4f",
          "propsChecksum": "e49c20d1aecfd3efc25def2f3674d317"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "0.1 Experimental Shit",
        "includeLabel": false,
        "sortBy": "0.1 Experimental Shit",
        "index": 526,
        "label": "(new)",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:x=getLibProperty(\"padNameList\", \"lib:eventmacros\")]<br>\n[h,if(!listContains(x,\"SoundPad\")):setLibProperty(\"padNameList\", listAppend(x, \"SoundPad\"),\"lib:eventmacros\")]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "57e4f56a-feaf-4c3d-8d66-f0c5a16859f6",
          "commandChecksum": "cb1e076d8ab6f29610f75c3c44c9e3c6",
          "propsChecksum": "58b007993ef00b33ba5eb138e8feb3ba"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "Util - General",
        "index": 527,
        "label": "getRangedDistance",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[H: source = arg(0)]\n[H: target = arg(1)]\n\n\n[H: assert(! json.isEmpty(source) && ! json.isEmpty(target),\"<b>getRangedDistance(source,target): range<\/b> - Source or target not defined.\",0)]\n\n\n[H: source.elevation = getProperty(\"Elevation\",source)]\n[H, if(! isNumber(source.elevation)): source.elevation = 0]\n[H: target.elevation = getProperty(\"Elevation\",target)]\n[H, if(! isNumber(target.elevation)): target.elevation = 0]\n\n\n[H, if(source.elevation != target.elevation), code: {\n   [H, if(source.elevation < target.elevation): distance.vertical = max(0,target.elevation - (source.elevation + (listFind(\"Large,Huge,Gargantuan,NA,Colossal\",getSize(source)) + 1)*5));\n      distance.vertical = max(0,source.elevation - (target.elevation + (listFind(\"Large,Huge,Gargantuan,NA,Colossal\",getSize(target)) + 1)*5))]\n};{\n   [H: distance.vertical = 0]\n}]\n\n[H, if(! distance.vertical), code: {\n   [H: totalDistance = getDistance(source,1,target,\"ONE_TWO_ONE\")]\n};{\n   \n   [H: distance.direct = getDistance(source,1,target,\"ONE_ONE_ONE\")]\n   \n   [H: horizontal.diagonals = floor((getDistance(source,1,target,\"NO_DIAGONALS\") - distance.direct)/5)]\n   \n   [H: vertical.diagonals = min(distance.direct,distance.vertical)]\n   \n   [H: extra.diagonals =  floor((max(vertical.diagonals,horizontal.diagonals) - horizontal.diagonals)/5)]\n   \n   [H: totalDistance = floor((horizontal.diagonals + extra.diagonals) * 0.5) * 5 + distance.direct + distance.vertical - vertical.diagonals]\n}]\n\n[H: macro.return = totalDistance]\n",
        "maxWidth": "",
        "tooltip": "created by Aliasmask",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "59dde0ba-2c85-455c-a9c6-8b35458c6a9f",
          "commandChecksum": "8abc20158e6976945187d9fefabd3d0e",
          "propsChecksum": "a07f4a8c79ba8b4a4820889c4c6dc7e9"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "Util - General",
        "includeLabel": false,
        "sortBy": "Util - General",
        "index": 528,
        "label": "changeElevation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:assert(listCount(getSelected())==1,\"Make sure (only) one token is selected\",0)]\n[h:switchToken(getSelected())]\n\n[H: elevation.value = getProperty(\"Elevation\")]\n[H, if(! isNumber(elevation.value)): elevation.value = 0]\n\n[H: abort(input(\"tip|<html><b><i>Either set current elevation or put adjustment value in.<\/i><\/b><\/html>||LABEL|SPAN=TRUE\",\n   strformat('elevation.input|%{elevation.value}|Current Elevation|TEXT'),\n   \"elevation.adjustment|0|Adjust Elevation|TEXT\"\n))]\n\n\n[H, if(! isNumber(elevation.input)): elevation.input = 0]\n[H, if(! isNumber(elevation.adjustment)): elevation.adjustment = 0]\n\n\n[H, if(elevation.input != elevation.value), code: {\n   [elevation.new = elevation.input]\n};{\n   [if(elevation.adjustment > 0), code: {\n      [elevation.new = elevation.value + elevation.adjustment]\n   };{\n      [elevation.new = max(0,elevation.value - elevation.adjustment)]\n   }]\n}]\n\n\n[H, if(elevation.new > 0): setState(\"flying\",1)]\n[H, if(elevation.new < 0): setState(\"burrowing\",1)]\n[H, if(elevation.new <= 0): setState(\"flying\",0)]\n[H, if(elevation.new >= 0): setState(\"burrowing\",0)]\n\n\n[H: setProperty(\"Elevation\",elevation.new)]\n\n\n[H: tokenImage = getTokenImage()]\n\n[H: output = strformat('\n   <table style=\"border-spacing:0px;border-style:solid;border-color:black;border-width:1pt;padding:0px\">\n      <tr>\n         <td width=\"34\" style=\"padding:0px\">%{tokenImage}<\/td>\n         <td width=\"250\" style=\"background-color:aqua;padding:0px 5px 2px 5px;\">%{token.name} moves to Elevation %{elevation.new}.<\/td>\n      <\/tr>\n   <\/table>\n')]\n\n[H: broadcast(output)]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "created by Aliasmask",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b9232608-da64-4cbc-9906-d7f39b6b5713",
          "commandChecksum": "139f71bc3d0f9d73e995dacf18f89047",
          "propsChecksum": "90cb6daab58541eb928b0ec14b1c7353"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 531,
        "label": "Language2Script",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:assert(isGM(), \"GM Only, 0\")]\n[h:Languages\t= getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n[h:choices\t\t= getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\")]\n\n[h:tables\t\t= listSort(getTableNames(),\"A+\")]\n[h:exampleTxt\t= \"This script looks like this\"]\n\n[h:scripts\t\t= \"\"]\n[h:names\t\t= \"none\"]\n\n[h:showScript\t= \"<table><tr>\"]\n[h,foreach(tbl, tables), if(startsWith(tbl, \"script_\")), CODE:{\n\t[name\t\t= substring(tbl, 7, length(tbl))]\n\t[scripts\t= listAppend(scripts, tbl)]\n\t[names\t\t= listAppend(names, name)]\n\t[showScript\t= showScript + \"<font size=5>\"+name+\"<\/font><\/td><td>\" + bot_textToScript(exampleTxt, tbl) + \"<\/tr><tr>\"]\n};{}]\n[showScript\t\t= showScript + \"<\/tr><\/table>\"]\n\n[h:inputStr\t\t= \"[]\"]\n[H, foreach(language,Languages), CODE:{\n\t[choice\t\t= json.get(choices,language)]\n\t[nChoice\t= listFind(scripts,choice)+1]\n\t[inputStr\t= json.append(inputStr,strformat(\n\t\tlanguage+\"_link|\"+names+\"|Pick script to link to \"+language+\"|LIST|VALUE=STRING SELECT=\"+nChoice\n\t))]\n\n}]\n\n[h:abort(input(\n\t\t\"junk|<html>\n\t\tHere you can link a language to a certain special script.<br>\n\t\tThe encoded message will show up in that script instead of<br>\n\t\tnormal text, giving it an extra effect. \n\t\t<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"junk|<html>\"+showScript+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"junk|<html><br><br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\tjson.toList(json.evaluate(inputStr),\"##\")\n))]\n\n[json.script = \"{}\"]\n[foreach(language, languages), if(eval(language+\"_link\")!=\"none\"): \n\tjson.script = json.set(json.script, language, \"script_\"+eval(language+\"_link\"))\n]\n\n}]\n[h:setLibProperty(\"w42.bot.whisperPanel.script\", json.script, \"lib:eventMacros\")]",
        "maxWidth": "",
        "tooltip": "Link the languages to scripts",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "49dfc867-0f84-4b1a-8fe1-6c9f3b4b33bf",
          "commandChecksum": "38e54cf5df5386711d79aaf82ac20019",
          "propsChecksum": "7965dfc17bb3758142d998d868e55c92"
        }
      },
            {
        "autoExecute": true,
        "color": "yellow",
        "fontColor": "black",
        "group": "Util - OnCampaignLoad",
        "includeLabel": false,
        "sortBy": "Util - OnCampaignLoad",
        "index": 539,
        "label": "diagnose",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:'']\n\n\n\n\n\n\n[h,if(argCount() > 0): onCampaignLoad\t= arg(0)  ; onCampaignLoad = 0]\n\n[h,if(!onCampaignLoad), CODE:{\n\t\n\t[info\t\t= getInfo(\"client\")]\n\t[libs\t\t= json.get(info, \"library tokens\")]\n\t[botVersion\t= json.get(libs, \"lib:OnTokenMove\")]\n\t[baseMap\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t[mapList\t= getAllMapNames(\"json\")]\n\t[oldMap\t\t= getCurrentMapName()]\n\t[abort(input(\"checkLevel|Light, Medium, Heavy|<html>\n\tHow thorough should the Token Name Check be?<br>\n\tNote that 'Heavy' might result in a lot\tof 'error'<br>\n\treports that are not a threat at all!<\/html>|RADIO|SELECT=1\"))]\n\n\t\n\t\n\t[regIllCharChk\t= \":'\\\\\\$\" + if(checkLevel, \"&?@;\", \"\") + if(checkLevel==2, \"+=#|<>.-\", \"\")]\n};{}]\n\n[h:'']\n[h:'']\n\n[h:varsFromStrProp(getLibProperty('bot.fg.diagArrays',  'lib:OnTokenMove'))]\n[h:varsFromStrProp(getLibProperty('bot.fg.diagLists',  'lib:OnTokenMove'))]\n\n[h:'']\n\n[h:'']\n[h:allStates\t\t= getTokenStates(\"json\")]\n[h:found\t\t\t= json.intersection(allStates, diagStateArray))]\n[h:notFound\t\t\t= json.difference(diagStateArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \"x <u><font color='red'>The following states are currently <b>NOT<\/b> defined for this campaign:<\/font><\/u><br>\"]\n\t[foreach(state, notFound): output\t= output + \"<b> - \"+state+\"<\/b>: used in the Bag of Tricks for \"+listGet(diagStateList, json.indexOf(diagStateArray, state))+\"<br>\"]\n\t[stateOutput\t= output + \"If you're not planning to make use of any of these functions, you can ignore this message.\"]\n};{\n\t[stateOutput\t= \"v All necessary Bag of Tricks states have been defined\"]\n}]\n\n[h:'']\n\n\n[h:toggles = getLibProperty(\"toggles\", \"lib:EventMacros\")]\n[h:output\t\t\t= \"<u><font color='green'><b>The following BoT Toggles are currently turned ON (in the settings): <\/font><\/u><\/b>\"]\n[h,foreach(toggle, toggles, \"\",\";\"), if(indexValueStrProp(toggle, 0) == 1 || indexValueStrProp(toggle, 0) == 2): output\t= listAppend(output, indexKeyStrProp(toggle, 0),\", \")]\n[h:togglesOutput\t\t= output]\n\n[h:'']\n[h, if(listContains(togglesOutput, \"doInvisibility\")), CODE:{ \n\t\n\t[invisState\t\t\t= getLibProperty('invisState','lib:EventMacros')]\n\t[seeInvisState\t\t= getLibProperty('seeInvisState','lib:EventMacros')]\n\t[purgeInvisState\t= getLibProperty('purgeInvisState','lib:EventMacros')]\n\t[annulInvisState\t= getLibProperty('annulInvisState','lib:EventMacros')]\n\t[invisStates\t\t= json.append(\"[]\", invisState, seeInvisState, purgeInvisState,annulInvisState)]\n\t[numStates\t\t\t= json.length(json.intersection(allStates, invisStates))]\n\t[if(numStates != 4), CODE:{\n\t\t\n\t\t\n\t\t[toggles = setStrProp(toggles, \"doInvisibility\", 0)]\n\t\t[setLibProperty(\"toggles\", toggles, \"lib:EventMacros\")]\n\t\t[invisOutput\t= \"x <u><font color='red'>In the Settings, Invisibility is turned on, however there are \" + numStates + \" invisibility defined, while 4 are required!! <b>Setting is TURNED OFF!<b><\/font><\/u>\"]\n\t};{\n\t\t[invisOutput\t= \"v Invisibility is used and all required states are defined\"]\n}]\n};{\n\t[invisOutput\t\t= \"v Invisibility is not used\"]\n}]\n\n\n[h:'']\n[h:setCurrentMap(baseMap)]\n[h:allToks\t\t\t= getTokenNames(\"json\", json.set(\"{}\", \"layer\", json.append(\"[]\",\"TOKEN\",\"HIDDEN\",\"OBJECT\",\"BACKGROUND\")))]\n[h:setCurrentMap(oldMap)]\n[h:found\t\t\t= json.intersection(allToks, diagTokenArray))]\n[h:notFound\t\t\t= json.difference(diagTokenArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \"x <u><font color='red'>The following Tokens are currently <b>NOT<\/b> present in this campaign file:<\/font><\/u><br>\"]\n\t[foreach(state, notFound): output\t= output + \"<b> - \"+state+\"<\/b>: used in the Bag of Tricks for \"+listGet(diagTokenList, json.indexOf(diagTokenArray, state))+\"<br>\"]\n\t[tokOutput\t\t= output + \"If you're not planning to make use of any of these functions, you can ignore this message.\"]\n};{\n\t[tokOutput\t\t= \"v All necessary Bag of Tricks tokens have been found\"]\n}]\n\n[h:'']\n[h:tableJson\t\t= json.get(getInfo(\"campaign\"),\"tables\")]\n[h:tableGroups\t\t= json.toList(tableJson)]\n[h:found\t\t\t= json.intersection(tableJson, diagTableArray))]\n[h:notFound\t\t\t= json.difference(diagTableArray, found)]\n\n[h,if(!json.isEmpty(notFound)), CODE:{\n\t[output\t\t\t= \"x <u><font color='red'>The following table(s) is/are currently <b>NOT<\/b> present in this campaign <\/font><\/u><font color='blue'><a href='https://forums.rptools.net/viewtopic.php?p=274503#p274503'>(link to the special pads zip file)<\/a><\/font>:<br>\"]\n\t[foreach(table, notFound): output\t= output + \"<b> - \"+table+\"<\/b>: \"+listGet(diagTableList, json.indexOf(diagTableArray, table))+\".<br>\"]\n\t[tableOutput\t= output]\n\n\t[if(!json.contains(tableJson, \"tbl_Image\")), CODE:{\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t};{\n\t\t[right\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 24, 15) + \"'><\/image>\"]\n\t\t[wrong\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 25, 15) + \"'><\/image>\"]\n\t}]\n};{\n\t[tableOutput\t= \"v All necessary Bag of Tricks tables are installed\"]\n\t[if(table(\"tbl_Image\", 25) != \"Wrong\"), CODE:{\n\t\t[tableOutput\t= tableOutput + \"<br>x However 'tbl_Image' is not up to date. You can extract it from <font color='blue'><a href='http://bit.ly/GGVCzN'>here<\/a><\/font>\"]\n\t\t[right\t\t\t= \"\"]\n\t\t[wrong\t\t\t= \"\"]\n\t};{\n\t\t[right\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 24, 15) + \"'><\/image>\"]\n\t\t[wrong\t\t\t= \"<image src='\" + tableImage(\"tbl_Image\", 25, 15) + \"'><\/image>\"]\n\t}]\n}]\n\n[h:libList\t\t\t= json.fields(json.get(info, \"library tokens\"))]\n[h:hasOwner\t\t\t= \"\"]\n\n[h,if(onCampaignLoad), CODE:{\n\t\n\t[foreach(map, mapList), CODE:{\n\t\t[setCurrentMap(map)]\n\t\t[foreach(libTok, libList), if(findToken(libTok) != \"\"), CODE:{\n\t\t\t[if(isOwnedByAll(libTok) || getOwners(\",\",libTok) != \"\"):\thasOwner = listAppend(hasOwner, strformat(\"%{libTok} (%{map})\"))]\n\t\t''\n\t\t}]\n\t''\t\n\t}]\n''\n};{\n\t\n\t[isHidden\t\t\t= \"\"]\n\t[h:txtOutput\t\t= \"<b><u><font color='red'>ERRORS FOUND: <\/font><\/u><\/b><br>If any errors have been found in a token, a hyperlink is shown which will goto the corresponding map and select the token (if possible). Keep in mind however that the listed tokens likely have characters in their name that might break these hyperlinks, which will result in an error report. In this case just go to the map and search it manually<br><br>\"]\n\t\n\t[h:result\t\t\t= \"<a href='macro://gotoToken@lib:OnTokenMove/none/impersonated?["%{map}", "%s", "3", "0", "0"]'>%s<\/a>\"]\n\n\t[foreach(map, mapList), CODE:{\n\t\t[txtOutput\t\t= txtOutput + strformat(\"<b><u>%{map}<\/u><\/b><br>\")]\n\t\t[setCurrentMap(map)]\n\t\t\n\t\t\n\t\t[warningName\t= if(getFindCount(strfind(map,\"[^,\\\\w\\\\s\\\\-._]\")) ||  getFindCount(strfind(map,\",\")),1,0)]\n\t\t[if(warningName):\ttxtOutput = txtOutput + strformat(\"<font color=red>This map contains non-alphanumerical characters, that can potentially break Bag of Tricks or Framework macros. After you fixed the name, run Diagnose again!!<\/font><br>\")]\n\t\t\n\t\t[warningName\t= if(isNumber(substring(map,0,1)), 1, 0)]\n\t\t[if(warningName):\ttxtOutput = txtOutput + strformat(\"<font color=red>Either the name of this map starts with a number or the map name IS a number. Both cases will lead to errors for the Bag of Tricks.<\/font><br>\")]\n\t\t\n\t\t\n\t\t[foreach(libTok, libList), if(findToken(libTok) != \"\"), CODE:{\n\t\t\t[hasOwner = \"\"]\n\t\t\t[isHidden = \"\"]\n\t\t\t[if(isOwnedByAll(libTok) || getOwners(\",\",libTok) != \"\"):\thasOwner\t\t= listAppend(hasOwner,\t\tstrformat(\"%{libTok} (%{map})\"))]\n\t\t\t[if(!getVisible(libTok)):\t\t\t\t\t\t\t\t\tisHidden\t\t= listAppend(isHidden,\t\tstrformat(\"%{libTok} (%{map})\"))]\n\n\t\t\t\n\t\t\t[h,if(listCount(hasOwner)):\t\ttxtOutput\t= txtOutput + strformat(\"The following lib(s) have a(n) owner(s) set. If the lib is for general use (all players) then you need to correct this (uncheck all owners): \")]\n\t\t\t[h:txtOutputL\t= \"\"]\n\t\t\t[h,foreach(tok, hasOwner): \t\ttxtOutputL\t= listAppend(txtOutputL, strformat(result, tok, tok))]\n\t\t\t[h:txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<br><br>\", \"\")]\n\n\t\t\t\n\t\t\t[h,if(listCount(isHidden)):\t\ttxtOutput\t= txtOutput + strformat(\"The following lib(s) are NOT visible to players. Make sure they are: \")]\n\t\t\t[h:txtOutputL\t= \"\"]\n\t\t\t[h,foreach(tok, isHidden):\t\ttxtOutputL\t= listAppend(txtOutputL, strformat(result, tok, tok))]\n\t\t\t[h:txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<br><br>\", \"\")]\n\t\t''\n\t\t}]\n\t\t\n\t\t\n\t\t[H:tokListP\t= getTokenNames(\"%\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t\t[h:tokList\t= getTokenNames(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\n\t\t[h:hasWrongTokName\t= \"[]\"]\n\n\t\t\n\t\t[h:regResult\t= strfind(tokListP,\"[^%]*(,+)[^%]*\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t\t\t\n\t\t\n\t\t[h:tokListC\t= json.difference(tokList, hasWrongTokName)]\n\t\t[h:tokListC\t= json.toList(tokListC)]\n\n\t\t\n\t\t[h:regResult\t= strfind(tokListC,\"[^,]*([\"+regIllCharChk+\"]+)[^,]*\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasWrongTokName = json.append(hasWrongTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t\n\t\t[if(json.length(hasWrongTokName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>NAMES<\/b> have non alphanumerical characters in their name and <i>might<\/i> render an issue:<br><font color='red'>\")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasWrongTokName):txtOutputL\t= listAppend(txtOutputL, id)]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br><\/font>\"]\n\n\t\t\n\t\t[h:hasSpaceTokName\t= \"[]\"]\n\t\t[h:regResult\t= strfind(tokListC,\"(?<=,)\\\\s[^,]*|[^,]*\\\\s(?=,)\")]\n\t\t[h:numWrong\t\t= min(1000,getFindCount(regResult))]\n\n\t\t[h,if(numWrong), CODE:{\n\t\t\t[count(numWrong): hasSpaceTokName = json.append(hasSpaceTokName, getGroup(regResult, roll.count+1,0))]\n\t\t''\n\t\t}]\n\t\t\n\t\t[if(json.length(hasSpaceTokName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>NAMES<\/b> have SPACES in their name (either trailing or leading) and <i>might<\/i> render an issue:<br><font color='red'>\")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasSpaceTokName):txtOutputL\t= listAppend(txtOutputL, id)]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br><\/font>\"]\n\n\t\t\n\t\t\n\t\t\n\t\t[hasWrongIdName\t= \"[]\"]\n\t\t[idList\t= getTokens(\"json\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t\t[splices\t= bot_createSplices(idList)]\n\t\t[foreach(splice, splices), CODE:{\n\t\t\t[foreach(id, splice), if(length(id) != 32): hasWrongIdName = json.append(hasWrongIdName, id)]\n\t\t\t\n\t\t''\n\t\t}]\n\t\t\n\t\t[if(json.length(hasWrongIdName)):\ttxtOutput\t= txtOutput + strformat(\"The following token <b>ID's<\/b> have been <b>fixed<\/b> (numerical token ids can lead to a lot of issues in maptool. By copy pasting the original they get a new ID. Run Diagnose again just to be sure that the new name is not a number):<b> \")]\n\t\t[txtOutputL\t= \"\"]\n\t\t[foreach(id, hasWrongIdName), CODE:{\n\t\t\t[txtOutputL\t= listAppend(txtOutputL, getName(strformat(\"%032d\",id)))]\n\t\t\t[copyToken(strformat(\"%032d\",id),1,\"\",json.set(\"{}\",\"name\",getName(strformat(\"%032d\",id)),\"delta\",1,\"x\",0,\"y\",0)) ]\n\t\t\t[removeToken(strformat(\"%032d\",id)) ]\n\t\t}]\n\t\t[txtOutput\t= txtOutput + txtOutputL + if(txtOutputL != \"\", \"<\/b><br><br>\", \"\")]\n\t\t[txtOutput\t= txtOutput + \"<br>\"]\n\t''\n\t}]\n''\n}]\n[h:setCurrentMap(oldMap)]\n\n[h,if(hasOwner != \"\"):\n   libOwnerOutput   = \"x <u><font color='red'>The following lib:Tokens have an owner set and trusted macros <b>WILL NOT WORK!<\/b>: <\/font><\/u><br>\"+hasOwner+\". If this is a lib:token of a player, then this is no issue. If this however is a lib:token belonging to the gm or Framework then it most likely will pose a problem. To fix this, double click on these lib:Tokens, goto the ownership tab and make sure ALL checkboxes are UNchecked\"\n;\n   libOwnerOutput   = \"v All lib:Tokens have no owners set (this is good!).\"\n]\n\n[if(!onCampaignLoad), CODE:{\n\t[r,frame(\"Initialization result\")\t\t\t\t:{[r:txtOutPut]}]\n};{}]",
        "maxWidth": "",
        "tooltip": "<html>Maps diagnosis. This function checks ALL maps and ALL (lib)tokens for potential issues.<br> It checks whether token names contain non-alphanumerical characters and checks the libs for the<br> same and owner ship and visibility. Any errors are rendered in a frame with hyperlinks that lead<br> you to the token. <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f038c145-787c-4ea9-9ec9-26dba7395d01",
          "commandChecksum": "fdd78a381e9f6924b0e31c47d62307f6",
          "propsChecksum": "3a900325e2c71d6e23dd41eb2f1cf2d5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 540,
        "label": "setDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n currentVBLAngle=0;\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n drawVBL=1;\n windowVBL=0;\n keyholeVBL=0;\n crackVBL=0;\n halfVBL=0;\n fullVBL=1;\n stepSize=0;\n crackStepSize=0;\n halfStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n halfOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpenDoorX=0;\n crackOpenDoorY=0;\n halfOpenDoorX=0;\n halfOpenDoorY=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n choice= \"fullVBL\";\n')]\n\n\n[h:varsFromStrProp(initList)]\n\n\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:vblSupport\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:drawVBL\t\t\t= if(drawVBL && vblSupport, 1, 0)]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(getTokenWidth() != getTokenHeight()):\twarning = listAppend(warning, \"The image you are using is NOT square. IF you are using VBL then this may result in pieces of VBL remaining on the map. The easiest solution is to set the door to a preset size like 'Large'.\", \"<br><br>\")]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n\n[h:hasVbl\t\t= !json.isEmpty(json.get(json.get(bot_VBLGrenade(1,0),0),\"points\"))]\n[h:removeVBL\t= 0]\n\n[h: abort(input(\n\tif(vblSupport, \"tab0|Door option|| TAB\", \"\"),\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t- when using VBL: there is NO VBL where the door-opening is.<br>\n\t\t- when using VBL: the UNROTATED* door image has the HINGES at the CENTRE and has the HANDLE on the EAST side<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\",\n\t\n\tif(vblSupport, \"tab1|VBL Options|| TAB\", \"\"),\n\tif(vblSupport, \"junk|<html><b>The below options are ONLY availabel if you check 'VBL for doors'<\/b><\/html>|-|LABEL|SPAN=TRUE\", \"\"),\n\tif(vblSupport, \"drawVBL|\"+drawVBL+\"|Use vision blocking for door|CHECK\", \"\"),\n\tif(vblSupport && hasVbl, \"removeVBL|0|<html><span title='<html><b>When checked: ALL VBL on the ENTIRE token will be erased (so not only the door line)<\/html>'>Remove current VBL on door<\/html><\/span><\/html>|CHECK\", \"\"),\n\tif(vblSupport, \"junk|<html><b>When you check any of these a menu will pop-up when you toggle the door<\/b><br>Players are allowed to:<\/html>|-|LABEL|SPAN=TRUE\", \"\"),\n\tif(vblSupport, \"windowVBL|\"+windowVBL+\"|peek through a window in the door|CHECK\", \"\"),\n\tif(vblSupport, \"keyholeVBL|\"+keyholeVBL+\"|peek through the key hole|CHECK\", \"\"),\n\tif(vblSupport, \"crackVBL|\"+crackVBL+\"|crack the door and peek|CHECK\", \"\"),\n\tif(vblSupport, \"halfVBL|\"+halfVBL+\"|open the door half way|CHECK\", \"\"),\n\tif(vblSupport, \"fullVBL|\"+fullVBL+\"|open the door fully|CHECK\", \"\")\n))]\n\n\n[h,if(drawVBL && !sum(windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL)): fullVBL  = 1]\n\n\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, drawVBL, openDistance, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n[h,if(animateTime == 0): animateTime = 1]\n\n\n\n\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t\n\t[h:currentVBLAngle\t= currentJavaAngle]\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\t\n\t[h,if(vblSupport): setTokenShape(\"TOP DOWN\", mainDoor)]\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t\n\t\t[stepSize\t\t=  openAngle/animateTime]\n\t\t[crackStepSize\t= 10/animateTime]\n\t\t[halfStepSize\t= 45/animateTime]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t[crackOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*10,360)]\n\t\t[halfOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*45,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t\n\t\t[stepSize\t\t= openDistance/animateTime]\n\t\t[crackStepSize\t= (openDistance/10)/animateTime]\n\t\t[halfStepSize\t= (openDistance/2)/animateTime]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t['pause(\"openMethod\",\"currentX\",\"currentY\",\"closedDoorX\",\"closedDoorY\",\"openDoorX\",\"openDoorY\",\"openDistance\",\"xDistance\",\"yDistance\")']\n\t\t[crackOpenDoorX\t= currentX + floor(xDistance/10)]\n\t\t[crackOpenDoorY\t= currentY + floor(yDistance/10)]\n\t\t[halfOpenDoorX\t= currentX + floor(xDistance/2)]\n\t\t[halfOpenDoorY\t= currentY + floor(yDistance/2)]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\",\t\"closedDoorX=\"\t+getTokenX(1,doubleDoorName)+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\";closedDoorY=\"\t+getTokenY(1,doubleDoorName)+\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\";currentVBLAngle=\"\t+bot_getTokenFacing(doubleDoorName, 1), doubleDoorName)\n\t]\n\t\n\t[h,if(vblSupport && doubleDoor): setTokenShape(\"TOP DOWN\", doubleDoorName)]\n\n\t\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t\n\t[h:setState(\"Locked\",isLocked)]\n\n\t\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, currentVBLAngle, openAngle, openDistance, animateTime, withSwitch, proximity, drawVBL, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t\n\t[h,if(removeVBL): bot_VBLGrenade(1,1, mainDoor)]\n\t[h,if(removeVBL && doubleDoor): bot_VBLGrenade(1,1, doubleDoorName)]\n\n\t\n\t[h,if(drawVBL), CODE:{\n\t\t\n\t\t[xOffset\t= round(getTokenWidth() / 2, 0)]\n\n\t\t[vblSetup\t= strformat(\n\t\t\t\"applyVBL=1; VBLType=3; scaleX=100; scaleY=100; offsetX=%{xOffset}; offsetY=0; thickness=2; fill=0; scale=0.5; close=0; sides=6; centreOffset=0; resetFoW=1; rxOffset=0; ryOffset=0;\"\n\t\t)]\n\n\t\t\n\t\t[setProperty(\"w42.bot.vblSetup\", vblSetup, mainDoor)]\n\n\t\t\n\t\t[bot_createVBL(mainDoor,0,1)]\n\t\t[if(doubleDoor): bot_createVBL(doubleDoorName,0,1)]\n\t}]\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "754717f7-c3c0-4fd6-97d0-f9dcdfe7a4a8",
          "commandChecksum": "339cd358a34d5c8e811e6e98fbf7ac77",
          "propsChecksum": "76f8ba2c0ea721d76eb1cdcc36027bc7"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 541,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n[h:drawVBL\t\t\t\t= if(drawVBL && vblSupport, 1,0)]\n\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n[h:choice\t= getProperty(\"clearedVBL\", mainDoor)]\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t[isClosed\t\t= 1]\n\t[setProperty(\"clearedVBL\", \"\", mainDoor)]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n\n[h,if(drawVBL && !isClosed && choice == \"\" || !drawVBL): choice = \"fullVBL\"]\n[h,if(drawVBL && isClosed), CODE:{\n\t[nothing\t= 1]\n\t[propList\t= \"nothing, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n\n['windowVBL = 0']\n['keyholeVBL = 0']\n\t[if(windowVBL+keyholeVBL+crackVBL+halfVBL+fullVBL > 1), CODE:{\n\t\t[optionList = \"\"]\n\t\t[choices\t= \"Do nothing, Peek through the window, Peek through the key hole, Crack the door open, Open the door halfway, Open the door all the way\"]\n\t\t[foreach(item, propList): optionList = if(eval(item), listAppend(optionList, listGet(choices, roll.count)), optionList)]\n\t\t\n\t\t[abort(input(\n\t\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\t\"choice|\"+optionList+\"|You...|RADIO|VALUE=STRING\"\n\t\t))]\n\t\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t\t[abort(if(choice == \"nothing\", 0,1))]\n\t}; {\n\t\t\n\t\t[choice = \"\"]\n\t\t[foreach(item, propList): choice = if(eval(item), item, choice)]\n\t\t\n\t\t[if(choice == \"\"):choice = \"fullVBL\"]\n\t}]\n}; {}]\n\n[h:setProperty(\"clearedVBL\", choice, mainDoor)]\n[h:'pause(\"choice\")']\n\n\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t\n\t[isClosed\t\t= 0]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\n\t\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[doubleStartPos\t\t= bot_getTokenFacing(mainDoor+'a')]\n\t\t[setTokenFacing(doubleEndPos, mainDoor+\"a\")]\n\t}; {\n\t\t[doubleOldPos\t\t= 0]\n\t}]\n\n\t[if(drawVBL): bot_moveStamp()]\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t\n\t\n\t[if(choice == \"crackVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(crackOpenDoorX, crackOpenDoorY, 1, mainDoor)\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"halfVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(halfOpenDoorX, halfOpenDoorY, 1, mainDoor)\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"fullVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(openDoorX, openDoorY, 1, mainDoor)\t\t\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[xDirection\t= if(openMethod < 4, 1, 0)]\n\t\t[newXPos\t= if(isClosed, openDoorX, closedDoorX)]\n\t\t[newYPos\t= if(isClosed, openDoorY, closedDoorY)]\n\t\t[DDoorX\t\t= if(xDirection, doubleDoorParam - newXPos, getTokenX(1, mainDoor+'a'))]\n\t\t[DDoorY\t\t= if(xDirection, getTokenY(1, mainDoor+'a'), doubleDoorParam - newYPos)]\n\t\t[moveToken(DDoorX, DDoorY, 1, mainDoor+\"a\")]\n\t}]\n\t[isClosed \t= 1 - isClosed]\n\t[if(drawVBL):bot_moveStamp()]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, choice, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, choice, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, choice, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eeb6953d-3007-454e-8c90-0cbe8fe64d3b",
          "commandChecksum": "3eb0f088e42bbd01e3811f5cde080a0f",
          "propsChecksum": "77c53ceeccb6f814831836cb14780891"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "1",
        "index": 586,
        "label": "toggleDoor BCK",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[h: '']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t\n\t\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[doubleOldPos\t= 0]\n\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t\n\t\n\n\t[isClosed \t= 1 - isClosed]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "240b2d6c-0f37-4c61-9d95-8c06dee58096",
          "commandChecksum": "836d33158c56ca1c26da6cbe13187322",
          "propsChecksum": "c9bb1bd63d98531786c6ef639ed5d7b5"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 542,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n[H, if(init), code: {\n\t\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[choice\t\t\t= arg(3)]\n\t[isClosed\t\t= arg(4)]\n\t\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[if(drawVBL), CODE:{\n\t\t\n\t\t[if(!getLibProperty('vblSupport','lib:EventMacros')):drawVBL = 0]\n\t};{}]\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\n\n\t\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tendPos = totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tstartPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tstartPos = totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n\n\n\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tendPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tendPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tstartPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tstartPos\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[if(choice == \"crackVBL\"):\tcurrentStepSize = direction * crackStepSize]\n\t[if(choice == \"halfVBL\"):\tcurrentStepSize = direction * halfStepSize]\n\t[if(choice == \"fullVBL\"):\tcurrentStepSize = direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor && choice == \"fullVBL\"): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t}; {\n\t\t\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, choice, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t};{}]\n\n\t\t[if(doubleDoor && choice == \"fullVBL\"): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\t}]\n}]\n\n\n\n\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\tchoice\t\t\t= %{choice}; \n\t\t\tdrawVBL\t\t\t= %{drawVBL};\n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t\t\n\t\t[doVBL\t= 0]\n\t}; {\n\t\t\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t\t[doVBL\t= 1]\n\t}]\n\t\n\t[if(drawVBL && doVBL), CODE:{\n\t\t[mainDoor\t\t= me]\n\t\t[isClosed \t\t= bot_isDoorClosed(mainDoor)]\n\t\t[bot_moveStamp(me)]\n\t\t[if(doubleDoor): bot_moveStamp(me + 'a')]\n\t}; {}]\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52108fe7-be3a-4398-81ac-44444a31de0c",
          "commandChecksum": "9ca84639869988eea580128d631d09df",
          "propsChecksum": "e6bc4a6f868393ee0cd3f1df9ee55223"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "2",
        "index": 585,
        "label": "deferToggleDoor BCK",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[h:'']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\n\t\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n\n\t\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n\n\n\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n\n\n\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7f35e3b3-bd68-4b5d-a07e-4699b46b25aa",
          "commandChecksum": "b90143e816d05b7dc07530820ee1e099",
          "propsChecksum": "33aa9d3383a24d75d881ec944e482423"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 543,
        "label": "setVBLDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n\n\n\n\n\n[h,if(argCount() > 0): mainDoor = arg(0)]\n[switchToken(mainDoor)]\n[gridSize\t= json.get(json.get(getInfo(\"map\"), \"grid\"), \"size\")]\n\n\n[varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[varsFromStrProp(\"r=0; points=[]; scale=1; thickness=2; fill=0; close=0; x=0;y=0;w=0;h=0\")]\n\n[shape\t= \"polygon\"]\n[doorX\t= closedDoorX]\n[doorY\t= closedDoorY]\n[xOffset= round(getTokenWidth() / 2, 0)]\n[rx\t\t= doorX + xOffset] \n[ry\t\t= doorY + round(getTokenHeight() / 2, 0)]\n[x1\t\t= rx+2] \n[x2\t\t= doorX + getTokenWidth()]\n[y1\t\t= ry]\n[y2\t\t= ry]\n\n\n[h,switch(choice),CODE:\n\tcase \"keyholeVBL\": {\n\t\t\n\t\t[mDoor\t\t= rx + round(getTokenWidth() / 4, 0)] \n\t\t[width\t\t= max(1, floor(gridSize/50))]\n\t\t[x1\t\t\t= mDoor - width]\n\t\t[x2\t\t\t= mDoor + width]\n\t}; \n\tcase \"windowVBL\": {\n\t\t\n\t\t[mDoor\t\t= rx + round(getTokenWidth() / 4, 0)] \n\t\t[width\t\t= max(2, floor(gridSize/8))]\n\t\t[x1\t\t\t= mDoor - width]\n\t\t[x2\t\t\t= mDoor + width]\n\t\t['pause(\"mDoor\",\"rx\",\"x1\",\"x2\",\"width\",\"gridSize\")']\t\n\t}; \n\tdefault: {\n\t\t[error = \"Unknown VBL choice: \"+choice]\n\t\t[pause(\"error\")]\n\t}\n]\n\n\n[re \t= currentVBLAngle]\n[rd \t= bot_getTokenFacing(mainDoor, 1)]\n\n\n[currentVBLAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[setProperty(\"w42.bot.doorData\", setStrProp(getProperty(\"w42.bot.doorData\", mainDoor), \"currentVBLAngle\", currentVBLAngle), mainDoor)]\n\n\n[if(isClosed), CODE:{\n\t\n\t[points1\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[points2\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[ePoints\t= json.append('[]', points1, points2) ]\t\t\t\n\n\t\n\t[points1\t= json.set(\"{ }\", \"x\", x1, \"y\", y1) ]\n\t[points2\t= json.set(\"{ }\", \"x\", x2, \"y\", y2) ]\n\t[dPoints\t= json.append('[]', points1, points2) ]\t\t\t\n};{\n\t\n\t[points1\t= json.set(\"{ }\", \"x\", x1, \"y\", y1) ]\n\t[points2\t= json.set(\"{ }\", \"x\", x2, \"y\", y2) ]\n\t[ePoints\t= json.append('[]', points1, points2) ]\t\t\t\n\n\t\n\t[points1\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[points2\t= json.set(\"{ }\", \"x\", 0, \"y\", 0) ]\n\t[dPoints\t= json.append('[]', points1, points2) ]\t\t\t\n}]\n\n[jsonVBL = \"[]\"]\n['VBLData = json.fromStrProp(strPropFromVars(\"shape, x, y, w, h, points, r, scale, thickness, fill, close\", \"UNSUFFIXED\"))']\n[eShape\t\t= json.set(\"{ }\", \"shape\", \"polygon\", \"rx\", rx, \"ry\", ry, \"r\", re, \"close\", 0, \"thickness\", 2, \"scale\", 1, \"points\", ePoints)] \n[dShape\t\t= json.set(\"{ }\", \"shape\", \"polygon\", \"rx\", rx, \"ry\", ry, \"r\", rd, \"close\", 0, \"thickness\", 2, \"scale\", 1, \"points\", dPoints)] \n\n[eJsonVBL\t= json.append(jsonVBL, eShape)]\t\n[dJsonVBL\t= json.append(jsonVBL, dShape)]\t\n\n['pause(\"eJsonVBL\",\"dJsonVBL\", \"isClosed\", \"doubleDoor\", \"choice\")']\n[eraseVBL(eJsonVBL)]\n[drawVBL(dJsonVBL)]\n\n[selectTokens(getTokens(\",\", '{ pc:1 }'),1,\",\")]\n[exposeFOW()]\n[deselectTokens()]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "46f25fc3-9b82-47b4-b99c-5bd9ae4c37c8",
          "commandChecksum": "f9d948e6855ad009efb7f787c5ac5b82",
          "propsChecksum": "5118696368a7449241b96cedec408df5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "18. Invisibility",
        "index": 544,
        "label": "startInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:'']\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t\n\t[setState(invisState, 1, meTok)]\n\t\n\t\n\t[setProperty(\"w42.originalOwners\", getOwners(\"json\", meTok), meTok)]\n\t\n\t[setProperty(\"w42.purgedBy\", \"[]\", meTok)]\n\t\n\t[setOwnerOnlyVisible(1, meTok)]\n\n\t[broadcast(\"Invisibility is turned on for <b>\" + meTok, bot_ownergm(meTok))]\n\n\t[tCopyID = copyToken(meTok, 1, \"\", json.set(\"{}\",\"layer\", \"object\", \"name\", getName(meTok)+\"(invis)\"))]\n\n\t['']\n\t\n\t[link1 = macroLinkText(\"createShadow@\" + getMacroLocation(), \"self\", tCopyID)]\n\t[execLink(link1, 1)]\n\n\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "21bac035-0266-4977-a153-14873ceaf07e",
          "commandChecksum": "6dc42fa7135fd523fa7fe2993a9b9566",
          "propsChecksum": "f0de154f3d6b3980e5ee7b29bee46691"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "18. Invisibility",
        "index": 545,
        "label": "createShadow",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:'\n[h:link1 = macroLinkText(\"checkInvisibility@\" + getMacroLocation(), \"self\", meTok)]\n[h:execLink(link1, 1)]\n\n\n[h:' bot_checkInvisibility(meTok)']\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "4025a958-774f-4711-a260-e52c623bcfb8",
          "commandChecksum": "9e5c01fd38fdf1c881e8fc514c4e1750",
          "propsChecksum": "3aa03b5f9430f4ad36ef23ed351c936b"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "18. Invisibility",
        "index": 546,
        "label": "endInvisibility",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n[h:\"\"]\n\n[h,if(argCount()): toks\t= arg(0) ; toks\t\t= getSelectedNames()]\n[h:invisState\t\t= getLibProperty('invisState','lib:EventMacros')]\n\n[h,foreach(meTok, toks), code:{\n\t\n\t[setState(invisState, 0, meTok)]\n\t\n\t[setOwner(getProperty(\"w42.originalOwners\", meTok),meTok)]\n\n\t\n\t[setProperty(\"w42.purgedBy\", \"[]\", meTok)]\n\t\n\t[setOwnerOnlyVisible(0, meTok)]\n\n\t\n\t[shadowToken = findToken(getName(meTok)+\"(invis)\")]\n\t[if(shadowToken!=\"\"): removeToken(getName(meTok)+\"(invis)\")]\n\t\n\t[broadcast(\"Invisibility is turned off for <b>\" + meTok, bot_ownergm(meTok))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "e3c15f67-2c02-4a52-9354-d01c769f7204",
          "commandChecksum": "8944b893a6518c1c92ae2a3d2fc57927",
          "propsChecksum": "ce56b1c8d237b09aab18df1d465e5025"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "white",
        "group": "18. Invisibility",
        "includeLabel": false,
        "sortBy": "18. Invisibility",
        "index": 550,
        "label": "resetRanges",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:' ']\n\n[resetProperty(\"w42.seeInvisRange\")]\n[resetProperty(\"w42.purgeInvisRange\")]\n[resetProperty(\"w42.annulInvisRange\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare": [],
        "metadata":         {
          "uuid": "2cd4a16e-f107-4a5c-8f35-0102df8d6d7a",
          "commandChecksum": "e613dbf64fd3217cd13fc38800a6b2a7",
          "propsChecksum": "e207b877b81e1247e8fb0fe316c70956"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 551,
        "label": "Reset Ranges",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_resetRanges()]",
        "maxWidth": "",
        "tooltip": "resets the invisibility related ranges of the selected tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "627afd89-1bba-444e-b171-bef57014c4e0",
          "commandChecksum": "5dfd9821d08b0b8ef67a616ae9c838b5",
          "propsChecksum": "57b3b82519e8bd92a569e477d3c553a4"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 552,
        "label": "Change Elevation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:bot_changeElevation()]",
        "maxWidth": "",
        "tooltip": "Sets flying or burrowing (or swimming) of selected token. Is used for getRangedDistance Macro that is used in the invisibility macros",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "de04a4fa-2730-4102-ab57-1e26cddae25d",
          "commandChecksum": "80f0b6f4c52d7d25009bbdf6e1fdffca",
          "propsChecksum": "7dd97b72506738008191587b2f6b13a0"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation",
        "index": 554,
        "label": "setDoorBCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n\n[h:allDoors\t\t\t= getSelectedNames()]\n[h:mainDoor\t\t\t= listGet(allDoors, 0)]\n[h:switchToken(mainDoor)]\n\n[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n[h:openDistance\t\t= bot_getGridSize()]\n\n[h:initList\t\t\t= strformat(\n'switchId=\"\";\n openMethod=0;\n doubleDoor=0;\n addGMMote=1;\n description=\"\";\n closedAngle=%{currentAngle};\n openAngle=160;\n openDistance=%{openDistance};\n animateTime=2000;\n withSwitch=0;\n proximity=0;\n stepSize=0;\n crackStepSize=0;\n doubleDoorParam=0;\n totalOpenAngle=0;\n crackOpenAngle=0;\n closedDoorX=0;\n closedDoorY=0;\n openDoorX=0;\n openDoorY=0;\n crackOpenDoorX=0;\n crackOpenDoorY=0;\n xDirection=0;\n onOpen=0; \n onClose=0;\n isClosed=1;\n')]\n\n\n[h:varsFromStrProp(initList)]\n\n\n[h:doubleDoor\t\t= if(findToken(mainDoor+\"a\") != \"\", 1, 0)]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\n[h: isLocked\t\t= if(getState(\"Locked\"), 1, 0)]\n\n\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:setCurrentMap(getLibProperty(\"baseMapName\", \"lib:EventMacros\"))]\n\t[h:macroIDList\t\t= getMacroGroup(\"Event Door Macros\", \",\", \"lib:EventMacros\")]\n\t\n\t[h:macroNameList\t= \"<none>\"]\n\t[h,foreach(id, macroIDList): macroNameList = listAppend(macroNameList, getStrProp(getMacroProps(id, \"; \", \"lib:EventMacros\"),\"label\"))]\n[h:setCurrentMap(oldMap)]\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\")]\n[h,if(macroName == \"\"): macroName = \"name of macro\"]\n[h:eventTypeList\t= getProperty(\"w42.bot.eventTypeList\")]\n[h:triggerTypeList\t= \"onOpen, onClose\"]\n[h,foreach(event, eventTypeList): set(event, 1)]\n[h,if(listContains(macroNameList, macroName)):currentMacro = listFind(macroNameList,macroName) ; currentMacro = 0]\n\n[h:\t\t\t\t\t\t\t\t\t\t\twarning = \"\"]\n[h,if(closedAngle != currentAngle):\t\t\twarning = \"It appears there is already a value set for 'Closed Angle' (\"+closedAngle+\") and this does NOT correspond with the current angle (\"+currentAngle+\") of the door. If you are installing a new door and its currently in the 'closed' position, then change the value for 'closed angle' in the next input box to: \"+ currentAngle]\n[h,if(warning != \"\"):\t\t\t\t\t\tpause(\"warning\")]\n\n\n[h: abort(input(\n\t\"junk|<html><font color=red><b>MAKE SURE THAT<\/b><br>\n\t\t- the door is in the CLOSED position<br>\n\t\t- for SLIDING doors: SNAP TO GRID is TURNED OFF<br>\n\t\t*Unrotated: right mouseclick --> clear facing.<br>\n\t\tNote that you *can* rotate the door in any direction you like BEFORE you use this macro, but the UNROTATED IMAGE <br>\n\t\tmust fullfill the above requirements!!<br>\n\t\t<\/font><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"junk|<html><b>Door Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openMethod|Anti Clockwise, Clockwise, Slide to left, Slide to Right, Slide North, Slide South|How does the door open?|RADIO|SELECT=\"+openMethod,\n\t\"doubleDoor|\"+doubleDoor+\"|Double door? (if checked make sure that there is another door with the name: \"+token.name+\"a)|CHECK\",\n\t\"addGMMote|\"+addGMMote+\"|Add Door name to GM Notes|CHECK\",\n\t\"description|\"+description+\"|Description of door (This appears in the toggle doors macro) (set to 0 for no description)\",\n\n\t\"junk|<html><i>Rotating Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"closedAngle|\"+closedAngle+\"|Set the angle for closed door (number between 0 and 360)(current angle is give here)\",\n\t\"openAngle|\"+openAngle+\"|How many degrees does the door turn to open (typically 90 degrees)\",\n\n\t\"junk|<html><i>Sliding Door<\/i><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"openDistance|\"+openDistance+\"|How much does the door slide away (in distance per cell e.g.: 50)\",\n\t\"junk|<html><b>Animation Properties<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"animateTime|\"+animateTime+\"|How much time does it take for the door to open in milli seconds (set to 0 for no animation)\",\n\n\t\"junk|<html><b>Door Switch Button<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"withSwitch|\"+withSwitch+\"|Add a switch to the door, this will summon a 'switch' token to the door?|CHECK\",\n\t\"isLocked|\"+isLocked+\"|Lock door? (When a door is locked only the GM can open it)|CHECK\",\n\t\"proximity|\"+proximity+\"|Proximity of Player token to switch (set to 0 to not check proximity)?\",\n\n\t\"junk|<html><b>Macro run on trigger (only works with switch)<\/b><br>Note that only the macros from the group: 'Event Button macros' on 'Lib:EventMacros' are in the drop downlist<\/html>|-|LABEL|SPAN=TRUE\",\n\t\"macroName|\"+macroNameList+\"|<html><span title='<html><b>Enter here the name of the macro that is used when this door is opened or closed.<\/html>'>Name of event macro<\/html><\/span><\/html>|LIST|SELECT=\"+currentMacro,\n\n\t\"junk|<html><b>Which event triggers the macro<\/b><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"onOpen|\"+onOpen+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>opened<\/b><\/html>'>Door is opened<\/html><\/span><\/html>|CHECK\",\n\t\"onClose|\"+onClose+\"|<html><span title='<html><b>When checked:<\/b> The macro associated with this door,<br>will be triggered when the door is <b>closed<\/b><\/html>'>Door is closed<\/html><\/span><\/html>|CHECK\"\n))]\n\n\n[h:description = if(description == 0, \"\", description))]\n[h:propList = \"closedAngle, openAngle, openMethod, animateTime, doubleDoor, openDistance\"]\n[h,foreach(prop, propList): assert(isNumber(eval(prop)), \"Please fill in a number for: \"+prop+\", even if its not used\",0)]\n\n[h:assert(closedAngle\t>= 0\t&& closedAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for closed door'\",0)]\n[h:assert(openAngle\t\t>= 0\t&& openAngle\t<= 360,\t\"Please enter a number between 0 and 360 for the 'angle for open door'\",0)]\n[h:assert(openDistance\t>= 0,\t\t\t\t\t\t\t\"Please enter positive number for how far the doors slides away\",0)]\n[h:assert(animateTime\t>= 10\t&& animateTime\t<= 10000 || animateTime == 0,\t\"Please enter a number between 10 and 10000 for the 'Rotation time', or set to 0 for no rotation\",0)]\n[h,if(animateTime == 0): animateTime = 1]\n\n\n\n\n[h,foreach(mainDoor, allDoors), CODE:{\n\t[h:switchToken(mainDoor)]\n\t[h:currentAngle\t\t= bot_getTokenFacing(mainDoor)]\n\t[h:closedAngle\t\t= currentAngle]\n\t[h:currentJavaAngle\t= bot_getTokenFacing(mainDoor, 1)]\n\t[h:switchId\t\t\t= \"\"]\n\n\t[h:doubleDoorName = findToken(token.name+\"a\")]\n\t[h:assert(!doubleDoor || (doubleDoor && doubleDoorName != \"\") ,\t\"No <b>\"+token.name+\"a<\/b> found on map, either change the double door to the correct name or uncheck the box.\",0)]\n\n\t\n\t[h:currentX\t\t\t= getTokenX(1, mainDoor)]\n\t[h:currentY\t\t\t= getTokenY(1, mainDoor)]\n\t[h:closedDoorX\t\t= currentX]\n\t[h:closedDoorY\t\t= currentY]\n\n\n\t[h, if(openMethod < 2), CODE:{\n\t\t\n\t\t[stepSize\t\t=  openAngle/animateTime]\n\t\t[crackStepSize\t= 10/animateTime]\n\t\t[halfStepSize\t= 45/animateTime]\n\t\t[doubleDoorParam= closedAngle + if(openMethod, -90, 90)]\n\t\t[totalOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*openAngle,360)]\n\t\t[crackOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*10,360)]\n\t\t[halfOpenAngle\t= mod(closedAngle + if(openMethod, -1, 1)*45,360)]\n\t\t\n\t\t[startPos\t\t=  closedAngle]\n\t\t[endPos\t\t\t=  closedAngle]\n\t\t[doubleStartPos\t=  closedAngle + 180]\n\t\t[doubleEndPos\t=  doubleStartPos]\n\t};{\n\t\t\n\t\t[stepSize\t\t= openDistance/animateTime]\n\t\t[crackStepSize\t= (openDistance/10)/animateTime]\n\t\t[halfStepSize\t= (openDistance/2)/animateTime]\n\n\t\t[xDistance\t\t=  0]\n\t\t[yDistance\t\t=  0]\n\t\t\n\t\t[switch(openMethod):\n\t\t\tcase 2: xDistance\t= - openDistance; \n\t\t\tcase 3: xDistance\t= + openDistance; \n\t\t\tcase 4: yDistance\t= - openDistance; \n\t\t\tcase 5: yDistance\t= + openDistance; \n\t\t]\n\t\t[openDoorX\t\t= currentX + xDistance]\n\t\t[openDoorY\t\t= currentY + yDistance]\n\t\t['pause(\"openMethod\",\"currentX\",\"currentY\",\"closedDoorX\",\"closedDoorY\",\"openDoorX\",\"openDoorY\",\"openDistance\",\"xDistance\",\"yDistance\")']\n\t\t[crackOpenDoorX\t= currentX + floor(xDistance/10)]\n\t\t[crackOpenDoorY\t= currentY + floor(yDistance/10)]\n\t\t[halfOpenDoorX\t= currentX + floor(xDistance/2)]\n\t\t[halfOpenDoorY\t= currentY + floor(yDistance/2)]\n\t\t\n\t\t[xDirection\t\t=  if(openMethod < 4, 1, 0)]\n\t\t[if(doubleDoorName\t== \"\"): doubleDoorName\t=  token.name]\n\t\t[if(xDirection):\n\t\t\tdoubleDoorParam\t= getTokenX(1,doubleDoorName) + currentX)\n\t\t; \n\t\t\tdoubleDoorParam\t= getTokenY(1,doubleDoorName) + currentY)\n\t\t]\n\n\t}]\n\n\t\n\t[h,if(doubleDoor): setProperty(\"w42.bot.doorData\", \"closedDoorX=\"+getTokenX(1,doubleDoorName)+\";closedDoorY=\"+getTokenY(1,doubleDoorName))]\n\n\t\n\t[h,if(withSwitch && findToken(switchId) == \"\"), CODE:{\n\t\t[baseMap\t\t= getLibProperty(\"baseMapName\", \"lib:EventMacros\")]\n\t\t[switchId\t\t= copyToken(\"DoorLeverToken\", 1, baseMap, strformat(\"{x:'%s', y:'%s'}\", getTokenX(0), getTokenY(0)))]\n\t\t[tmpbuttonArgs\t= setStrProp(\"\", \"leverToken\", switchId)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"mainDoor\", mainDoor)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"macroToCall\", \"operateLever@this\")]\n\t\t[message  \t\t= \"This pause is unfortunately necessary for the door lever to work. Press ok to continue. A switch will appear close to the door, you can place this anywhere you want. You can also resize it or change its image.\"]\n\t\t[pause(\"message\")]\n\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t[switchId\t\t= getName(switchId)]\n\t''\n\t}; {\n\t\t[if(withSwitch), CODE:{\n\t\t\t[tmpbuttonArgs\t= getProperty(\"buttonArgs\", switchId)]\n\t\t\t[tmpbuttonArgs\t= setStrProp(tmpbuttonArgs, \"proximity\", proximity)]\n\t\t\t[setProperty(\"buttonArgs\", tmpbuttonArgs, switchId)]\n\t\t''\n\t\t}]\n\t''\n\t}]\n\n\t\n\t[h:setState(\"Locked\",isLocked)]\n\n\t\n\t[h, if(addGMMote), CODE:{\n\t\t[GMNote = \"<b>\" + token.name + \"<\/b><br>\"]\n\t\t[if(getGMNotes() == \"\"): setGMNotes(\"<b>\" + token.name + \"<\/b><br>\")]\n\t};{}]\n\n\t\n\t[r, if(macroName), CODE:{\n\t\t[h:macroName\t\t= listGet(macroNameList, macroName)]\n\t\t[h:setProperty(\"w42.bot.macroName\", macroName)]\n\t\t[h:eventTypeList\t= \"\"]\n\t\t[h,foreach(event, triggerTypeList), if(eval(event)): eventTypeList = listAppend(eventTypeList, event)]\n\t\t[h:setProperty(\"w42.bot.eventTypeList\", eventTypeList)]\n\t\t[r,gm: \"The Macro <u>\"+macroName+\"<\/u> is now linked to the following token(s)<u> \"+mainDoor+\"<\/u>. This macro will be executed when one of the following events are triggered: <u>\"+eventTypeList+\"<\/u>\"]\n\t\t<br><br>\n\t}; {\n\t\t[h:setProperty(\"w42.bot.macroName\", \"\")]\n\t}]\n\n\t[h:propList\t\t= \"switchId, openMethod, doubleDoor, addGMMote, description, closedAngle, openAngle, openDistance, animateTime, withSwitch, proximity, stepSize, crackStepSize, halfStepSize, doubleDoorParam, totalOpenAngle, crackOpenAngle, halfOpenAngle, closedDoorX, closedDoorY, openDoorX, openDoorY, crackOpenDoorX, crackOpenDoorY, halfOpenDoorX, halfOpenDoorY, xDirection\"]\n\n\t[h:setProperty(\"w42.bot.doorData\", strPropFromVars(propList, \"UNSUFFIXED\"), mainDoor)]\n\n\t[broadcast(strformat(\"door %{mainDoor} is successfully setup\"))]\n\t[selectTokens(mainDoor)]\n''\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "976fd2c6-f621-426d-af1f-da160e77d6b6",
          "commandChecksum": "a73620b2df9701117a4a332e57e80036",
          "propsChecksum": "73bdfea351a111f55ced9187619e1bbb"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "3. Pad Macros",
        "includeLabel": false,
        "sortBy": "3. Pad Macros",
        "index": 557,
        "label": "SoundPad",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h: return(isPC(tok, getCurrentMapName()), \"\")]\n[h: ownerNames\t\t= getOwners(\"json\", tok, getCurrentMapName())]\n[h: return(json.length(ownerNames), \"\")]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.soundSettings\",padName))]\t\n[h: soundExists\t\t= json.length(getSoundProperties(uri))]\n\n\n[h: dist\t\t\t= getDistance(padName, 1, tok)]\n[h, if (dist > distStart), CODE:{\n\t[execFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)]\n\n};{\n\t\n\t[if(effectArea != 0):\n\t\tonArea\t\t= bot_isOnDrawing(lastPath, effectArea)\n\t;\n\t\tonArea\t\t= 1\n\t]\n\t\n\t[if(onArea):\n\t\texecFunction(if(soundExists,\"editStream\", \"playStream\"), json.append(\n\t\t\t\"[]\", uri, \"-1\",\tstartVolume + \n\t\t\t\t\t\t\t\tsquare(1 - \n\t\t\t\t\t\t\t\t\tmax(0,dist-distMaxVolume) /\n\t\t\t\t\t\t\t\t\tmax(0.1,distStart-distMaxVolume)\n\t\t\t\t\t\t\t\t) * \n\t\t\t\t\t\t\t\t(maxVolume-startVolume)\n\t\t), 0, ownerNames)\n\t;\n\t\texecFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)\n\t]\n\n}]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a3f54328-783b-478b-9ef4-5474133f220d",
          "commandChecksum": "87383b79679968b3e94d6e6993bc7b59",
          "propsChecksum": "c433778603da1c0f875febe1590874ac"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 558,
        "label": "chkSounds",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h,if(argCount()==2), CODE:{\n\t[ownerNames\t= arg(0)]\n\t[forceStop\t= arg(1)]\n\t[padNames= json.get(getLibProperty(\"allMapsPads\", \"lib:EventMacros\"), getCurrentMapName())]\n};{\n\t[tok\t\t= arg(0)]\n\t[srcMap\t\t= arg(1)]\n\t[forceStop\t= arg(2)]\n\t[if(argCount()>3): padNames\t= arg(3) ; padNames = json.get(getLibProperty(\"allMapsPads\", \"lib:EventMacros\"), getCurrentMapName())]\n\t[return(if(tok==\"\",0,1), \"\")]\n\t[return(isPC(tok, SrcMap), \"\")]\n\t[ownerNames\t= getOwners(\"json\", tok, SrcMap)]\n\t[return(json.length(ownerNames), \"\")]\n}]\n\n[h,foreach(padName, padNames), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t[varsFromStrProp(getProperty(\"w42.bot.soundSettings\",padName))]  \n\t[if(forceStop), CODE:{\n\t\t[soundExists\t= json.length(getSoundProperties(uri))]\n\t\t[if (soundExists): execFunction(\"stopSound\", json.append(\"[]\", uri, 1, 1), 0, ownerNames)]\n\t};{\n\t\t[bot_SoundPad()]\t\n\t}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "4d959a28-236f-4847-a926-3fef051ea993",
          "commandChecksum": "4d1084e3de1c6480219cf7d1db0b7af8",
          "propsChecksum": "dfb8314523205f5338845d2d9c583767"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 559,
        "label": "setupSound",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:tok\t\t\t= getSelectedNames()]\n[h:assert(listCount(tok)==1, \"Make sure (only) one token is selected\",0)]\n\n\n[h:x=getLibProperty(\"padNameList\", \"lib:eventmacros\")]<br>\n[h,if(!listContains(x,\"SoundPad\")):setLibProperty(\"padNameList\", listAppend(x, \"SoundPad\"),\"lib:eventmacros\")]\n\n[h:'assert(startsWith(tok, \"SoundPad\"), \"Selected token name should start with 'SoundPad'\",0)']\n[h:isSoundPad\t= startsWith(tok, \"SoundPad\")]\n[h:switchToken(tok)]\n\n\n[h:varsFromStrProp(\"\n\turi=http://webadres.to.file.mp3 OR file:/C:/folder/file.mp3;\n\tstartVolume=0;\n\tdistStart=30;\n\tmaxVolume=1;\n\tdistMaxVolume=1;\n\teffectArea=;\n\tflag=0;\n\tflagTriggered=0;\n\")]\n\n[h:settings\t\t= getProperty(\"w42.bot.soundSettings\")]\n[h:varsFromStrProp(settings)]\n\n[h:abort(input(\n\t\"junk|<html>\"+if(isSoundPad,\n\t\t\"<b>Note that this IS a SoundPad.<\/b><br>\",\n\t\t\"<b>Note that this is NOT a SoundPad.<\/b><br>\"\n\t)\n\t+\"<u>SoundPads<\/u> are triggered based on proximity of a token to it.<br>\"\n\t+\"<u>Other tokens<\/u> only play a sound when they're triggered by their event.<br>\"\n\t+\"<b>For example<\/b> a PadStart token (teleport) will play its linked sound when you move onto it,<br>\"\n\t+\"while a SoundPad token will play its linked sound when you move close (enough) to it.<br>\"\n\t+\"Hence the below settings will differ whether you've selected a SoundPad or not<br><br>\"\n\t+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\n\t\"uri|\"+uri+\"|Set URI/URL of the sound||WIDTH=40\",\n\t\"startVolume|\"+startVolume+\"|Set volume of sound at furthest distance (value between 0 and 1)||WIDTH=4\",\n\n\tif(!isSoundPad, \n\t\t\"flag|\"+flag+\"|Play sound only once (use flag)||WIDTH=4\",\n\t\t\"\"\n\t),\n\tif(!isSoundPad, \n\t\t\"flagTriggered|\"+flagTriggered+\"|(use flag:) 0=pad is active ; 1=pad is inactive||WIDTH=4\",\n\t\t\"\"\n\t),\n\n\t\"distStart|\"+distStart+\"| Set furthest distance at which sound is \"+if(isSoundPad,\"first\", \"still\")+\" heard||WIDTH=4\",\n\t\"maxVolume|\"+maxVolume+\"|Set volume of sound at closest distance (value between 0 and 1)||WIDTH=4\",\n\t\"distMaxVolume|\"+distMaxVolume+\"|Set distance at which sound is at max volume||WIDTH=4\",\n\n\tif(isSoundPad, \n\t\t\t\t\"junk|<html>\"\n\t\t+\"<b>Optional: area check!<\/b> You can draw an are on (e.g.) the hidden layer. In the draw explorer<br>\"\n\t\t+\"you can give this drawing a name (right mouseclick on drawing --> 'Set Name')<br>\"\n\t\t+\"here you can enter that given name (make sure there are no duplicate names!<br>\"\n\t\t+\"now an owned pc token must be AND near enough of the pad AND end its move on the drawing<br>\"\n\t\t+\"in this way you can contain the sound within an area. <br>\"\n\t\t+\"Please note that the related MT function is a bit buggy so it might not work with 1 cell wide areas.\"\n\t\t+\"<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"\"\n\t),\n\t\n\tif(isSoundPad, \n\t\t\"effectArea|\"+effectArea+\"|Optionally: set the NAME of the area the token MUST be on||WIDTH=15\",\n\t\t\"\"\n\t)\n))]\n\n[h:settings\t\t\t= strPropFromVars(\"uri,startVolume,distStart,maxVolume,distMaxVolume,effectArea,flag,flagTriggered\",\"UNSUFFIXED\")]\n[h: setProperty(\"w42.bot.soundSettings\", settings)]\n\n[h: id\t\t\t\t= findDrawings(getCurrentMapName(),effectArea)] \n[h,if(id==\"\" && effectArea !=0):broadcast(\"<font color='red'><b>Settings have been saved. Do note however that the area <u>\"+ effectArea +\"<\/u> does not exist!!\")]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "22f71660-7bed-44f4-9d98-986bca315a2a",
          "commandChecksum": "83260b127d4046e1e26d0108a55c0c3e",
          "propsChecksum": "6cfc14900c418665adf5c5db3ac6e331"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 560,
        "label": "Setup Sound",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[H: bot_setupSound()]",
        "maxWidth": "",
        "tooltip": "Used to setup soundPad tokens",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "505adfc3-a2c2-4761-bcff-2682ed80e7bd",
          "commandChecksum": "930d8272df24a15def5ef1eb3eb35123",
          "propsChecksum": "fa106c5c1546a36bf7a4846ae906673b"
        }
      },
            {
        "autoExecute": true,
        "color": "teal",
        "fontColor": "blue",
        "group": "Util - Documented",
        "includeLabel": false,
        "sortBy": "Util - Documented",
        "index": 561,
        "label": "switchMap BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n[h:assert(isGM(),\"This macro can only be run by the GM\",0)]\n\n[h:mapList\t\t= listSort(getAllMapNames(),\"N+\")]\n[h:comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t\n\n[h:locationList = \"\"]\n[h,foreach(location, comLocations,\"<br>\"), CODE:{\n\t[map\t\t\t= json.get(location, \"map\")]\n\t[spot\t\t\t= json.get(location, \"spot\")]\n\t[if(!listContains(mapList, map)), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[assert(0,\"error encountere, maplist needs to be updated, please run again\",0)]\n\t}]\n\t[locationList\t= listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n}]\n\n[h:oldMap\t\t= getCurrentMapName()]\n[h:allPlayers\t= getAllPlayerNames()]\n\n[h,if(argCount() > 0): newMap\t= arg(0) ; newMap\t= oldMap]\n[h:assert(listFind(mapList, newMap) != -1, \"The map \"+arg(0)+\" does not exist\",0)]\n\n[h,if(argCount() > 1), CODE:{\n\t\n\t[userList\t\t= arg(1)]\n\t[if(userList == 1): userList = getAllPlayerNames()]\n\n\t\n\t[playerList = \"\"]\n\n\t[FOREACH(player, userList), if(listContains(allPlayers, player)): playerList = listAppend(playerList, player) ; broadcast(\"The player: \"+player+\" does not exist!\")]\n\t[selCount\t\t= 0]\n''\n};{\n\t\n\t\n\t[if(listFind(locationList, oldMap) == -1), CODE:{\n\t\t[bot_CoMScan()]\n\t\t[comLocations = getLibProperty(\"centreOnMePads\", \"lib:EventMacros\")]\t\n\t\t[locationList = \"\"]\n\t\t[foreach(location, comLocations,\"<br>\"), CODE:{\n\t\t\t[map = json.get(location, \"map\")]\n\t\t\t[spot = json.get(location, \"spot\")]\n\t\t\t[locationList = listAppend(locationList, if(spot != \"\", map + \" - \" + spot,map))]\n\t\t''\n\t\t}]\n\t''\n\t};{}]\n\t\n\t[newMap\t\t= listFind(locationList, newMap)]\n\t[userList\t= allPlayers]\n\t[selected\t= getSelectedNames()]\n\t[selCount\t= listCount(selected)]\n\n\n\t\n\t[\t\t\t\t\t\t\tinputStr = \"junk|Force Selected Players to Map|-|LABEL|SPAN=TRUE\"]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"newMap|\"+locationList+\"|Select map|RADIO| SELECT=\"+newMap,\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"selCount|1|Move selected token(s)?|CHECK\",\"@\")]\n\t[if(selCount):\t\t\t\tinputStr = listAppend(inputStr, \"junk|(\"+selected+\")<br>|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Select Players|-|LABEL|SPAN=TRUE\",\"@\")]\n\t[FOREACH(player, userList):\tinputStr = listAppend(inputStr, \"player\"+roll.count+\"|1|\"+player+\"|CHECK\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"junk|Res-scan all maps for new locations<br>|When checked this macro will scan ALL maps looking for<br>tokens that are called <i>centrOnMePad Some Location Name<\/i><br>and adds <i>Some Location Name<\/i> to the above list of locations<br>when you choose that location the map will be centred around<br><i>that<\/i> pad. Obviously <i>Some Location Name<\/i> can be any<br>alphanumerical string you like!|LABEL|SPAN=TRUE\",\"@\")]\n\t[\t\t\t\t\t\t\tinputStr = listAppend(inputStr, \"rescan|0|Re-scan|CHECK\",\"@\")]\n\n\t\n\t[abort(eval(listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")))]\n\t\n\t\n\t[playerList = \"\"]\n\t[FOREACH(player, userList), CODE:{\n\t\t[if(eval(\"player\"+roll.count)): playerList = listAppend(playerList, player)]\n\t''\n\t}]\n''\n}]\n\n\n[h:newLocation = json.get(comLocations, newMap)]\n[h:newMap = json.get(newLocation, \"map\")]\n[h:newLoc = json.get(newLocation, \"spot\")]\n[h:comPad = \"centreOnMePad\" + newLoc]\n\n\n[h:setCurrentMap(newMap)]\n[h,if(findToken(comPad)!=\"\"), CODE:{\n\t[X = getTokenX(0, comPad)]\n\t[Y = getTokenY(0, comPad)]\n};{\n\t[X = 0]\n\t[Y = 0]\n}]\n\n[h,if(rescan): bot_CoMScan()]\t\n\n[h, if(selCount == 1), CODE: {\n\t[h,FOREACH(tok, selected),if(oldMap != newMap): moveTokenFromMap(tok, oldMap, X+roll.count, Y)]\n\t[h,FOREACH(tok, selected),if(oldMap == newMap): moveToken(X+roll.count, Y, 0, tok)]\n\t[h:setCurrentMap(oldMap)]\n};{\n}]\n\n[h:setCurrentMap(oldMap)]\n\n[h:bot_execAllPlayers(\"gotoMap@lib:OnTokenMove\",json.append(\"[]\",newMap,newLoc), playerList)]",
        "maxWidth": "",
        "tooltip": "<html> Forces ALL clients to chosen map AND centres view on the token <i>centreOnMePad<\/i> <br>\n<br>\nIf you select tokens before you use this macro, then the option will be added to move<br>\nthe selected tokens to the new map as well. These tokens will be placed near the <i>centreOnMePad<\/i><br>\nIf you create a centreOnMePad with additional text e.g. <i>centreOnMePad First Floor<\/i> and <i>centreOnMePad Second Floor<\/i><br>\nthen these will show up as location in this macro (after a 'rescan').<br>\n<br>\nIf there is no <i>centreOnMePad<\/i> then the coords (X,Y) 0,0 will be used instead.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "12867007-a9a5-438c-8d0b-5dd365db1fcf",
          "commandChecksum": "5ac9dfeef293b0038a6ce7d699d79b02",
          "propsChecksum": "8db870d9f8284c64d562a8544752269d"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 562,
        "label": "changeAdress",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:mapList\t\t\t= getAllMapNames(\"json\")]\n[h:oldMap\t\t\t= getCurrentMapName()]\n[h:oldAddress\t\t= \"https://www.eyecom.nl/temp/\"]\n[h:newAddress\t\t= \"http://wolph42.ddns.net:4242/sounds/Bot_Inn/\"]\n\n[oldAddress\t\t\t= \"\"]\n[n\t\t\t\t\t= 0]\n[h,while(oldAddress == \"\"), CODE:{\n\t[currentMap\t\t= json.get(mapList, n)]\n\t[setCurrentMap(currentMap)]\n\n\t[tokList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t[foreach(padName, tokList), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t\t[var\t\t= getStrProp(getProperty(\"w42.bot.soundSettings\",padName),\"uri\")]  \n\t\t[id\t\t\t= strfind(var, \"(.*)\\\\/\")]\t\t\n\t\t[if(getFindCount(id)): oldAddress\t= getGroup(id,1,0)]\n\t}]\n\t[n = n + 1]\n\t[setCurrentMap(oldMap)]\n\t[assert(n < json.length(mapList), \"Aborting function as no SoundPads were found in campaign\",0)]\n}]\n\n[h:abort(input(\n\t\"oldAddress|\"+oldAddress+\"|Give old address to replace||WIDTH=40\", \n\t\"newAddress|\"+oldAddress+\"|Give new addres to use||WIDTH=40\"\n))]\n\n[H,foreach(currentMap,mapList), CODE:{\n\t[setCurrentMap(currentMap)]\n\t[tokList\t\t= getTokenNames(\",\", '{layer:[\"TOKEN\",\"GM\",\"OBJECT\",\"BACKGROUND\"]}')]\n\t[foreach(padName, tokList), if(startsWith(padName, \"SoundPad\")), CODE: {\n\t\t[var\t= getProperty(\"w42.bot.soundSettings\",padName))]  \n\t\t[nVar\t= replace(var, oldAddress, newAddress)]\n\t\t[setProperty(\"w42.bot.soundSettings\", nVar, padName)]\n\t}]\n}]\n\n[h:setCurrentMap(oldMap)]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e699876e-3165-4c7d-ad78-f131348af527",
          "commandChecksum": "da524c6f34669294f4f1801ed6637866",
          "propsChecksum": "7848194dbb65a0b766bd050ac7adf4c5"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 563,
        "label": "clearSound",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h:stopSound(\"*\", 1)]",
        "maxWidth": "",
        "tooltip": "Clears all buffered sounds (both played so far and the ones setup in setup_sound",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "72a73d87-6c2c-4600-83d8-3ac13473d8d5",
          "commandChecksum": "5ea7c55d5d2374155257a62bf2a3b209",
          "propsChecksum": "93c63c242f8a5a82808730e2af304fe6"
        }
      },
            {
        "autoExecute": true,
        "color": "green",
        "fontColor": "white",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 564,
        "label": "Message Mngr",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"notes@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "<html> This macro allows you to store prepared messages and manage these.<br> For GM's these will be store on lib:EventMacros, for players these will <br> be stored on the token that they own (and is selected). <br> To add a picture to a message: <br> - create the message (and save it). <br> - select the token that contains the image (can be token,portrait or handout).<br> - click 'add selected image' for that message. The rest should be simple.<br> <\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f57a50e2-2a91-4b6f-8ec7-fe2c670f82b4",
          "commandChecksum": "feb221bc6a453e452d039dc3cf47f852",
          "propsChecksum": "3b006d09e9c624f8acd79e14983b5465"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 565,
        "label": "Change Sound URI",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"changeAdress@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "9d63a9af-45d3-4e1e-98af-761c5559ab5c",
          "commandChecksum": "02db3153f6110da915e495ba783e5ea6",
          "propsChecksum": "e5f758e22eb5f4dd7bb236ae6c50eebc"
        }
      },
            {
        "autoExecute": true,
        "color": "lime",
        "fontColor": "black",
        "group": "(drag to) Campaign Macros",
        "includeLabel": false,
        "sortBy": "(drag to) Campaign Macros",
        "index": 566,
        "label": "Clear All Sound",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[macro(\"clearSound@Lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "This stop ALL sounds currently streaming/playing AND removes them from memory",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "c5179401-c393-4341-8a86-1248186e134c",
          "commandChecksum": "1579047e542db0fc989af11a32baaf8b",
          "propsChecksum": "78e8b40397daa59184c0ba831f28cf17"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 567,
        "label": "playPadSound",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:padName\t= arg(0)]\n[h:me\t\t= arg(1)]\n\n[h:settings\t\t= getProperty(\"w42.bot.soundSettings\", padName)]\n[h,if(settings != \"\"), CODE:{\n\t[varsFromStrProp(settings)]\t\n\t[return(json.length(getOwners(\"json\", me)), \"\")]\n\n\t[if(flag): flagPlay = !flagTriggered; flagPlay = 1]\n\t[if(flagPlay), CODE:{\n\t\t[cond\t= json.set(\"{}\", \"range\", json.set(\"{}\", \"upto\", distStart, \"distancePerCell\", 1, \"token\",padName), \"pc\",1)]\n\t\t[toks\t= getTokenNames(\"json\", cond)]\n\t\t\n\t\t[foreach(tok,toks), CODE:{\n\t\t\t[ownerNames\t\t= getOwners(\"json\", tok)]\n\t\t\t[dist\t\t\t= getDistance(padName, 1, tok)]\n\t\t\t['pause(\"toks\", \"tok\", \"dist\", \"cond\",\"distStart\",\"distMaxVolume\",\"padName\", \"me\",\"ownerNames\")']\n\t\t\t[execFunction(\"playStream\", json.append(\n\t\t\t\t\"[]\", uri, \"1\",\tstartVolume + \n\t\t\t\t\t\t\t\t\tsquare(1 - \n\t\t\t\t\t\t\t\t\t\tmax(0,dist-distMaxVolume) /\n\t\t\t\t\t\t\t\t\t\tmax(0.1,distStart-distMaxVolume)\n\t\t\t\t\t\t\t\t\t) * \n\t\t\t\t\t\t\t\t\t(maxVolume-startVolume)\n\t\t\t\t), 0, ownerNames)\n\t\t\t]\n\t\t''\n\t\t}]\n\n\t\t[if(flag): flagTriggered = 1]\n\t\t[settings\t\t\t= strPropFromVars(\n\t\t\t\"uri,startVolume,distStart,maxVolume,distMaxVolume,effectArea,flag,flagTriggered\",\"UNSUFFIXED\"\n\t\t)]\n\t\t[setProperty(\"w42.bot.soundSettings\", settings, padName)]\n\t''\n\t};{}]\n''\n};{}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "70448743-e6b5-4fd0-8a6c-3d97b74f6816",
          "commandChecksum": "29bfc6cc05c5076e261c24a188d7e600",
          "propsChecksum": "f6994a1686c016eb37a2418dd431c42e"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 568,
        "label": "pickLanguage",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:Languages\t= getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n[h:players\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\", \"lib:eventMacros\")]\n\n[h,if(json.type(players)==\"UNKNOWN\"): players = \"{}\"]\n[h:player\t\t= getPlayerName()]\n[h:currLanguage\t= json.get(players, player+\"LAN\")]\n[h:currTok\t\t= json.get(players, player+\"TOK\")]\n[h:ownedToks\t= getOwnedNames(player)]\n\n[h:assert(listCount(ownedToks),\"Make sure there is at least one token on the map that you own!\",0)]\n\n[h,foreach(language,Languages): set(language,0)]\n[h,foreach(language,currLanguage): set(language,1)]\n\n[h:inpLanguages=\"\"]\n[h,foreach(language,languages):\n    inpLanguages = listAppend(inpLanguages,language+\"|\"+eval(language)+\"|\"+language+\"|CHECK\",\"##\")\n]\n\n\n[h:abort(input(\n\t\"junk|<html><b>Choose the languages that your character speaks:<br><\/html>|-|LABEL|SPAN=TRUE\",\n\tinpLanguages,\n\t\"junk|<html><b>Choose the Tokenname of the character you play:<br><\/html>|-|LABEL|SPAN=TRUE\",\n\t\"ownedTok|\"+ownedToks+\"|Choose|LIST|VALUE=STRING SELECT=\"+listfind(ownedToks,currTok)\n))]\n\n[h:langList = \"\"]\n[h,foreach(language,languages):\n    langList = if(eval(language), listappend(langList, language),langList)\n]\n\n[h:setLibProperty(\"w42.bot.whisperPanel.playerChoices\", json.set(players, player+\"LAN\", langList, player+\"TOK\", ownedTok), \"lib:eventMacros\")]\n[broadcast(strformat(\"<b><font color='red'>%{player} has chosen the following languages to use in the whisper tool: %{langlist}\"),bot_selfgm())]",
        "maxWidth": "",
        "tooltip": "Choose the languages that you speak",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0bead40e-0e09-424a-aab6-096b044e36f6",
          "commandChecksum": "fd625ab3ab574ac297a5dd6c525412a5",
          "propsChecksum": "63f3d5b4fb1abb14a5c03da4698405bb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 569,
        "label": "whisperFrame",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h:lastSettings\t\t\t= arg(0)]\n[h:'broadcast(\"hi\"+ lastSettings)']\n[h: keepItShort\t\t\t= 8]\n[H: allPlayerNames\t\t= json.difference(getAllPlayerNames(\"json\"), json.fromList(getPlayerName())  )]\n\n[h: players\t\t\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\", \"lib:eventMacros\")]\n\n\n[h, if(json.type(players)!=\"OBJECT\"): \n\tLanguages\t\t\t= \"\"\n;\n\tLanguages\t\t\t= json.get(players, getPlayerName()+\"LAN\")\n]\n\n[h:check\t\t\t\t\t= getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\")]\n[h,if(json.type(check)==\"UNKNOWN\"): setLibProperty(\"w42.bot.whisperPanel.script\", \"{}\",\"lib:eventMacros\")]\n\n[h,foreach(language,Languages): set(language,0)]\n[H: count\t\t\t\t= 0]\n\n[h, if(json.type(lastSettings) != \"OBJECT\"), CODE: {\n\t[lastSettings\t= getLibProperty(\"w42.bot.whisperPanel.lastSettings\")]\n\n\t[if(json.type(lastSettings) == \"UNKNOWN\"): \n\t\tlastSettings\t= '{\"color\":\"Black\",\"bold\":\"0\",\"italic\":\"0\",\"underline\":\"0\",\"allPlayers\":\"0\",\"impersonate\":\"0\",\"currLanguage\":\"\"}'\n\t]\n};{}]\n\n[foreach(setting, lastSettings): set(setting, json.get(lastSettings, setting))]\n\n\n[frame(\"Whisper\", \"width=250; height=300\"): {\n\t<html><head><title>Whisper<\/title><\/head><body>\n\t<form name=\"Whisper\" method=\"json\" action='[R: macroLinkText(\"sendWhisper@this\",\"none\")]'>\n\n\t\n\t<input type=\"hidden\" name=\"italic\"\t\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"bold\"\t\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"underline\"\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"allPlayers\"\t\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"impersonate\"\tvalue=\"0\"/>\n\t<input type=\"hidden\" name=\"currLanguage\"\tvalue=\"Common\"/>\n\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td colspan=5><small>([R: macroLink(\"<b>Refresh Player & Language List<\/b>\", \"whisperFrame@this\", \"none\")])<\/small><\/td><\/tr><tr>\n\t\t<td><b>Plyr <\/b><\/td><td>Address<\/td><td>|Overhear|<\/td><td>Out Rnge <\/td><td><b>Char<\/b><\/td><\/tr><tr>\n\t\t[r,foreach(player, allPlayerNames, \"<\/tr><tr>\"), CODE:{\n\t\t\t[h,if(json.contains(players, player+\"TOK\")): character\t= json.get(players, player+\"TOK\")) ; character = \"\"]\n\n\t\t\t[h,if(keepItShort): playerStr\t= substring(player, 0, min(length(player), keepItShort))\t\t; playerStr\t= player]\n\t\t\t[h,if(keepItShort): charStr\t\t= substring(character, 0, min(length(character), keepItShort))\t; charStr\t= character]\n\n\t\t\t[h:checked\t\t= json.get(lastSettings, player)]\n\t\t\t[h:checked\t\t= if(checked == \"\", \"Not\", checked)]\n\t\t\t<td>[r:playerStr]<\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Address\"\t\t[r:if(checked == \"Address\",\t\t\"CHECKED\", \"\")]><\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Overhear\"\t[r:if(checked == \"Overhear\",\t\"CHECKED\", \"\")]><\/td><td style=\"text-align:center\">\n\t\t\t<input type=\"radio\" name=\"[r:player]\" value=\"Not\"\t\t\t[r:if(checked == \"Not\", \t\t\"CHECKED\", \"\")]><\/td>\n\t\t\t[r,if(character !=\"\"): '<td>'+charStr+'<\/td><td style=\"text-align:center\">']\n\t\t}]\n\t<\/tr><\/table>\n\t\t\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td><input type=\"checkbox\" name=\"allPlayers\"\tvalue=\"1\" [R: checked\t= if(allPlayers,\t\"CHECKED\", \"\")] ><\/td><td> Address All (no whisper)<\/td><\/tr><tr>\n\t\t<td><input type=\"checkbox\" name=\"impersonate\"\tvalue=\"1\" [R: checked\t= if(impersonate,\t\"CHECKED\", \"\")] ><\/td><td> Impersonate (selected token)<\/td>\n\t<\/tr><\/table>\n\t\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<td><textarea name=\"whisperText\" cols=\"30\" rows=\"5\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table cellpadding=\"4\" cellspacing=\"0\">\n\t\t\n\t\t[r,if(listcount(Languages)), CODE:{\n\t\t\t<tr><td>Message Language: <\/td>\n\t\t\t<td><select name=\"currLanguage\">\n\t\t\t\t[r,foreach(language, Languages, \"\"):'\n\t\t\t\t\t<option value=\"'+language+'\"' + if(currLanguage == language,\" selected\",\t\" \") + '>'+language+'\t\t<\/option>\n\t\t\t\t']\n\t\t\t<\/select><\/td><\/tr>\n\t\t};{}]\n\t\t<\/tr><\/table>\n\t\t\n\t\t<table cellpadding=\"0\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td><select name='color'>\n\t\t\t\t<option value='black'\t[r:if(color == 'black',\t\t'selected',\t'')]>Black\t\t<\/option>\n\t\t\t\t<option value='gray'\t[r:if(color == 'gray',\t\t'selected',\t'')]>Gray\t\t<\/option>\n\t\t\t\t<option value='maroon'\t[r:if(color == 'maroon',\t'selected',\t'')]>Maroon\t\t<\/option>\t\n\t\t\t\t<option value='red'\t\t[r:if(color == 'red',\t\t'selected',\t'')]>Red\t\t<\/option>\n\t\t\t\t<option value='yellow'\t[r:if(color == 'yellow',\t'selected',\t'')]>Yellow\t\t<\/option>\n\t\t\t\t<option value='green'\t[r:if(color == 'green',\t\t'selected',\t'')]>Green\t\t<\/option>\n\t\t\t\t<option value='blue'\t[r:if(color == 'blue',\t\t'selected',\t'')]>Blue\t\t<\/option>\n\t\t\t\t<option value='navy'\t[r:if(color == 'navy',\t\t'selected',\t'')]>Dark Blue\t<\/option>\n\t\t\t\t<option value='purple'\t[r:if(color == 'purple',\t'selected',\t'')]>Purple\t\t<\/option>\n\t\t\t<\/select><\/td>\n\t\t\t<td><input type='checkbox' name='italic'\t\tvalue='1'\t[r:if(italic,\t\t'checked', '')]>\t<\/td><td><i>Italic<\/i>\t\t<\/input><\/td>\n\t\t\t\t<td><input type='checkbox' name='bold'\t\t\tvalue='1'\t[r:if(bold,\t\t\t'checked', '')]>\t<\/td><td><b>Bold<\/b>\t\t<\/input><\/td>\n\t\t\t\t<td><input type='checkbox' name='underline'\tvalue='1'\t[r:if(underline,\t'checked', '')]>\t<\/td><td><u>Underline<\/u>\t<\/input><\/td><\/tr>\n\t\t<\/font><\/table>\n\n\t\t<table cellpadding=\"4\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td align=\"center\"><input type='submit' value='Send Message' ><\/td>\n\t\t\t<td><\/td>\n\t\t\t<td align=\"center\"><input type='submit' value='Manual & Settings' ><\/td>\n\t\t<\/tr><\/table>\n\t\t\n\t<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send formatted text to specific players.<br> <u>Alternatively<\/u> you can send a message to <u>all<\/u> players as if you<br> impersonate the selected token, without actually needing to impersonate it.<br> <br> <b>Notes<\/b> <br> - you must either be the gm or own the selected token to do this.<br> - the impersonation ONLY works with <i>all players<\/i> check box <br>   selected. (So not when some or all the individual player checkboxes are<br>   selected!!)<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e77a33b5-1023-4a6c-b2b8-d918d7518989",
          "commandChecksum": "eb702fb30e4595f916a1180e484d8450",
          "propsChecksum": "0642cc7f539e459c528cdbfda897fb18"
        }
      },
            {
        "autoExecute": true,
        "color": "fuchsia",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 571,
        "label": "sendWhisper",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'broadcast(macro.args)']\n\n[h:'']\n\n[H: args\t\t\t\t= arg(0) ]\n\n[h: button\t\t\t\t= json.get(args, \"Whisper\")]\n[h,switch(button),code:\n\tcase \"Manual & Settings\": {\n\t  [macro(\"WhisperManual@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Pick Languages & Token\": {\n\t  [macro(\"pickLanguage@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Set Languages\": {\n\t  [macro(\"setLanguages@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\tcase \"Link Script to Language\": {\n\t  [macro(\"Language2Script@this\"):\"\"]\n\t  [abort(0)]\n\t};\n\t\n\tdefault: {}\n]\n\n\n[h:setLibProperty(\"w42.bot.whisperPanel.lastSettings\", args,\"lib:EventMacros\")]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[H:allPlayerNames\t\t= json.difference(getAllPlayerNames(\"json\"), json.fromList(thisPlayer)  )]\n\n\n[h,foreach(setting, args), CODE:{\n\t[val \t\t\t= json.get(args, setting)]\n\t[if(isNumber(val)): val = number(val)]\t\n\t[set(setting, val)]\n}]\n\n\n[h:italicOpen\t\t= if(italic,\t\"<i>\",\t\"\")]\n[h:italicClose\t\t= if(italic,\t\"<\/i>\",\t\"\")]\n[h:boldOpen\t\t= if(bold,\t\t\"<b>\",\t\"\")]\n[h:boldClose\t\t= if(bold,\t\t\"<\/b>\",\t\"\")]\n[h:underlineOpen\t= if(underline,\t\"<b>\",\t\"\")]\n[h:underlineClose\t= if(underline,\t\"<\/b>\",\t\"\")]\n[h:'']\n[h:playerSet\t\t= getLibProperty(\"w42.bot.whisperPanel.playerChoices\",\"lib:EventMacros\")]\n[h:hasSet\t\t\t= if(json.type(playerSet)==\"UNKNOWN\", 0, 1)]\n\n[h:\tscramWisperText\t= bot_scrambleText(whisperText, currLanguage) ]\n\n[h: whisperText\t\t= strformat(\"<font color=%{color}>%{italicOpen}%{boldOpen}%{underlineOpen}%{whisperText}%{underlineClose}%{boldClose}%{italicClose}<\/font>\")]\n[h: messageScram\t= strformat(\"<font color=%{color}>%{italicOpen}%{boldOpen}%{underlineOpen}%{scramWisperText}%{underlineClose}%{boldClose}%{italicClose}<\/font>\")]\n\n[h,if(impersonate), CODE:{\n\t[fromWho\t\t= getSelectedNames()]\n\t[if(!listCount(fromWho) && hasSet): fromWho = json.get(playerSet, thisPlayer+\"TOK\")]\t\t\t\t\n\t[assert(listCount(fromWho) == 1, \"ABORTED: make sure you have (only) one token selected\",0)]\n\t[assert(if(isGM() || isOwner(thisPlayer, fromWho),1,0),\"ABORTED: you do not own this token\",0)]\n};{\n\t[fromWho\t\t= thisPlayer]\n}]\n\n[h,if(allPlayers), CODE:{\n\t[foreach(player, allPlayerNames):args = json.set(args, player, \"Address\")]\t\t\t\t\n};{}]\n\n[h:addressHeader\t= \"%{fromwho} addresses %{addressed} in %{currLanguage} this is overheared by %{overheared}\"]\n[h:overhearHeader\t= \"%{overheared} overhear %{fromwho} who addresses %{addressed} in %{currLanguage}\"]\n[h:addressed\t\t\t= \"\"]\n[h:overheared\t\t= \"\"]\n[h:nPlayers\t\t\t= 0]\n[h:count\t\t\t= 0]\n[h,foreach(player, allPlayerNames), CODE: {\n\t[type \t\t\t= json.get(args, player)]\t\t\t\t\t\t\t\t\t\t\t\n\t[if(type != \"Not\"), CODE:{\n\t\t[nPlayers\t\t= nPlayers\t+ 1]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t['']\n\t\t[if(impersonate && hasSet): \n\t\t\tname = json.get(playerSet, player+\"TOK\")\n\t\t; \n\t\t\tname =  player)\n\t\t]\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\t[if(hasSet): \n\t\t\tlan\t\t= json.get(playerSet, player+\"LAN\"))\n\t\t;\n\t\t\tlan\t\t= \"\"\n\t\t]\t\t\t\t\t\t\t\t\n\n\t\t\n\t\t[message\t= if(listContains(lan, currLanguage)||currLanguage==\"Common\", whisperText,messageScram)]\t\t\n\n\t\t[set(\"playerNAME\"+count, player)]\t\t\t\t\t\t\t\t\t\t\t\n\t\t[set(\"playerCHAR\"+count, name)]\t\t\t\t\t\t\t\t\t\t\t\n\t\t[set(\"playerMESS\"+count, message)]\t\t\t\t\t\t\t\t\t\t\n\n\t\t[if(type == \"Address\"), CODE:{\n\t\t\t[addressed = listappend(addressed, name)]\t\t\t\t\t\t\t\t\t\n\t\t\t[set(\"playerHEAD\"+count, addressHeader)]\t\t\t\t\t\t\t\t\n\t\t\t[set(\"playerCOLR\"+count, \"black-white\")]\t\t\t\t\t\t\t\t\n\t\t''\n\t\t};{\t\n\t\t\t[overheared = listappend(overheared, name)]\t\t\t\t\t\t\t\t\n\t\t\t[set(\"playerHEAD\"+count, overhearHeader)]\t\t\t\t\t\t\t\n\t\t\t[set(\"playerCOLR\"+count, \"gray-white\")]\t\t\t\t\t\t\t\t\n\t\t''\n\t\t}]\n\t[count = count + 1]\n\t''\t\n\t};{''}] \n['pause(\"allPlayerNames\",\"player\",\"type\",\"playerNAME\"+count,\"nPlayers\",\"count\",\"addressed\",\"overheared\")']\n\n\n''\n}]\n\n\n[h,if(overheared == \"\"):\t\t\toverheared = \"no one\"]\n[h,if(addressed == \"\"):\t\t\t\taddressed = \"no one\"]\n[h,if(currLanguage == \"Common\"):\tcurrLanguage = \"\" ; currLanguage = replace(\" in \" + currLanguage, \"_\", \" \")]\n[h:addressHeader\t= strformat(\"%{fromwho} addresses %{addressed}%{currLanguage}, this is overheared by %{overheared}\")]\n[h:overhearHeader\t= strformat(\"%{overheared} are overhearing %{fromwho}, who addresses %{addressed}%{currLanguage}\")]\n[h:tok\t\t\t\t= if(fromWho != thisPlayer, fromWho, \"\")]\n\n[count(nPlayers), CODE:{\n\t[name\t\t= eval(\"playerCHAR\"+roll.count)]\n\t[message\t= eval(\"playerMESS\"+roll.count)]\n\t[header\t\t= replace(strformat(eval(\"playerHEAD\"+roll.count)), name, \"you\")]\t\n\t[header\t\t= replace(header,\",(?!.*?,)\",\" and \")]\t\t\t\t\t\t\t\t\t\n\t[color\t\t= eval(\"playerCOLR\"+roll.count)]\n\t[player\t\t= eval(\"playerNAME\"+roll.count)]\n\t[bot_message(message, header, color, player, tok, \"\", 1, \"100%\", 1)]\n\t['pause(\"fromWho\",\"addressed\",\"overheared\",\"addressHeader\",\"overhearHeader\",\"name\",\"message\",\"header\",\"player\")']\n}]\n\n[addressed\t\t= replace(addressed,\",(?!.*?,)\",\" and \")]\n[overheared\t\t= replace(overheared,\",(?!.*?,)\",\" and \")]\n[if(overheared == \"no one\" && addressed == \"no one\"): \n\theader\t\t= \"You are talking to yourself\"\n;\n\theader\t\t= \"You address %{addressed}%{currLanguage}, this is overheared by %{overheared}\"\n]\n\n[bot_message(whisperText, strformat(header), \"black-white\", thisPlayer, tok, \"\", 1, \"100%\", 1)]\t\n\n\n[H: bot_whisperFrame(args)]\n\ntest text: Pick up the bloody phone!",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "613f1e6f-60f2-43d9-9905-fe9c993c5da7",
          "commandChecksum": "82688b015bb4a3e331575832872c9ef7",
          "propsChecksum": "cedd53229fd6a137169aacc97f093746"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 572,
        "label": "WhisperManual",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[frame(\"Whisper frame explained\", \"width=250; height=300\"): {\n<html><head><title>Whisper frame explained<\/title><\/head><body>\n<form name=\"Whisper\" method=\"json\" action='[R: macroLinkText(\"sendWhisper@this\",\"none\")]'>\n\t<table cellpadding=\"0\" cellspacing=\"0\"><font size=\"150%\"><tr>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Pick Languages & Token\" ><\/td>\n\t\t[r,if(isGM()):'\n\t\t<td><\/td>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Set Languages\" ><\/td>\n\t\t<td><\/td>\n\t\t<td align=\"center\"><input type=\"submit\" value=\"Link Script to Language\" ><\/td>\n\t\t']\n\t<\/tr><\/table>\n\t\t\n\t<h3>Whisper Frame User Manual and Settings<\/h3>\n\t<h4><font color=red>What do the Buttons Do?<\/h4>\n\tI`ll start with the button(s) on the top. The GM has a <b>Set Languages<\/b> button where she\n\tcan enter a list of Languages used by the players. I would strongly advice against \n\tentering all languages of the game as that could potentiall make the tool hard to use.<br><br>\n\n\tThe other button the GM has is <b>Link Script to Language<\/b>, this button allows to replace\n\tnormal text to images of text, like elvish or dwarfish runes. The images are drawn from script\n\ttables that can be found in the maptool Tables panel. A gm can create his own set as long as it\n\tcomplies with the other tables (similar setup) and the table name starts with script_. <br><br>\n\t\t\n\tWhen the GM is done, the players can click on the <b>Pick Languages & Token<\/b> button and select the\n\tlanguages their Character speaks.<br>\n\tNext to that the player can choose the token that represents her character. This is used\n\twhen you address someone while <b>impersonated<\/b> and is used as the default for \n\t'impersonation' (more on this later).\n\t\n\t<h4><font color=red>How Does the Whisperframe work?<\/h4>\n\tI`ll go through the items from top  to bottom.<br><br>\n\t<b>REFRESH Player& Language List<\/b><br>\n\tWhen players log in or out or when you update your chosen languages you can click on Refresh\n\tto update the Whisperframe with these changes.<br><br>\n\n\t<b>WHO<\/b><br>\n\tHere you find a list of players who are connected to the server. Per player there are 3 options:<br>\n\t<u>Address:<\/u> you are directly speaking (addressing) that player<br>\n\t<u>Overhear:<\/u> you are NOT addressing that player, but they`re nearby and can hear you<br>\n\t<u>Out Range:<\/u> this player cannot hear anything you say. <br><br>\n\t\n\t<b>ADDRESS ALL<\/b><br>\n\tThis fully overrides the 'WHO' settings and addresses ALL players (or characters, depending on\n\tyour impersonation settings (see below).<br><br>\n\t\n\t<b>IMPERSONATE<\/b><br>\n\t<u>CHECKED<\/u> = In character. This means that you speak as the token that you have selected\n\tOR if you have no token selected you speak as your default character (which you picked in\n\tpick languages). You address the other players in their character names!<br>\n\t<u>UNCHECKED<\/u> = Out of character. This means that you speak as Player, using your player\n\tname and address the other players in their players names<br><br>\n\n\t<b>TEXTBOX<\/b><br>\n\tHere you enter the mesage you want to sent<br><br>\n\n\t<b>LANGUAGE<\/b><br>\n\tYou will onlly see this box if you actually picked one or more languages from the Settings-->\n\tPick Languages menu. When you choose  a language an other player (who you either address or can \n\thear you) does NOT speak, that player will het garbled text. Only players that speak the language\n\tyou chose (and are addressed by you or can hear the conversation) can read and understand the \n\tmessage. <br><br>\n\t\n\t<b>COLOR, BOLD, ITALIC, etc,<\/b><br>\n\tWith these you can format the text that you send.<br><br>\n\n\t<b>SEND<\/b><br>\n\tSend message.<br><br>\n\t\n\t\n\t\n\t\n<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "0e01a4a4-b2d0-4f3e-a350-96688b5309c9",
          "commandChecksum": "0e833d8ee245a927ced78f94ad15a7cb",
          "propsChecksum": "d9d81cf79bb084ac1bedcaa6e38ef5f2"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 574,
        "label": "textToScript",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:text\t\t\t= arg(0)]\n[h:script\t\t= arg(1)]\n\n[h:translated\t= \"\"]\n[h:lst\t\t\t= stringToList(text,\"\",\"@\")]\n\n[h,foreach(char, lst, \"\", \"@\"), CODE:{\n\t\n\t[if(char==\"\\$\"): char=\" \"]\n\t[if(!listContains(\"a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,1,2,3,4,5,6,7,8,9,0\", char)):char = \" \"]\n\t[switch(char):\n\t\tcase \"\":asset\t= \"\";\n\t\tcase \" \":asset\t= \"\";\n\t\tcase \"a\":asset\t= \"<img src='\"+tableImage(script,101)+\"'>\";\n\t\tcase \"b\":asset\t= \"<img src='\"+tableImage(script,102)+\"'>\";\n\t\tcase \"c\":asset\t= \"<img src='\"+tableImage(script,103)+\"'>\";\n\t\tcase \"d\":asset\t= \"<img src='\"+tableImage(script,104)+\"'>\";\n\t\tcase \"e\":asset\t= \"<img src='\"+tableImage(script,105)+\"'>\";\n\t\tcase \"f\":asset\t= \"<img src='\"+tableImage(script,106)+\"'>\";\n\t\tcase \"g\":asset\t= \"<img src='\"+tableImage(script,107)+\"'>\";\n\t\tcase \"h\":asset\t= \"<img src='\"+tableImage(script,108)+\"'>\";\n\t\tcase \"i\":asset\t= \"<img src='\"+tableImage(script,109)+\"'>\";\n\t\tcase \"j\":asset\t= \"<img src='\"+tableImage(script,110)+\"'>\";\n\t\tcase \"k\":asset\t= \"<img src='\"+tableImage(script,111)+\"'>\";\n\t\tcase \"l\":asset\t= \"<img src='\"+tableImage(script,112)+\"'>\";\n\t\tcase \"m\":asset\t= \"<img src='\"+tableImage(script,113)+\"'>\";\n\t\tcase \"n\":asset\t= \"<img src='\"+tableImage(script,114)+\"'>\";\n\t\tcase \"o\":asset\t= \"<img src='\"+tableImage(script,115)+\"'>\";\n\t\tcase \"p\":asset\t= \"<img src='\"+tableImage(script,116)+\"'>\";\n\t\tcase \"q\":asset\t= \"<img src='\"+tableImage(script,117)+\"'>\";\n\t\tcase \"r\":asset\t= \"<img src='\"+tableImage(script,118)+\"'>\";\n\t\tcase \"s\":asset\t= \"<img src='\"+tableImage(script,119)+\"'>\";\n\t\tcase \"t\":asset\t= \"<img src='\"+tableImage(script,120)+\"'>\";\n\t\tcase \"u\":asset\t= \"<img src='\"+tableImage(script,121)+\"'>\";\n\t\tcase \"v\":asset\t= \"<img src='\"+tableImage(script,122)+\"'>\";\n\t\tcase \"w\":asset\t= \"<img src='\"+tableImage(script,123)+\"'>\";\n\t\tcase \"x\":asset\t= \"<img src='\"+tableImage(script,124)+\"'>\";\n\t\tcase \"y\":asset\t= \"<img src='\"+tableImage(script,125)+\"'>\";\n\t\tcase \"z\":asset\t= \"<img src='\"+tableImage(script,126)+\"'>\";\n\t\tcase \"1\":asset\t= \"<img src='\"+tableImage(script,1)  +\"'>\";\n\t\tcase \"2\":asset\t= \"<img src='\"+tableImage(script,2)  +\"'>\";\n\t\tcase \"3\":asset\t= \"<img src='\"+tableImage(script,3)  +\"'>\";\n\t\tcase \"4\":asset\t= \"<img src='\"+tableImage(script,4)  +\"'>\";\n\t\tcase \"5\":asset\t= \"<img src='\"+tableImage(script,5)  +\"'>\";\n\t\tcase \"6\":asset\t= \"<img src='\"+tableImage(script,6)  +\"'>\";\n\t\tcase \"7\":asset\t= \"<img src='\"+tableImage(script,7)  +\"'>\";\n\t\tcase \"8\":asset\t= \"<img src='\"+tableImage(script,8)  +\"'>\";\n\t\tcase \"9\":asset\t= \"<img src='\"+tableImage(script,9)  +\"'>\";\n\t\tcase \"0\":asset\t= \"<img src='\"+tableImage(script,0)  +\"'>\";\n\t\tdefault:\tasset\t= \"\"\n\t]\n\t[translated\t= translated + asset]\n}]\n[h:macro.return = translated]\n",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "f50e9d87-e808-48a6-8e43-91240f7d1820",
          "commandChecksum": "217955151708a723433389af36aea521",
          "propsChecksum": "ac2f4263fdfb9ae7b5058aab1cde518c"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 575,
        "label": "setLanguages",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:assert(isGM(), \"GM Only, 0\")]\n[h:Languages = getLibProperty(\"w42.bot.whisperPanel.languages\", \"lib:eventMacros\")]\n\n[h:abort(input(\n\t\t\"junk|<html>Enter the list of Languages used in game seperated by comma ','.<br><b>Do NOT use any spaces ' '. Use underscore '_' instead. <\/b><br>Note that the 'Common' language is automatically added to the list and set as default.<br>So don't add that one here!<\/html>|-|LABEL|SPAN=TRUE\",\n\t\t\"Languages|\"+Languages+\"|Languages||WIDTH=50\"\n))]\n[hasSpaces\t= 0]\n[h,foreach(lan, Languages): hasSpaces = max(hasSpaces, if(getFindCount(strfind(lan, \" \")), 1,0))]\n\n\n[h:assert(!hasSpaces, \"<b><font color='red'>RTFM dimwit: DO NOT USE SPACES in the language names, use _ instead, function aborted!!\",0)]\n[h,if(listCount(Languages) && !listContains(Languages, \"Common\") ): Languages = listappend(\"Common\", Languages)]\t\t\n[h:setLibProperty(\"w42.bot.whisperPanel.languages\", trim(Languages), \"lib:eventMacros\")]",
        "maxWidth": "",
        "tooltip": "Choose the languages that the players can speak",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "79ffc022-c0cd-4059-9b87-5635eb1adbfe",
          "commandChecksum": "85d0f05cc158a3ec144b0dada3bc6e75",
          "propsChecksum": "460d50060c41384e5359fb8049f8ceb9"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "c. LMarkus & W42 Whisper Frame",
        "includeLabel": false,
        "sortBy": "c. LMarkus & W42 Whisper Frame",
        "index": 576,
        "label": "scrambleText",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:text\t\t\t= arg(0)]\n[h:language\t\t= arg(1)]\n[h:script\t\t= json.get(getLibProperty(\"w42.bot.whisperPanel.script\", \"lib:eventMacros\"), language)]\n[h:script\t\t= if(json.contains(json.get(getInfo(\"campaign\"),\"tables\"), script),  script, \"\")]\n\n[h:cText\t\t= \"\"]\n[h:l\t\t\t= length(text)]\n[h,for(i,l-1,0,-2):cText = cText + substring(text, i, i+1)]\n[h,for(i,l-2,1,-2):cText = cText + substring(text, i, i+1)]\n[h,if(script != \"\"): cText\t= bot_textToScript(cText, script)]\n\n[h:macro.return = cText]\n",
        "maxWidth": "",
        "tooltip": "Scramble Text",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "ff242f0a-1bd4-4071-9022-fbfdcf175098",
          "commandChecksum": "2887294f2669908734810e1adfa12f75",
          "propsChecksum": "927f4cd32221e02677063fe629e8b8eb"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "blue",
        "group": "x. Documentation",
        "includeLabel": false,
        "sortBy": "x. Documentation",
        "index": 577,
        "label": "videoTutorials",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n[h: styleHTML = strformat('\n<style>\n   table.btnformat {\n      padding: 0pt;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n      background-color: white;\n      border-spacing:0;\n   }\n   td.btnformat {\n      padding: 3px;\n      border-width: 1pt;\n      border-style: solid;\n      border-color: black;\n      text-align: left;\n      white-space: wrap;\n   }\n \n<\/style>\n')]\n\n\n[h:output\t=  strformat(\"%{styleHTML}<html><body><table class='btnformat'><tr><td class='btnformat'>\")]\n\n[h:output\t= output + \"\n\t<table  style='width:100%' ><tr>\t<td>\n\t\t<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><Back to the welcome screen<\/a><br>\n\t<\/td><td style='text-align:right'>\n\t\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'>Continue to choose features to install ><\/a><br>\n\t<\/td><\/tr>\n\t<\/table>\n\t\t\n\t<table style='font-family:verdana'><tr><td><\/td><\/tr>\n\t<tr style='color:#ffffff;background-color:#ff0000;text-align: center; height:70px;font-size:150%;'><td colspan=2><b>BAG OF TRICKS - VIDEO TUTORIALS<\/b><\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/i8L4XTEI7Sw'><b>Choose BoT features <\/b><\/a><\/td><td>When you install the BoT for the first time, this screen is the first one you get. Here a short vid on what to choose!<\/td><\/tr>\n\t<tr><td><\/td><\/tr>\n\t<tr style='text-indent: 0px;background-color:#cccccc'><td><a href='http://bit.ly/RP6hYA'><b>Full Overview<\/b><\/a><\/td><td>Shows most functionalities of the bag of tricks, it deals with roughly 75% of the features.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://youtu.be/wVIzObJtK4c?t=1'>\t\t\t\t\t\t0:00<\/a><\/td><td>\tSettings<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=1841s'>\t30:41<\/a><\/td><td>\tALL the different teleport pads explained<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=3720s'>\t1:02:00<\/a><\/td><td>Special areas (e.g. difficult terrain)<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=4545s'>\t1:15:45<\/a><\/td><td>(Animated) doors<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=5340s'>\t1:29:00<\/a><\/td><td>Animated token movement<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=wVIzObJtK4c&t=5610s'>\t1:33:30<\/a><\/td><td>Most of the utility functions (e.g. switch map, show handout, etc.)<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td colspan=2><b><i>Note: <\/b>The BoT is under constant construction and new stuff is added or old stuff updated on a regular basis. This makes the tutorials somewhat outdated over time. When I've created a newer version I remove the time slot in the above list, so not all start times are automatically end times of the previous topic!<\/i><\/td><\/tr>\n\t<tr><td><br><\/td><\/tr>\n\t<tr style='text-indent: 0px;background-color:#cccccc'><td><a href='http://bit.ly/1f5wn6X'><b>Interactive Pads<\/b><\/a><\/td><td> Shows how to setup Roofs, Canopy, Foliage & Bridges including VBL swapping for houses, make them change or dissapear when you move over them.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=0s'>\t\t0:00<\/a><\/td><td>\tQuick Install of the Bag of Tricks<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=150s'>\t2:30<\/a><\/td><td>\tRoofs<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=240s'>\t4:00<\/a><\/td><td>\tCanopy & Foliage<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=420s'>\t7:00<\/a><\/td><td>\tLinked Pads<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=660s'>\t11:00<\/a><\/td><td>\tBridges<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td><a href='https://www.youtube.com/watch?v=Oe6HAQr9c34&t=890s'>\t14:50<\/a><\/td><td>\tSwapping Vision Blocking Layers (VBL) between house & roof and forcing movement through door.<\/td><\/tr>\n\t<tr style='text-indent: 10px;background-color:#eeeeee'><td colspan=2><b><i>Note: <\/b>I've added 'Tunnels' in a later BoT version (and thus not in this video) which work opposite from bridges but are installed in the same way. Read the manual for more info.<\/i><\/td><\/tr>\n\t<tr><td><br><\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/fs7WdCQwi-Y'><b>Animated View<\/b><\/a><\/td><td>Shows how to set up an animation to introduce your new map to the players by showing them a pan and zoom view of that map.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/pzMHfc'><b>Build Forest<\/b><\/a><\/td><td>Shows you how to build an entire forest with a few clicks. This is a rather old tutorial, but it still works the same. The extra feature that has been added since is that its now also possible to automatically add VBL to all the tree trunks in the forest.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/YEhS4a'><b>Event Areas <\/b><\/a><\/td><td>Shows how to set up areas that limit movement and spring traps when moving over them. <\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1iYQkA3'><b>Fleeing Crowd<\/b><\/a><\/td><td>Shows you how to quickly fill a (town) square with folk and then letting them flee as a dragon lands in the middle of them.<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/iXV32ruh9ro'><b>Invisibility<\/b><\/a><\/td><td>Shows how to make tokens invisible for players, and how to use spells to 'see invisibility' or 'purge' it or 'dispell' it when tokens get in range.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1rhqlce'><b>Map Editor<\/b><\/a><\/td><td>One of my more nifty BoT inventions. It shows how to quickly create a map filled with different tokens.<\/td><\/tr>\n\t<tr><td><a href='http://bit.ly/1e536cg'><b>ShadowPads<\/b><\/a><\/td><td>Shows how to set up multi level building where you can 'watch' tokens move on the ground floor map from the first floor map (and vice versa).<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/PLYdqQzEcrA'><b>SoundPads<\/b><\/a><\/td><td>Shows how to setup and use the SoundPads. Tokens that stream sound to the client at a volume that is dependent on the distance of the player token to the soundpad.<\/td><\/tr>\n\t<tr><td><a href='https://youtu.be/1aZ-4Ip9RvI'><b>Switch Maps<\/b><\/a><\/td><td>Shows how to setup and use CentreOnMePads in combination with the upgraded Switch Map macro. Which automatically teleports selected tokens AND forces all players consoles to the new map.<\/td><\/tr>\n\t<tr><td><a href='https://www.youtube.com/watch?v=HLaby6Fblpo'><b>Whisperframe<\/b><\/a><\/td><td>Shows how to setup and use the updated whisperframe, you can now speak in e.g. elfish and players who don't speak that language cannot understand what you say.<\/td><\/tr>\n\t\n\t<tr><td colspan=2><br><br><a href='https://www.youtube.com/user/TheWolph42/videos'><b>The entire BoT tutorial channel<\/b><\/a>\n\t<\/td><\/tr><\/table>\n<br>\n\t<table  style='width:100%' ><tr>\t<td>\n\t\t<a href='macro://welcomeInit@Lib:OnTokenMove/none/Impersonated?'><Back to the welcome screen<\/a><br>\n\t<\/td><td style='text-align:right'>\n\t\t<a href='macro://featureTable@Lib:OnTokenMove/none/Impersonated?'>Continue to choose features to install ><\/a><br>\n\t<\/td><\/tr>\n\t<\/table>\n\n\"]\n[h:output\t= strformat(\"%{output}<\/td class='btnformat'><\/tr><\/table><br><\/body><\/html>\")]\n\n[h:'bot_showHTML(output)']\n\n[r, if(bot_isFullScreen()), CODE:{\n\t[r,dialog(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600; input=1\"): {[r:output]}]\n};{\n\t[r,frame5(\"Set BoT features\", \"temp=0; closebutton=0; width=800; height=600\"): {[r:output]}]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "566d84cf-70c4-4a79-b101-ea6b8e0ab32b",
          "commandChecksum": "3d5aacdc40d2575934e7df7d3bf032bd",
          "propsChecksum": "ec16b393f5ee2856cec9a988046a70d0"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "4a. Soundpads",
        "includeLabel": false,
        "sortBy": "4a. Soundpads",
        "index": 579,
        "label": "isOnDrawing",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n[h: lp\t\t\t\t= arg(0)]\n[h: area\t\t\t= arg(1)]\n[h: id\t\t\t\t= findDrawings(getCurrentMapName(),area)] \n[h:\tmd\t\t\t\t= \"[]\"]\n[h, if(id !=\"\"): \n\tmd\t\t\t\t= movedOverDrawing(getCurrentMapName(),id,lp)\n; \n\tbroadcast(area+\" does not exist\")\n]\n\n[h, if(json.length(md)):lpmd\t= replace(json.get(md, -1, -1), \"([x|y])2\", \"\\$1\");return(0,0)]\n[h: lplp\t\t\t= json.get(lp, -1, -1)]\n[h: macro.return\t= json.equals(lplp,lpmd)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "e972e2fb-fd4f-4a17-bb26-c1a84de309dd",
          "commandChecksum": "4db1fea7945a9e638b6cf8257a7b0024",
          "propsChecksum": "91865bd8300cd7ab2de5786e2c133e42"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "20: Table Creator",
        "includeLabel": false,
        "sortBy": "20: Table Creator",
        "index": 580,
        "label": "xls2Table",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n\n\n\n\n[frame(\"xls2Tbl\", \"width=270; height=550; temporary=1\"): {\n\t<html><head><title>EXCEL TO MT TABLE<\/title><\/head><body>\n\t<form name=\"x2t\" method=\"json\" action='[R: macroLinkText(\"processX2T@this\",\"all\")]'>\n\n\t<b>Paste List here (straight from excel):<\/b>\n\tThis creates a MAPTOOL table. If a table with the same name exists this will overwrite the ENTIRE table!\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<tr><td><b>Name of Table<\/b><\/td><\/tr>\n\t\t<td><textarea name=\"tblName\" cols=\"30\" rows=\"1\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr>\n\t\t<tr><td><b>Content of Table<\/b><\/td><\/tr>\n\t\t<td><textarea name=\"tblContent\" cols=\"30\" rows=\"20\" wrap=\"soft\" ><\/textarea><\/td>\n\t<\/tr><\/table>\n\n\t<table cellpadding=\"4\" cellspacing=\"0\">\n\t\t\n\t\t<table cellpadding=\"4\" cellspacing=\"0\"><font size='150%'><tr>\n\t\t\t<td align=\"center\"><input type='submit' value='Build Table' ><\/td>\n\t\t\t<td><\/td>\n\t\t<\/tr><\/table>\n\t\t\n\t<\/form><\/body><\/html>\n}]\n[H: abort(0)]",
        "maxWidth": "",
        "tooltip": "<html>This opens a frame where you can send ",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "b35ec2ca-b909-4c21-bac3-622ae2ad2bda",
          "commandChecksum": "3e4e29360182ea4db392488f2fba35af",
          "propsChecksum": "5e27aa178a3d514cc398ec643ba9e137"
        }
      },
            {
        "autoExecute": true,
        "color": "aqua",
        "fontColor": "black",
        "group": "20: Table Creator",
        "includeLabel": false,
        "sortBy": "20: Table Creator",
        "index": 581,
        "label": "processX2T",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:'broadcast(macro.args)']\n\n[h:tblName\t\t= json.get(macro.args, \"tblName\")]\n[h:tblContent\t= json.get(macro.args, \"tblContent\")]\n[h:content\t\t= encode(tblContent)]\n\n[h:tab\t\t\t= \"%09\"]\n[h:nl\t\t\t= \"%0A\"]\n\n\n[h:createTable(tblName,1,1)]\n\n[h,foreach(line, content, \"<br>\", \"%0A\"), CODE:{\n\t[r\t\t= roll.count]\n\t[n\t\t= listCount(line, \"%09\")]\n\t[if(n), CODE:{ \n\t\t[assert(n>1, \"too few entries (tabs) in the following line: \"+line,0)]\n\t\t\n\t\t[i1\t\t= listGet(line, 0, \"%09\")]\t\t\t\n\t\t[i1\t\t= if(isNumber(i1),i1,roll.count)]\t\n\t\n\t\t[if(n>2), CODE:{\t\t\t\t\t\t\t\n\t\t\t[i2\t\t= listGet(line, 1, \"%09\")]\t\t\n\t\t\t[i2\t\t= if(isNumber(i2),i2,i1)]\n\t\t\t[val\t= decode(listGet(line, 2, \"%09\"))]\t\n\t\t''\n\t\t};{\n\t\t\t[i2\t\t= i1)]\t\t\t\t\t\t\t\n\t\t\t[val\t= decode(listGet(line, 1, \"%09\"))]\t\t\n\t\t''\n\t\t}]\n\t\t\n\t\t[addTableEntry(tblName, i1, i2, val)]\n\t''\n\t}]\n''\n}]\n\n<i>[r:tblName]<\/i> created with <b>[r:r+1]<\/b> entries!",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7a6c0f51-9861-4a19-90bb-1e5dcf2f2e11",
          "commandChecksum": "a56a0dbeae15cbb4078597d49105a682",
          "propsChecksum": "8d977e80b04c2e121e8c669edd2619a3"
        }
      },
            {
        "autoExecute": true,
        "color": "black",
        "fontColor": "white",
        "group": "z. Version",
        "includeLabel": false,
        "sortBy": "z. Version",
        "index": 582,
        "label": "Token Version 48",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:libversion = \"48\"]\n[h:setLibProperty(\"libversion\", libversion, \"lib:OnTokenMove\")]\n[h:setLibProperty(\"libversion\", libversion, \"lib:EventMacros\")]\n\n[h:credits = \"<b>Credits<\/b><br>\nThe Bag of Tricks is created by Wolph42. For any questions, remarks or requests, simply post in the <font color='blue'><a href='https://forums.rptools.net/viewtopic.php?f=46&t=28409&p=274496#p274496'>BoT Thread<\/a><\/font> on the rptools forum.<br><br>\nA couple of macros were based on the code of others, here an overview of who the original creators are and my improvements to their code:\n<table>\n\t<tr><td><b><u>What<\/b><\/u><\/td><td><b><u>Who<\/b><\/u><\/td><td><b><u>Improvements<\/u<\/b><\/td><\/tr>\n\t<tr><td>SoundPads<\/td><td>Blackwing<\/td><td>Rewrote the code so it fits in the BoT, optimized code and added additional sound check after map switch (works with both teleports as well as switchmap)<\/td><\/tr>\n\t<tr><td>Dicebox<\/td><td>Rumble<\/td><td>rewrote most of the code, redid the dice images, added d5 die and the options tab<\/td><\/tr>\n\t<tr><td>Disguise macro<\/td><td>Aliasmaks<\/td><td>added the option so you can also create a disguise list by selecting image:tokens together with the disguise token<\/td><\/tr>\n\t<tr><td>Whisper frame<\/td><td>LMarkus<\/td><td>completely rewrote it, biggest change: rpg language support. The idea from the script signs additions came from Takehara<\/td><\/tr>\n\t<tr><td>Delete Macros<\/td><td>Rumble<\/td><td>added copy/paste function and an 'all macros' panel where you can meta select all macros or groups of macros.<\/td><\/tr>\n\t<tr><td>Message Manager<\/td><td>Plothos<\/td><td>added text formatting and images (select a token and then use 'add selected image').<\/td><\/tr>\n\t<tr><td>Input String Builder<\/td><td>Bubblobill<\/td><td>no addition!.<\/td><\/tr>\n\t<tr><td>Fancy Frames<\/td><td>Nildik<\/td><td>Added 'Frame Overview' function!. Fixed titles of incompatible frames<\/td><\/tr>\n\t<tr><td>Room Description Tokens<\/td><td>Nildik<\/td><td>Added option to force share immediately to players screen<\/td><\/tr>\n<\/table>\n\n\"]\n\n[h:output = credits + \"<br>\n<b>Version 48<\/b><br>\n<b>New Features<\/b>\n- possibility to create MT tables by copy pasting from excel<br>\n- update to soundPads: \n + added flag to eventPad triggered soundpad so you can set it to only play once.<br>\n + added sounddistance to the other tokens for the sound triggerpath as well<br>\n + To all the teleports and eventpads you can now also link a sound that plays when the pad is activated.<br>\n - Added video tutorials to splashscreen<br>\n- Added script signs to whisper frame, thanks to Takehara.<br>\n\n<b>bugfixes<br><\/b>\n- bugfix in whisperframe.<br>\n- Bug fixes soundPad, turned off new scope in teleport and mapteleport functions (so lastpath is passed on)<br>\n- Bug fixes in animate door<br>\n\n\n<b>Version 47<\/b><br>\nNew Feature\nAdded soundpads as originally designed by Blackwing. <br>\n- bugfix in switch map<br>\n- bugfix in switch map<br>\n- removed debug code from seektoken<br>\n- added hilltopVBL function to libeventmacro<br>\n- added bot_owner() and bot_nowner() functions to the BoT<br>\n- bug fix in embarkation<br>\n- bug fix in onmultipletokensmove icw a post move trigger macro<br>\n\n<b>Version 46<\/b><br>\nNew Features<br>\n- REMOVED TOKEN VBL FROM DOORS. Exchanged it for 'crack open door'. You can keep moving it further open if you want. For VBL you will have to use token vbl itself.<br>\n- Complete do over of the invisibility macros. <br>\n-- Players no longer 'own' the token if the can see a visible token. <br>\n-- added VBL check so you cant see an invisible token through a wall. <br>\n-- Also you can now set elevation for a token. The invisibility macros keep track of this when checking for range. <br>\n-- New macros buttons have been added to the bot panel and campaign panel.<br>\nFixes<br>\n- fixed Nildiks frame overview<br>\n- fixed assertion error (and added one) in crowd function<br>\n- added check in link animate view and clear assertion (order numbering mistake) <br>\n- fixed issue where moving of teleportsborder would execute another teleport.<br>\n- added invisibility use check to diagnose (breaks when turned on but states not defined.<br>\n- fixed several bugs in whisperframe and added 'keepitshort' var to whisperframe where you can set the max length of both player and character name as it shows up in the panel. this keeps things a bit more compact<br>\n- moved the linked triggermacros in ontokenmove a bit around so they are in context of ontokenmove.<br>\n- made whisperframe more compact, saving screen estate.<br>\n- got notebook and manual running again.<br>\n<br>\n<b>Version 45<\/b><br>\nNew Features:<br>\n- Full overhaul of the whisperframe. It now supports languages, meaning you can send messages and only those who speak the language can understand the message. (that and other stuff)<br>\n- Added changeElevation and getRangedDistance macros. Further worked required to integrate,but they work. Elevation is now taken into account when using the invisibility functions.<br>\nFIXES:<br>\n- fixed bug in ontokenmove with linked eventtriggers (these are created in lib:eventmacros and linked in the settings to the ontokenmove event)<br>\n- Also changed the naming for better understanding and added clarifying texts.<br>\n- fixed issue with resizing roofs when using the transparent roof option<br>\n- updated invisibility, need to check if it works. <br>\n- fixed macro buttons layout (removed the padding) <br>\n- fixed dicetool issue, but expect a LOT more issues due to newly introduced 'bug' in MT <br>\n- fixed switchmap issue I think 3x over<br>\n- removed <v40 history from this macro <br>\n- fixed idiot mistake in broadcast OCL (started manual when connecting to server) <br>\n- fixed division by zero bug in crowd control <br>\n- fixed all http links in the BoT (broken due to new topic or dropbox screwing things over) <br>\n- added additional argument to 'seekToken()' function to force json output<br>\n<br>\n<b>Version 44<\/b><br>\nNew Features:<br>\n- when you load the campaign youll see a blue button in the chat with the manual<br>\n- its now possible to add a piece of text after the 'centreOnMePad' tokens e.g. 'centrOnMePad First Floor' AND have multiple 'centreOnMePad' tokens like this on one map. When you use the 'switchmap' macro these location will show up and the map will centre on the location chosen!<br>\nFIXES:<br>\n- Shadowpad tokens are now one size smaller than the original token (unless they're freesize or fine size).<br>\n- Added fix to 'set reference' macro for shadowpads. It cleans previous settings from the pads, should they reside there. Can also be used to fix a broken shadowpad.<br>\n- Fixed wrong referencetoken calculation for shadowpads and other stuff wrong with shadowpads<br>\n- Fixed door VBL compatibility for later versions of MT.<br>\n- Fixed issue with Nildiks room descriptor.<br>\n- applied Derfs' fix for door lever proximity<br>\n- fixed feet when moving through vbl<br>\n- Added overview of turned on Toggles (in the BoT settings) during OCL (on request of bobifle).<br>\n- Renamed 'titlelink' tag in Nildiks room description to 'title' tag.<br>\n- Made 'title' tag generic (as in its fully optional, resets after use and can be placed for any of the Nildiks special tags.<br>\n- Updated the descriptor help and added a 'copy paste' section where the links can easily be grabbed.<br>\n- Added Room Descriptor Help button to menu.<br>\nTABLE UPDATE REQUIRED: tbl_Image <br>\n- Implemented Nildiks room descriptor update (titlelink and infolink).<br>\n- Fixed stupid mistake in summonToken macro created while working on Embarkation.<br>\n- Fixed error report when setting door animation to 0.<br>\n- Fixed hard coded invisibility states.<br>\n<b>Version 43<\/b><br>\nNew Feature: added Embarkation of tokens into vehicles or containers which you can then use to move the tokens around. <br><br>\n- fixed bug in limit movement.<br>\n- fixed bug in delete properties.<br>\n- fixed bug in disguise button.<br>\n- added 'cycle disguise' macro, not added to the enchilada\n- added bot_message() width parameter also to header text on suggestion of full bleed.<br>\n- added additional parameter to bot_message() to allow you to set the width of the table. <br>\n- updates to the function manual. <br>\n- added bot_getTokCDistance() including manual entry. Function calculates distance between the corners of two tokens, returns distance in either cells, pixels or dpc<br>\n- added back link to the introduction window<br>\n- fixed error message on clean install<br>\n<b>Version 42<\/b><br>\nAdded Vew Area Animation. Three functions to create an 'animated overflight scene' for your players. On a new map you can run a macro and then all the views of the players are moved over the map while zooming in or out. The animation is based on the lastpath of a token. The macros are:<br>\n- Set View Animation: turn the last path of a token into a view area animation\n- Link View Animations: link the animations of several tokens into one big animation\n- Run View Animation: select the token where the animation is stored and run this macro to show the animation on ALL clients. \nExanded the invisibility functions. All available macros and corresponding functions now are:<br>\nStart Invisibility\t   bot_startInvisibility()\t\t<br> \nEnd Invisibility  \t   bot_endInvisibility()    \t<br>\nSee Invisibility  \t   bot_seeInvisibility()     \t<br>\nSaw Invisibility  \t   bot_sawInvisibility()     \t<br>\nPurge Invisibility\t   bot_purgeInvisibility()   \t<br>\nPurged Invisibilit\t   bot_purgedInvisibilityy() \t<br>\nAnul Invisibility \t   bot_anulInvisibility()    \t<br>\nAnnuled Invisibili\t   bot_annuledInvisibility()\t<br>\nbot_checkInvisibility()<br>\nSee manual for more info concerning these macros. <br>\nAdded these functions to the BoT Virtual Macro Panel. And fixed the original invisibility buttons on the campaign panel<br>\nOther stuff:<br>\nFixed FU in bot_getTokenFacing()<br>\n<b>Version 41<\/b><br>\nNew Feature: This new version contains a full set of macro to make use of invisibility and invisibility purge. It works with onTokenMove and checks for purgin when a token moves. See the manual for more info. <br>\nOther stuff<br>\n- Updated manual for bot_getTokenFacing() and bot_setTokenFacing(), the descriptions were erroneous (the functions remain unchanged).<br>\n- added Jamz purple feet (invisible tokens) .<br>\n- setDoor can now be used when multiple doors are selected. ALL doors will be set according the given settings.<br>\n- fixed handout text issue.<br>\n- Experiment with follow me tokens (maybe for future follow me random dungeon).<br>\n- Added size options to polymorph/disguise macro. And fixed a bug in there as well.<br>\n- updated clean token names (search and replace characters. Added semicolon and open character.<br>\n- set 'allow players to edit macro' back to false for 177 macros<br>\n- updated installation instructions<br>\n- fixed settigns bug in 40b<br>\n- fixed vbl check OCL for MT 1.4+ <br>\n- tbl check in manual <br>\n<b>Version 40<\/b><br>\nOn request added a 'BoT features' options list. This will pop up on first install and you can choose which features are available and which not. It additionally shows an entire overview of all features and the required dependencies needed to use certain features. To accomplish this.<br>\nThe other stuff changed:<br>\n- Complete overhaul of the virtual menus, faster now and more versatile. <br>\n- The optional features now influence the virtual menu. <br>\n- Diagnose is now updated with the foptional features  as well. <br>\n- Settings has been updated with the optional features<br>\n- upgraded bot_showHTML to better format the html output. <br>\n- removed 'player editable' from 179 macros on ontokenmove to prevent A LOT of debugging headache...<br>\n- Reorganised all macro groups. <br>\n- Fixed small FU in onselect frame. <br>\n\n\"]\n[r:broadcast(output)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2f4e220c-590e-4357-96ee-b81925d07f2d",
          "commandChecksum": "1d488cd1ec6c04984f4c55109548b3e9",
          "propsChecksum": "9bbcace4b6fc3d1554264535ad6dafd7"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "",
        "includeLabel": false,
        "sortBy": "",
        "index": 583,
        "label": "Collapse UDFs",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: \"\n\"]\n\n[h: \"\"]\n[h: vCollapsedGroup = \"All BoT Macros (Smol)\"]\n[h: vUDFGroupREGEX = \".+\"]\n\n[h: \"\"]\n[h: vThisMacro = getMacroName()]\n[h: vExpandedLabel  = \"Collapse UDFs\"]\n[h: vCollapsedLabel = \"Expand UDFs\"]\n\n[h: \"\"]\n[h: vThisMacroProps = getMacroProps(getMacroButtonIndex())]\n[h, if(matches(vThisMacro, vExpandedLabel)), code: {\n\t[vFontSize = \"0\"]\n\t[vMinWidth = \"0\"]\n\t[vGroupAll = true]\n\t[setMacroProps(getMacroButtonIndex(), json.set(\"{}\", \"label\", vCollapsedLabel), \"json\")]\n};{\n\t[vFontSize = \"1.00em\"]\n\t[vMinWidth = \"\"]\n\t[vGroupAll = false]\n\t[setMacroProps(getMacroButtonIndex(), json.set(\"{}\", \"label\", vExpandedLabel), \"json\")]\n}]\n\n[h: \"\"]\n[h: vMacros = getMacros(\"json\")]\n[h: vUDFMacroGroups = \"\"]\n[h, foreach(vMacro, vMacros), code: {\n\t[vMacroIndex = listget(getMacroIndexes(vMacro), 0)]\n\t[vMacroProps = getMacroProps(vMacroIndex, \"json\")]\n\t[vMacroSort  = json.get(vMacroProps, \"sortBy\")]\n\t[vMacroGroup = json.get(vMacroProps, \"group\")]\n\t[vNewMacroProps = json.set(\"{}\", \n\t\t\"fontSize\", vFontSize,\n\t\t\"minWidth\", vMinWidth,\n\t\t\"sortBy\", \tif(vMacroGroup != vCollapsedGroup, vMacroGroup, vMacroSort),\n\t\t\"group\", \tif(vGroupAll, vCollapsedGroup, if(vMacroSort != \"\", vMacroSort, vMacroGroup)))]\n\t[if(matches(vMacroGroup, vUDFGroupREGEX) == 1): \t\t\n\t\tsetMacroProps(vMacroIndex, vNewMacroProps, \"json\")]\n}]",
        "maxWidth": "",
        "tooltip": "<html>Collapse/Expand Macro groups according to a RegEx pattern.<br>Note: Overwrites Sort Prefix, use with care.<\/html>",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "691c7b9f-c8de-4688-ae92-539c48ca6f86",
          "commandChecksum": "bd6f89aa3f68037fd8f5c0c79e168e33",
          "propsChecksum": "75a0d3c24547ef206e5be149d815ce3a"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "998",
        "includeLabel": false,
        "sortBy": "All BoT Macros with Images (Smol)",
        "index": 584,
        "label": "<image src=\" asset://3fcd87c798fedd3ade1bd9ed272550e0\"><\/image> ",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[macro(\"showDescription@lib:OnTokenMove\"):\"\"]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "2d712ddc-fb14-4f9e-bde3-6e077dcc57f9",
          "commandChecksum": "fa12341d480b8edf8298f549383a1ff6",
          "propsChecksum": "7f69195adb583f165e3af14a7d03c80b"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 542,
        "label": "deferToggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h:'']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n[H, if(init), code: {\n\t\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[choice\t\t\t= arg(3)]\n\t[isClosed\t\t= arg(4)]\n\t\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[if(drawVBL), CODE:{\n\t\t\n\t\t[if(!getLibProperty('vblSupport','lib:EventMacros')):drawVBL = 0]\n\t};{}]\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\n\n\t\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tendPos = totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos = crackOpenAngle]\n\t\t[if(choice == \"halfVBL\"):\tstartPos = halfOpenAngle]\n\t\t[if(choice == \"fullVBL\"):\tstartPos = totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n\n\n\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tendPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tendPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tendPos\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[if(choice == \"crackVBL\"):\tstartPos\t= if(xDirection, crackOpenDoorX, crackOpenDoorY)]\n\t\t[if(choice == \"halfVBL\"):\tstartPos\t= if(xDirection, halfOpenDoorX, halfOpenDoorY)]\n\t\t[if(choice == \"fullVBL\"):\tstartPos\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[if(choice == \"crackVBL\"):\tcurrentStepSize = direction * crackStepSize]\n\t[if(choice == \"halfVBL\"):\tcurrentStepSize = direction * halfStepSize]\n\t[if(choice == \"fullVBL\"):\tcurrentStepSize = direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor && choice == \"fullVBL\"): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t}; {\n\t\t\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, choice, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t};{}]\n\n\t\t[if(doubleDoor && choice == \"fullVBL\"): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\t}]\n}]\n\n\n\n\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\tchoice\t\t\t= %{choice}; \n\t\t\tdrawVBL\t\t\t= %{drawVBL};\n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t\t\n\t\t[doVBL\t= 0]\n\t}; {\n\t\t\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t\t[doVBL\t= 1]\n\t}]\n\t\n\t[if(drawVBL && doVBL), CODE:{\n\t\t[mainDoor\t\t= me]\n\t\t[isClosed \t\t= bot_isDoorClosed(mainDoor)]\n\t\t[bot_moveStamp(me)]\n\t\t[if(doubleDoor): bot_moveStamp(me + 'a')]\n\t}; {}]\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "52108fe7-be3a-4398-81ac-44444a31de0c",
          "commandChecksum": "9ca84639869988eea580128d631d09df",
          "propsChecksum": "e6bc4a6f868393ee0cd3f1df9ee55223"
        }
      },
            {
        "autoExecute": true,
        "color": "default",
        "fontColor": "black",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "2",
        "index": 585,
        "label": "deferToggleDoor BCK",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[h:'']\n[h:debug = 0]\n\n[H: time = json.get(getInfo(\"client\"),\"timeInMs\")]\n[h: init = !getFindCount(strfind(macro.args, \"currentStepSize\"))]\n\n\n[H, if(init), code: {\n\t\n\t[me\t\t\t\t= arg(0)]\n\t[mainDoor\t\t= arg(1)]\n\t[doorMap\t\t= arg(2)]\n\t[isClosed\t\t= arg(3)]\n\n\t\n\t[currentMap\t\t= getCurrentMapName()]\n\t[if(doorMap != currentMap),CODE:{\n\t\t[setCurrentMap(doorMap)]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor):\tremoveToken(me + 'a')]\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor):\tsetOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[setCurrentMap(currentMap)]\n\t\t[abort(0)]\n\t}; {}]\n\t[switchToken(me)]\n\n\t\n\t[h:varsFromStrProp(getProperty(\"w42.bot.doorData\"))]\n\t\n\t[assert(openMethod != \"\", \"Please set the value openMethod of the door first (select the door and run 'set door' on the campaign panel)\")]\n\t[rotating\t\t= if(openMethod < 2, 1,0)]\n\n\t\n\t[startTime\t\t= time]\n\t[endTime\t\t= min(15000,number(animateTime))]\t\n\t\n\n\t\n\t[currentPos\t\t= bot_getTokenFacing(me)]\n\n\t[currentX\t\t= getTokenX(1,me)]\n\t[currentY\t\t= getTokenY(1,me)]\n\t\n\t[xDirection\t\t= if(openMethod < 4, 1, 0)]\n\t[otherPos\t\t= if(xDirection, currentY, currentX)]\n\n\n\t[if(isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, -1, 1)]\n\t\t[startPos\t\t= closedAngle]\n\t\t[endPos \t\t= totalOpenAngle]\n\t}; {}]\n\n\t[if(!isClosed && rotating), CODE:{\n\t\t[direction \t\t= if(openMethod, 1, -1)]\n\t\t[startPos \t\t= totalOpenAngle]\n\t\t[endPos\t\t\t= closedAngle]\n\t\t[setTokenFacing(startPos)]\n\t}; {}]\n\n\n\n\t[if(isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), 1, -1)]\n\t\t[startPos\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[endPos\t\t\t= if(xDirection, openDoorX, openDoorY)]\n\t}; {}]\n\n\t[if(!isClosed && !rotating), CODE:{\n\t\t[direction \t\t= if(odd(openMethod), -1, 1)]\n\t\t[endPos\t\t\t= if(xDirection, closedDoorX, closedDoorY)]\n\t\t[startPos\t\t= if(xDirection, openDoorX, openDoorY)]\n\n\t\t\n\t\t[moveToken(if(xDirection, startPos, otherPos), if(xDirection, otherPos, startPos), 1, me)]\n\t}; {}]\n\n\n\t[currentPos\t\t\t= startPos]\n\t[if(doubleDoor): doubleStartPos\t= bot_getTokenFacing(me+'a') ; doubleStartPos = 0]\n\t[currentStepSize \t= direction * stepSize]\n}; {\n\t[varsFromStrProp(macro.args)]\n\t[currentPos\t\t\t= newPos]\n}]\n\n[H: elapsedTime\t= time - startTime]\n[h: newPos \t\t= startPos + floor(elapsedTime * currentStepSize)]\n\n['pause(\"endPos\",\"currentPos\",\"newPos\",\"elapsedTime\",\"endTime\",\"currentStepSize\")']\n[h: tooFar \t\t= if( (endPos - currentPos) * (endPos - newPos) < 0 || elapsedTime > endTime, 1, 0 )]\n[h: newPos\t\t= if( tooFar, endPos, newPos )]\n\n\n[h, if(newPos != currentPos), CODE:{\n\t[if(rotating), CODE:{\n\t\t\n\t\t[setTokenFacing(newPos, me)]\n\t\t[if(doubleDoor): setTokenFacing(2*doubleDoorParam - newPos, me+\"a\")]\n\t''\n\t};{\n\t\t\n\t\t[moveToken(if(xDirection, newPos, otherPos), if(xDirection, otherPos, newPos), 1, me)]\n\n\t\t[if(debug), CODE:{\n\t\t\t[currDX\t= getTokenX(1, me+'a')]\n\t\t\t[currDY\t= getTokenY(1, me+'a')]\n\t\t\t[bot_debugInfo(\"doubleDoor, xDirection, doubleDoorParam, newPos, me, otherPos, currDX, currDY\", 1)]\n\t\t''\n\t\t};{}]\n\n\t\t[if(doubleDoor): moveToken(if(xDirection, doubleDoorParam - newPos, getTokenX(1, me+'a')), if(xDirection, getTokenY(1, me+'a'), doubleDoorParam - newPos), 1, me+\"a\")]\n\n\t''\n\t}]\n''\n}]\n\n\n\n\n[H, if(newPos != endPos && newPos != endPos ), code: {\n\t\n\t[args = strformat(\"\n\t\t\tme\t\t\t\t= %{me}; \n\t\t\trotating\t\t= %{rotating}; \n\t\t\tstartTime\t\t= %{startTime}; \n\t\t\tendTime\t\t\t= %{endTime}; \n\t\t\tcurrentStepSize\t= %{currentStepSize}; \n\n\t\t\tstartPos\t\t= %{startPos}; \n\t\t\tendPos\t\t\t= %{endPos}; \n\t\t\tnewPos\t\t\t= %{newPos}; \n\n\t\t\tdoubleDoorParam\t= %{doubleDoorParam}; \n\t\t\tdoubleStartPos\t= %{doubleStartPos}; \n\t\t\totherPos\t\t= %{otherPos}; \n\t\t\txDirection\t\t= %{xDirection}; \n\t\t\topenMethod\t\t= %{openMethod}; \n\t\t\t\n\t\t\tdoubleDoor\t\t= %{doubleDoor}; \n\t\t\tmainDoor\t\t= %{mainDoor}\n\t\")]\n\t[link = macroLinkText(\"deferToggleDoor@lib:onTokenMove\",\"none\",args)]\n\t[execLink(link,1)]\n}; {\n\t\n\t[if(mainDoor != \"\"), CODE:{\n\t\t[setOwnerOnlyVisible(0, mainDoor)]\n\t\t[if(doubleDoor): setOwnerOnlyVisible(0, mainDoor + 'a')]\n\t\t[removeToken(me)]\n\t\t[if(doubleDoor): removeToken(me + 'a')]\n\t}; {\n\t\t\n\t\t[numClients = listCount(getAllPlayerNames())]\n\t\t[if(numClients == 1):setOwnerOnlyVisible(0, me)]\n\t}]\n\n}]\n\n[bot_resetTimer(1)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "7f35e3b3-bd68-4b5d-a07e-4699b46b25aa",
          "commandChecksum": "b90143e816d05b7dc07530820ee1e099",
          "propsChecksum": "33aa9d3383a24d75d881ec944e482423"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "6b.  Door Animation VBL OLD",
        "includeLabel": false,
        "sortBy": "6b.  Door Animation VBL OLD",
        "index": 541,
        "label": "toggleDoor BCK",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": false,
        "command": "[h: '']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:vblSupport\t\t\t= getLibProperty('vblSupport','lib:EventMacros')]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n[h:drawVBL\t\t\t\t= if(drawVBL && vblSupport, 1,0)]\n\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n[h:choice\t= getProperty(\"clearedVBL\", mainDoor)]\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t[isClosed\t\t= 1]\n\t[setProperty(\"clearedVBL\", \"\", mainDoor)]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n\n[h,if(drawVBL && !isClosed && choice == \"\" || !drawVBL): choice = \"fullVBL\"]\n[h,if(drawVBL && isClosed), CODE:{\n\t[nothing\t= 1]\n\t[propList\t= \"nothing, windowVBL, keyholeVBL, crackVBL, halfVBL, fullVBL\"]\n\n['windowVBL = 0']\n['keyholeVBL = 0']\n\t[if(windowVBL+keyholeVBL+crackVBL+halfVBL+fullVBL > 1), CODE:{\n\t\t[optionList = \"\"]\n\t\t[choices\t= \"Do nothing, Peek through the window, Peek through the key hole, Crack the door open, Open the door halfway, Open the door all the way\"]\n\t\t[foreach(item, propList): optionList = if(eval(item), listAppend(optionList, listGet(choices, roll.count)), optionList)]\n\t\t\n\t\t[abort(input(\n\t\t\tstrformat(\"junk|<html><b>%{mainDoor} %s<\/b><\/html>|-|LABEL|SPAN=TRUE\", if(description != \"\", \"(\"+description+\")\", \"\")),\n\t\t\t\"choice|\"+optionList+\"|You...|RADIO|VALUE=STRING\"\n\t\t))]\n\t\t[choice\t\t= listGet(propList, listFind(choices, choice))]\n\t\t[abort(if(choice == \"nothing\", 0,1))]\n\t}; {\n\t\t\n\t\t[choice = \"\"]\n\t\t[foreach(item, propList): choice = if(eval(item), item, choice)]\n\t\t\n\t\t[if(choice == \"\"):choice = \"fullVBL\"]\n\t}]\n}; {}]\n\n[h:setProperty(\"clearedVBL\", choice, mainDoor)]\n[h:'pause(\"choice\")']\n\n\n[h,if(choice == \"windowVBL\" || choice == \"keyholeVBL\"), CODE:{\n\t\n\t[isClosed\t\t= 0]\n\t['pause(\"choice\",\"choice\",\"windowVBL\",\"keyholeVBL\",\"closedAngle\")']\n\t[bot_setVBLDoor()]\n\t[abort(0)]\n}; {}]\n\n\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t[if(choice == \"crackVBL\"):\tendPos = crackOpenAngle]\n\t[if(choice == \"halfVBL\"):\tendPos = halfOpenAngle]\n\t\n\t\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[doubleStartPos\t\t= bot_getTokenFacing(mainDoor+'a')]\n\t\t[setTokenFacing(doubleEndPos, mainDoor+\"a\")]\n\t}; {\n\t\t[doubleOldPos\t\t= 0]\n\t}]\n\n\t[if(drawVBL): bot_moveStamp()]\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t\n\t\n\t[if(choice == \"crackVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(crackOpenDoorX, crackOpenDoorY, 1, mainDoor)\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"halfVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(halfOpenDoorX, halfOpenDoorY, 1, mainDoor)\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\t[if(choice == \"fullVBL\"), CODE:{\n\t\t[if(isClosed): moveToken(openDoorX, openDoorY, 1, mainDoor)\t\t\t\t; moveToken(closedDoorX, closedDoorY, 1, mainDoor) ]\n\t}; {}]\n\n\t[if(doubleDoor && choice == \"fullVBL\"), CODE:{\n\t\t[xDirection\t= if(openMethod < 4, 1, 0)]\n\t\t[newXPos\t= if(isClosed, openDoorX, closedDoorX)]\n\t\t[newYPos\t= if(isClosed, openDoorY, closedDoorY)]\n\t\t[DDoorX\t\t= if(xDirection, doubleDoorParam - newXPos, getTokenX(1, mainDoor+'a'))]\n\t\t[DDoorY\t\t= if(xDirection, getTokenY(1, mainDoor+'a'), doubleDoorParam - newYPos)]\n\t\t[moveToken(DDoorX, DDoorY, 1, mainDoor+\"a\")]\n\t}]\n\t[isClosed \t= 1 - isClosed]\n\t[if(drawVBL):bot_moveStamp()]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, choice, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, choice, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, choice, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "eeb6953d-3007-454e-8c90-0cbe8fe64d3b",
          "commandChecksum": "3eb0f088e42bbd01e3811f5cde080a0f",
          "propsChecksum": "77c53ceeccb6f814831836cb14780891"
        }
      },
            {
        "autoExecute": true,
        "color": "darkgray",
        "fontColor": "black",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "1",
        "index": 586,
        "label": "toggleDoor BCK",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[h: '']\n[h: debug = 0]\n\n[h,if(argCount() == 4), CODE: {\n\t\n\t[mainDoor \t\t= getName(arg(0))]\n\t[closeEnough\t= arg(1)]\n\t\n\t[operator\t\t= arg(2)]\n\t[tokList\t\t= arg(3)]\n}; {\n\t\n\t[if(macro.args != \"\"):mainDoor = \"Door \"+arg(0); mainDoor = getSelectedNames()]\n\t[assert(listCount(mainDoor)==1, \"Make sure (only) one door is selected\",0)]\n\t[closeEnough\t= 1]\n\t[operator\t\t= \"\"]\n}]\n\n\n[h:onlinePlayers\t\t= getAllPlayerNames()]\n[h:thisPlayer\t\t\t= getPlayerName()]\n[h:animationPerClient\t= getLibProperty(\"animationPerClient\", \"lib:EventMacros\")]\n[h:byStanders\t\t\t= listDelete(onlinePlayers, listFind(onlinePlayers, thisPlayer))]\n[h,if(animationPerClient): otherPlayers = byStanders; otherPlayers = \"\"]\n\n\n[h:varsFromStrProp(getProperty(\"w42.bot.doorData\", mainDoor))]\n\n\n[H:assert(listCount(mainDoor)==1,\t\"Make sure (only) one token is selected\",0)]\n[h:assert(closeEnough || isGM(),\t\"You are standing too far away from the switch to operate it\",0)]\n[h:assert(animateTime != \"\",\t\t\"Please set the value 'time to open' of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(openMethod != \"\",\t\t\t\"It looks like this door is not setup for animation. Please do this first(select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(closedAngle != \"\",\t\t\"Please set the value closed angle of the door first (select the door and run 'set door' on the campaign panel)\",0)]\n[h:assert(!( getState(\"Locked\",mainDoor) && !isGM() ),\t\"The door is locked\",0)]\n\n[h:isClosed \t\t\t= bot_isDoorClosed(mainDoor)]\n\n\n\n\n[h:macroName\t\t= getProperty(\"w42.bot.macroName\", mainDoor)]\n[h,if(macroName != \"\" && operator != \"\"),CODE:{\n\t[tokList\t\t= listDelete(tokList, listFind(tokList, operator))]\n\t[eventTypeList\t= getProperty(\"w42.bot.eventTypeList\", mainDoor)]\n\t[eventType\t\t= if(isClosed, \"doorIsOpened\", \"doorIsClosed\")]\n\t[triggered\t\t= listContains(eventTypeList, eventType)]\n\t\n\t[args\t\t\t= json.append(\"\", operator, thisPlayer, tokList, byStanders, mainDoor, 'door', isClosed, getState(\"Locked\",mainDoor))]\n\t[macro(macroName+\"@Lib:EventMacros\"): args]\n}; {\n\t[macro.return=\"\"]\n}]\n\n\n[h,if(!animateTime && openMethod < 2), CODE:{\n\t\n\t[direction\t= if(openMethod, -1, 1)]\n\t[startPos\t= bot_getTokenFacing(mainDoor)]\n\t[endPos\t\t= if(isClosed, getProperty(\"totalOpenAngle\", mainDoor), closedAngle)]\n\t\n\t\n\t[setTokenFacing(endPos, mainDoor)]\n\t[isClosed \t\t= 1 - isClosed]\n\t[doubleOldPos\t= 0]\n\n\t[abort(0)]\n}; {}]\n\n[h,if(!animateTime && openMethod >= 2), CODE:{\n\t\n\t\n\n\t[isClosed \t= 1 - isClosed]\n\t\n\t[if(debug): bot_debugInfo(\"animateTime, openMethod, isClosed, crackOpenDoorX, crackOpenDoorY, mainDoor, closedDoorX, closedDoorY, xDirection, doubleDoor, xDirection, newXPos, newYPos, DDoorX, DDoorY, doubleDoorParam\",0)]\n\t[abort(0)]\n}; {}]\n\n[h,if(animationPerClient), CODE:{\n\t[h:setOwner(thisPlayer, mainDoor)]\n\t[h:setOwnerOnlyVisible(1, mainDoor)]\n\t[h,if(doubleDoor), CODE:{\n\t\t[setOwner(thisPlayer, mainDoor + 'a')]\n\t\t[setOwnerOnlyVisible(1, mainDoor + 'a')]\n\t}; {}]\n}; {}]\n\n[h:currentMap\t= getCurrentMapName()]\n[h:args\t\t\t= json.append(\"[]\",mainDoor,\"\",currentMap, isClosed)]\n[h,macro('deferToggleDoor@Lib:OnTokenMove'): args]\n\n[h,foreach(tokenOwner, otherPlayers), CODE:{\n\t[door = getName(copyToken(mainDoor))]\n\t[setOwnerOnlyVisible(1, door)]\n\t[setOwner(tokenOwner, door)]\n\n\t[h,if(doubleDoor), CODE:{\n\t\t[idDoor = copyToken(mainDoor + 'a')]\n\t\t[dDoor = door + 'a']\n\t\t[token(idDoor): token.name = dDoor]\n\t\t[setOwnerOnlyVisible(1, dDoor)]\n\t\t[setOwner(tokenOwner, dDoor)]\n\t}; {}]\n\n\t[args = json.append(\"[]\",door, mainDoor, currentMap, isClosed)]\n\t[broadcast(macroLink(\"<color='white'>\", 'deferToggleDoor@Lib:OnTokenMove', 'none', args,tokenOwner))]\n}]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "240b2d6c-0f37-4c61-9d95-8c06dee58096",
          "commandChecksum": "836d33158c56ca1c26da6cbe13187322",
          "propsChecksum": "c9bb1bd63d98531786c6ef639ed5d7b5"
        }
      },
            {
        "autoExecute": true,
        "color": "lightgray",
        "fontColor": "blue",
        "group": "16. Animate Move",
        "includeLabel": false,
        "sortBy": "16. Animate Move",
        "index": 502,
        "label": "Embarkation",
        "fontSize": "1.00em",
        "minWidth": "",
        "playerEditable": true,
        "command": "[h:timeOut()]\n[h:'']\n[h:me = getSelectedNames()]\n[h:assert(listCount(me)==1, \"Make sure that (only) one token (the vehicle) is selected\",0)]\n[h:switchToken(me)]\n\n[h:'']\n[h:ok\t\t\t= 0]\n\n[h:maxPassengers= 10]\n\n[h:Passengers\t= getProperty(\"Passengers\", me)]\n[h:embarkedList = Passengers]\n[h:numEmbarked\t= listCount(embarkedList)]\n\n[h:'']\n[h: conditions = \"{'visible':1, 'range':{'token':'\"+me+\"', 'distancePerCell':0, 'upto':10}}\"]\n\n[h:'']\n[h:bot_getValidTokens(1, conditions)]\n[h:tokenList = charList]\n[h,if(tokenList != 'none'): numByStanders = listCount(tokenList)-1 ; numByStanders = 0]\n[h:fancyTokenList = fancyCharList]\n\n[h:'']\n[h,foreach(embarked, embarkedList), CODE:{\n\t[if(!listContains(tokenList, embarked)), CODE: {\n\t\t[token(embarked): tmp = getTokenImage(60)]\n\t\t[fancyTokenList = listAppend(fancyTokenList, embarked + tmp)]\n\t\t[tokenList = listAppend(tokenList, embarked)]\n\t}]\n}]\n\n[h:nPotentialEmbarkers = numByStanders + numEmbarked]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[passenger = if(listCount(passengers) > roll.count, listGet(passengers, roll.count), \"\")]\n\t[npassenger = max(0, listFind(tokenList, passenger))]\n\t[set(\"passenger\" + roll.count, npassenger)]\n}]\n\n[h:'']\n[h, if(!numByStanders): inputStrTxt\t= \"junk|<html>\n\tNo characters found. If you think this is wrong then:<br>\n\t1. make sure that tokens are visible<br>\n\t2. tokens are within 10 squares<br>\n\t3. in the BoT settings-->General Tab-->Summon Token Macro section--><br>\n\tMake sure that the property types of PC and NPC are setup correctly! <br>\n\tE.g. is your property type for PCs is Basic then it should say: Basic. \n\t<\/html>|-|LABEL|SPAN=TRUE\"\n;\n\tinputStrTxt = \"junk|<html><b>passengers<\/b><\/html>|-|LABEL|SPAN=TRUE\"\n]\n\n[h:inputStrPass\t= \"\"]\n[h,for(i, 0, min(nPotentialEmbarkers, maxPassengers)), CODE:{\n\t\t[newStr = \"passenger\" + i + \"|\" + fancyTokenList + \"| <html>passenger<\/b><\/html> | LIST | ICON=TRUE  ICONSIZE=30 SELECT=\" + eval(\"passenger\" + roll.count)]\n\t\t[inputStrPass = listAppend(inputStrPass, newStr,\"@\")]\n}]\n\n[h:'']\n[h:inputStr\t= \"junk|<html><b>Embarkation<\/b><\/html>|-|LABEL|SPAN=TRUE\"]\n[h:inputStr\t= listAppend(inputStr, inputStrTxt,\"@\")]\n[h:inputStr\t= listAppend(inputStr, inputStrPass,\"@\")]\n\n[h:'']\n[h:inputStr \t= listFormat(inputStr, \"input( %list )\", \" ' %item ' \", \",\", \"@\")]\n[h:'']\n\n[h:'']\n[h:abort(eval(inputStr))]\n\n[h:'']\n\n[h:'']\n[h,for(i, 0, nPotentialEmbarkers): set(\"namepassenger\"+i, listGet(tokenList, eval(\"passenger\"+i)))]\n\n[h:passengers \t\t= \"\"]\n[h,count(nPotentialEmbarkers), CODE:{\n\t[if(eval(\"passenger\"+roll.count)): passengers = listAppend(passengers, eval(\"namepassenger\"+roll.count))]\n}]\n\n[h:' ']\n[h:'check is vpcu is on the map, if not get if from the base map!!!']\n\n[h,if (findToken(\"VPCU\") == \"\"):sendToBack(copyToken(\"VPCU\", 1, \"BASE\"))]\n\n[h:vpcuX\t\t\t= getTokenX(0,\"VPCU\")]\n[h:vpcuY\t\t\t= getTokenY(0,\"VPCU\")]\n[h:meX\t\t\t\t= getTokenX(0,me)]\n[h:meY\t\t\t\t= getTokenY(0,me)]\n[h:newEmbarkedList\t= passengers]\n[h, if(listContains(newEmbarkedList,\"_none\")): newEmbarkedList = listDelete(newEmbarkedList, listFind(newEmbarkedList, \"_none\")]\n\n[h,foreach(embarked, embarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(newEmbarkedList, embarked)), CODE: {\n\t\t[moveToken(meX,meY,0,embarked)]\n\t}]\n}]\n\n[h,foreach(toEmbark, newEmbarkedList), CODE:{\n\t[' ']\n\t[if(!listContains(embarkedList, toEmbark)), CODE: {\n\t\t[moveToken(vpcuX+1,vpcuY+1,0,toEmbark )]\n\t}]\n}]\n\n[h:setProperty(\"Passengers\", newEmbarkedList, me)]\n\n\n[h: message(\"Embarkation done\", \"Embarkation done\", \"#063404\", ownergm(),  token.name)]",
        "maxWidth": "",
        "tooltip": "",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "1204f009-6754-4a6f-90b1-c6025d7f1aa0",
          "commandChecksum": "301a312514d201f95e6a95c5a0e87fce",
          "propsChecksum": "bc6b53ff410e689d2d7cfbd02c694fdd"
        }
      },
            {
        "autoExecute": true,
        "color": "blue",
        "fontColor": "yellow",
        "group": "All BoT Macros (Smol) ",
        "includeLabel": false,
        "sortBy": "23",
        "index": 587,
        "label": "Embarkation",
        "fontSize": "0",
        "minWidth": "0",
        "playerEditable": true,
        "command": "[r:bot_embarkation()]",
        "maxWidth": "",
        "tooltip": "<html>With this macro you can move (N)PC tokens inside a vehicle.",
        "applyToSelected": false,
        "compare":         [
          "group",
          "sortPrefix",
          "command",
          "includeLabel",
          "autoExecute",
          "applyToSelected"
        ],
        "metadata":         {
          "uuid": "a5e5ad91-eb8d-462f-acff-0688775134d8",
          "commandChecksum": "2dd3e081596b1132d19a7426602d7ef9",
          "propsChecksum": "b4082e1367860c4d750a0bff9237195c"
        }
      }
    ]
  }}
}
